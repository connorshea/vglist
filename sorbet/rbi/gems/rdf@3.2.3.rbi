# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rdf` gem.
# Please instead update this file by running `bin/tapioca gem rdf`.

class OptionParser
  def args; end
  def args=(value); end
  def options; end
  def options=(value); end
end

OptionParser::Version = T.let(T.unsafe(nil), String)

module RDF
  class << self
    def Graph(**options, &block); end
    def List(*args); end
    def Literal(literal, **options); end
    def Node(*args); end
    def Resource(*args); end
    def Statement(*args, **options); end
    def StrictVocabulary(uri); end
    def URI(*args); end
    def Vocabulary(uri); end
    def [](property); end
    def config; end
    def enum_for(method = T.unsafe(nil), *args); end
    def method_missing(property, *args, &block); end
    def respond_to?(method, include_all = T.unsafe(nil)); end
    def to_enum(method = T.unsafe(nil), *args); end
  end
end

class RDF::CLI
  class << self
    def abort(msg); end
    def add_command(command, **options, &block); end
    def basename; end
    def commands(format: T.unsafe(nil), **options); end
    def exec(args, output: T.unsafe(nil), option_parser: T.unsafe(nil), messages: T.unsafe(nil), **options); end
    def formats(reader: T.unsafe(nil), writer: T.unsafe(nil)); end
    def load_commands; end
    def options(argv, format: T.unsafe(nil)); end
    def parse(files, evaluate: T.unsafe(nil), format: T.unsafe(nil), encoding: T.unsafe(nil), **options, &block); end
    def repository; end
    def repository=(_arg0); end
    def usage(options, cmd_opts: T.unsafe(nil), banner: T.unsafe(nil)); end
  end
end

RDF::CLI::COMMANDS = T.let(T.unsafe(nil), Hash)
RDF::CLI::OPTIONS = T.let(T.unsafe(nil), Array)

class RDF::CLI::Option
  def initialize(symbol: T.unsafe(nil), on: T.unsafe(nil), datatype: T.unsafe(nil), control: T.unsafe(nil), description: T.unsafe(nil), use: T.unsafe(nil), default: T.unsafe(nil), **options, &block); end

  def call(arg, options = T.unsafe(nil)); end
  def control; end
  def datatype; end
  def default; end
  def description; end
  def on; end
  def symbol; end
  def to_hash; end
  def use; end
  def use=(_arg0); end
end

class RDF::Changeset
  include ::RDF::Util::Coercions

  def initialize(insert: T.unsafe(nil), delete: T.unsafe(nil), &block); end

  def <<(*statements); end
  def >>(*statements); end
  def apply(mutable, **options); end
  def count; end
  def delete(*statements); end
  def delete!(*statements); end
  def deletes; end
  def empty?; end
  def insert(*statements); end
  def insert!(*statements); end
  def inserts; end
  def inspect; end
  def inspect!; end
  def mutable?; end
  def options; end
  def readable?; end
  def writable?; end

  private

  def append_statements(target, arg); end
  def query(stmt); end

  class << self
    def apply(mutable, **options, &block); end
  end
end

module RDF::Countable
  extend ::RDF::Util::Aliasing::LateBound

  def count; end
  def empty?; end
  def enum_for(method = T.unsafe(nil), *args); end
  def size(*args, &block); end
  def to_enum(*args, &block); end
end

class RDF::Countable::Enumerator < ::Enumerator
  include ::RDF::Countable
end

class RDF::Dataset
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable
  include ::RDF::Durable
  include ::RDF::Queryable

  def initialize(statements: T.unsafe(nil), **options, &block); end

  def durable?; end
  def each; end
  def inspect; end
  def inspect!; end
  def isolation_level; end
  def supports?(feature); end

  protected

  def query_pattern(pattern, **options, &block); end
end

RDF::Dataset::ISOLATION_LEVELS = T.let(T.unsafe(nil), Array)

module RDF::Durable
  extend ::RDF::Util::Aliasing::LateBound

  def durable?; end
  def ephemeral?(*args, &block); end
  def nondurable?; end
  def nonpersistent?(*args, &block); end
  def persistent?(*args, &block); end
  def transient?(*args, &block); end
  def volatile?(*args, &block); end
end

module RDF::Enumerable
  include ::Enumerable
  include ::RDF::Countable
  extend ::RDF::Util::Aliasing::LateBound

  def dump(*args, **options); end
  def each_graph; end
  def each_object; end
  def each_predicate; end
  def each_quad; end
  def each_statement(&block); end
  def each_subject; end
  def each_term; end
  def each_triple; end
  def enum_graph; end
  def enum_graphs(*args, &block); end
  def enum_object; end
  def enum_objects(*args, &block); end
  def enum_predicate; end
  def enum_predicates(*args, &block); end
  def enum_quad; end
  def enum_quads(*args, &block); end
  def enum_statement; end
  def enum_statements(*args, &block); end
  def enum_subject; end
  def enum_subjects(*args, &block); end
  def enum_term; end
  def enum_terms(*args, &block); end
  def enum_triple; end
  def enum_triples(*args, &block); end
  def graph?(graph_name); end
  def graph_names(unique: T.unsafe(nil)); end
  def has_graph?(*args, &block); end
  def has_object?(*args, &block); end
  def has_predicate?(*args, &block); end
  def has_quad?(*args, &block); end
  def has_statement?(*args, &block); end
  def has_subject?(*args, &block); end
  def has_term?(*args, &block); end
  def has_triple?(*args, &block); end
  def include?(*args, &block); end
  def invalid?; end
  def object?(value); end
  def objects(unique: T.unsafe(nil)); end
  def predicate?(value); end
  def predicates(unique: T.unsafe(nil)); end
  def project_graph(graph_name); end
  def quad?(quad); end
  def quads(**options); end
  def statement?(*args); end
  def statements(**options); end
  def subject?(value); end
  def subjects(unique: T.unsafe(nil)); end
  def supports?(feature); end
  def term?(*args); end
  def terms(unique: T.unsafe(nil)); end
  def to_a; end
  def to_enum(*args, &block); end
  def to_h; end
  def to_set; end
  def triple?(triple); end
  def triples(**options); end
  def valid?; end
  def validate(*args, &block); end
  def validate!; end

  protected

  def enum_for(method = T.unsafe(nil), *args); end
  def method_missing(meth, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

class RDF::Enumerable::Enumerator < ::Enumerator
  include ::RDF::Queryable
  include ::RDF::Countable
  include ::RDF::Enumerable

  def to_a; end
end

class RDF::Format
  extend ::Enumerable

  class << self
    def accept_type; end
    def accept_types; end
    def cli_commands; end
    def content_encoding(encoding = T.unsafe(nil)); end
    def content_type(type = T.unsafe(nil), options = T.unsafe(nil)); end
    def content_types; end
    def detect(sample); end
    def each(file_name: T.unsafe(nil), file_extension: T.unsafe(nil), content_type: T.unsafe(nil), has_reader: T.unsafe(nil), has_writer: T.unsafe(nil), sample: T.unsafe(nil), all_if_none: T.unsafe(nil), **options, &block); end
    def file_extension; end
    def file_extensions; end
    def for(*arg, &block); end
    def inherited(child); end
    def name; end
    def reader(klass = T.unsafe(nil), &block); end
    def reader_class(klass = T.unsafe(nil), &block); end
    def reader_symbols; end
    def reader_types; end
    def require(library); end
    def symbols; end
    def to_sym; end
    def writer(klass = T.unsafe(nil), &block); end
    def writer_class(klass = T.unsafe(nil), &block); end
    def writer_symbols; end
    def writer_types; end
  end
end

class RDF::FormatError < ::IOError; end

class RDF::Graph
  include ::RDF::Value
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Durable
  include ::RDF::Enumerable
  include ::RDF::Queryable
  include ::RDF::Readable
  include ::RDF::Util::Coercions
  include ::RDF::Writable
  include ::RDF::Mutable
  include ::RDF::Transactable

  def initialize(graph_name: T.unsafe(nil), data: T.unsafe(nil), **options, &block); end

  def ==(other); end
  def anonymous?; end
  def count; end
  def data; end
  def data=(_arg0); end
  def durable?; end
  def each(&block); end
  def each_graph; end
  def graph?(*args); end
  def graph_name; end
  def graph_name=(_arg0); end
  def graph_names(unique: T.unsafe(nil)); end
  def graphs; end
  def has_statement?(*args); end
  def insert_statements(statements); end
  def load!(*args); end
  def name; end
  def name=(_arg0); end
  def named?; end
  def options; end
  def project_graph(graph_name, &block); end
  def statement?(*args); end
  def to_s; end
  def to_uri; end
  def unnamed?; end

  protected

  def begin_transaction(mutable: T.unsafe(nil), graph_name: T.unsafe(nil)); end
  def clear_statements; end
  def delete_statement(statement); end
  def insert_statement(statement); end
  def query_pattern(pattern, **options, &block); end

  class << self
    def load(url, graph_name: T.unsafe(nil), **options, &block); end
  end
end

RDF::IRI = RDF::URI

module RDF::Indexable
  def index!; end
  def indexed?; end
end

class RDF::List
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable
  include ::RDF::Value
  include ::Comparable

  def initialize(subject: T.unsafe(nil), graph: T.unsafe(nil), values: T.unsafe(nil), wrap_transaction: T.unsafe(nil), &block); end

  def &(other); end
  def *(int_or_str); end
  def +(other); end
  def -(other); end
  def <<(value); end
  def <=>(other); end
  def ==(other); end
  def [](*args); end
  def []=(*args); end
  def at(index); end
  def clear; end
  def each; end
  def each_statement(&block); end
  def each_subject; end
  def eighth; end
  def empty?; end
  def eql?(other); end
  def fetch(index, default = T.unsafe(nil)); end
  def fifth; end
  def first; end
  def first_subject; end
  def fourth; end
  def graph; end
  def index(value); end
  def inspect; end
  def join(sep = T.unsafe(nil)); end
  def last; end
  def last_subject; end
  def length; end
  def list?; end
  def ninth; end
  def nth(index); end
  def rest; end
  def rest_subject; end
  def reverse; end
  def second; end
  def seventh; end
  def shift; end
  def sixth; end
  def size; end
  def slice(*args); end
  def sort(&block); end
  def sort_by(&block); end
  def subject; end
  def tail; end
  def tenth; end
  def third; end
  def to_a; end
  def to_rdf(&block); end
  def to_s; end
  def to_set; end
  def to_term; end
  def uniq; end
  def unshift(value); end
  def valid?; end
  def |(other); end

  protected

  def slice_with_range(range); end
  def slice_with_start_and_length(start, length); end

  private

  def normalize_value(value); end

  class << self
    def [](*values); end
  end
end

RDF::List::NIL = T.let(T.unsafe(nil), RDF::List)
RDF::List::UNSET = T.let(T.unsafe(nil), Object)

class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype2?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(_arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = T.unsafe(nil)); end
  def inspect; end
  def language; end
  def language=(_arg0); end
  def language?; end
  def literal?; end
  def object; end
  def plain?; end
  def simple?; end
  def squish(*other_string); end
  def squish!; end
  def to_s; end
  def to_sxp(**options); end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end

  protected

  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def datatype_map; end
    def datatyped_class(uri); end
    def inherited(child); end
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

class RDF::Literal::Boolean < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def canonicalize!; end
  def false?; end
  def inspect; end
  def to_i; end
  def to_s; end
  def true?; end
end

RDF::Literal::Boolean::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Boolean::FALSES = T.let(T.unsafe(nil), Array)
RDF::Literal::Boolean::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::Boolean::TRUES = T.let(T.unsafe(nil), Array)

class RDF::Literal::Date < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = T.unsafe(nil)); end
  def timezone?; end
  def to_s; end
  def tz; end
  def tz?; end
  def valid?; end
end

RDF::Literal::Date::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Date::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Date::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::DateTime < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def ==(other); end
  def canonicalize!; end
  def has_milliseconds?; end
  def has_ms?; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = T.unsafe(nil)); end
  def milliseconds?; end
  def ms?; end
  def timezone; end
  def timezone?; end
  def to_s; end
  def tz; end
  def tz?; end
  def valid?; end
end

RDF::Literal::DateTime::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DateTime::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::DateTime::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Decimal < ::RDF::Literal::Numeric
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def abs; end
  def canonicalize!; end
  def ceil; end
  def floor; end
  def nonzero?; end
  def round; end
  def to_s; end
  def zero?; end
end

RDF::Literal::Decimal::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Decimal::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Double < ::RDF::Literal::Numeric
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def abs; end
  def canonicalize!; end
  def ceil; end
  def finite?; end
  def floor; end
  def infinite?; end
  def nan?; end
  def nonzero?; end
  def round; end
  def to_s; end
  def to_sxp(**options); end
  def zero?; end
end

RDF::Literal::Double::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Double::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::FALSE = T.let(T.unsafe(nil), RDF::Literal::Boolean)

class RDF::Literal::Integer < ::RDF::Literal::Decimal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def abs; end
  def canonicalize!; end
  def even?; end
  def next; end
  def nonzero?; end
  def odd?; end
  def pred; end
  def round; end
  def succ; end
  def to_bn; end
  def to_s; end
  def zero?; end
end

RDF::Literal::Integer::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Integer::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Numeric < ::RDF::Literal
  def %(other); end
  def *(other); end
  def **(other); end
  def +(other); end
  def +@; end
  def -(other); end
  def -@; end
  def /(other); end
  def <=>(other); end
  def ==(other); end
  def abs; end
  def ceil; end
  def floor; end
  def ord; end
  def round; end
  def to_d; end
  def to_f; end
  def to_i; end
  def to_int; end
  def to_r; end
end

RDF::Literal::TRUE = T.let(T.unsafe(nil), RDF::Literal::Boolean)

class RDF::Literal::Time < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = T.unsafe(nil)); end
  def timezone?; end
  def to_s; end
  def tz; end
  def tz?; end
  def valid?; end
end

RDF::Literal::Time::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Time::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Time::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Token < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def canonicalize!; end
  def to_s; end
  def to_sym; end
end

RDF::Literal::Token::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Token::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::ZERO = T.let(T.unsafe(nil), RDF::Literal::Integer)

module RDF::Mutable
  include ::RDF::Readable
  include ::RDF::Util::Coercions
  include ::RDF::Writable
  extend ::RDF::Util::Aliasing::LateBound

  def <<(data); end
  def apply_changeset(changeset); end
  def clear; end
  def clear!(*args, &block); end
  def delete(*statements); end
  def delete!(*args, &block); end
  def delete_insert(deletes, inserts); end
  def delete_insert!(*args, &block); end
  def immutable?; end
  def insert(*statements); end
  def load(url, graph_name: T.unsafe(nil), **options); end
  def load!(*args, &block); end
  def method_missing(meth, *args); end
  def mutable?; end
  def snapshot; end
  def update(*statements); end
  def update!(*args, &block); end

  protected

  def delete_statement(statement); end
  def delete_statements(statements); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module RDF::NQuads
  include ::RDF::NTriples

  class << self
    def serialize(value); end
    def unserialize(data); end
  end
end

class RDF::NQuads::Format < ::RDF::Format
  class << self
    def detect(sample); end
    def name; end
  end
end

class RDF::NQuads::Reader < ::RDF::NTriples::Reader
  def read_triple; end
end

class RDF::NQuads::Writer < ::RDF::NTriples::Writer
  def format_quad(subject, predicate, object, graph_name, **options); end
  def format_statement(statement, **options); end
  def write_quad(subject, predicate, object, graph_name); end
end

module RDF::NTriples
  class << self
    def escape(string); end
    def serialize(value); end
    def unescape(string); end
    def unserialize(data); end
  end
end

class RDF::NTriples::Format < ::RDF::Format
  class << self
    def detect(sample); end
    def name; end
  end
end

class RDF::NTriples::Reader < ::RDF::Reader
  def read_comment; end
  def read_eos; end
  def read_literal; end
  def read_node; end
  def read_quotedTriple; end
  def read_triple; end
  def read_uriref(intern: T.unsafe(nil), **options); end
  def read_value; end

  class << self
    def parse_literal(input, **options); end
    def parse_node(input, **options); end
    def parse_object(input, **options); end
    def parse_predicate(input, **options); end
    def parse_subject(input, **options); end
    def parse_uri(input, intern: T.unsafe(nil), **options); end
    def unescape(string); end
    def unserialize(input, **options); end
  end
end

RDF::NTriples::Reader::BLANK_NODE_LABEL = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::COMMENT = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::DATATYPE_URI = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::ECHAR = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::END_OF_STATEMENT = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::ESCAPE_CHARS = T.let(T.unsafe(nil), Array)
RDF::NTriples::Reader::ESCAPE_CHARS_ESCAPED = T.let(T.unsafe(nil), Hash)
RDF::NTriples::Reader::ESCAPE_CHARS_ESCAPED_REGEXP = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::IRIREF = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::IRI_RANGE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::LANGTAG = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::LITERAL = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::LITERAL_PLAIN = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::LITERAL_WITH_DATATYPE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::LITERAL_WITH_LANGUAGE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::NODEID = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::OBJECT = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::PN_CHARS = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::PN_CHARS_BASE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::PN_CHARS_U = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::PREDICATE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::STRING_LITERAL_QUOTE = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::ST_END = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::ST_START = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::SUBJECT = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::UCHAR = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::UCHAR4 = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::UCHAR8 = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::URIREF = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::U_CHARS1 = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Reader::U_CHARS2 = T.let(T.unsafe(nil), Regexp)

class RDF::NTriples::Writer < ::RDF::Writer
  def initialize(output = T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def escaped(string); end
  def format_literal(literal, **options); end
  def format_node(node, unique_bnodes: T.unsafe(nil), **options); end
  def format_quotedTriple(statement, **options); end
  def format_statement(statement, **options); end
  def format_triple(subject, predicate, object, **options); end
  def format_uri(uri, **options); end
  def write_comment(text); end
  def write_triple(subject, predicate, object); end

  class << self
    def escape(string, encoding = T.unsafe(nil)); end
    def escape_ascii(u, encoding); end
    def escape_unicode(u, encoding); end
    def escape_utf16(u); end
    def escape_utf32(u); end
    def serialize(value); end
  end
end

RDF::NTriples::Writer::ESCAPE_PLAIN = T.let(T.unsafe(nil), Regexp)
RDF::NTriples::Writer::ESCAPE_PLAIN_U = T.let(T.unsafe(nil), Regexp)

class RDF::Node
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(id = T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def anonymous?; end
  def dup; end
  def eql?(other); end
  def hash; end
  def id; end
  def id=(_arg0); end
  def labeled?; end
  def make_unique!; end
  def node?; end
  def original; end
  def original=(_arg0); end
  def to_s; end
  def to_sxp(**options); end
  def to_sym; end
  def to_unique_base; end
  def unlabeled?; end

  class << self
    def cache; end
    def intern(id); end
    def uuid(format: T.unsafe(nil)); end
  end
end

class RDF::OWL < ::RDF::StrictVocabulary
  class << self
    def AllDifferent; end
    def AllDisjointClasses; end
    def AllDisjointProperties; end
    def Annotation; end
    def AnnotationProperty; end
    def AsymmetricProperty; end
    def Axiom; end
    def Class; end
    def DataRange; end
    def DatatypeProperty; end
    def DeprecatedClass; end
    def DeprecatedProperty; end
    def FunctionalProperty; end
    def InverseFunctionalProperty; end
    def IrreflexiveProperty; end
    def NamedIndividual; end
    def NegativePropertyAssertion; end
    def Nothing; end
    def ObjectProperty; end
    def Ontology; end
    def OntologyProperty; end
    def ReflexiveProperty; end
    def Restriction; end
    def SymmetricProperty; end
    def Thing; end
    def TransitiveProperty; end
    def allValuesFrom; end
    def annotatedProperty; end
    def annotatedSource; end
    def annotatedTarget; end
    def assertionProperty; end
    def backwardCompatibleWith; end
    def bottomDataProperty; end
    def bottomObjectProperty; end
    def cardinality; end
    def complementOf; end
    def datatypeComplementOf; end
    def deprecated; end
    def differentFrom; end
    def disjointUnionOf; end
    def disjointWith; end
    def distinctMembers; end
    def equivalentClass; end
    def equivalentProperty; end
    def hasKey; end
    def hasSelf; end
    def hasValue; end
    def imports; end
    def incompatibleWith; end
    def intersectionOf; end
    def inverseOf; end
    def maxCardinality; end
    def maxQualifiedCardinality; end
    def members; end
    def minCardinality; end
    def minQualifiedCardinality; end
    def onClass; end
    def onDataRange; end
    def onDatatype; end
    def onProperties; end
    def onProperty; end
    def oneOf; end
    def priorVersion; end
    def propertyChainAxiom; end
    def propertyDisjointWith; end
    def qualifiedCardinality; end
    def sameAs; end
    def someValuesFrom; end
    def sourceIndividual; end
    def targetIndividual; end
    def targetValue; end
    def topDataProperty; end
    def topObjectProperty; end
    def unionOf; end
    def versionIRI; end
    def versionInfo; end
    def withRestrictions; end
  end
end

class RDF::Query
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable

  def initialize(*patterns, solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def +(other); end
  def <<(pattern); end
  def ==(other); end
  def apply_graph_name(graph_name = T.unsafe(nil)); end
  def bind(solution); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def executable?; end
  def execute(queryable, bindings: T.unsafe(nil), solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_variables?(*args); end
  def matched?; end
  def named?; end
  def ndvars; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def optimize_without_expression!(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def rewrite(&block); end
  def solutions; end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), **options); end
  def to_sxp(**options); end
  def to_sxp_bin; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?(*args); end
  def variable_count; end
  def variables; end
  def variables?(*args); end
  def vars; end

  protected

  def compile_hash_patterns(hash_patterns); end

  class << self
    def Solutions(*args); end
    def execute(queryable, patterns = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class RDF::Query::HashPatternNormalizer
  def initialize(**options); end

  def normalize!(hash_pattern); end
  def options; end

  class << self
    def normalize!(*args); end

    private

    def ensure_absence_of_duplicate_subjects!(acc, subject); end
    def normalize_array!(array, *args); end
    def normalize_hash!(hash, *args); end
    def normalize_object!(object, *args); end
    def replace_hash_with_anonymous_subject!(hash, acc, counter, anonymous_subject_format); end
  end
end

class RDF::Query::HashPatternNormalizer::Counter
  def initialize(offset = T.unsafe(nil), increment = T.unsafe(nil)); end

  def decrement!; end
  def increment; end
  def increment!; end
  def offset; end
  def to_f; end
  def to_i; end
  def to_s; end
end

class RDF::Query::Pattern < ::RDF::Statement
  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(_arg0); end
  def dup; end
  def eql?(other); end
  def executable?; end
  def execute(queryable, bindings = T.unsafe(nil), &block); end
  def has_variables?; end
  def initialize!; end
  def ndvars; end
  def optional?; end
  def options; end
  def solution(statement); end
  def to_s; end
  def to_sxp(**options); end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def var_values(var, statement); end
  def variable_count; end
  def variable_terms(name = T.unsafe(nil)); end
  def variables; end
  def variables?; end
  def vars; end

  class << self
    def from(pattern, graph_name: T.unsafe(nil), **options); end
  end
end

class RDF::Query::Solution
  include ::Enumerable

  def initialize(bindings = T.unsafe(nil), &block); end

  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def __send(*_arg0); end
  def bindings; end
  def bound?(name); end
  def compatible?(other); end
  def disjoint?(other); end
  def dup; end
  def each(&block); end
  def each_binding(&block); end
  def each_key(&block); end
  def each_name(&block); end
  def each_value(&block); end
  def each_variable; end
  def enum_binding; end
  def enum_name; end
  def enum_value; end
  def enum_variable; end
  def eql?(other); end
  def has_variables?(*args); end
  def hash; end
  def inspect; end
  def isomorphic_with?(other); end
  def merge(other); end
  def merge!(other); end
  def to_a; end
  def to_h; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end
  def to_sxp_bin; end
  def unbound?(name); end
  def variable?(*args); end
  def variables?(*args); end

  protected

  def enum_for(method = T.unsafe(nil)); end
  def method_missing(name, *args, &block); end
  def to_enum(method = T.unsafe(nil)); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

RDF::Query::Solution::INSTANCE_METHODS = T.let(T.unsafe(nil), Array)

class RDF::Query::Solutions < ::Array
  include ::SPARQL::Results

  def bindings; end
  def count(&block); end
  def distinct; end
  def distinct!; end
  def dup; end
  def each_solution; end
  def filter(expression = T.unsafe(nil), &block); end
  def filter!(expression = T.unsafe(nil), &block); end
  def filter_without_expression(criteria = T.unsafe(nil)); end
  def has_variables?(*args); end
  def have_variables?(*args); end
  def limit(length); end
  def limit!(length); end
  def merge(other); end
  def minus(other); end
  def offset(start); end
  def offset!(start); end
  def order(*variables); end
  def order_by(*variables); end
  def project(*variables); end
  def reduced; end
  def reduced!; end
  def select(*variables); end
  def variable?(*args); end
  def variable_names; end
  def variables?(*args); end
end

class RDF::Query::Variable
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(name = T.unsafe(nil), value = T.unsafe(nil), distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def bind(value); end
  def bind!(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def name; end
  def name=(_arg0); end
  def named?; end
  def optimize(**options); end
  def to_base; end
  def to_h; end
  def to_s; end
  def to_sparql(**options); end
  def to_sxp(**options); end
  def to_sym; end
  def unbind; end
  def unbind!; end
  def unbound?; end
  def value; end
  def value=(_arg0); end
  def var_values(var, term); end
  def variable?(*args); end
  def variables; end
end

module RDF::Queryable
  include ::Enumerable

  def concise_bounded_description(*terms, **options, &block); end
  def enum_for(method = T.unsafe(nil), *args); end
  def first(pattern = T.unsafe(nil)); end
  def first_literal(pattern = T.unsafe(nil)); end
  def first_object(pattern = T.unsafe(nil)); end
  def first_predicate(pattern = T.unsafe(nil)); end
  def first_subject(pattern = T.unsafe(nil)); end
  def first_value(pattern = T.unsafe(nil)); end
  def query(pattern, **options, &block); end
  def query_without_sparql(pattern, **options, &block); end
  def to_enum(method = T.unsafe(nil), *args); end
  def to_sparql(**options); end

  protected

  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
end

class RDF::Queryable::Enumerator < ::Enumerator
  include ::RDF::Queryable
  include ::RDF::Countable
  include ::RDF::Enumerable

  def to_a; end
end

class RDF::RDFS < ::RDF::StrictVocabulary
  class << self
    def Class; end
    def Container; end
    def ContainerMembershipProperty; end
    def Datatype; end
    def Literal; end
    def Resource; end
    def comment; end
    def domain; end
    def isDefinedBy; end
    def label; end
    def member; end
    def range; end
    def seeAlso; end
    def subClassOf; end
    def subPropertyOf; end
  end
end

class RDF::RDFV < ::RDF::StrictVocabulary
  class << self
    def Alt; end
    def Bag; end
    def CompoundLiteral; end
    def Description; end
    def HTML; end
    def ID; end
    def JSON; end
    def List; end
    def PlainLiteral; end
    def Property; end
    def Seq; end
    def Statement; end
    def XMLLiteral; end
    def __name__; end
    def about; end
    def datatype; end
    def direction; end
    def first; end
    def langString; end
    def language; end
    def li; end
    def name; end
    def nil; end
    def nodeID; end
    def object; end
    def parseType; end
    def predicate; end
    def resource; end
    def rest; end
    def subject; end
    def type; end
    def value; end
  end
end

RDF::RDF_N_REGEXP = T.let(T.unsafe(nil), Regexp)

module RDF::Readable
  extend ::RDF::Util::Aliasing::LateBound

  def readable?; end
end

class RDF::Reader
  include ::RDF::Util::Logger
  include ::RDF::Readable
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable
  extend ::Enumerable
  extend ::RDF::Util::Aliasing::LateBound

  def initialize(input = T.unsafe(nil), base_uri: T.unsafe(nil), canonicalize: T.unsafe(nil), encoding: T.unsafe(nil), intern: T.unsafe(nil), prefixes: T.unsafe(nil), rdfstar: T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def base_uri; end
  def canonicalize?; end
  def close; end
  def close!(*args, &block); end
  def each(*args, &block); end
  def each_statement(&block); end
  def each_triple(&block); end
  def encoding; end
  def intern?; end
  def lineno; end
  def options; end
  def prefix(name, uri = T.unsafe(nil)); end
  def prefix!(*args, &block); end
  def prefixes; end
  def prefixes=(prefixes); end
  def rewind; end
  def rewind!(*args, &block); end
  def to_sym; end
  def valid?; end
  def validate?; end

  protected

  def each_pg_statement(statement, &block); end
  def fail_object; end
  def fail_predicate; end
  def fail_subject; end
  def read_statement; end
  def read_triple; end

  private

  def blank?; end
  def current_line; end
  def match(pattern); end
  def readline; end
  def strip!; end

  class << self
    def each(&block); end
    def for(*arg, &block); end
    def format(klass = T.unsafe(nil)); end
    def format_class(klass = T.unsafe(nil)); end
    def inherited(child); end
    def open(filename, format: T.unsafe(nil), **options, &block); end
    def options; end
    def to_sym; end
  end
end

class RDF::ReaderError < ::IOError
  def initialize(message, token: T.unsafe(nil), lineno: T.unsafe(nil)); end

  def lineno; end
  def token; end
end

class RDF::Repository < ::RDF::Dataset
  include ::RDF::Readable
  include ::RDF::Util::Coercions
  include ::RDF::Writable
  include ::RDF::Mutable
  include ::RDF::Transactable

  def initialize(uri: T.unsafe(nil), title: T.unsafe(nil), **options, &block); end

  def delete_insert(deletes, inserts); end
  def isolation_level; end
  def options; end
  def project_graph(graph_name, &block); end
  def snapshot; end
  def supports?(feature); end
  def title; end
  def uri; end
  def url; end

  protected

  def begin_transaction(mutable: T.unsafe(nil), graph_name: T.unsafe(nil)); end

  class << self
    def load(urls, **options, &block); end
  end
end

RDF::Repository::DEFAULT_TX_CLASS = RDF::Transaction

module RDF::Repository::Implementation
  def apply_changeset(changeset); end
  def count; end
  def each(&block); end
  def each_graph(&block); end
  def each_statement(&block); end
  def graph?(*args); end
  def graph_names(options = T.unsafe(nil), &block); end
  def has_graph?(*args); end
  def has_statement?(*args); end
  def isolation_level; end
  def snapshot; end
  def statement?(*args); end
  def supports?(feature); end

  protected

  def clear_statements; end
  def data; end
  def data=(hash); end
  def delete_statement(statement); end
  def insert_statement(statement); end
  def query_pattern(pattern, **options, &block); end

  private

  def delete_from(data, statement); end
  def has_statement_in?(data, statement); end
  def insert_to(data, statement); end
  def statement_in?(data, statement); end

  class << self
    def extend_object(obj); end
  end
end

RDF::Repository::Implementation::SerializedTransaction = RDF::Transaction::SerializedTransaction

module RDF::Resource
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def resource?; end

  class << self
    def new(*args, &block); end
  end
end

class RDF::Statement
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def [](index); end
  def []=(index, value); end
  def asserted?; end
  def canonicalize; end
  def canonicalize!; end
  def complete?; end
  def embedded?; end
  def eql?(other); end
  def executable?; end
  def graph?(*args); end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_graph?(*args); end
  def has_name?(*args); end
  def has_object?; end
  def has_predicate?; end
  def has_subject?; end
  def hash; end
  def id; end
  def id=(_arg0); end
  def incomplete?; end
  def inferred?; end
  def initialize!; end
  def invalid?; end
  def name?(*args); end
  def node?; end
  def object; end
  def object=(_arg0); end
  def object?; end
  def optimize(**options); end
  def options; end
  def options=(_arg0); end
  def predicate; end
  def predicate=(_arg0); end
  def predicate?; end
  def quoted?; end
  def reified(subject: T.unsafe(nil), id: T.unsafe(nil), graph_name: T.unsafe(nil)); end
  def statement?(*args); end
  def subject; end
  def subject=(_arg0); end
  def subject?; end
  def terms; end
  def to_a; end
  def to_h(subject_key = T.unsafe(nil), predicate_key = T.unsafe(nil), object_key = T.unsafe(nil), graph_key = T.unsafe(nil)); end
  def to_quad; end
  def to_s; end
  def to_sparql(as_statement: T.unsafe(nil), **options); end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end
  def to_sxp_bin; end
  def to_triple; end
  def valid?; end
  def variable?(*args); end

  class << self
    def from(statement, graph_name: T.unsafe(nil), **options); end
  end
end

class RDF::StrictVocabulary < ::RDF::Vocabulary
  class << self
    def [](name); end
    def method_missing(*_arg0); end
    def strict?; end
  end
end

module RDF::Term
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  def <=>(other); end
  def ==(other); end
  def aggregate?; end
  def compatible?(other); end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def ndvars; end
  def optimize(**options); end
  def term?(*args); end
  def terms; end
  def to_base; end
  def to_sparql(**options); end
  def to_term; end
  def vars; end

  protected

  def escape(string); end
end

module RDF::Transactable
  def transact(mutable: T.unsafe(nil), &block); end
  def transaction(mutable: T.unsafe(nil), &block); end

  protected

  def begin_transaction(mutable: T.unsafe(nil), graph_name: T.unsafe(nil)); end
  def commit_transaction(tx); end
  def rollback_transaction(tx); end
end

class RDF::Transaction
  include ::RDF::Readable
  include ::RDF::Util::Coercions
  include ::RDF::Writable
  include ::RDF::Mutable
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable
  include ::RDF::Queryable

  def initialize(repository, graph_name: T.unsafe(nil), mutable: T.unsafe(nil), **options, &block); end

  def changes; end
  def each(*args, &block); end
  def execute; end
  def graph_name; end
  def has_statement?(*args); end
  def inspect; end
  def inspect!; end
  def isolation_level; end
  def mutable?; end
  def mutated?; end
  def options; end
  def readable?; end
  def repository; end
  def rollback; end
  def statement?(*args); end
  def writable?; end

  protected

  def delete_statement(statement); end
  def insert_statement(statement); end
  def query_execute(*args, &block); end
  def query_pattern(*args, &block); end

  private

  def process_statement(statement); end
  def read_target; end

  class << self
    def begin(repository, mutable: T.unsafe(nil), **options, &block); end
  end
end

class RDF::Transaction::SerializedTransaction < ::RDF::Transaction
  def initialize(*args, **options, &block); end

  def delete_statement(statement); end
  def execute; end
  def insert_statement(statement); end
  def isolation_level; end
  def mutated?; end
end

class RDF::Transaction::TransactionError < ::RuntimeError; end

module RDF::TypeCheck
  def type_error(message); end
end

class RDF::URI
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(*args, validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def +(other); end
  def /(fragment); end
  def ==(other); end
  def ===(other); end
  def =~(pattern); end
  def _dump(level); end
  def absolute?; end
  def authority; end
  def authority=(value); end
  def canonicalize; end
  def canonicalize!; end
  def dup; end
  def end_with?(string); end
  def ends_with?(string); end
  def eql?(other); end
  def fragment; end
  def fragment=(value); end
  def freeze; end
  def has_parent?; end
  def hash; end
  def hier?; end
  def host; end
  def host=(value); end
  def inspect; end
  def join(*uris); end
  def length; end
  def lexical; end
  def lexical=(value); end
  def normalize; end
  def normalize!; end
  def normalized_authority; end
  def normalized_fragment; end
  def normalized_host; end
  def normalized_password; end
  def normalized_path; end
  def normalized_port; end
  def normalized_query; end
  def normalized_scheme; end
  def normalized_user; end
  def normalized_userinfo; end
  def object; end
  def parent; end
  def parent?; end
  def parse(value); end
  def password; end
  def password=(value); end
  def path; end
  def path=(value); end
  def pname(prefixes: T.unsafe(nil)); end
  def port; end
  def port=(value); end
  def qname(prefixes: T.unsafe(nil)); end
  def query; end
  def query=(value); end
  def query_values(return_type = T.unsafe(nil)); end
  def query_values=(value); end
  def relative?; end
  def relativize(base_uri); end
  def request_uri; end
  def root; end
  def root?; end
  def scheme; end
  def scheme=(value); end
  def size; end
  def to_h; end
  def to_s; end
  def to_str; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil), **options); end
  def to_uri; end
  def uri?; end
  def url?; end
  def urn?; end
  def user; end
  def user=(value); end
  def userinfo; end
  def userinfo=(value); end
  def valid?; end
  def validate!; end
  def value; end

  private

  def format_authority; end
  def format_userinfo(append = T.unsafe(nil)); end
  def normalize_segment(value, expr, downcase = T.unsafe(nil)); end

  class << self
    def _load(data); end
    def cache; end
    def decode(str); end
    def encode(str, expr); end
    def intern(str, *args, **options); end
    def normalize_path(path); end
    def parse(str); end
  end
end

RDF::URI::GEN_DELIMS = T.let(T.unsafe(nil), Regexp)
RDF::URI::HOST_FROM_AUTHORITY_RE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IAUTHORITY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IFRAGMENT = T.let(T.unsafe(nil), Regexp)
RDF::URI::IHIER_PART = T.let(T.unsafe(nil), Regexp)
RDF::URI::IHOST = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ABEMPTY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ABSOLUTE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_EMPTY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_NOSCHEME = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ROOTLESS = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPCHAR = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPRIVATE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IP_literal = T.let(T.unsafe(nil), Regexp)
RDF::URI::IQUERY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IREG_NAME = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRELATIVE_PART = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRELATIVE_REF = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRI = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRI_PARTS = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT_NZ = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT_NZ_NC = T.let(T.unsafe(nil), Regexp)
RDF::URI::IUNRESERVED = T.let(T.unsafe(nil), Regexp)
RDF::URI::IUSERINFO = T.let(T.unsafe(nil), Regexp)
RDF::URI::NON_HIER_SCHEMES = T.let(T.unsafe(nil), Array)
RDF::URI::PCT_ENCODED = T.let(T.unsafe(nil), Regexp)
RDF::URI::PN_ESCAPES = T.let(T.unsafe(nil), Regexp)
RDF::URI::PN_ESCAPE_CHARS = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT_FROM_AUTHORITY_RE = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT_MAPPING = T.let(T.unsafe(nil), Hash)
RDF::URI::RDS_2A = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2B1 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2B2 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2C1 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2C2 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2D = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2E = T.let(T.unsafe(nil), Regexp)
RDF::URI::RESERVED = T.let(T.unsafe(nil), Regexp)
RDF::URI::SCHEME = T.let(T.unsafe(nil), Regexp)
RDF::URI::SUB_DELIMS = T.let(T.unsafe(nil), Regexp)
RDF::URI::UCSCHAR = T.let(T.unsafe(nil), Regexp)
RDF::URI::UNRESERVED = T.let(T.unsafe(nil), Regexp)
module RDF::Util; end
module RDF::Util::Aliasing; end

module RDF::Util::Aliasing::LateBound
  def alias_method(new_name, old_name); end
end

class RDF::Util::Cache
  def initialize(capacity = T.unsafe(nil)); end

  def capacity; end
  def capacity?; end
  def has_capacity?; end
  def size; end

  class << self
    def new(*args); end
  end
end

class RDF::Util::Cache::ObjectSpaceCache < ::RDF::Util::Cache
  def [](key); end
  def []=(key, value); end
  def delete(key); end
end

class RDF::Util::Cache::WeakRefCache < ::RDF::Util::Cache
  def initialize(capacity = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def delete(key); end
end

module RDF::Util::Coercions
  protected

  def coerce_statements(statements, query: T.unsafe(nil), constant: T.unsafe(nil), &block); end
end

module RDF::Util::File
  class << self
    def http_adapter(use_net_http = T.unsafe(nil)); end
    def http_adapter=(http_adapter); end
    def open_file(filename_or_url, proxy: T.unsafe(nil), headers: T.unsafe(nil), verify_none: T.unsafe(nil), **options, &block); end
  end
end

class RDF::Util::File::FaradayAdapter < ::RDF::Util::File::HttpAdapter
  class << self
    def conn; end
    def conn=(conn); end
    def open_url(base_uri, proxy: T.unsafe(nil), headers: T.unsafe(nil), verify_none: T.unsafe(nil), **options); end
  end
end

class RDF::Util::File::HttpAdapter
  class << self
    def default_accept_header; end
    def default_user_agent; end
    def headers(headers: T.unsafe(nil)); end
    def open_url(base_uri, proxy: T.unsafe(nil), headers: T.unsafe(nil), verify_none: T.unsafe(nil), **options); end
  end
end

class RDF::Util::File::NetHttpAdapter < ::RDF::Util::File::HttpAdapter
  class << self
    def open_url(base_uri, proxy: T.unsafe(nil), headers: T.unsafe(nil), verify_none: T.unsafe(nil), **options); end
  end
end

class RDF::Util::File::RemoteDocument < ::StringIO
  def initialize(body, options = T.unsafe(nil)); end

  def base_uri; end
  def charset; end
  def code; end
  def content_encoding; end
  def content_type; end
  def etag; end
  def headers; end
  def last_modified; end
  def links; end
  def parameters; end
  def requested_url; end
end

class RDF::Util::File::RestClientAdapter < ::RDF::Util::File::HttpAdapter
  class << self
    def open_url(base_uri, proxy: T.unsafe(nil), headers: T.unsafe(nil), verify_none: T.unsafe(nil), **options); end
  end
end

module RDF::Util::Logger
  def log_debug(*args, level: T.unsafe(nil), **options, &block); end
  def log_depth(**options, &block); end
  def log_error(*args, level: T.unsafe(nil), **options, &block); end
  def log_fatal(*args, level: T.unsafe(nil), **options, &block); end
  def log_info(*args, level: T.unsafe(nil), **options, &block); end
  def log_recover(*args, level: T.unsafe(nil), **options, &block); end
  def log_recovering?(**options); end
  def log_statistics(**options); end
  def log_warn(*args, level: T.unsafe(nil), **options, &block); end
  def logger(logger: T.unsafe(nil), **options); end

  private

  def logger_common(*args, level:, **options); end
end

class RDF::Util::Logger::IOWrapper
  def <<(*args, &block); end
  def <=>(*args, &block); end
  def __binding__(*args, &block); end
  def __getobj__; end
  def __setobj__(obj); end
  def abort(*args, &block); end
  def acts_like?(*args, &block); end
  def advise(*args, &block); end
  def all?(*args, &block); end
  def any?(*args, &block); end
  def as_json(*args, &block); end
  def autoclose=(*args, &block); end
  def autoclose?(*args, &block); end
  def beep(*args, &block); end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def blank?(*args, &block); end
  def byebug(*args, &block); end
  def chain(*args, &block); end
  def check_winsize_changed(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def class_eval(*args, &block); end
  def clear_screen(*args, &block); end
  def close(*args, &block); end
  def close_on_exec=(*args, &block); end
  def close_on_exec?(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def collect(*args, &block); end
  def collect_concat(*args, &block); end
  def compact_blank(*args, &block); end
  def console_mode(*args, &block); end
  def console_mode=(*args, &block); end
  def cooked(*args, &block); end
  def cooked!(*args, &block); end
  def count(*args, &block); end
  def cursor(*args, &block); end
  def cursor=(*args, &block); end
  def cursor_down(*args, &block); end
  def cursor_left(*args, &block); end
  def cursor_right(*args, &block); end
  def cursor_up(*args, &block); end
  def cycle(*args, &block); end
  def debugger(*args, &block); end
  def deep_dup(*args, &block); end
  def detect(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def duplicable?(*args, &block); end
  def each(*args, &block); end
  def each_byte(*args, &block); end
  def each_char(*args, &block); end
  def each_codepoint(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_line(*args, &block); end
  def each_slice(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end
  def echo=(*args, &block); end
  def echo?(*args, &block); end
  def entries(*args, &block); end
  def eof(*args, &block); end
  def eof?(*args, &block); end
  def erase_line(*args, &block); end
  def erase_screen(*args, &block); end
  def exclude?(*args, &block); end
  def excluding(*args, &block); end
  def exit(*args, &block); end
  def external_encoding(*args, &block); end
  def fcntl(*args, &block); end
  def fdatasync(*args, &block); end
  def fileno(*args, &block); end
  def filter(*args, &block); end
  def filter_map(*args, &block); end
  def find(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def flat_map(*args, &block); end
  def flush(*args, &block); end
  def friendly_id?(*args, &block); end
  def fsync(*args, &block); end
  def getbyte(*args, &block); end
  def getc(*args, &block); end
  def getch(*args, &block); end
  def getpass(*args, &block); end
  def gets(*args, &block); end
  def goto(*args, &block); end
  def goto_column(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end
  def hash(*args, &block); end
  def html_safe?(*args, &block); end
  def iflush(*args, &block); end
  def in?(*args, &block); end
  def include?(*args, &block); end
  def including(*args, &block); end
  def index_by(*args, &block); end
  def index_with(*args, &block); end
  def inject(*args, &block); end
  def instance_values(*args, &block); end
  def instance_variable_names(*args, &block); end
  def internal_encoding(*args, &block); end
  def ioctl(*args, &block); end
  def ioflush(*args, &block); end
  def isatty(*args, &block); end
  def lazy(*args, &block); end
  def lineno(*args, &block); end
  def lineno=(*args, &block); end
  def load_dependency(*args, &block); end
  def many?(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def noecho(*args, &block); end
  def nonblock(*args, &block); end
  def nonblock=(*args, &block); end
  def nonblock?(*args, &block); end
  def none?(*args, &block); end
  def nread(*args, &block); end
  def oflush(*args, &block); end
  def one?(*args, &block); end
  def partition(*args, &block); end
  def pathconf(*args, &block); end
  def pick(*args, &block); end
  def pid(*args, &block); end
  def pluck(*args, &block); end
  def pos(*args, &block); end
  def pos=(*args, &block); end
  def pread(*args, &block); end
  def presence(*args, &block); end
  def presence_in(*args, &block); end
  def present?(*args, &block); end
  def pressed?(*args, &block); end
  def pretty_inspect(*args, &block); end
  def pretty_print(*args, &block); end
  def pretty_print_cycle(*args, &block); end
  def pretty_print_inspect(*args, &block); end
  def pretty_print_instance_variables(*args, &block); end
  def print(*args, &block); end
  def printf(*args, &block); end
  def pry(*args, &block); end
  def putc(*args, &block); end
  def puts(*args, &block); end
  def pwrite(*args, &block); end
  def raw(*args, &block); end
  def raw!(*args, &block); end
  def read(*args, &block); end
  def read_nonblock(*args, &block); end
  def readbyte(*args, &block); end
  def readchar(*args, &block); end
  def readline(*args, &block); end
  def readlines(*args, &block); end
  def readpartial(*args, &block); end
  def ready?(*args, &block); end
  def reduce(*args, &block); end
  def reject(*args, &block); end
  def remote_byebug(*args, &block); end
  def reopen(*args, &block); end
  def require_dependency(*args, &block); end
  def require_or_load(*args, &block); end
  def reverse_each(*args, &block); end
  def rewind(*args, &block); end
  def scroll_backward(*args, &block); end
  def scroll_forward(*args, &block); end
  def seek(*args, &block); end
  def select(*args, &block); end
  def set_encoding(*args, &block); end
  def set_encoding_by_bom(*args, &block); end
  def should(*args, &block); end
  def should_not(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort(*args, &block); end
  def sort_by(*args, &block); end
  def stat(*args, &block); end
  def sum(*args, &block); end
  def sync(*args, &block); end
  def sync=(*args, &block); end
  def sysread(*args, &block); end
  def sysseek(*args, &block); end
  def syswrite(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def tally(*args, &block); end
  def tell(*args, &block); end
  def to_a(*args, &block); end
  def to_h(*args, &block); end
  def to_i(*args, &block); end
  def to_io(*args, &block); end
  def to_json(*args, &block); end
  def to_param(*args, &block); end
  def to_query(*args, &block); end
  def to_set(*args, &block); end
  def to_sxp(*args, &block); end
  def to_yaml(*args, &block); end
  def try(*args, &block); end
  def try!(*args, &block); end
  def tty?(*args, &block); end
  def unfriendly_id?(*args, &block); end
  def ungetbyte(*args, &block); end
  def ungetc(*args, &block); end
  def uniq(*args, &block); end
  def unloadable(*args, &block); end
  def wait(*args, &block); end
  def wait_priority(*args, &block); end
  def wait_readable(*args, &block); end
  def wait_writable(*args, &block); end
  def winsize(*args, &block); end
  def winsize=(*args, &block); end
  def with_options(*args, &block); end
  def without(*args, &block); end
  def write(*args, &block); end
  def write_nonblock(*args, &block); end
  def zip(*args, &block); end

  class << self
    def instance_method(name); end
    def instance_methods(all = T.unsafe(nil)); end
    def protected_instance_methods(all = T.unsafe(nil)); end
    def public_instance_method(name); end
    def public_instance_methods(all = T.unsafe(nil)); end
  end
end

RDF::Util::Logger::LOGGER_COMMON_LEVELS = T.let(T.unsafe(nil), Hash)
RDF::Util::Logger::LOGGER_COMMON_LEVELS_REVERSE = T.let(T.unsafe(nil), Hash)

module RDF::Util::Logger::LoggerBehavior
  def log_depth(depth: T.unsafe(nil), **options); end
  def log_statistics; end
  def method_missing(method, *args); end
  def recovering; end
  def recovering=(_arg0); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module RDF::Util::UUID
  class << self
    def generate(format: T.unsafe(nil)); end
  end
end

module RDF::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

RDF::VERSION::FILE = T.let(T.unsafe(nil), String)
RDF::VERSION::MAJOR = T.let(T.unsafe(nil), String)
RDF::VERSION::MINOR = T.let(T.unsafe(nil), String)
RDF::VERSION::STRING = T.let(T.unsafe(nil), String)
RDF::VERSION::TINY = T.let(T.unsafe(nil), String)
RDF::VOCABS = T.let(T.unsafe(nil), Hash)

module RDF::Value
  def anonymous?; end
  def canonicalize; end
  def canonicalize!; end
  def constant?; end
  def graph?(*args); end
  def inspect; end
  def inspect!; end
  def invalid?; end
  def iri?; end
  def list?; end
  def literal?; end
  def node?; end
  def resource?; end
  def start_with?(string); end
  def starts_with?(string); end
  def statement?(*args); end
  def term?(*args); end
  def to_nquads; end
  def to_ntriples; end
  def to_rdf; end
  def to_term; end
  def type_error(message); end
  def uri?; end
  def valid?; end
  def validate; end
  def validate!; end
  def variable?(*args); end
end

class RDF::Vocabulary
  extend ::Enumerable

  def initialize(uri); end

  def [](property); end
  def inspect; end
  def to_iri; end
  def to_s; end
  def to_uri; end

  protected

  def method_missing(property, *args, &block); end

  class << self
    def [](property); end
    def __imports__; end
    def __name__; end
    def __ontology__(*args); end
    def __prefix__; end
    def __prefix__=(prefix); end
    def __properties__; end
    def __property__(*args); end
    def camelize(str); end
    def create(uri); end
    def each(&block); end
    def each_statement(&block); end
    def enum_for(method = T.unsafe(nil), *args); end
    def expand_pname(pname); end
    def find(uri); end
    def find_term(uri); end
    def from_graph(graph, url: T.unsafe(nil), class_name: T.unsafe(nil), extra: T.unsafe(nil)); end
    def from_sym(sym); end
    def imported_from; end
    def imports; end
    def inspect; end
    def limit_vocabs(*vocabs); end
    def ontology(*args); end
    def properties; end
    def property(*args); end
    def register(prefix, vocab, **params); end
    def strict?; end
    def term(*args); end
    def to_enum(method = T.unsafe(nil), *args); end
    def to_iri; end
    def to_s; end
    def to_uri; end
    def vocab_map; end

    protected

    def inherited(subclass); end
    def list(*values); end
    def method_missing(property, *args, &block); end

    private

    def props; end
  end
end

class RDF::Vocabulary::Format < ::RDF::Format; end

module RDF::Vocabulary::Term
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def attribute_value(prop); end
  def attributes; end
  def class?; end
  def datatype?; end
  def domain_includes; end
  def dup; end
  def each_statement; end
  def enum_for(method = T.unsafe(nil), *args); end
  def inspect; end
  def other?; end
  def properties; end
  def property?; end
  def range_includes; end
  def respond_to?(method, include_all = T.unsafe(nil)); end
  def restriction?; end
  def to_enum(method = T.unsafe(nil), *args); end
  def to_ruby(indent: T.unsafe(nil)); end
  def valid?; end
  def vocab; end

  protected

  def method_missing(method, *args, &block); end

  class << self
    def intern(str, *args, **options); end
    def new(*args, vocab: T.unsafe(nil), attributes: T.unsafe(nil), **options); end
  end
end

RDF::Vocabulary::Term::ATTR_URIs = T.let(T.unsafe(nil), Hash)
RDF::Vocabulary::Term::URI_ATTRs = T.let(T.unsafe(nil), Hash)

class RDF::Vocabulary::Writer < ::RDF::Writer
  def initialize(output = T.unsafe(nil), base_uri:, **options, &block); end

  def class_name; end
  def class_name=(_arg0); end
  def module_name; end
  def module_name=(_arg0); end
  def write_epilogue; end
  def write_triple(subject, predicate, object); end

  private

  def from_node(name, attributes, term_type); end
  def serialize_value(value, key, indent: T.unsafe(nil)); end

  class << self
    def options; end
  end
end

module RDF::Writable
  include ::RDF::Util::Coercions
  extend ::RDF::Util::Aliasing::LateBound

  def <<(data); end
  def insert(*statements); end
  def insert!(*args, &block); end
  def writable?; end

  protected

  def insert_graph(graph); end
  def insert_reader(reader); end
  def insert_statement(statement); end
  def insert_statements(statements); end
end

class RDF::Writer
  include ::RDF::Util::Logger
  include ::RDF::Util::Coercions
  include ::RDF::Writable
  extend ::Enumerable
  extend ::RDF::Util::Aliasing::LateBound

  def initialize(output = T.unsafe(nil), **options, &block); end

  def base_uri; end
  def canonicalize?; end
  def encoding; end
  def flush; end
  def flush!(*args, &block); end
  def format_list(value, **options); end
  def format_literal(value, **options); end
  def format_node(value, **options); end
  def format_quotedTriple(value, **options); end
  def format_term(term, **options); end
  def format_uri(value, **options); end
  def insert_statement(*args, &block); end
  def options; end
  def prefix(name, uri = T.unsafe(nil)); end
  def prefix!(*args, &block); end
  def prefixes; end
  def prefixes=(prefixes); end
  def to_sym; end
  def validate?; end
  def write_comment(text); end
  def write_epilogue; end
  def write_prologue; end
  def write_statement(statement); end
  def write_triple(subject, predicate, object); end
  def write_triples(*triples); end

  protected

  def escaped(string); end
  def node_id; end
  def puts(*args); end
  def quoted(string); end
  def uri_for(term); end

  class << self
    def accept?(accept_params); end
    def buffer(*args, **options, &block); end
    def dump(data, io = T.unsafe(nil), **options); end
    def each(&block); end
    def for(*arg, &block); end
    def format(klass = T.unsafe(nil)); end
    def format_class(klass = T.unsafe(nil)); end
    def inherited(child); end
    def open(filename, format: T.unsafe(nil), **options, &block); end
    def options; end
    def to_sym; end
  end
end

class RDF::WriterError < ::IOError; end

class RDF::XSD < ::RDF::Vocabulary
  class << self
    def ENTITIES; end
    def ENTITY; end
    def ID; end
    def IDREF; end
    def IDREFS; end
    def NCName; end
    def NMTOKEN; end
    def NMTOKENS; end
    def NOTATION; end
    def Name; end
    def QName; end
    def anyAtomicType; end
    def anySimpleType; end
    def anyType; end
    def anyURI; end
    def base64Binary; end
    def boolean; end
    def byte; end
    def date; end
    def dateTime; end
    def dateTimeStamp; end
    def dayTimeDuration; end
    def decimal; end
    def double; end
    def duration; end
    def float; end
    def gDay; end
    def gMonth; end
    def gMonthDay; end
    def gYear; end
    def gYearMonth; end
    def hexBinary; end
    def int; end
    def integer; end
    def language; end
    def long; end
    def negativeInteger; end
    def nonNegativeInteger; end
    def nonPositiveInteger; end
    def normalizedString; end
    def positiveInteger; end
    def short; end
    def string; end
    def time; end
    def token; end
    def unsignedByte; end
    def unsignedInt; end
    def unsignedLong; end
    def unsignedShort; end
    def yearMonthDuration; end
  end
end
