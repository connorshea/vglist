# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sparql` gem.
# Please instead update this file by running `bin/tapioca gem sparql`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def aggregate?; end
  def bind(solution); end
  def constant?; end
  def deep_dup; end
  def evaluatable?; end
  def executable?; end
  def execute(queryable, **options); end
  def ndvars; end
  def node?; end
  def optimize(**options); end
  def replace_aggregate!(&block); end
  def replace_vars!(&block); end
  def to_sparql(delimiter: T.unsafe(nil), **options); end
  def to_sxp_bin; end
  def valid?; end
  def validate!; end
  def variable?; end
  def vars; end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils
  include ::SafeType::BooleanMixin

  def to_sxp(**options); end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def deep_dup; end
  def optimize(**options); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def evaluate(bindings, **options); end
  def to_sxp(**options); end
end

class Object < ::BasicObject
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::Kernel
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::ActiveSupport::Dependencies::Loadable
  include ::FriendlyId::ObjectUtils
  include ::PP::ObjectMixin
  include ::MakeMakefile

  def deep_dup; end
  def optimize(**options); end
  def to_sparql(**options); end
  def to_sse; end
  def to_sxp_bin; end
end

class RDF::Query
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable

  def initialize(*patterns, solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def +(other); end
  def <<(pattern); end
  def ==(other); end
  def apply_graph_name(graph_name = T.unsafe(nil)); end
  def bind(solution); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def executable?; end
  def execute(queryable, bindings: T.unsafe(nil), solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_variables?(*args); end
  def matched?; end
  def named?; end
  def ndvars; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def optimize_without_expression!(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def rewrite(&block); end
  def solutions; end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), **options); end
  def to_sxp(**options); end
  def to_sxp_bin; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?(*args); end
  def variable_count; end
  def variables; end
  def variables?(*args); end
  def vars; end

  protected

  def compile_hash_patterns(hash_patterns); end

  class << self
    def Solutions(*args); end
    def execute(queryable, patterns = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class RDF::Query::Pattern < ::RDF::Statement
  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(_arg0); end
  def dup; end
  def eql?(other); end
  def executable?; end
  def execute(queryable, bindings = T.unsafe(nil), &block); end
  def has_variables?; end
  def initialize!; end
  def ndvars; end
  def optional?; end
  def options; end
  def solution(statement); end
  def to_s; end
  def to_sxp(**options); end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def var_values(var, statement); end
  def variable_count; end
  def variable_terms(name = T.unsafe(nil)); end
  def variables; end
  def variables?; end
  def vars; end

  class << self
    def from(pattern, graph_name: T.unsafe(nil), **options); end
  end
end

class RDF::Query::Solution
  include ::Enumerable

  def initialize(bindings = T.unsafe(nil), &block); end

  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def __send(*_arg0); end
  def bindings; end
  def bound?(name); end
  def compatible?(other); end
  def disjoint?(other); end
  def dup; end
  def each(&block); end
  def each_binding(&block); end
  def each_key(&block); end
  def each_name(&block); end
  def each_value(&block); end
  def each_variable; end
  def enum_binding; end
  def enum_name; end
  def enum_value; end
  def enum_variable; end
  def eql?(other); end
  def has_variables?(*args); end
  def hash; end
  def inspect; end
  def isomorphic_with?(other); end
  def merge(other); end
  def merge!(other); end
  def to_a; end
  def to_h; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end
  def to_sxp_bin; end
  def unbound?(name); end
  def variable?(*args); end
  def variables?(*args); end

  protected

  def enum_for(method = T.unsafe(nil)); end
  def method_missing(name, *args, &block); end
  def to_enum(method = T.unsafe(nil)); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

RDF::Query::Solution::INSTANCE_METHODS = T.let(T.unsafe(nil), Array)

class RDF::Query::Solutions < ::Array
  include ::SPARQL::Results

  def bindings; end
  def count(&block); end
  def distinct; end
  def distinct!; end
  def dup; end
  def each_solution; end
  def filter(expression = T.unsafe(nil), &block); end
  def filter!(expression = T.unsafe(nil), &block); end
  def filter_without_expression(criteria = T.unsafe(nil)); end
  def has_variables?(*args); end
  def have_variables?(*args); end
  def limit(length); end
  def limit!(length); end
  def merge(other); end
  def minus(other); end
  def offset(start); end
  def offset!(start); end
  def order(*variables); end
  def order_by(*variables); end
  def project(*variables); end
  def reduced; end
  def reduced!; end
  def select(*variables); end
  def variable?(*args); end
  def variable_names; end
  def variables?(*args); end
end

class RDF::Query::Variable
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(name = T.unsafe(nil), value = T.unsafe(nil), distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def bind(value); end
  def bind!(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def name; end
  def name=(_arg0); end
  def named?; end
  def optimize(**options); end
  def to_base; end
  def to_h; end
  def to_s; end
  def to_sparql(**options); end
  def to_sxp(**options); end
  def to_sym; end
  def unbind; end
  def unbind!; end
  def unbound?; end
  def value; end
  def value=(_arg0); end
  def var_values(var, term); end
  def variable?(*args); end
  def variables; end
end

module RDF::Queryable
  include ::Enumerable

  def concise_bounded_description(*terms, **options, &block); end
  def enum_for(method = T.unsafe(nil), *args); end
  def first(pattern = T.unsafe(nil)); end
  def first_literal(pattern = T.unsafe(nil)); end
  def first_object(pattern = T.unsafe(nil)); end
  def first_predicate(pattern = T.unsafe(nil)); end
  def first_subject(pattern = T.unsafe(nil)); end
  def first_value(pattern = T.unsafe(nil)); end
  def query(pattern, **options, &block); end
  def query_without_sparql(pattern, **options, &block); end
  def to_enum(method = T.unsafe(nil), *args); end
  def to_sparql(**options); end

  protected

  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
end

class RDF::Statement
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def [](index); end
  def []=(index, value); end
  def asserted?; end
  def canonicalize; end
  def canonicalize!; end
  def complete?; end
  def embedded?; end
  def eql?(other); end
  def executable?; end
  def graph?(*args); end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_graph?(*args); end
  def has_name?(*args); end
  def has_object?; end
  def has_predicate?; end
  def has_subject?; end
  def hash; end
  def id; end
  def id=(_arg0); end
  def incomplete?; end
  def inferred?; end
  def initialize!; end
  def invalid?; end
  def name?(*args); end
  def node?; end
  def object; end
  def object=(_arg0); end
  def object?; end
  def optimize(**options); end
  def options; end
  def options=(_arg0); end
  def predicate; end
  def predicate=(_arg0); end
  def predicate?; end
  def quoted?; end
  def reified(subject: T.unsafe(nil), id: T.unsafe(nil), graph_name: T.unsafe(nil)); end
  def statement?(*args); end
  def subject; end
  def subject=(_arg0); end
  def subject?; end
  def terms; end
  def to_a; end
  def to_h(subject_key = T.unsafe(nil), predicate_key = T.unsafe(nil), object_key = T.unsafe(nil), graph_key = T.unsafe(nil)); end
  def to_quad; end
  def to_s; end
  def to_sparql(as_statement: T.unsafe(nil), **options); end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end
  def to_sxp_bin; end
  def to_triple; end
  def valid?; end
  def variable?(*args); end

  class << self
    def from(statement, graph_name: T.unsafe(nil), **options); end
  end
end

module RDF::Term
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  def <=>(other); end
  def ==(other); end
  def aggregate?; end
  def compatible?(other); end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def ndvars; end
  def optimize(**options); end
  def term?(*args); end
  def terms; end
  def to_base; end
  def to_sparql(**options); end
  def to_term; end
  def vars; end

  protected

  def escape(string); end
end

module SPARQL
  private

  def first_content_type(acceptable, available); end
  def serialize_exception(exception, **options); end
  def serialize_results(solutions, **options); end

  class << self
    def execute(query, queryable, **options, &block); end
    def first_content_type(acceptable, available); end
    def parse(query, **options); end
    def serialize_exception(exception, **options); end
    def serialize_results(solutions, **options); end
  end
end

module SPARQL::Algebra
  include ::RDF

  private

  def Expression(*sse); end
  def Operator(name, arity = T.unsafe(nil)); end
  def Variable(name); end
  def open(sse, **options); end
  def parse(sse, **options); end

  class << self
    def Expression(*sse); end
    def Operator(name, arity = T.unsafe(nil)); end
    def Variable(name); end
    def open(sse, **options); end
    def parse(sse, **options); end
  end
end

module SPARQL::Algebra::Aggregate
  def aggregate(solutions = T.unsafe(nil), **options); end
  def apply(enum, **options); end
  def replace_aggregate!(&block); end
  def replace_vars!(&block); end
end

module SPARQL::Algebra::Evaluatable
  def apply(*operands, **options); end
  def evaluate(bindings, **options); end
  def memoize(*operands, **options); end
  def replace_aggregate!(&block); end
  def replace_vars!(&block); end
end

module SPARQL::Algebra::Expression
  include ::RDF::Util::Logger

  def constant?; end
  def evaluate(bindings, **options); end
  def invalid?; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def to_sxp_bin; end
  def valid?; end
  def validate; end
  def validate!; end
  def variable?; end

  private

  def debug(*args, &block); end

  class << self
    def [](*sse, **options); end
    def cast(datatype, value); end
    def debug(*args, &block); end
    def extension(function, *args); end
    def extension?(function); end
    def extensions; end
    def for(*sse, **options); end
    def new(sse, **options); end
    def open(filename, **options, &block); end
    def parse(sse, **options, &block); end
    def register_extension(uri, &block); end
  end
end

class SPARQL::Algebra::Operator
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  def initialize(*operands, **options); end

  def ==(other); end
  def aggregate?; end
  def base_uri; end
  def bind(solution); end
  def constant?; end
  def deep_dup; end
  def descendants(&block); end
  def each(&block); end
  def each_descendant(&block); end
  def eql?(other); end
  def evaluatable?; end
  def executable?; end
  def first_ancestor(klass); end
  def inspect; end
  def ndvars; end
  def node?; end
  def operand(index = T.unsafe(nil)); end
  def operands; end
  def optimize(**options); end
  def optimize!(**options); end
  def parent; end
  def parent=(operator); end
  def prefixes; end
  def rewrite(&block); end
  def to_sparql(**options); end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end
  def to_sxp_bin; end
  def validate!; end
  def variable?; end
  def vars; end

  protected

  def boolean(literal); end
  def to_binary(klass, *expressions); end

  class << self
    def arity; end
    def base_uri; end
    def base_uri=(uri); end
    def evaluate(*operands, **options); end
    def for(name, arity = T.unsafe(nil)); end
    def inherited(child); end
    def prefixes; end
    def prefixes=(hash); end
    def to_sparql(content, datasets: T.unsafe(nil), distinct: T.unsafe(nil), extensions: T.unsafe(nil), filter_ops: T.unsafe(nil), group_ops: T.unsafe(nil), having_ops: T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil), order_ops: T.unsafe(nil), project: T.unsafe(nil), reduced: T.unsafe(nil), values_clause: T.unsafe(nil), where_clause: T.unsafe(nil), **options); end
  end
end

SPARQL::Algebra::Operator::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Abs < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Abs::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Add < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Add::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Alt < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Alt::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::And < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(left, right, **options); end

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::And::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Asc < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Asc::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Ask < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options); end
  def query_yields_boolean?; end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Ask::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Avg < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def initialize(*operands, **options); end

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Avg::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::BGP < ::SPARQL::Algebra::Operator
  class << self
    def new(*patterns, **options, &block); end
  end
end

SPARQL::Algebra::Operator::BGP::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::BNode < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(literal = T.unsafe(nil), **options); end

  def apply(literal, bindings, **options); end
  def evaluate(bindings, **options); end
  def to_sparql(**options); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::BNode::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Base < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def optimize(**options); end
  def query_yields_boolean?; end
  def query_yields_statements?; end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Base::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Binary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, **options); end
end

SPARQL::Algebra::Operator::Binary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Bound < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(var, **options); end

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Bound::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Ceil < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Ceil::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Clear < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Clear::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Coalesce < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Coalesce::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Compare < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end

  private

  def spaceship(left, right, **options); end
end

SPARQL::Algebra::Operator::Compare::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Concat < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Concat::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Construct < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def query_yields_statements?; end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Construct::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Contains < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Contains::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Copy < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Copy::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Count < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Count::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Create < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Create::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Dataset < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &base); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Dataset::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Datatype < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(literal, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Datatype::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Day < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Day::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Delete < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Update

  def execute(queryable, solutions: T.unsafe(nil), **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Delete::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::DeleteData < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::DeleteData::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::DeleteWhere < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::DeleteWhere::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Desc < ::SPARQL::Algebra::Operator::Asc
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Desc::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Describe < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def query_yields_statements?; end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Describe::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Distinct < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Distinct::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Divide < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Divide::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Drop < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Drop::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::EncodeForURI < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::EncodeForURI::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Equal < ::SPARQL::Algebra::Operator::Compare
  def apply(term1, term2, **options); end
end

SPARQL::Algebra::Operator::Equal::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Exists < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(top_level: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Exists::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Exprlist < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Exprlist::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Extend < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Extend::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Filter < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Filter::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Floor < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Floor::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::FunctionCall < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def apply(iri, *args, **options); end
  def to_sparql(**options); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::FunctionCall::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Graph < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def rewrite(&block); end
  def to_sparql(top_level: T.unsafe(nil), **options); end

  class << self
    def new(name, patterns, **options, &block); end
  end
end

SPARQL::Algebra::Operator::Graph::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::GreaterThan < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right, **options); end
end

SPARQL::Algebra::Operator::GreaterThan::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::GreaterThanOrEqual < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right, **options); end
end

SPARQL::Algebra::Operator::GreaterThanOrEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Group < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(extensions: T.unsafe(nil), filter_ops: T.unsafe(nil), **options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Group::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::GroupConcat < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def aggregate(solutions = T.unsafe(nil), **options); end
  def apply(enum, separator, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::GroupConcat::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Hours < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Hours::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IRI < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(literal, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IRI::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::If < ::SPARQL::Algebra::Operator::Ternary
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::If::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::In < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::In::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Insert < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Update

  def execute(queryable, solutions: T.unsafe(nil), **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Insert::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::InsertData < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::InsertData::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::IsBlank < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IsBlank::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IsIRI < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IsIRI::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::IsLiteral < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IsLiteral::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IsNumeric < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IsNumeric::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IsTriple < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::IsTriple::NAME = T.let(T.unsafe(nil), Symbol)
SPARQL::Algebra::Operator::IsURI = SPARQL::Algebra::Operator::IsIRI

class SPARQL::Algebra::Operator::Join < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), extensions: T.unsafe(nil), **options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Join::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::LCase < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::LCase::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Lang < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(literal, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Lang::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LangMatches < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(language_tag, language_range, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::LangMatches::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LeftJoin < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), extensions: T.unsafe(nil), **options); end
  def validate!; end
end

SPARQL::Algebra::Operator::LeftJoin::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::LessThan < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right, **options); end
end

SPARQL::Algebra::Operator::LessThan::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LessThanOrEqual < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right, **options); end
end

SPARQL::Algebra::Operator::LessThanOrEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Load < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Load::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::MD5 < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::MD5::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Max < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def initialize(*operands, **options); end

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Max::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Min < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def initialize(*operands, **options); end

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Min::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Minus < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), extensions: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Minus::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Minutes < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Minutes::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Modify < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Modify::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Month < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Month::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Move < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Move::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Multiply < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Multiply::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Negate < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Negate::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Not < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Not::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::NotEqual < ::SPARQL::Algebra::Operator::Equal
  def apply(term1, term2, **options); end
end

SPARQL::Algebra::Operator::NotEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::NotExists < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(top_level: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::NotExists::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::NotIn < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::NotIn::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::NotOneOf < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::NotOneOf::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Now < ::SPARQL::Algebra::Operator::Nullary
  include ::SPARQL::Algebra::Evaluatable

  def apply(**options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Now::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Nullary < ::SPARQL::Algebra::Operator
  def initialize(**options); end
end

SPARQL::Algebra::Operator::Nullary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Object < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Object::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Or < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(left, right, **options); end

  def evaluate(bindings, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Or::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Order < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Order::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Path < ::SPARQL::Algebra::Operator::Ternary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(top_level: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Path::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathOpt < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::PathOpt::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathPlus < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::PathPlus::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathStar < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::PathStar::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Plus < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right = T.unsafe(nil), **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Plus::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Predicate < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Predicate::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Prefix < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def merge!(other); end
  def optimize(**options); end
  def query_yields_boolean?; end
  def query_yields_statements?; end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Prefix::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Project < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Project::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Quaternary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, arg3, arg4, **options); end
end

SPARQL::Algebra::Operator::Quaternary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Rand < ::SPARQL::Algebra::Operator::Nullary
  include ::SPARQL::Algebra::Evaluatable

  def apply(**options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Rand::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Reduced < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Reduced::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Regex < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Evaluatable

  def apply(text, pattern, flags = T.unsafe(nil), **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Regex::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Replace < ::SPARQL::Algebra::Operator::Quaternary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(text, pattern, replacement, flags = T.unsafe(nil), **options); end

  def apply(text, pattern, replacement, flags = T.unsafe(nil), **options); end
  def to_sparql(**options); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::Replace::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Reverse < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Reverse::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Round < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
end

SPARQL::Algebra::Operator::Round::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::SHA1 < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::SHA1::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SHA256 < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::SHA256::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SHA384 < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::SHA384::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SHA512 < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::SHA512::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SameTerm < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term1, term2, **options); end
  def optimize(**options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::SameTerm::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Sample < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def initialize(*operands, **options); end

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Sample::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Seconds < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Seconds::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Seq < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Seq::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Sequence < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Sequence::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Slice < ::SPARQL::Algebra::Operator::Ternary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Slice::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Str < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(term, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Str::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrAfter < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrAfter::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrBefore < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrBefore::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrDT < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(value, datatypeIRI, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrDT::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrEnds < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrEnds::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrLang < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(value, langTag, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrLang::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrLen < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrLen::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrStarts < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrStarts::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrUUID < ::SPARQL::Algebra::Operator::Nullary
  include ::SPARQL::Algebra::Evaluatable

  def apply(**options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::StrUUID::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SubStr < ::SPARQL::Algebra::Operator::Ternary
  include ::SPARQL::Algebra::Evaluatable

  def initialize(source, startingLoc, length = T.unsafe(nil), **options); end

  def apply(source, startingLoc, length, **options); end
  def to_sparql(**options); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::SubStr::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Subject < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Subject::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Subtract < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Evaluatable

  def apply(left, right, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Subtract::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Sum < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Aggregate

  def apply(enum, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Sum::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::TZ < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::TZ::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Table < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(top_level: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Table::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Ternary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, arg3, **options); end
end

SPARQL::Algebra::Operator::Ternary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Timezone < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Timezone::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::UCase < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::UCase::NAME = T.let(T.unsafe(nil), Symbol)
SPARQL::Algebra::Operator::URI = SPARQL::Algebra::Operator::IRI

class SPARQL::Algebra::Operator::UUID < ::SPARQL::Algebra::Operator::Nullary
  include ::SPARQL::Algebra::Evaluatable

  def apply(**options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::UUID::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Unary < ::SPARQL::Algebra::Operator
  def initialize(arg, **options); end
end

SPARQL::Algebra::Operator::Unary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Union < ::SPARQL::Algebra::Operator::Binary
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def to_sparql(top_level: T.unsafe(nil), **options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Union::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Update < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Update::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Using < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Query

  def execute(queryable, **options, &block); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Using::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::With < ::SPARQL::Algebra::Operator
  include ::SPARQL::Algebra::Update

  def execute(queryable, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::With::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Year < ::SPARQL::Algebra::Operator::Unary
  include ::SPARQL::Algebra::Evaluatable

  def apply(operand, **options); end
  def to_sparql(**options); end
end

SPARQL::Algebra::Operator::Year::NAME = T.let(T.unsafe(nil), Symbol)

module SPARQL::Algebra::Query
  def each_solution(&block); end
  def empty?; end
  def execute(queryable, **options, &block); end
  def failed?; end
  def graph_name=(value); end
  def matched?; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def solutions; end
  def unshift(query); end
  def variables; end
end

module SPARQL::Algebra::Update
  def execute(queryable, **options, &block); end
  def graph_name=(value); end
  def unshift(query); end
  def variables; end
end

SPARQL::Algebra::Variable = RDF::Query::Variable
SPARQL::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

module SPARQL::Grammar
  class << self
    def open(filename, **options, &block); end
    def parse(query, **options, &block); end
    def tokenize(query, **options, &block); end
    def valid?(query, **options); end
  end
end

module SPARQL::Grammar::Meta; end
SPARQL::Grammar::Meta::BRANCH = T.let(T.unsafe(nil), Hash)
SPARQL::Grammar::Meta::CLEANUP = T.let(T.unsafe(nil), Hash)
SPARQL::Grammar::Meta::FIRST = T.let(T.unsafe(nil), Hash)
SPARQL::Grammar::Meta::FOLLOW = T.let(T.unsafe(nil), Hash)
SPARQL::Grammar::Meta::START = T.let(T.unsafe(nil), Symbol)
SPARQL::Grammar::Meta::TERMINALS = T.let(T.unsafe(nil), Array)

class SPARQL::Grammar::Parser
  include ::SPARQL::Grammar::Meta
  include ::SPARQL::Grammar::Terminals
  include ::EBNF::LL1::Parser
  extend ::EBNF::LL1::Parser::ClassMethods

  def initialize(input = T.unsafe(nil), **options, &block); end

  def input; end
  def input=(_arg0); end
  def ll1_parse(input = T.unsafe(nil), start = T.unsafe(nil), **options, &block); end
  def options; end
  def parse(prod = T.unsafe(nil)); end
  def result; end
  def result=(_arg0); end
  def to_s; end
  def to_sxp_bin; end
  def tokens; end
  def valid?; end

  private

  def accumulate_operator_expressions(operator, production, data); end
  def add_operator_expressions(production, data); end
  def add_pattern(production, **options); end
  def base_uri; end
  def base_uri=(iri); end
  def bnode(id = T.unsafe(nil)); end
  def clear_bnode_cache; end
  def expand_collection(data); end
  def flatten_filter(data); end
  def freeze_bnodes; end
  def gen_bnodes(value = T.unsafe(nil)); end
  def iri(value); end
  def literal(value, **options); end
  def merge_modifiers(data); end
  def nd_var_gen; end
  def nd_var_gen=(_arg0); end
  def ns(prefix, suffix); end
  def prefix(name, iri = T.unsafe(nil)); end
  def prefixes; end
  def prefixes=(prefixes); end
  def resolve_iris?; end
  def validate?; end
  def variable(id, distinguished = T.unsafe(nil)); end
end

SPARQL::Grammar::Parser::AGGREGATE_RULES = T.let(T.unsafe(nil), Array)
SPARQL::Grammar::Parser::BUILTINS = T.let(T.unsafe(nil), Array)
SPARQL::Grammar::Parser::BUILTIN_RULES = T.let(T.unsafe(nil), Array)
module SPARQL::Grammar::Terminals; end
SPARQL::Grammar::Terminals::ANON = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::BLANK_NODE_LABEL = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DECIMAL = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DECIMAL_NEGATIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DECIMAL_POSITIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DOUBLE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DOUBLE_NEGATIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::DOUBLE_POSITIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::ECHAR = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::EXPONENT = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::INTEGER = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::INTEGER_NEGATIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::INTEGER_POSITIVE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::IRIREF = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::IRI_RANGE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::LANGTAG = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::NIL = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PERCENT = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PLX = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PNAME_LN = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PNAME_NS = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_CHARS = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_CHARS_BASE = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_CHARS_BODY = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_CHARS_U = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_LOCAL = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_LOCAL_BODY = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_LOCAL_ESC = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::PN_PREFIX = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STRING_LITERAL1 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STRING_LITERAL2 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STRING_LITERAL_LONG1 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STRING_LITERAL_LONG2 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STR_EXPR = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::STR_MAP = T.let(T.unsafe(nil), Hash)
SPARQL::Grammar::Terminals::UCHAR = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::U_CHARS1 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::U_CHARS2 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::VAR1 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::VAR2 = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::VARNAME = T.let(T.unsafe(nil), Regexp)
SPARQL::Grammar::Terminals::WS = T.let(T.unsafe(nil), Regexp)

class SPARQL::MalformedQuery < ::Exception
  def title; end
end

class SPARQL::QueryRequestRefused < ::Exception
  def title; end
end

module SPARQL::Results
  def to_csv(bnode_map: T.unsafe(nil)); end
  def to_html; end
  def to_json; end
  def to_tsv; end
  def to_xml; end
end

SPARQL::Results::MIME_TYPES = T.let(T.unsafe(nil), Hash)

module SPARQL::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

SPARQL::VERSION::MAJOR = T.let(T.unsafe(nil), String)
SPARQL::VERSION::MINOR = T.let(T.unsafe(nil), String)
SPARQL::VERSION::STRING = T.let(T.unsafe(nil), String)
SPARQL::VERSION::TINY = T.let(T.unsafe(nil), String)
SPARQL::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils
  include ::SafeType::BooleanMixin

  def to_sxp(**options); end
end
