# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sparql` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

class FalseClass
  include(::JSON::Ext::Generator::GeneratorMethods::FalseClass)
  include(::MessagePack::CoreExt)
  include(::FriendlyId::UnfriendlyUtils)
  include(::SafeType::BooleanMixin)

  def to_sxp; end
end

class NilClass
  include(::JSON::Ext::Generator::GeneratorMethods::NilClass)
  include(::MessagePack::CoreExt)
  include(::FriendlyId::UnfriendlyUtils)
  include(::FriendlyId::Reserved::Configuration)
  include(::FriendlyId::Scoped::Configuration)
  include(::FriendlyId::SimpleI18n::Configuration)
  include(::FriendlyId::Slugged::Configuration)

  def to_sxp; end
end

class RDF::Query::Solutions < ::Array
  include(::SPARQL::Results)

  def bindings; end
  def count(&block); end
  def distinct; end
  def distinct!; end
  def dup; end
  def each_solution; end
  def filter(criteria = T.unsafe(nil)); end
  def filter!(criteria = T.unsafe(nil)); end
  def has_variables?(variables); end
  def have_variables?(variables); end
  def limit(length); end
  def limit!(length); end
  def merge(other); end
  def minus(other); end
  def offset(start); end
  def offset!(start); end
  def order(*variables); end
  def order_by(*variables); end
  def project(*variables); end
  def reduced; end
  def reduced!; end
  def select(*variables); end
  def variable_names; end
end

module RDF::Queryable
  include(::Enumerable)

  def concise_bounded_description(*terms, &block); end
  def enum_for(method = T.unsafe(nil), *args); end
  def first(pattern = T.unsafe(nil)); end
  def first_literal(pattern = T.unsafe(nil)); end
  def first_object(pattern = T.unsafe(nil)); end
  def first_predicate(pattern = T.unsafe(nil)); end
  def first_subject(pattern = T.unsafe(nil)); end
  def first_value(pattern = T.unsafe(nil)); end
  def query(pattern, **options, &block); end
  def to_enum(method = T.unsafe(nil), *args); end

  protected

  def query_execute(query, **options, &block); end
  def query_pattern(pattern, **options, &block); end
end

module SPARQL

  private

  def first_content_type(acceptable, available); end
  def serialize_exception(exception, **options); end
  def serialize_results(solutions, **options); end

  class << self
    def execute(query, queryable, **options, &block); end
    def first_content_type(acceptable, available); end
    def parse(query, **options); end
    def serialize_exception(exception, **options); end
    def serialize_results(solutions, **options); end
  end
end

module SPARQL::Algebra
  include(::RDF)


  private

  def Expression(*sse); end
  def Operator(name, arity = T.unsafe(nil)); end
  def Variable(name); end
  def open(sse, **options); end
  def parse(sse, **options); end

  class << self
    def Expression(*sse); end
    def Operator(name, arity = T.unsafe(nil)); end
    def Variable(name); end
    def open(sse, **options); end
    def parse(sse, **options); end
  end
end

module SPARQL::Algebra::Aggregate
  def aggregate(solutions = T.unsafe(nil), **options); end
  def apply(enum); end
  def replace_aggregate!(&block); end
  def replace_vars!(&block); end
end

module SPARQL::Algebra::Evaluatable
  def apply(*operands); end
  def evaluate(bindings, **options); end
  def memoize(*operands); end
  def replace_aggregate!(&block); end
  def replace_vars!(&block); end
end

module SPARQL::Algebra::Expression
  def constant?; end
  def evaluate(bindings, options = T.unsafe(nil)); end
  def invalid?; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def to_sxp_bin; end
  def valid?; end
  def validate; end
  def validate!; end
  def variable?; end

  private

  def debug(*args, &block); end

  class << self
    def [](*sse); end
    def cast(datatype, value); end
    def debug(*args); end
    def extension(function, *args); end
    def extensions; end
    def for(*sse); end
    def new(sse, **options); end
    def open(filename, **options, &block); end
    def parse(sse, **options, &block); end
    def register_extension(uri, &block); end
  end
end

class SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Expression)

  def initialize(*operands); end

  def ==(other); end
  def aggregate?; end
  def base_uri; end
  def bind(solution); end
  def constant?; end
  def deep_dup; end
  def descendants(&block); end
  def each(&block); end
  def each_descendant(&block); end
  def eql?(other); end
  def evaluatable?; end
  def executable?; end
  def first_ancestor(klass); end
  def inspect; end
  def ndvars; end
  def node?; end
  def operand(index = T.unsafe(nil)); end
  def operands; end
  def optimize(**options); end
  def optimize!(**options); end
  def parent; end
  def parent=(operator); end
  def prefixes; end
  def rewrite(&block); end
  def to_sxp; end
  def to_sxp_bin; end
  def validate!; end
  def variable?; end
  def vars; end

  protected

  def boolean(literal); end
  def to_binary(klass, *expressions); end

  class << self
    def arity; end
    def base_uri; end
    def base_uri=(uri); end
    def evaluate(*operands); end
    def for(name, arity = T.unsafe(nil)); end
    def inherited(child); end
    def prefixes; end
    def prefixes=(hash); end
  end
end

SPARQL::Algebra::Operator::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Abs < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Abs::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Add < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Add::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Alt < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Alt::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::And < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(left, right, **options); end

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::And::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Asc < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Asc::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Ask < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options); end
  def query_yields_boolean?; end
end

SPARQL::Algebra::Operator::Ask::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Avg < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Avg::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::BGP < ::SPARQL::Algebra::Operator
  class << self
    def new(*patterns, &block); end
  end
end

SPARQL::Algebra::Operator::BGP::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::BNode < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(literal = T.unsafe(nil), **options); end

  def apply(literal, bindings); end
  def evaluate(bindings, **options); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::BNode::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Base < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def optimize(**options); end
  def query_yields_boolean?; end
  def query_yields_statements?; end
end

SPARQL::Algebra::Operator::Base::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Binary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, options = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Binary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Bound < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(var, **options); end

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Bound::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Ceil < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Ceil::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Clear < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Clear::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Coalesce < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Coalesce::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Compare < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::Compare::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Concat < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Concat::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Construct < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def query_yields_statements?; end
end

SPARQL::Algebra::Operator::Construct::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Contains < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::Contains::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Copy < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Copy::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Count < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Count::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Create < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Create::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Dataset < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &base); end
end

SPARQL::Algebra::Operator::Dataset::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Datatype < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(literal); end
end

SPARQL::Algebra::Operator::Datatype::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Day < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Day::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Delete < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Update)

  def execute(queryable, solutions: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Delete::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::DeleteData < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::DeleteData::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::DeleteWhere < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::DeleteWhere::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Desc < ::SPARQL::Algebra::Operator::Asc
end

SPARQL::Algebra::Operator::Desc::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Describe < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def query_yields_statements?; end
end

SPARQL::Algebra::Operator::Describe::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Distinct < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Distinct::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Divide < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::Divide::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Drop < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Drop::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::EncodeForURI < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::EncodeForURI::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Equal < ::SPARQL::Algebra::Operator::Compare
  def apply(term1, term2); end
end

SPARQL::Algebra::Operator::Equal::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Exists < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Exists::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Exprlist < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Exprlist::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Extend < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def validate!; end
end

SPARQL::Algebra::Operator::Extend::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Filter < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def validate!; end
end

SPARQL::Algebra::Operator::Filter::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Floor < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Floor::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Graph < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def rewrite(&block); end

  class << self
    def new(name, patterns, &block); end
  end
end

SPARQL::Algebra::Operator::Graph::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::GreaterThan < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right); end
end

SPARQL::Algebra::Operator::GreaterThan::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::GreaterThanOrEqual < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right); end
end

SPARQL::Algebra::Operator::GreaterThanOrEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Group < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def validate!; end
end

SPARQL::Algebra::Operator::Group::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::GroupConcat < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def aggregate(solutions = T.unsafe(nil), **options); end
  def apply(enum, separator); end
end

SPARQL::Algebra::Operator::GroupConcat::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Hours < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Hours::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IRI < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(literal); end
end

SPARQL::Algebra::Operator::IRI::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::If < ::SPARQL::Algebra::Operator::Ternary
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::If::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::In < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::In::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Insert < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Update)

  def execute(queryable, solutions: T.unsafe(nil), **options); end
end

SPARQL::Algebra::Operator::Insert::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::InsertData < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::InsertData::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::IsBlank < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::IsBlank::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IsIRI < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::IsIRI::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::IsLiteral < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::IsLiteral::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::IsNumeric < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::IsNumeric::NAME = T.let(T.unsafe(nil), Symbol)

SPARQL::Algebra::Operator::IsURI = SPARQL::Algebra::Operator::IsIRI

class SPARQL::Algebra::Operator::Join < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Join::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::LCase < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::LCase::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Lang < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(literal); end
end

SPARQL::Algebra::Operator::Lang::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LangMatches < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(language_tag, language_range); end
end

SPARQL::Algebra::Operator::LangMatches::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LeftJoin < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def validate!; end
end

SPARQL::Algebra::Operator::LeftJoin::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::LessThan < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right); end
end

SPARQL::Algebra::Operator::LessThan::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::LessThanOrEqual < ::SPARQL::Algebra::Operator::Compare
  def apply(left, right); end
end

SPARQL::Algebra::Operator::LessThanOrEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Load < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Load::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::MD5 < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::MD5::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Max < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Max::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Min < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Min::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Minus < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
end

SPARQL::Algebra::Operator::Minus::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Minutes < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Minutes::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Modify < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Modify::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Month < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Month::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Move < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Move::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Multiply < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::Multiply::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Negate < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::Negate::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Not < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Not::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::NotEqual < ::SPARQL::Algebra::Operator::Equal
  def apply(term1, term2); end
end

SPARQL::Algebra::Operator::NotEqual::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::NotExists < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::NotExists::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::NotIn < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::NotIn::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::NotOneOf < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::NotOneOf::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Now < ::SPARQL::Algebra::Operator::Nullary
  include(::SPARQL::Algebra::Evaluatable)

  def apply; end
end

SPARQL::Algebra::Operator::Now::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Nullary < ::SPARQL::Algebra::Operator
  def initialize(options = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Nullary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Or < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(left, right, **options); end

  def evaluate(bindings, **options); end
end

SPARQL::Algebra::Operator::Or::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Order < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Order::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Path < ::SPARQL::Algebra::Operator::Ternary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Path::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathOpt < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::PathOpt::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathPlus < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::PathPlus::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::PathStar < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::PathStar::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Plus < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Plus::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Prefix < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def merge!(other); end
  def optimize(**options); end
  def query_yields_boolean?; end
  def query_yields_statements?; end
end

SPARQL::Algebra::Operator::Prefix::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Project < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Project::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Quaternary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, arg3, arg4, options = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Quaternary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Rand < ::SPARQL::Algebra::Operator::Nullary
  include(::SPARQL::Algebra::Evaluatable)

  def apply; end
end

SPARQL::Algebra::Operator::Rand::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Reduced < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Reduced::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Regex < ::SPARQL::Algebra::Operator::Ternary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(text, pattern, flags = T.unsafe(nil), **options); end

  def apply(text, pattern, flags = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Regex::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Replace < ::SPARQL::Algebra::Operator::Quaternary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(text, pattern, replacement, flags = T.unsafe(nil), **options); end

  def apply(text, pattern, replacement, flags = T.unsafe(nil)); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::Replace::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Reverse < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Reverse::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Round < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Round::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::SHA1 < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::SHA1::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SHA256 < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::SHA256::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SHA512 < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::SHA512::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SameTerm < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term1, term2); end
  def optimize(**options); end
end

SPARQL::Algebra::Operator::SameTerm::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Sample < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Sample::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Seconds < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Seconds::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Seq < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Seq::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Sequence < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Sequence::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Slice < ::SPARQL::Algebra::Operator::Ternary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Slice::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Str < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(term); end
end

SPARQL::Algebra::Operator::Str::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrAfter < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::StrAfter::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrBefore < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::StrBefore::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrDT < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(value, datatypeIRI); end
end

SPARQL::Algebra::Operator::StrDT::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrEnds < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::StrEnds::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrLang < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(value, langTag); end
end

SPARQL::Algebra::Operator::StrLang::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrLen < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::StrLen::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrStarts < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::StrStarts::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::StrUUID < ::SPARQL::Algebra::Operator::Nullary
  include(::SPARQL::Algebra::Evaluatable)

  def apply; end
end

SPARQL::Algebra::Operator::StrUUID::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::SubStr < ::SPARQL::Algebra::Operator::Ternary
  include(::SPARQL::Algebra::Evaluatable)

  def initialize(source, startingLoc, length = T.unsafe(nil), **options); end

  def apply(source, startingLoc, length); end
  def to_sxp_bin; end
end

SPARQL::Algebra::Operator::SubStr::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Subtract < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(left, right); end
end

SPARQL::Algebra::Operator::Subtract::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Sum < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Aggregate)

  def apply(enum); end
end

SPARQL::Algebra::Operator::Sum::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::TZ < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::TZ::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Table < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Table::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Ternary < ::SPARQL::Algebra::Operator
  def initialize(arg1, arg2, arg3, options = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Ternary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Timezone < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Timezone::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::UCase < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::UCase::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::UUID < ::SPARQL::Algebra::Operator::Nullary
  include(::SPARQL::Algebra::Evaluatable)

  def apply; end
end

SPARQL::Algebra::Operator::UUID::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Unary < ::SPARQL::Algebra::Operator
  def initialize(arg, options = T.unsafe(nil)); end
end

SPARQL::Algebra::Operator::Unary::ARITY = T.let(T.unsafe(nil), Integer)

class SPARQL::Algebra::Operator::Union < ::SPARQL::Algebra::Operator::Binary
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
  def optimize!(**options); end
  def validate!; end
end

SPARQL::Algebra::Operator::Union::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Update < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::Update::NAME = T.let(T.unsafe(nil), Array)

class SPARQL::Algebra::Operator::Using < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Query)

  def execute(queryable, **options, &block); end
end

SPARQL::Algebra::Operator::Using::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::With < ::SPARQL::Algebra::Operator
  include(::SPARQL::Algebra::Update)

  def execute(queryable, **options); end
end

SPARQL::Algebra::Operator::With::NAME = T.let(T.unsafe(nil), Symbol)

class SPARQL::Algebra::Operator::Year < ::SPARQL::Algebra::Operator::Unary
  include(::SPARQL::Algebra::Evaluatable)

  def apply(operand); end
end

SPARQL::Algebra::Operator::Year::NAME = T.let(T.unsafe(nil), Symbol)

module SPARQL::Algebra::Query
  def each_solution(&block); end
  def empty?; end
  def execute(queryable, **options, &block); end
  def failed?; end
  def graph_name=(value); end
  def matched?; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def solutions; end
  def unshift(query); end
  def variables; end
end

module SPARQL::Algebra::Update
  def execute(queryable, **options, &block); end
  def graph_name=(value); end
  def unshift(query); end
  def variables; end
end

SPARQL::Algebra::Variable = RDF::Query::Variable

SPARQL::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

module SPARQL::Grammar
  class << self
    def open(filename, **options, &block); end
    def parse(query, **options, &block); end
    def tokenize(query, **options, &block); end
    def valid?(query, **options); end
  end
end

class SPARQL::Grammar::Parser
  include(::SPARQL::Grammar::Meta)
  include(::SPARQL::Grammar::Terminals)
  include(::EBNF::LL1::Parser)
  extend(::EBNF::LL1::Parser::ClassMethods)

  def initialize(input = T.unsafe(nil), **options, &block); end

  def input; end
  def input=(_arg0); end
  def ll1_parse(input = T.unsafe(nil), start = T.unsafe(nil), **options, &block); end
  def options; end
  def parse(prod = T.unsafe(nil)); end
  def result; end
  def result=(_arg0); end
  def to_s; end
  def to_sxp_bin; end
  def tokens; end
  def valid?; end

  private

  def accumulate_operator_expressions(operator, production, data); end
  def add_operator_expressions(production, data); end
  def add_pattern(production, **options); end
  def base_uri; end
  def base_uri=(iri); end
  def bnode(id = T.unsafe(nil)); end
  def clear_bnode_cache; end
  def expand_collection(data); end
  def flatten_filter(data); end
  def freeze_bnodes; end
  def gen_bnodes(value = T.unsafe(nil)); end
  def iri(value); end
  def literal(value, **options); end
  def merge_modifiers(data); end
  def nd_var_gen; end
  def nd_var_gen=(_arg0); end
  def ns(prefix, suffix); end
  def prefix(name, iri = T.unsafe(nil)); end
  def prefixes; end
  def prefixes=(prefixes); end
  def resolve_iris?; end
  def validate?; end
  def variable(id, distinguished = T.unsafe(nil)); end
end

SPARQL::Grammar::Parser::AGGREGATE_RULES = T.let(T.unsafe(nil), Array)

SPARQL::Grammar::Parser::BUILTINS = T.let(T.unsafe(nil), Array)

SPARQL::Grammar::Parser::BUILTIN_RULES = T.let(T.unsafe(nil), Array)

module SPARQL::Grammar::Terminals
end

SPARQL::Grammar::Terminals::ANON = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::BLANK_NODE_LABEL = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DECIMAL = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DECIMAL_NEGATIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DECIMAL_POSITIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DOUBLE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DOUBLE_NEGATIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::DOUBLE_POSITIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::ECHAR = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::EXPONENT = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::INTEGER = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::INTEGER_NEGATIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::INTEGER_POSITIVE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::IRIREF = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::IRI_RANGE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::LANGTAG = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::NIL = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PERCENT = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PLX = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PNAME_LN = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PNAME_NS = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_CHARS = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_CHARS_BASE = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_CHARS_BODY = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_CHARS_U = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_LOCAL = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_LOCAL_BODY = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_LOCAL_ESC = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::PN_PREFIX = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STRING_LITERAL1 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STRING_LITERAL2 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STRING_LITERAL_LONG1 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STRING_LITERAL_LONG2 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STR_EXPR = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::STR_MAP = T.let(T.unsafe(nil), Hash)

SPARQL::Grammar::Terminals::UCHAR = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::U_CHARS1 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::U_CHARS2 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::VAR1 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::VAR2 = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::VARNAME = T.let(T.unsafe(nil), Regexp)

SPARQL::Grammar::Terminals::WS = T.let(T.unsafe(nil), Regexp)

class SPARQL::MalformedQuery < ::Exception
  def title; end
end

class SPARQL::QueryRequestRefused < ::Exception
  def title; end
end

module SPARQL::Results
  def to_csv; end
  def to_html; end
  def to_json; end
  def to_tsv; end
  def to_xml; end
end

SPARQL::Results::MIME_TYPES = T.let(T.unsafe(nil), Hash)

module SPARQL::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

SPARQL::VERSION::MAJOR = T.let(T.unsafe(nil), String)

SPARQL::VERSION::MINOR = T.let(T.unsafe(nil), String)

SPARQL::VERSION::STRING = T.let(T.unsafe(nil), String)

SPARQL::VERSION::TINY = T.let(T.unsafe(nil), String)

SPARQL::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

module SPARQL::Grammar::Meta
end

SPARQL::Grammar::Meta::BRANCH = T.let(T.unsafe(nil), Hash)

SPARQL::Grammar::Meta::CLEANUP = T.let(T.unsafe(nil), Hash)

SPARQL::Grammar::Meta::FIRST = T.let(T.unsafe(nil), Hash)

SPARQL::Grammar::Meta::FOLLOW = T.let(T.unsafe(nil), Hash)

SPARQL::Grammar::Meta::START = T.let(T.unsafe(nil), Symbol)

SPARQL::Grammar::Meta::TERMINALS = T.let(T.unsafe(nil), Array)

class TrueClass
  include(::JSON::Ext::Generator::GeneratorMethods::TrueClass)
  include(::MessagePack::CoreExt)
  include(::FriendlyId::UnfriendlyUtils)
  include(::SafeType::BooleanMixin)

  def to_sxp; end
end
