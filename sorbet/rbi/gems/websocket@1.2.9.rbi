# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `websocket` gem.
# Please instead update this file by running `bin/tapioca gem websocket`.

# WebSocket protocol implementation in Ruby
# This module does not provide a WebSocket server or client, but is made for using
# in http servers or clients to provide WebSocket support.
#
# @author Bernard "Imanel" Potocki
# @see http://github.com/imanel/websocket-ruby main repository
module WebSocket
  class << self
    # Limit of frame size payload in bytes
    def max_frame_size; end

    # Set limit of frame size payload in bytes
    def max_frame_size=(val); end

    # If set to true error will be raised instead of setting `error` method.
    # All errors inherit from WebSocket::Error.
    def should_raise; end

    # Should protocol errors raise ruby errors? If false then `error` flag is set instead.
    def should_raise=(val); end
  end
end

# Default WebSocket version to use
WebSocket::DEFAULT_VERSION = T.let(T.unsafe(nil), Integer)

class WebSocket::Error < ::RuntimeError; end
class WebSocket::Error::Frame < ::WebSocket::Error; end

class WebSocket::Error::Frame::ControlFramePayloadTooLong < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::DataFrameInsteadContinuation < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::FragmentedControlFrame < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::Invalid < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::InvalidPayloadEncoding < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::MaskTooShort < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::ReservedBitUsed < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::TooLong < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnexpectedContinuationFrame < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownCloseCode < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownFrameType < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownOpcode < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownVersion < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Handshake < ::WebSocket::Error; end

class WebSocket::Error::Handshake::GetRequestRequired < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidAuthentication < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidHeader < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidStatusCode < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::NoHostProvided < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::UnknownVersion < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::UnsupportedProtocol < ::WebSocket::Error::Handshake
  def message; end
end

module WebSocket::ExceptionHandler
  mixes_in_class_methods ::WebSocket::ExceptionHandler::ClassMethods

  # Returns the value of attribute error.
  def error; end

  # Sets the attribute error
  #
  # @param value the value to set the attribute error to.
  def error=(_arg0); end

  class << self
    # @private
    def included(base); end
  end
end

module WebSocket::ExceptionHandler::ClassMethods
  # Rescue from WebSocket::Error errors.
  #
  # @option options
  # @param method_name [String] Name of method that should be wrapped and rescued
  # @param options [Hash] Options for rescue
  def rescue_method(method_name, options = T.unsafe(nil)); end
end

module WebSocket::Frame; end

# @abstract Subclass and override to implement custom frames
class WebSocket::Frame::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  extend ::WebSocket::ExceptionHandler::ClassMethods

  # Initialize frame
  #
  # @option args
  # @option args
  # @option args
  # @option args
  # @param args [Hash] Arguments for frame
  # @return [Base] a new instance of Base
  def initialize(*args); end

  # Returns the value of attribute code.
  def code; end

  # Sets the attribute code
  #
  # @param value the value to set the attribute code to.
  def code=(_arg0); end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # Returns the value of attribute error.
  def error; end

  # Check if some errors occured
  #
  # @return [Boolean] True if error is set
  def error?; end

  def initialize_with_rescue(*args); end

  # Is selected type supported for selected handler?
  #
  # @return [Boolean]
  def support_type?; end

  # Implement in submodules
  #
  # @raise [NotImplementedError]
  def supported_frames; end

  # Returns the value of attribute type.
  def type; end

  # Returns the value of attribute version.
  def version; end

  private

  # Include set of methods for selected protocol version
  #
  # @return [Boolean] false if protocol number is unknown, otherwise true
  def include_version; end

  def initialize_without_rescue(args = T.unsafe(nil)); end
end

class WebSocket::Frame::Data < ::String
  # @return [Data] a new instance of Data
  def initialize(*args); end

  def <<(*args); end

  # Convert all arguments to ASCII-8BIT for easier traversing
  def convert_args(args); end

  # Extract `count` bytes starting from `start_index` and unmask it if needed.
  def getbytes(start_index, count); end

  # Mask whole payload using mask key
  def mask(payload, mask); end

  # Extract mask from 4 first bytes according to spec
  #
  # @raise [WebSocket::Error::Frame::MaskTooShort]
  def set_mask; end

  # Remove mask flag - it will still be present in payload
  def unset_mask; end
end

module WebSocket::Frame::Handler; end

class WebSocket::Frame::Handler::Base
  # @return [Base] a new instance of Base
  def initialize(frame); end

  # Convert raw data to decoded frame
  #
  # @raise [NotImplementedError]
  # @return [WebSocket::Frame::Incoming] Frame if found, nil otherwise
  def decode_frame; end

  # Convert data to raw frame ready to send to client
  #
  # @raise [NotImplementedError]
  # @return [String] Encoded frame
  def encode_frame; end

  private

  # Check if frame is one of control frames
  #
  # @param frame_type [Symbol] Frame type
  # @return [Boolean] True if given frame type is control frame
  def control_frame?(frame_type); end

  # Check if frame is one of data frames
  #
  # @param frame_type [Symbol] Frame type
  # @return [Boolean] True if given frame type is data frame
  def data_frame?(frame_type); end
end

class WebSocket::Frame::Handler::Handler03 < ::WebSocket::Frame::Handler::Base
  # @return [Handler03] a new instance of Handler03
  def initialize(frame); end

  # @see WebSocket::Frame::Handler::Base#decode_frame
  def decode_frame; end

  # @see WebSocket::Frame::Handler::Base#encode_frame
  def encode_frame; end

  # Allow turning on or off masking
  #
  # @return [Boolean]
  def masking?; end

  # @see WebSocket::Frame::Base#supported_frames
  def supported_frames; end

  private

  # @return [Boolean]
  def buffer_exists?(buffer_number); end

  def decode_continuation_frame(application_data, frame_type); end

  # @raise [WebSocket::Error::Frame::UnexpectedContinuationFrame]
  def decode_finish_continuation_frame(application_data); end

  # @raise [WebSocket::Error::Frame::ReservedBitUsed]
  def decode_first_byte; end

  # @raise [WebSocket::Error::Frame::TooLong]
  def decode_header; end

  def decode_payload(payload_length, mask); end
  def decode_payload_length(length); end

  # @raise [WebSocket::Error::Frame::ControlFramePayloadTooLong]
  def decode_second_byte(frame_type); end

  def encode_header; end
  def encode_payload_length(length, mask); end

  # This allows flipping the more bit to fin for draft 04
  def fin; end

  # Convert frame opcode to type name
  #
  # @param opcode [Integer] Opcode
  # @raise [WebSocket::Error] if frame type name is not known
  # @return [Symbol] Frame type name or nil
  def opcode_to_type(opcode); end

  # Convert frame type name to opcode
  #
  # @param frame_type [Symbol] Frame type name
  # @raise [WebSocket::Error] if frame opcode is not known
  # @return [Integer] opcode or nil
  def type_to_opcode(frame_type); end
end

# Hash of frame names and it's opcodes
WebSocket::Frame::Handler::Handler03::FRAME_TYPES = T.let(T.unsafe(nil), Hash)

# Hash of frame opcodes and it's names
WebSocket::Frame::Handler::Handler03::FRAME_TYPES_INVERSE = T.let(T.unsafe(nil), Hash)

class WebSocket::Frame::Handler::Handler04 < ::WebSocket::Frame::Handler::Handler03
  private

  # The only difference between draft 03 framing and draft 04 framing is
  # that the MORE bit has been changed to a FIN bit
  def fin; end
end

class WebSocket::Frame::Handler::Handler05 < ::WebSocket::Frame::Handler::Handler04
  # Since handler 5 masking should be enabled by default
  #
  # @return [Boolean]
  def masking?; end
end

class WebSocket::Frame::Handler::Handler07 < ::WebSocket::Frame::Handler::Handler05
  def decode_frame; end
  def encode_frame; end

  private

  # @return [Boolean]
  def close_code?(frame); end

  # Convert frame opcode to type name
  #
  # @param opcode [Integer] Opcode
  # @raise [WebSocket::Error] if frame type name is not known
  # @return [Symbol] Frame type name or nil
  def opcode_to_type(opcode); end

  # Convert frame type name to opcode
  #
  # @param frame_type [Symbol] Frame type name
  # @raise [WebSocket::Error] if frame opcode is not known
  # @return [Integer] opcode or nil
  def type_to_opcode(frame_type); end

  # @return [Boolean]
  def valid_code?(code); end

  # @return [Boolean]
  def valid_encoding?(data); end
end

# Hash of frame names and it's opcodes
WebSocket::Frame::Handler::Handler07::FRAME_TYPES = T.let(T.unsafe(nil), Hash)

# Hash of frame opcodes and it's names
WebSocket::Frame::Handler::Handler07::FRAME_TYPES_INVERSE = T.let(T.unsafe(nil), Hash)

class WebSocket::Frame::Handler::Handler75 < ::WebSocket::Frame::Handler::Base
  # @see WebSocket::Frame::Handler::Base#decode_frame
  def decode_frame; end

  # @see WebSocket::Frame::Handler::Base#encode_frame
  def encode_frame; end

  # @see WebSocket::Frame::Base#supported_frames
  def supported_frames; end
end

# Construct or parse incoming WebSocket Frame.
#
# @example
#   frame = WebSocket::Frame::Incoming::Server.new(version: @handshake.version)
#   frame << "\x81\x05\x48\x65\x6c\x6c\x6f\x81\x06\x77\x6f\x72\x6c\x64\x21"
#   frame.next # "Hello"
#   frame.next # "world!""
# @note You should NEVER use this class directly - use Client or Server subclasses instead, as they contain additional frame options(i.e. Client-side masking in draft 04)
class WebSocket::Frame::Incoming < ::WebSocket::Frame::Base
  # @return [Incoming] a new instance of Incoming
  def initialize(args = T.unsafe(nil)); end

  # Add provided string as raw incoming frame.
  #
  # @param data [String] Raw frame
  def <<(data); end

  # If data is still encoded after receiving then this is false. After calling "next" you will receive
  # another instance of incoming frame, but with data decoded - this function will return true and
  # to_s will return frame content instead of raw data.
  #
  # @return [Boolean] If frame already decoded?
  def decoded?; end

  # Return next complete frame.
  # This function will merge together splitted frames and return as combined content.
  # Check #error if nil received to check for eventual parsing errors
  #
  # @return [WebSocket::Frame::Incoming] Single incoming frame or nil if no complete frame is available.
  def next(*args); end

  def next_with_rescue(*args); end
  def next_without_rescue; end

  # If decoded then this will return frame content. Otherwise it will return raw frame.
  #
  # @return [String] Data of frame
  def to_s; end
end

class WebSocket::Frame::Incoming::Client < ::WebSocket::Frame::Incoming
  # @return [Boolean]
  def incoming_masking?; end

  # @return [Boolean]
  def outgoing_masking?; end
end

class WebSocket::Frame::Incoming::Server < ::WebSocket::Frame::Incoming
  # @return [Boolean]
  def incoming_masking?; end

  # @return [Boolean]
  def outgoing_masking?; end
end

# Construct or parse incoming WebSocket Frame.
#
# @example
#   frame = WebSocket::Frame::Outgoing::Server.new(version: @handshake.version, data: "Hello", type: :text)
#   frame.to_s # "\x81\x05\x48\x65\x6c\x6c\x6f"
# @note You should NEVER use this class directly - use Client or Server subclasses instead, as they contain additional frame options(i.e. Client-side masking in draft 04)
class WebSocket::Frame::Outgoing < ::WebSocket::Frame::Base
  # Should current frame be sent? Exclude empty frames etc.
  #
  # @return [Boolean] true if frame should be sent
  def require_sending?; end

  # Is selected type supported by current draft version?
  #
  # @return [Boolean] true if frame type is supported
  def supported?; end

  # Return raw frame formatted for sending.
  #
  # @raise [WebSocket::Error::Frame::UnknownFrameType]
  def to_s(*args); end

  def to_s_with_rescue(*args); end
  def to_s_without_rescue; end
end

class WebSocket::Frame::Outgoing::Client < ::WebSocket::Frame::Outgoing
  # @return [Boolean]
  def incoming_masking?; end

  # @return [Boolean]
  def outgoing_masking?; end
end

class WebSocket::Frame::Outgoing::Server < ::WebSocket::Frame::Outgoing
  # @return [Boolean]
  def incoming_masking?; end

  # @return [Boolean]
  def outgoing_masking?; end
end

module WebSocket::Handshake; end

# @abstract Subclass and override to implement custom handshakes
class WebSocket::Handshake::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  extend ::WebSocket::ExceptionHandler::ClassMethods

  # Initialize new WebSocket Handshake and set it's state to :new
  #
  # @return [Base] a new instance of Base
  def initialize(args = T.unsafe(nil)); end

  # @abstract Add data to handshake
  def <<(data); end

  # Is parsing of data finished?
  #
  # @return [Boolena] True if request was completely parsed or error occured. False otherwise
  def finished?; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute host.
  def host; end

  # Data left from parsing. Sometimes data that doesn't belong to handshake are added - use this method to retrieve them.
  #
  # @return [String] String if some data are available. Nil otherwise
  def leftovers; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute port.
  def port; end

  # Returns the value of attribute protocols.
  def protocols; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute secure.
  def secure; end

  # @abstract Should send data after parsing is finished?
  # @raise [NotImplementedError]
  # @return [Boolean]
  def should_respond?; end

  # Returns the value of attribute state.
  def state; end

  # Return textual representation of handshake request or response
  #
  # @return [String] text of response
  def to_s(*args); end

  def to_s_with_rescue(*args); end
  def to_s_without_rescue; end

  # URI of request.
  #
  # @example
  #   @handshake.uri #=> "ws://example.com/path?query=true"
  # @return [String] Full URI with protocol
  def uri; end

  # Is parsed data valid?
  #
  # @return [Boolean] False if some errors occured. Reason for error could be found in error method
  def valid?(*args); end

  # Returns the value of attribute version.
  def version; end

  private

  # Changes state to error and sets error message
  #
  # @param message [String] Error message to set
  def error=(message); end

  # Parse data imported to handshake and sets state to finished if necessary.
  #
  # @return [Boolean] True if finished parsing. False if not all data received yet.
  def parse_data; end

  # Number of lines after header that should be handled as belonging to handshake. Any data after those lines will be handled as leftovers.
  #
  # @return [Integer] Number of lines
  def reserved_leftover_lines; end
end

WebSocket::Handshake::Base::HEADER = T.let(T.unsafe(nil), Regexp)

# Construct or parse a client WebSocket handshake.
#
# @example
#   @handshake = WebSocket::Handshake::Client.new(url: 'ws://example.com')
#
#   # Create request
#   @handshake.to_s # GET /demo HTTP/1.1
#   # Upgrade: websocket
#   # Connection: Upgrade
#   # Host: example.com
#   # Origin: http://example.com
#   # Sec-WebSocket-Version: 13
#   # Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
#
#   # Parse server response
#   @handshake << <<EOF
#   HTTP/1.1 101 Switching Protocols\r
#   Upgrade: websocket\r
#   Connection: Upgrade\r
#   Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r
#   \r
#   EOF
#
#   # All data received?
#   @handshake.finished?
#
#   # No parsing errors?
#   @handshake.valid?
class WebSocket::Handshake::Client < ::WebSocket::Handshake::Base
  # Initialize new WebSocket Client
  #
  # @example
  #   Websocket::Handshake::Client.new(url: "ws://example.com/path?query=true")
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @option args
  # @param args [Hash] Arguments for client
  # @raise [WebSocket::Error::Handshake::NoHostProvided]
  # @return [Client] a new instance of Client
  def initialize(*args); end

  # Add text of response from Server. This method will parse content immediately and update state and error(if neccessary)
  #
  # @example
  #   @handshake << <<EOF
  #   HTTP/1.1 101 Switching Protocols
  #   Upgrade: websocket
  #   Connection: Upgrade
  #   Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  #
  #   EOF
  # @param data [String] Data to add
  def <<(*args); end

  # Returns the value of attribute headers.
  def headers; end

  def initialize_with_rescue(*args); end

  # Returns the value of attribute origin.
  def origin; end

  # Should send content to server after finished parsing?
  #
  # @return [Boolean] false
  def should_respond?; end

  private

  # Include set of methods for selected protocol version
  #
  # @return [Boolean] false if protocol number is unknown, otherwise true
  def include_version; end

  def initialize_without_rescue(args = T.unsafe(nil)); end

  # Parse first line of Server response.
  #
  # @param line [String] Line to parse
  # @raise [WebSocket::Error::Handshake::InvalidHeader]
  # @return [Boolean] True if parsed correctly. False otherwise
  def parse_first_line(line); end
end

WebSocket::Handshake::Client::FIRST_LINE = T.let(T.unsafe(nil), Regexp)
module WebSocket::Handshake::Handler; end

# This class and it's descendants are included in client or server handshake in order to extend basic functionality
class WebSocket::Handshake::Handler::Base
  # @return [Base] a new instance of Base
  def initialize(handshake); end

  # @see WebSocket::Handshake::Base#to_s
  def to_s; end

  # @return [Boolean]
  def valid?; end

  private

  # Set data to send after headers. In most cases it will be blank data.
  #
  # @return [String] data
  def finishing_line; end

  # Set handshake headers. Provided as array because some protocol version require specific order of fields.
  #
  # @return [Array] List of headers as arrays [key, value]
  def handshake_keys; end

  # Set first line of text representation according to specification.
  #
  # @return [String] First line of HTTP header
  def header_line; end
end

class WebSocket::Handshake::Handler::Client < ::WebSocket::Handshake::Handler::Base
  private

  # @see WebSocket::Handshake::Handler::Base#header_handshake_keys
  def handshake_keys; end

  # @see WebSocket::Handshake::Handler::Base#header_line
  def header_line; end

  # Verify if received header matches with one of the sent ones
  #
  # @raise [WebSocket::Error::Handshake::UnsupportedProtocol]
  # @return [Boolean] True if matching. False otherwise(appropriate error is set)
  def verify_protocol; end
end

class WebSocket::Handshake::Handler::Client01 < ::WebSocket::Handshake::Handler::Client76
  private

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end
end

class WebSocket::Handshake::Handler::Client04 < ::WebSocket::Handshake::Handler::Client
  # @return [Boolean]
  # @see WebSocket::Handshake::Base#valid?
  def valid?; end

  private

  # Value of Sec-WebSocket-Accept that should be delivered back by server
  #
  # @return [Sering] accept
  def accept; end

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end

  # Sec-WebSocket-Key value
  #
  # @return [String] key
  def key; end

  def provided_protocols; end
  def supported_protocols; end

  # Verify if received header Sec-WebSocket-Accept matches generated one.
  #
  # @raise [WebSocket::Error::Handshake::InvalidAuthentication]
  # @return [Boolean] True if accept is matching. False otherwise(appropriate error is set)
  def verify_accept; end
end

class WebSocket::Handshake::Handler::Client11 < ::WebSocket::Handshake::Handler::Client04
  private

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end
end

class WebSocket::Handshake::Handler::Client75 < ::WebSocket::Handshake::Handler::Client
  # @return [Boolean]
  # @see WebSocket::Handshake::Base#valid?
  def valid?; end

  private

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end

  def provided_protocols; end
  def supported_protocols; end
end

class WebSocket::Handshake::Handler::Client76 < ::WebSocket::Handshake::Handler::Client75
  # @return [Boolean]
  # @see WebSocket::Handshake::Base#valid?
  def valid?; end

  private

  # Expected challenge that should be sent by server
  #
  # @return [String] challenge
  def challenge; end

  # @see WebSocket::Handshake::Handler::Base#finishing_line
  def finishing_line; end

  # Generate Sec-WebSocket-Key1 and Sec-WebSocket-Key2
  #
  # @param key [String] name of key. Will be used to set number variable needed later. Valid values: key1, key2
  # @return [String] generated key
  def generate_key(key); end

  # Generate third key
  def generate_key3; end

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end

  # Sec-WebSocket-Key1 value
  #
  # @return [String] key
  def key1; end

  # Sec-WebSocket-Key2 value
  #
  # @return [String] key
  def key2; end

  # Value of third key, sent in body
  #
  # @return [String] key
  def key3; end

  def provided_protocols; end

  # @see WebSocket::Handshake::Base#reserved_leftover_lines
  def reserved_leftover_lines; end

  # Verify if challenge sent by server match generated one
  #
  # @raise [WebSocket::Error::Handshake::InvalidAuthentication]
  # @return [Boolena] True if challenge matches, false otherwise(sets appropriate error)
  def verify_challenge; end
end

WebSocket::Handshake::Handler::Client76::NOISE_CHARS = T.let(T.unsafe(nil), Array)
class WebSocket::Handshake::Handler::Server < ::WebSocket::Handshake::Handler::Base; end

class WebSocket::Handshake::Handler::Server04 < ::WebSocket::Handshake::Handler::Server
  # @return [Boolean]
  # @see WebSocket::Handshake::Base#valid?
  def valid?; end

  private

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end

  # @see WebSocket::Handshake::Handler::Base#header_line
  def header_line; end

  def key; end
  def protocol; end

  # Signature of response, created from client request Sec-WebSocket-Key
  #
  # @return [String] signature
  def signature; end

  # @raise [WebSocket::Error::Handshake::InvalidAuthentication]
  def verify_key; end
end

class WebSocket::Handshake::Handler::Server75 < ::WebSocket::Handshake::Handler::Server
  private

  # @see WebSocket::Handshake::Handler::Base#handshake_keys
  def handshake_keys; end

  # @see WebSocket::Handshake::Handler::Base#header_line
  def header_line; end

  def headers; end
  def protocol; end
end

class WebSocket::Handshake::Handler::Server76 < ::WebSocket::Handshake::Handler::Server75
  # @return [Boolean]
  # @see WebSocket::Handshake::Base#valid?
  def valid?; end

  private

  # Response to client challenge from request Sec-WebSocket-Key1, Sec-WebSocket-Key2 and leftovers
  #
  # @return [String] Challenge response or nil if error occured
  def challenge_response; end

  # @see WebSocket::Handshake::Handler::Base#finishing_line
  def finishing_line; end

  # @see WebSocket::Handshake::Handler::Base#header_line
  def header_line; end

  def headers; end

  # Calculate numbers over spaces, according to spec 5.2
  #
  # @param string [String] Key to parse
  # @raise [WebSocket::Error::Handshake::InvalidAuthentication]
  # @return [Integer] Result of calculations or nil if error occured
  def numbers_over_spaces(string); end

  # @see WebSocket::Handshake::Base#reserved_leftover_lines
  def reserved_leftover_lines; end
end

# Construct or parse a server WebSocket handshake.
#
# @example
#   handshake = WebSocket::Handshake::Server.new
#
#   # Parse client request
#   @handshake << <<EOF
#   GET /demo HTTP/1.1\r
#   Upgrade: websocket\r
#   Connection: Upgrade\r
#   Host: example.com\r
#   Origin: http://example.com\r
#   Sec-WebSocket-Version: 13\r
#   Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
#   \r
#   EOF
#
#   # All data received?
#   @handshake.finished?
#
#   # No parsing errors?
#   @handshake.valid?
#
#   # Create response
#   @handshake.to_s # HTTP/1.1 101 Switching Protocols
#   # Upgrade: websocket
#   # Connection: Upgrade
#   # Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
class WebSocket::Handshake::Server < ::WebSocket::Handshake::Base
  # Initialize new WebSocket Server
  #
  # @example
  #   Websocket::Handshake::Server.new(secure: true)
  # @option args
  # @option args
  # @param args [Hash] Arguments for server
  # @return [Server] a new instance of Server
  def initialize(args = T.unsafe(nil)); end

  # Add text of request from Client. This method will parse content immediately and update version, state and error(if neccessary)
  #
  # @example
  #   @handshake << <<EOF
  #   GET /demo HTTP/1.1
  #   Upgrade: websocket
  #   Connection: Upgrade
  #   Host: example.com
  #   Origin: http://example.com
  #   Sec-WebSocket-Version: 13
  #   Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  #
  #   EOF
  # @param data [String] Data to add
  def <<(*args); end

  # Parse the request from hash
  #
  # @example
  #   @handshake.from_hash(hash)
  # @option hash
  # @option hash
  # @option hash
  # @option hash
  # @param hash Hash to import data
  def from_hash(hash); end

  # Parse the request from a rack environment
  #
  # @example
  #   @handshake.from_rack(env)
  # @param env Rack Environment
  def from_rack(env); end

  # Host of server according to client header
  #
  # @return [String] host
  def host; end

  # Port of server according to client header
  #
  # @return [String] port
  def port; end

  # Should send content to client after finished parsing?
  #
  # @return [Boolean] true
  def should_respond?; end

  private

  # Include set of methods for selected protocol version
  #
  # @return [Boolean] false if protocol number is unknown, otherwise true
  def include_version; end

  # Parse first line of Client response.
  #
  # @param line [String] Line to parse
  # @raise [WebSocket::Error::Handshake::InvalidHeader]
  # @return [Boolean] True if parsed correctly. False otherwise
  def parse_first_line(line); end

  # Set version of protocol basing on client requets. AFter cotting method calls include_version.
  def set_version; end
end

WebSocket::Handshake::Server::PATH = T.let(T.unsafe(nil), Regexp)

module WebSocket::Mask
  class << self
    def mask(_arg0, _arg1); end
  end
end

module WebSocket::NiceInspect
  # Recreate inspect as #to_s will be overwritten
  def inspect; end
end

WebSocket::ROOT = T.let(T.unsafe(nil), String)
