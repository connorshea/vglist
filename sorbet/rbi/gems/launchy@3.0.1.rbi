# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `launchy` gem.
# Please instead update this file by running `bin/tapioca gem launchy`.


# The entry point into Launchy. This is the sole supported public API.
#
#   Launchy.open( uri, options = {} )
#
# The currently defined global options are:
#
#   :debug        Turn on debugging output
#   :application  Explicitly state what application class is going to be used.
#                 This must be a child class of Launchy::Application
#   :host_os      Explicitly state what host operating system to pretend to be
#   :dry_run      Do nothing and print the command that would be executed on $stdout
#
# Other options may be used, and those will be passed directly to the
# application class
module Launchy
  class << self
    def app_for_name(name); end
    def app_for_uri(uri); end
    def app_for_uri_string(str); end
    def application; end
    def application=(app); end
    def bug_report_message; end
    def debug=(enabled); end

    # we may do logging before a call to 'open', hence the need to check
    # LAUNCHY_DEBUG here
    #
    # @return [Boolean]
    def debug?; end

    def dry_run=(dry_run); end

    # @return [Boolean]
    def dry_run?; end

    def extract_global_options(options); end
    def host_os; end
    def host_os=(host_os); end
    def log(msg); end

    # Launch an application for the given uri string
    def open(uri_s, options = T.unsafe(nil)); end

    def path; end
    def path=(path); end
    def reset_global_options; end

    # @raise [Launchy::ArgumentError]
    def string_to_uri(str); end

    private

    def to_bool(arg); end
  end
end

# Application is the base class of all the application types that launchy may
# invoke. It essentially defines the public api of the launchy system.
#
# Every class that inherits from Application must define:
#
# 1. A constructor taking no parameters
# 2. An instance method 'open' taking a string or URI as the first parameter and a
#    hash as the second
# 3. A class method 'handles?' that takes a String and returns true if that
#    class can handle the input.
class Launchy::Application
  extend ::Launchy::DescendantTracker

  # @return [Application] a new instance of Application
  def initialize; end

  def find_executable(bin, *paths); end

  # Returns the value of attribute host_os_family.
  def host_os_family; end

  def run(cmd, *args); end

  # Returns the value of attribute runner.
  def runner; end

  class << self
    # Find the given executable in the available paths
    #
    # returns the path to the executable or nil if not found
    def find_executable(bin, *paths); end

    # Find the application with the given name
    #
    # returns the Class that has the given name
    #
    # @raise [ApplicationNotFoundError]
    def for_name(name); end

    # Find the application that handles the given uri.
    #
    # returns the Class that can handle the uri
    #
    # @raise [ApplicationNotFoundError]
    def handling(uri); end

    # Does this class have the given name-like string?
    #
    # returns true if the class has the given name
    #
    # @return [Boolean]
    def has_name?(qname); end
  end
end

# The class handling the browser application and all of its schemes
class Launchy::Application::Browser < ::Launchy::Application
  # use a call back mechanism to get the right app_list that is decided by the
  # host_os_family class.
  def app_list; end

  # Get the full commandline of what we are going to add the uri to
  #
  # @raise [Launchy::CommandNotFoundError]
  def browser_cmdline; end

  def browser_env; end
  def cmd_and_args(uri, _options = T.unsafe(nil)); end
  def cygwin_app_list; end

  # hardcode this to open?
  def darwin_app_list; end

  def nix_app_list; end

  # final assembly of the command and do %s substitution
  # http://www.catb.org/~esr/BROWSER/index.html
  def open(uri, options = T.unsafe(nil)); end

  def windows_app_list; end

  class << self
    # @return [Boolean]
    def handles?(uri); end

    def schemes; end
  end
end

class Launchy::ApplicationNotFoundError < ::Launchy::Error; end
class Launchy::ArgumentError < ::Launchy::Error; end

# Internal: Ecapsulate the commandline argumens passed to Launchy
class Launchy::Argv
  # @return [Argv] a new instance of Argv
  def initialize(*args); end

  def ==(other); end
  def [](idx); end

  # Returns the value of attribute argv.
  def argv; end

  # @return [Boolean]
  def blank?; end

  # @return [Boolean]
  def executable?; end

  def to_s; end
  def to_str; end

  # @return [Boolean]
  def valid?; end
end

# Internal: Command line interface for Launchy
class Launchy::Cli
  # @return [Cli] a new instance of Cli
  def initialize; end

  def error_output(error); end
  def good_run(argv, env); end

  # Returns the value of attribute options.
  def options; end

  def parse(argv, _env); end
  def parser; end
  def run(argv = T.unsafe(nil), env = T.unsafe(nil)); end
end

class Launchy::CommandNotFoundError < ::Launchy::Error; end

# Use by either
#
#   class Foo
#     extend DescendantTracker
#   end
#
# or
#
#   class Foo
#     class << self
#       include DescendantTracker
#     end
#   end
#
# It will track all the classes that inherit from the extended class and keep
# them in a Set that is available via the 'children' method.
module Launchy::DescendantTracker
  # The list of children that are registered
  def children; end

  # Find one of the child classes by calling the given method
  # and passing all the rest of the parameters to that method in
  # each child
  def find_child(method, *args); end

  def inherited(klass); end
end

# Internal: Namespace for detecting the environment that Launchy is running in
module Launchy::Detect; end

# Internal: Determine the host operating system that Launchy is running on
class Launchy::Detect::HostOs
  # @return [HostOs] a new instance of HostOs
  def initialize(host_os = T.unsafe(nil)); end

  def default_host_os; end

  # Returns the value of attribute host_os.
  def host_os; end

  def override_host_os; end

  # Returns the value of attribute host_os.
  def to_s; end

  # Returns the value of attribute host_os.
  def to_str; end
end

# Detect the current host os family
#
# If the current host familiy cannot be detected then return
# HostOsFamily::Unknown
class Launchy::Detect::HostOsFamily
  extend ::Launchy::DescendantTracker

  # @return [HostOsFamily] a new instance of HostOsFamily
  def initialize(host_os = T.unsafe(nil)); end

  # @return [Boolean]
  def cygwin?; end

  # @return [Boolean]
  def darwin?; end

  # Returns the value of attribute host_os.
  def host_os; end

  # @return [Boolean]
  def nix?; end

  # @return [Boolean]
  def windows?; end

  class << self
    # @return [Boolean]
    def cygwin?; end

    # @return [Boolean]
    def darwin?; end

    # @raise [NotFoundError]
    def detect(host_os = T.unsafe(nil)); end

    # @return [Boolean]
    def matches?(host_os); end

    # @return [Boolean]
    def nix?; end

    # @return [Boolean]
    def windows?; end
  end
end

# Cygwin - if anyone is still using that
class Launchy::Detect::HostOsFamily::Cygwin < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

# Mac OS X family
class Launchy::Detect::HostOsFamily::Darwin < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

# All the *nix family of operating systems, and BSDs
class Launchy::Detect::HostOsFamily::Nix < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

class Launchy::Detect::HostOsFamily::NotFoundError < ::Launchy::Error; end

# ---------------------------
# All known host os families
# ---------------------------
class Launchy::Detect::HostOsFamily::Windows < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

# Detect the current desktop environment for *nix machines
# Currently this is Linux centric. The detection is based upon the detection
# used by xdg-open from http://portland.freedesktop.org/
class Launchy::Detect::NixDesktopEnvironment
  extend ::Launchy::DescendantTracker

  class << self
    def browsers; end

    # Detect the current *nix desktop environment
    #
    # If the current dekstop environment be detected, the return
    # NixDekstopEnvironment::Unknown
    def detect; end

    def fallback_browsers; end
  end
end

# Gnome desktop environment
class Launchy::Detect::NixDesktopEnvironment::Gnome < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

# KDE desktop environment
class Launchy::Detect::NixDesktopEnvironment::Kde < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

# The one that is found when all else fails. And this must be declared last
class Launchy::Detect::NixDesktopEnvironment::NotFound < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

class Launchy::Detect::NixDesktopEnvironment::NotFoundError < ::Launchy::Error; end

# Fall back environment as the last case
class Launchy::Detect::NixDesktopEnvironment::Xdg < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

# Xfce desktop environment
class Launchy::Detect::NixDesktopEnvironment::Xfce < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

class Launchy::Error < ::StandardError; end

# Internal: Run a command in a child process
class Launchy::Runner
  def commandline_normalize(cmdline); end
  def dry_run(cmd, *args); end
  def run(cmd, *args); end

  # cut it down to just the shell commands that will be passed to exec or
  # posix_spawn. The cmd argument is split according to shell rules and the
  # args are not escaped because the whole set is passed to system as *args
  # and in that case system shell escaping rules are not done.
  def shell_commands(cmd, args); end

  def wet_run(cmd, *args); end
end

Launchy::VERSION = T.let(T.unsafe(nil), String)

# Internal: Version number of Launchy
module Launchy::Version
  class << self
    def to_a; end
    def to_s; end
  end
end

Launchy::Version::MAJOR = T.let(T.unsafe(nil), Integer)
Launchy::Version::MINOR = T.let(T.unsafe(nil), Integer)
Launchy::Version::PATCH = T.let(T.unsafe(nil), Integer)
