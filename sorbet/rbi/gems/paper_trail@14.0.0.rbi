# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `paper_trail` gem.
# Please instead update this file by running `bin/tapioca gem paper_trail`.

class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  include ::PaperTrail::Model
  extend ::PaperTrail::Model::ClassMethods
end

# An ActiveRecord extension that tracks changes to your models, for auditing or
# versioning.
module PaperTrail
  extend ::PaperTrail::Cleaner

  class << self
    # Returns PaperTrail's global configuration object, a singleton. These
    # settings affect all threads.
    #
    # @api public
    # @yield [@config]
    def config; end

    # Returns PaperTrail's global configuration object, a singleton. These
    # settings affect all threads.
    #
    # @api public
    # @yield [@config]
    def configure; end

    # Switches PaperTrail on or off, for all threads.
    #
    # @api public
    def enabled=(value); end

    # Returns `true` if PaperTrail is on, `false` otherwise. This is the
    # on/off switch that affects all threads. Enabled by default.
    #
    # @api public
    # @return [Boolean]
    def enabled?; end

    # Returns PaperTrail's `::Gem::Version`, convenient for comparisons. This is
    # recommended over `::PaperTrail::VERSION::STRING`.
    #
    # Added in 7.0.0
    #
    # @api public
    def gem_version; end

    # Set variables for the current request, eg. whodunnit.
    #
    # All request-level variables are now managed here, as of PT 9. Having the
    # word "request" right there in your application code will remind you that
    # these variables only affect the current request, not all threads.
    #
    # Given a block, temporarily sets the given `options`, executes the block,
    # and returns the value of the block.
    #
    # Without a block, this currently just returns `PaperTrail::Request`.
    # However, please do not use `PaperTrail::Request` directly. Currently,
    # `Request` is a `Module`, but in the future it is quite possible we may
    # make it a `Class`. If we make such a choice, we will not provide any
    # warning and will not treat it as a breaking change. You've been warned :)
    #
    # @api public
    def request(options = T.unsafe(nil), &block); end

    # Get the PaperTrail serializer used by all threads.
    #
    # @api public
    def serializer; end

    # Set the PaperTrail serializer. This setting affects all threads.
    #
    # @api public
    def serializer=(value); end

    # Set the field which records when a version was created.
    #
    # @api public
    # @raise [Error]
    def timestamp_field=(_field_name); end

    # @api public
    def version; end
  end
end

module PaperTrail::AttributeSerializers; end

# Values returned by some Active Record serializers are
# not suited for writing JSON to a text column. This factory
# replaces certain default Active Record serializers
# with custom PaperTrail ones.
#
# @api private
module PaperTrail::AttributeSerializers::AttributeSerializerFactory
  class << self
    # @api private
    def for(klass, attr); end

    private

    # @api private
    # @return [Boolean]
    def ar_pg_array?(obj); end
  end
end

# The `CastAttributeSerializer` (de)serializes model attribute values. For
# example, the string "1.99" serializes into the integer `1` when assigned
# to an attribute of type `ActiveRecord::Type::Integer`.
class PaperTrail::AttributeSerializers::CastAttributeSerializer
  # @return [CastAttributeSerializer] a new instance of CastAttributeSerializer
  def initialize(klass); end

  private

  # Returns a hash mapping attributes to hashes that map strings to
  # integers. Example:
  #
  # ```
  # { "status" => { "draft"=>0, "published"=>1, "archived"=>2 } }
  # ```
  #
  # ActiveRecord::Enum was added in AR 4.1
  # http://edgeguides.rubyonrails.org/4_1_release_notes.html#active-record-enums
  def defined_enums; end

  def deserialize(attr, val); end

  # @return [Boolean]
  def rails_gte_7_0?; end

  def serialize(attr, val); end
end

# Serialize or deserialize the `version.object` column.
class PaperTrail::AttributeSerializers::ObjectAttribute
  # @return [ObjectAttribute] a new instance of ObjectAttribute
  def initialize(model_class); end

  def deserialize(attributes); end
  def serialize(attributes); end

  private

  # Modifies `attributes` in place.
  # TODO: Return a new hash instead.
  def alter(attributes, serialization_method); end

  # @return [Boolean]
  def object_col_is_json?; end
end

# Serialize or deserialize the `version.object_changes` column.
class PaperTrail::AttributeSerializers::ObjectChangesAttribute
  # @return [ObjectChangesAttribute] a new instance of ObjectChangesAttribute
  def initialize(item_class); end

  def deserialize(changes); end
  def serialize(changes); end

  private

  # Modifies `changes` in place.
  # TODO: Return a new hash instead.
  def alter(changes, serialization_method); end

  # @return [Boolean]
  def object_changes_col_is_json?; end
end

# Utilities for deleting version records.
module PaperTrail::Cleaner
  # Destroys all but the most recent version(s) for items on a given date
  # (or on all dates). Useful for deleting drafts.
  #
  # Options:
  #
  # - :keeping - An `integer` indicating the number of versions to be kept for
  #   each item per date. Defaults to `1`. The most recent matching versions
  #   are kept.
  # - :date - Should either be a `Date` object specifying which date to
  #   destroy versions for or `:all`, which will specify that all dates
  #   should be cleaned. Defaults to `:all`.
  # - :item_id - The `id` for the item to be cleaned on, or `nil`, which
  #   causes all items to be cleaned. Defaults to `nil`.
  def clean_versions!(options = T.unsafe(nil)); end

  private

  # Returns a hash of versions grouped by the `item_id` attribute formatted
  # like this: {:item_id => PaperTrail::Version}. If `item_id` or `date` is
  # set, versions will be narrowed to those pointing at items with those ids
  # that were created on specified date. Versions are returned in
  # chronological order.
  def gather_versions(item_id = T.unsafe(nil), date = T.unsafe(nil)); end

  # Given an array of versions, returns a hash mapping dates to arrays of
  # versions.
  #
  # @api private
  def group_versions_by_date(versions); end
end

# Rails does not follow SemVer, makes breaking changes in minor versions.
# Breaking changes are expected, and are generally good for the rails
# ecosystem. However, they often require dozens of hours to fix, even with the
# [help of experts](https://github.com/paper-trail-gem/paper_trail/pull/899).
#
# It is not safe to assume that a new version of rails will be compatible with
# PaperTrail. PT is only compatible with the versions of rails that it is
# tested against. See `.github/workflows/test.yml`.
#
# However, as of
# [#1213](https://github.com/paper-trail-gem/paper_trail/pull/1213) our
# gemspec allows installation with newer, incompatible rails versions. We hope
# this will make it easier for contributors to work on compatibility with
# newer rails versions. Most PT users should avoid incompatible rails
# versions.
module PaperTrail::Compatibility
  class << self
    # Normal users need a warning if they accidentally install an incompatible
    # version of ActiveRecord. Contributors can silence this warning with an
    # environment variable.
    #
    # @raise [::TypeError]
    def check_activerecord(ar_version); end
  end
end

# enforced in gemspec
PaperTrail::Compatibility::ACTIVERECORD_GTE = T.let(T.unsafe(nil), String)

# not enforced in gemspec
PaperTrail::Compatibility::ACTIVERECORD_LT = T.let(T.unsafe(nil), String)

PaperTrail::Compatibility::E_INCOMPATIBLE_AR = T.let(T.unsafe(nil), String)

# Global configuration affecting all threads. Some thread-specific
# configuration can be found in `paper_trail.rb`, others in `controller.rb`.
class PaperTrail::Config
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Config] a new instance of Config
  def initialize; end

  # Returns the value of attribute association_reify_error_behaviour.
  def association_reify_error_behaviour; end

  # Sets the attribute association_reify_error_behaviour
  #
  # @param value the value to set the attribute association_reify_error_behaviour to.
  def association_reify_error_behaviour=(_arg0); end

  # Indicates whether PaperTrail is on or off. Default: true.
  def enabled; end

  def enabled=(enable); end

  # Returns the value of attribute has_paper_trail_defaults.
  def has_paper_trail_defaults; end

  # Sets the attribute has_paper_trail_defaults
  #
  # @param value the value to set the attribute has_paper_trail_defaults to.
  def has_paper_trail_defaults=(_arg0); end

  # Returns the value of attribute object_changes_adapter.
  def object_changes_adapter; end

  # Sets the attribute object_changes_adapter
  #
  # @param value the value to set the attribute object_changes_adapter to.
  def object_changes_adapter=(_arg0); end

  # Returns the value of attribute serializer.
  def serializer; end

  # Sets the attribute serializer
  #
  # @param value the value to set the attribute serializer to.
  def serializer=(_arg0); end

  # Returns the value of attribute version_limit.
  def version_limit; end

  # Sets the attribute version_limit
  #
  # @param value the value to set the attribute version_limit to.
  def version_limit=(_arg0); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

PaperTrail::E_TIMESTAMP_FIELD_CONFIG = T.let(T.unsafe(nil), String)

# Generic PaperTrail exception.
#
# @api public
class PaperTrail::Error < ::StandardError; end

module PaperTrail::Events; end

# We refer to times in the lifecycle of a record as "events". There are
# three events:
#
# - create
#   - `after_create` we call `RecordTrail#record_create`
# - update
#   - `after_update` we call `RecordTrail#record_update`
#   - `after_touch` we call `RecordTrail#record_update`
#   - `RecordTrail#save_with_version` calls `RecordTrail#record_update`
#   - `RecordTrail#update_columns` is also referred to as an update, though
#     it uses `RecordTrail#record_update_columns` rather than
#     `RecordTrail#record_update`
# - destroy
#   - `before_destroy` or `after_destroy` we call `RecordTrail#record_destroy`
#
# The value inserted into the `event` column of the versions table can also
# be overridden by the user, with `paper_trail_event`.
#
# @api private
class PaperTrail::Events::Base
  # @api private
  # @return [Base] a new instance of Base
  def initialize(record, in_after_callback); end

  # Determines whether it is appropriate to generate a new version
  # instance. A timestamp-only update (e.g. only `updated_at` changed) is
  # considered notable unless an ignored attribute was also changed.
  #
  # @api private
  # @return [Boolean]
  def changed_notably?; end

  private

  # @api private
  # @raise [PaperTrail::InvalidOption]
  def assert_metadatum_key_is_permitted(key); end

  # Rails 5.1 changed the API of `ActiveRecord::Dirty`. See
  # https://github.com/paper-trail-gem/paper_trail/pull/899
  #
  # @api private
  # @return [Boolean]
  def attribute_changed_in_latest_version?(attr_name); end

  # Rails 5.1 changed the API of `ActiveRecord::Dirty`. See
  # https://github.com/paper-trail-gem/paper_trail/pull/899
  #
  # Event can be any of the three (create, update, destroy).
  #
  # @api private
  def attribute_in_previous_version(attr_name, is_touch); end

  # @api private
  def calculated_ignored_array; end

  # @api private
  def changed_and_not_ignored; end

  # @api private
  def changed_in_latest_version; end

  # Memoized to reduce memory usage
  #
  # @api private
  def changes_in_latest_version; end

  # @api private
  def evaluate_only; end

  # An attributed is "ignored" if it is listed in the `:ignore` option
  # and/or the `:skip` option.  Returns true if an ignored attribute has
  # changed.
  #
  # @api private
  # @return [Boolean]
  def ignored_attr_has_changed?; end

  # Rails 5.1 changed the API of `ActiveRecord::Dirty`. See
  # https://github.com/paper-trail-gem/paper_trail/pull/899
  #
  # @api private
  def load_changes_in_latest_version; end

  # PT 10 has a new optional column, `item_subtype`
  #
  # @api private
  def merge_item_subtype_into(data); end

  # Updates `data` from `controller_info`.
  #
  # @api private
  def merge_metadata_from_controller_into(data); end

  # Updates `data` from the model's `meta` option.
  #
  # @api private
  def merge_metadata_from_model_into(data); end

  # Updates `data` from the model's `meta` option and from `controller_info`.
  # Metadata is always recorded; that means all three events (create, update,
  # destroy) and `update_columns`.
  #
  # @api private
  def merge_metadata_into(data); end

  # The model method can either be an attribute or a non-attribute method.
  #
  # If it is an attribute that is changing in an existing object,
  # be sure to grab the correct version.
  #
  # @api private
  def metadatum_from_model_method(event, method); end

  # Given a `value` from the model's `meta` option, returns an object to be
  # persisted. The `value` can be a simple scalar value, but it can also
  # be a symbol that names a model method, or even a Proc.
  #
  # @api private
  def model_metadatum(value, event); end

  # @api private
  def nonskipped_attributes_before_change(is_touch); end

  # @api private
  def notable_changes; end

  # @api private
  def notably_changed; end

  # Returns hash of attributes (with appropriate attributes serialized),
  # omitting attributes to be skipped.
  #
  # @api private
  def object_attrs_for_paper_trail(is_touch); end

  # @api private
  def prepare_object_changes(changes); end

  # Returns a boolean indicating whether to store the original object during save.
  #
  # @api private
  # @return [Boolean]
  def record_object?; end

  # Returns a boolean indicating whether to store serialized version diffs
  # in the `object_changes` column of the version record.
  #
  # @api private
  # @return [Boolean]
  def record_object_changes?; end

  # Returns an object which can be assigned to the `object` attribute of a
  # nascent version record. If the `object` column is a postgres `json`
  # column, then a hash can be used in the assignment, otherwise the column
  # is a `text` column, and we must perform the serialization here, using
  # `PaperTrail.serializer`.
  #
  # @api private
  def recordable_object(is_touch); end

  # Returns an object which can be assigned to the `object_changes`
  # attribute of a nascent version record. If the `object_changes` column is
  # a postgres `json` column, then a hash can be used in the assignment,
  # otherwise the column is a `text` column, and we must perform the
  # serialization here, using `PaperTrail.serializer`.
  #
  # @api private
  # @param changes HashWithIndifferentAccess
  def recordable_object_changes(changes); end

  # @api private
  def serialize_object_changes(changes); end
end

# @api private
PaperTrail::Events::Base::E_FORBIDDEN_METADATA_KEY = T.let(T.unsafe(nil), String)

# @api private
PaperTrail::Events::Base::FORBIDDEN_METADATA_KEYS = T.let(T.unsafe(nil), Array)

# See docs in `Base`.
#
# @api private
class PaperTrail::Events::Create < ::PaperTrail::Events::Base
  # Return attributes of nascent `Version` record.
  #
  # @api private
  def data; end
end

# See docs in `Base`.
#
# @api private
class PaperTrail::Events::Destroy < ::PaperTrail::Events::Base
  # Return attributes of nascent `Version` record.
  #
  # @api private
  def data; end

  private

  # Rails' implementation (eg. `@record.saved_changes`) returns nothing on
  # destroy, so we have to build the hash we want.
  #
  # @api private
  def changes_in_latest_version; end
end

# See docs in `Base`.
#
# @api private
class PaperTrail::Events::Update < ::PaperTrail::Events::Base
  # - is_touch - [boolean] - Used in the two situations that are touch-like:
  #   - `after_touch` we call `RecordTrail#record_update`
  # - force_changes - [Hash] - Only used by `RecordTrail#update_columns`,
  #   because there dirty-tracking is off, so it has to track its own changes.
  #
  # @api private
  # @return [Update] a new instance of Update
  def initialize(record, in_after_callback, is_touch, force_changes); end

  # If it is a touch event, and changed are empty, it is assumed to be
  # implicit `touch` mutation, and will a version is created.
  #
  # See https://github.com/rails/rails/commit/dcb825902d79d0f6baba956f7c6ec5767611353e
  #
  # @api private
  # @return [Boolean]
  def changed_notably?; end

  # Return attributes of nascent `Version` record.
  #
  # @api private
  def data; end

  private

  # @api private
  def merge_object_changes_into(data); end

  # `touch` cannot record `object_changes` because rails' `touch` does not
  # perform dirty-tracking. Specifically, methods from `Dirty`, like
  # `saved_changes`, return the same values before and after `touch`.
  #
  # See https://github.com/rails/rails/issues/33429
  #
  # @api private
  # @return [Boolean]
  def record_object_changes?; end
end

# An unexpected option, perhaps a typo, was passed to a public API method.
#
# @api public
class PaperTrail::InvalidOption < ::PaperTrail::Error; end

# Extensions to `ActiveRecord::Base`.  See `frameworks/active_record.rb`.
# It is our goal to have the smallest possible footprint here, because
# `ActiveRecord::Base` is a very crowded namespace! That is why we introduced
# `.paper_trail` and `#paper_trail`.
module PaperTrail::Model
  mixes_in_class_methods ::PaperTrail::Model::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

module PaperTrail::Model::ClassMethods
  # Declare this in your model to track every create, update, and destroy.
  # Each version of the model is available in the `versions` association.
  #
  # Options:
  #
  # - :on - The events to track (optional; defaults to all of them). Set
  #   to an array of `:create`, `:update`, `:destroy` and `:touch` as desired.
  # - :class_name (deprecated) - The name of a custom Version class that
  #   includes `PaperTrail::VersionConcern`.
  # - :ignore - An array of attributes for which a new `Version` will not be
  #   created if only they change. It can also accept a Hash as an
  #   argument where the key is the attribute to ignore (a `String` or
  #   `Symbol`), which will only be ignored if the value is a `Proc` which
  #   returns truthily.
  # - :if, :unless - Procs that allow to specify conditions when to save
  #   versions for an object.
  # - :only - Inverse of `ignore`. A new `Version` will be created only
  #   for these attributes if supplied it can also accept a Hash as an
  #   argument where the key is the attribute to track (a `String` or
  #   `Symbol`), which will only be counted if the value is a `Proc` which
  #   returns truthily.
  # - :skip - Fields to ignore completely.  As with `ignore`, updates to
  #   these fields will not create a new `Version`.  In addition, these
  #   fields will not be included in the serialized versions of the object
  #   whenever a new `Version` is created.
  # - :meta - A hash of extra data to store. You must add a column to the
  #   `versions` table for each key. Values are objects or procs (which
  #   are called with `self`, i.e. the model with the paper trail).  See
  #   `PaperTrail::Controller.info_for_paper_trail` for how to store data
  #   from the controller.
  # - :versions - Either,
  #   - A String (deprecated) - The name to use for the versions
  #     association.  Default is `:versions`.
  #   - A Hash - options passed to `has_many`, plus `name:` and `scope:`.
  # - :version - The name to use for the method which returns the version
  #   the instance was reified from. Default is `:version`.
  #
  # Plugins like the experimental `paper_trail-association_tracking` gem
  # may accept additional options.
  #
  # You can define a default set of options via the configurable
  # `PaperTrail.config.has_paper_trail_defaults` hash in your applications
  # initializer. The hash can contain any of the following options and will
  # provide an overridable default for all models.
  #
  # @api public
  def has_paper_trail(options = T.unsafe(nil)); end

  # @api public
  def paper_trail; end
end

# Wrap the following methods in a module so we can include them only in the
# ActiveRecord models that declare `has_paper_trail`.
module PaperTrail::Model::InstanceMethods
  # @api public
  def paper_trail; end
end

# Configures an ActiveRecord model, mostly at application boot time, but also
# sometimes mid-request, with methods like enable/disable.
class PaperTrail::ModelConfig
  # @return [ModelConfig] a new instance of ModelConfig
  def initialize(model_class); end

  # Adds a callback that records a version after a "create" event.
  #
  # @api public
  def on_create; end

  # Adds a callback that records a version before or after a "destroy" event.
  #
  # @api public
  def on_destroy(recording_order = T.unsafe(nil)); end

  # Adds a callback that records a version after a "touch" event.
  #
  # Rails < 6.0 has a bug where dirty-tracking does not occur during
  # a `touch`. (https://github.com/rails/rails/issues/33429) See also:
  # https://github.com/paper-trail-gem/paper_trail/issues/1121
  # https://github.com/paper-trail-gem/paper_trail/issues/1161
  # https://github.com/paper-trail-gem/paper_trail/pull/1285
  #
  # @api public
  def on_touch; end

  # Adds a callback that records a version after an "update" event.
  #
  # @api public
  def on_update; end

  # Set up `@model_class` for PaperTrail. Installs callbacks, associations,
  # "class attributes", instance methods, and more.
  #
  # @api private
  def setup(options = T.unsafe(nil)); end

  # @api private
  def version_class; end

  private

  # @api private
  def append_option_uniquely(option, value); end

  # Raises an error if the provided class is an `abstract_class`.
  #
  # @api private
  def assert_concrete_activerecord_class(class_name); end

  # @api private
  def assert_valid_recording_order_for_on_destroy(recording_order); end

  # @return [Boolean]
  def cannot_record_after_destroy?; end

  def check_version_class_name(options); end
  def check_versions_association_name(options); end
  def define_has_many_versions(options); end
  def ensure_versions_option_is_hash(options); end

  # Process an `ignore`, `skip`, or `only` option.
  def event_attribute_option(option_name); end

  def get_versions_scope(options); end
  def setup_associations(options); end
  def setup_callbacks_from_options(options_on = T.unsafe(nil)); end
  def setup_options(options); end
end

PaperTrail::ModelConfig::DPR_CLASS_NAME_OPTION = T.let(T.unsafe(nil), String)
PaperTrail::ModelConfig::DPR_PASSING_ASSOC_NAME_DIRECTLY_TO_VERSIONS_OPTION = T.let(T.unsafe(nil), String)
PaperTrail::ModelConfig::E_CANNOT_RECORD_AFTER_DESTROY = T.let(T.unsafe(nil), String)
PaperTrail::ModelConfig::E_HPT_ABSTRACT_CLASS = T.let(T.unsafe(nil), String)
module PaperTrail::Queries; end
module PaperTrail::Queries::Versions; end

# For public API documentation, see `where_attribute_changes` in
# `paper_trail/version_concern.rb`.
#
# @api private
class PaperTrail::Queries::Versions::WhereAttributeChanges
  # - version_model_class - The class that VersionConcern was mixed into.
  # - attribute - An attribute that changed. See the public API
  #   documentation for details.
  #
  # @api private
  # @return [WhereAttributeChanges] a new instance of WhereAttributeChanges
  def initialize(version_model_class, attribute); end

  # @api private
  def execute; end

  private

  # @api private
  def json; end
end

# For public API documentation, see `where_object` in
# `paper_trail/version_concern.rb`.
#
# @api private
class PaperTrail::Queries::Versions::WhereObject
  # - version_model_class - The class that VersionConcern was mixed into.
  # - attributes - A `Hash` of attributes and values. See the public API
  #   documentation for details.
  #
  # @api private
  # @return [WhereObject] a new instance of WhereObject
  def initialize(version_model_class, attributes); end

  # @api private
  # @raise [Error]
  def execute; end

  private

  # @api private
  def json; end

  # @api private
  def jsonb; end

  # @api private
  def text; end
end

# For public API documentation, see `where_object_changes` in
# `paper_trail/version_concern.rb`.
#
# @api private
class PaperTrail::Queries::Versions::WhereObjectChanges
  # - version_model_class - The class that VersionConcern was mixed into.
  # - attributes - A `Hash` of attributes and values. See the public API
  #   documentation for details.
  #
  # @api private
  # @return [WhereObjectChanges] a new instance of WhereObjectChanges
  def initialize(version_model_class, attributes); end

  # @api private
  def execute; end

  private

  # @api private
  def json; end

  # @api private
  def jsonb; end
end

# For public API documentation, see `where_object_changes_from` in
# `paper_trail/version_concern.rb`.
#
# @api private
class PaperTrail::Queries::Versions::WhereObjectChangesFrom
  # - version_model_class - The class that VersionConcern was mixed into.
  # - attributes - A `Hash` of attributes and values. See the public API
  #   documentation for details.
  #
  # @api private
  # @return [WhereObjectChangesFrom] a new instance of WhereObjectChangesFrom
  def initialize(version_model_class, attributes); end

  # @api private
  def execute; end

  private

  # @api private
  def json; end
end

# For public API documentation, see `where_object_changes_to` in
# `paper_trail/version_concern.rb`.
#
# @api private
class PaperTrail::Queries::Versions::WhereObjectChangesTo
  # - version_model_class - The class that VersionConcern was mixed into.
  # - attributes - A `Hash` of attributes and values. See the public API
  #   documentation for details.
  #
  # @api private
  # @return [WhereObjectChangesTo] a new instance of WhereObjectChangesTo
  def initialize(version_model_class, attributes); end

  # @api private
  def execute; end

  private

  # @api private
  def json; end
end

module PaperTrail::RSpec; end
module PaperTrail::RSpec::Helpers; end

# Extended by the RSpec configuration in `frameworks/rspec.rb`
module PaperTrail::RSpec::Helpers::ClassMethods
  # enable versioning for specific blocks (at class-level)
  def with_versioning(&block); end
end

# Included in the RSpec configuration in `frameworks/rspec.rb`
module PaperTrail::RSpec::Helpers::InstanceMethods
  # enable versioning for specific blocks (at instance-level)
  def with_versioning; end
end

# Represents code to load within Rails framework. See documentation in
# `railties/lib/rails/railtie.rb`.
#
# @api private
class PaperTrail::Railtie < ::Rails::Railtie; end

# Represents the history of a single record.
#
# @api private
class PaperTrail::RecordHistory
  # @api private
  # @param versions - ActiveRecord::Relation - All versions of the record.
  # @param version_class - Class - Usually PaperTrail::Version,
  #   but it could also be a custom version class.
  # @return [RecordHistory] a new instance of RecordHistory
  def initialize(versions, version_class); end

  # Returns ordinal position of `version` in `sequence`.
  #
  # @api private
  def index(version); end

  private

  # @api private
  # @return - Arel::Attribute - Attribute representing the primary key
  #   of the version table. The column's data type is usually a serial
  #   integer (the rails convention) but not always.
  def primary_key; end

  # Returns `@versions` in chronological order.
  #
  # @api private
  def sequence; end

  # @api private
  # @return - Arel::Table - The version table, usually named `versions`, but
  #   not always.
  def table; end
end

# Represents the "paper trail" for a single record.
class PaperTrail::RecordTrail
  # @return [RecordTrail] a new instance of RecordTrail
  def initialize(record); end

  # Invoked after rollbacks to ensure versions records are not created for
  # changes that never actually took place. Optimization: Use lazy `reset`
  # instead of eager `reload` because, in many use cases, the association will
  # not be used.
  def clear_rolled_back_versions; end

  # Invoked via`after_update` callback for when a previous version is
  # reified and then saved.
  def clear_version_instance; end

  # Returns true if this instance is the current, live one;
  # returns false if this instance came from a previous version.
  #
  # @return [Boolean]
  def live?; end

  # Returns the object (not a Version) as it became next.
  # NOTE: if self (the item) was not reified from a version, i.e. it is the
  #  "live" item, we return nil.  Perhaps we should return self instead?
  def next_version; end

  # Returns who put `@record` into its current state.
  #
  # @api public
  def originator; end

  # Returns the object (not a Version) as it was most recently.
  #
  # @api public
  def previous_version; end

  def record_create; end

  # `recording_order` is "after" or "before". See ModelConfig#on_destroy.
  #
  # paper_trail-association_tracking
  #
  # @api private
  # @return - The created version object, so that plugins can use it, e.g.
  def record_destroy(recording_order); end

  # paper_trail-association_tracking
  #
  # @api private
  # @param force [boolean] Insert a `Version` even if `@record` has not
  #   `changed_notably?`.
  # @param in_after_callback [boolean] True when called from an `after_update`
  #   or `after_touch` callback.
  # @param is_touch [boolean] True when called from an `after_touch` callback.
  # @return - The created version object, so that plugins can use it, e.g.
  def record_update(force:, in_after_callback:, is_touch:); end

  # Invoked via callback when a user attempts to persist a reified
  # `Version`.
  def reset_timestamp_attrs_for_update_if_needed; end

  # AR callback.
  #
  # @api private
  # @return [Boolean]
  def save_version?; end

  # Save, and create a version record regardless of options such as `:on`,
  # `:if`, or `:unless`.
  #
  # `in_after_callback`: Indicates if this method is being called within an
  #                      `after` callback. Defaults to `false`.
  # `options`: Optional arguments passed to `save`.
  #
  # This is an "update" event. That is, we record the same data we would in
  # the case of a normal AR `update`.
  def save_with_version(in_after_callback: T.unsafe(nil), **options); end

  def source_version; end

  # Like the `update_column` method from `ActiveRecord::Persistence`, but also
  # creates a version to record those changes.
  #
  # @api public
  def update_column(name, value); end

  # Like the `update_columns` method from `ActiveRecord::Persistence`, but also
  # creates a version to record those changes.
  #
  # @api public
  def update_columns(attributes); end

  # Returns the object (not a Version) as it was at the given timestamp.
  def version_at(timestamp, reify_options = T.unsafe(nil)); end

  # Returns the objects (not Versions) as they were between the given times.
  def versions_between(start_time, end_time); end

  private

  # @api private
  def assign_and_reset_version_association(version); end

  # @api private
  def build_version_on_create(in_after_callback:); end

  # @api private
  def build_version_on_update(force:, in_after_callback:, is_touch:); end

  # PT-AT extends this method to add its transaction id.
  #
  # @api public
  def data_for_create; end

  # PT-AT extends this method to add its transaction id.
  #
  # @api public
  def data_for_destroy; end

  # PT-AT extends this method to add its transaction id.
  #
  # @api public
  def data_for_update; end

  # PT-AT extends this method to add its transaction id.
  #
  # @api public
  def data_for_update_columns; end

  # Is PT enabled for this particular record?
  #
  # @api private
  # @return [Boolean]
  def enabled?; end

  def log_version_errors(version, action); end

  # paper_trail-association_tracking
  #
  # @api private
  # @return - The created version object, so that plugins can use it, e.g.
  def record_update_columns(changes); end

  def version; end
  def versions; end
end

# Given a version record and some options, builds a new model object.
#
# @api private
module PaperTrail::Reifier
  class << self
    # See `VersionConcern#reify` for documentation.
    #
    # @api private
    def reify(version, options); end

    private

    # Given a hash of `options` for `.reify`, return a new hash with default
    # values applied.
    #
    # @api private
    def apply_defaults_to(options, version); end

    # Initialize a model object suitable for reifying `version` into. Does
    # not perform reification, merely instantiates the appropriate model
    # class and, if specified by `options[:unversioned_attributes]`, sets
    # unversioned attributes to `nil`.
    #
    # Normally a polymorphic belongs_to relationship allows us to get the
    # object we belong to by calling, in this case, `item`.  However this
    # returns nil if `item` has been destroyed, and we need to be able to
    # retrieve destroyed objects.
    #
    # In this situation we constantize the `item_type` to get hold of the
    # class...except when the stored object's attributes include a `type`
    # key.  If this is the case, the object we belong to is using single
    # table inheritance (STI) and the `item_type` will be the base class,
    # not the actual subclass. If `type` is present but empty, the class is
    # the base class.
    #
    # @api private
    def init_model(attrs, options, version); end

    # @api private
    def init_model_by_finding_item_id(klass, version); end

    # Look for attributes that exist in `model` and not in this version.
    # These attributes should be set to nil. Modifies `attrs`.
    #
    # @api private
    def init_unversioned_attrs(attrs, model); end

    # Reify onto `model` an attribute named `k` with value `v` from `version`.
    #
    # `ObjectAttribute#deserialize` will return the mapped enum value and in
    # Rails < 5, the []= uses the integer type caster from the column
    # definition (in general) and thus will turn a (usually) string to 0
    # instead of the correct value.
    #
    # @api private
    def reify_attribute(k, v, model, version); end

    # Reify onto `model` all the attributes of `version`.
    #
    # @api private
    def reify_attributes(model, version, attrs); end

    # Given a `version`, return the class to reify. This method supports
    # Single Table Inheritance (STI) with custom inheritance columns and
    # custom inheritance column values.
    #
    # For example, imagine a `version` whose `item_type` is "Animal". The
    # `animals` table is an STI table (it has cats and dogs) and it has a
    # custom inheritance column, `species`. If `attrs["species"]` is "Dog",
    # this method returns the constant `Dog`. If `attrs["species"]` is blank,
    # this method returns the constant `Animal`.
    #
    # The values contained in the inheritance columns may be non-camelized
    # strings (e.g. 'dog' instead of 'Dog'). To reify classes in this case
    # we need to call the parents class `sti_class_for` method to retrieve
    # the correct record class.
    #
    # You can see these particular examples in action in
    # `spec/models/animal_spec.rb` and `spec/models/plant_spec.rb`
    #
    # @api private
    def version_reification_class(version, attrs); end
  end
end

# Manages variables that affect the current HTTP request, such as `whodunnit`.
#
# Please do not use `PaperTrail::Request` directly, use `PaperTrail.request`.
# Currently, `Request` is a `Module`, but in the future it is quite possible
# we may make it a `Class`. If we make such a choice, we will not provide any
# warning and will not treat it as a breaking change. You've been warned :)
#
# @api private
module PaperTrail::Request
  class << self
    # Returns the data from the controller that you want PaperTrail to store.
    # See also `PaperTrail::Rails::Controller#info_for_paper_trail`.
    #
    #   PaperTrail.request.controller_info = { ip: request_user_ip }
    #   PaperTrail.request.controller_info # => { ip: '127.0.0.1' }
    #
    # @api public
    def controller_info; end

    # Sets any data from the controller that you want PaperTrail to store.
    # See also `PaperTrail::Rails::Controller#info_for_paper_trail`.
    #
    #   PaperTrail.request.controller_info = { ip: request_user_ip }
    #   PaperTrail.request.controller_info # => { ip: '127.0.0.1' }
    #
    # @api public
    def controller_info=(value); end

    # Switches PaperTrail off for the given model.
    #
    # @api public
    def disable_model(model_class); end

    # Switches PaperTrail on for the given model.
    #
    # @api public
    def enable_model(model_class); end

    # Sets whether PaperTrail is enabled or disabled for the current request.
    #
    # @api public
    def enabled=(value); end

    # Returns `true` if PaperTrail is enabled for the request, `false` otherwise.
    # See `PaperTrail::Rails::Controller#paper_trail_enabled_for_controller`.
    #
    # @api public
    # @return [Boolean]
    def enabled?; end

    # Sets whether PaperTrail is enabled or disabled for this model in the
    # current request.
    #
    # @api public
    def enabled_for_model(model, value); end

    # Returns `true` if PaperTrail is enabled for this model in the current
    # request, `false` otherwise.
    #
    # @api public
    # @return [Boolean]
    def enabled_for_model?(model); end

    # Returns who is reponsible for any changes that occur during request.
    #
    # @api public
    def whodunnit; end

    # Sets who is responsible for any changes that occur during request. You
    # would normally use this in a migration or on the console, when working
    # with models directly.
    #
    # `value` is usually a string, the name of a person, but you can set
    # anything that responds to `to_s`. You can also set a Proc, which will
    # not be evaluated until `whodunnit` is called later, usually right before
    # inserting a `Version` record.
    #
    # @api public
    def whodunnit=(value); end

    # Temporarily set `options` and execute a block.
    #
    # @api private
    def with(options); end

    private

    # @api private
    def merge(options); end

    # @api private
    def set(options); end

    # Returns a Hash, initializing with default values if necessary.
    #
    # @api private
    def store; end

    # Returns a deep copy of the internal hash from our RequestStore. Keys are
    # all symbols. Values are mostly primitives, but whodunnit can be a Proc.
    # We cannot use Marshal.dump here because it doesn't support Proc. It is
    # unclear exactly how `deep_dup` handles a Proc, but it doesn't complain.
    #
    # @api private
    def to_h; end

    # Provide a helpful error message if someone has a typo in one of their
    # option keys. We don't validate option values here. That's traditionally
    # been handled with casting (`to_s`, `!!`) in the accessor method.
    #
    # @api private
    def validate_public_options(options); end
  end
end

module PaperTrail::Serializers; end

# An alternate serializer for, e.g. `versions.object`.
module PaperTrail::Serializers::JSON
  extend ::PaperTrail::Serializers::JSON

  def dump(object); end
  def load(string); end

  # Returns a SQL LIKE condition to be used to match the given field and
  # value in the serialized object.
  def where_object_condition(arel_field, field, value); end
end

# The default serializer for, e.g. `versions.object`.
module PaperTrail::Serializers::YAML
  extend ::PaperTrail::Serializers::YAML

  # `recordable_object` `object` will be a plain `Hash`. However, due to
  # recent [memory optimizations](https://github.com/paper-trail-gem/paper_trail/pull/1189),
  # when coming from `recordable_object_changes`, it will be a `HashWithIndifferentAccess`.
  #
  # @param object [Hash | HashWithIndifferentAccess] - Coming from
  def dump(object); end

  def load(string); end

  # Returns a SQL LIKE condition to be used to match the given field and
  # value in the serialized object.
  def where_object_condition(arel_field, field, value); end

  private

  # @return [Boolean]
  def use_safe_load?; end

  def yaml_column_permitted_classes; end
end

module PaperTrail::TypeSerializers; end

# Provides an alternative method of serialization
# and deserialization of PostgreSQL array columns.
class PaperTrail::TypeSerializers::PostgresArraySerializer
  # @return [PostgresArraySerializer] a new instance of PostgresArraySerializer
  def initialize(subtype, delimiter); end

  def deserialize(array); end
  def serialize(array); end

  private

  def deserialize_with_ar(array); end
end

# The application's database column type is not supported.
#
# @api public
class PaperTrail::UnsupportedColumnType < ::PaperTrail::UnsupportedSchema
  # @api public
  # @return [UnsupportedColumnType] a new instance of UnsupportedColumnType
  def initialize(method:, expected:, actual:); end
end

# The application's database schema is not supported.
#
# @api public
class PaperTrail::UnsupportedSchema < ::PaperTrail::Error; end

# The version number of the paper_trail gem. Not to be confused with
# `PaperTrail::Version`. Ruby constants are case-sensitive, apparently,
# and they are two different modules! It would be nice to remove `VERSION`,
# because of this confusion, but it's not worth the breaking change.
# People are encouraged to use `PaperTrail.gem_version` instead.
module PaperTrail::VERSION
  class << self
    def to_s; end
  end
end

PaperTrail::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
PaperTrail::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# Set PRE to nil unless it's a pre-release (beta, rc, etc.)
PaperTrail::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

PaperTrail::VERSION::STRING = T.let(T.unsafe(nil), String)
PaperTrail::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# This is the default ActiveRecord model provided by PaperTrail. Most simple
# applications will use this model as-is, but it is possible to sub-class,
# extend, or even do without this model entirely. See documentation section
# 6.a. Custom Version Classes.
#
# The paper_trail-association_tracking gem provides a related model,
# `VersionAssociation`.
class PaperTrail::Version < ::ActiveRecord::Base
  include ::PaperTrail::Version::GeneratedAttributeMethods
  include ::PaperTrail::Version::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  include ::PaperTrail::VersionConcern
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  extend ::PaperTrail::VersionConcern::ClassMethods

  def autosave_associated_records_for_item(*args); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def defined_enums; end
    def page(num = T.unsafe(nil)); end
  end
end

module PaperTrail::Version::GeneratedAssociationMethods
  def item; end
  def item=(value); end
  def item_changed?; end
  def item_previously_changed?; end
  def reload_item; end
end

module PaperTrail::Version::GeneratedAttributeMethods; end

# Originally, PaperTrail did not provide this module, and all of this
# functionality was in `PaperTrail::Version`. That model still exists (and is
# used by most apps) but by moving the functionality to this module, people
# can include this concern instead of sub-classing the `Version` model.
module PaperTrail::VersionConcern
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::PaperTrail::VersionConcern::ClassMethods

  # Returns what changed in this version of the item.
  # `ActiveModel::Dirty#changes`. returns `nil` if your `versions` table does
  # not have an `object_changes` text column.
  def changeset; end

  # Returns an integer representing the chronological position of the
  # version among its siblings. The "create" event, for example, has an index
  # of 0.
  #
  # @api public
  def index; end

  def next; end

  # @api private
  def object_deserialized; end

  # Returns who put the item into the state stored in this version.
  def paper_trail_originator; end

  def previous; end

  # Restore the item from this version.
  #
  # Options:
  #
  # - :mark_for_destruction
  #   - `true` - Mark the has_one/has_many associations that did not exist in
  #     the reified version for destruction, instead of removing them.
  #   - `false` - Default. Useful for persisting the reified version.
  # - :dup
  #   - `false` - Default.
  #   - `true` - Always create a new object instance. Useful for
  #     comparing two versions of the same object.
  # - :unversioned_attributes
  #   - `:nil` - Default. Attributes undefined in version record are set to
  #     nil in reified record.
  #   - `:preserve` - Attributes undefined in version record are not modified.
  def reify(options = T.unsafe(nil)); end

  # Returns who changed the item from the state it had in this version. This
  # is an alias for `whodunnit`.
  def terminator; end

  # Returns who changed the item from the state it had in this version. This
  # is an alias for `whodunnit`.
  def version_author; end

  private

  # @return [Boolean]
  def base_class_limit_option?(klass); end

  # Enforces the `version_limit`, if set. Default: no limit.
  #
  # @api private
  def enforce_version_limit!; end

  # @return [Boolean]
  def limit_option?(klass); end

  # @api private
  def load_changeset; end

  # If the `object_changes` column is a Postgres JSON column, then
  # ActiveRecord will deserialize it for us. Otherwise, it's a string column
  # and we must deserialize it ourselves.
  #
  # @api private
  def object_changes_deserialized; end

  # @api private
  def sibling_versions; end

  # See docs section 2.e. Limiting the Number of Versions Created.
  # The version limit can be global or per-model.
  #
  # @api private
  def version_limit; end
end

module PaperTrail::VersionConcern::ClassMethods
  def between(start_time, end_time); end
  def creates; end
  def destroys; end
  def not_creates; end

  # Returns whether the `object_changes` column is using the `json` type
  # supported by PostgreSQL.
  #
  # @return [Boolean]
  def object_changes_col_is_json?; end

  # Returns whether the `object` column is using the `json` type supported
  # by PostgreSQL.
  #
  # @return [Boolean]
  def object_col_is_json?; end

  # Returns versions before `obj`.
  #
  #
  # @api public
  # @param obj - a `Version` or a timestamp
  # @param timestamp_arg - boolean - When true, `obj` is a timestamp.
  #   Default: false.
  # @return `ActiveRecord::Relation`
  def preceding(obj, timestamp_arg = T.unsafe(nil)); end

  # @return [Boolean]
  def primary_key_is_int?; end

  # Returns versions after `obj`.
  #
  #
  # @api public
  # @param obj - a `Version` or a timestamp
  # @param timestamp_arg - boolean - When true, `obj` is a timestamp.
  #   Default: false.
  # @return `ActiveRecord::Relation`
  def subsequent(obj, timestamp_arg = T.unsafe(nil)); end

  # Defaults to using the primary key as the secondary sort order if
  # possible.
  def timestamp_sort_order(direction = T.unsafe(nil)); end

  def updates; end

  # Given an attribute like `"name"`, query the `versions.object_changes`
  # column for any changes that modified the provided attribute.
  #
  # @api public
  def where_attribute_changes(attribute); end

  # Given a hash of attributes like `name: 'Joan'`, query the
  # `versions.objects` column.
  #
  # ```
  # SELECT "versions".*
  # FROM "versions"
  # WHERE ("versions"."object" LIKE '%
  # name: Joan
  # %')
  # ```
  #
  # This is useful for finding versions where a given attribute had a given
  # value. Imagine, in the example above, that Joan had changed her name
  # and we wanted to find the versions before that change.
  #
  # Based on the data type of the `object` column, the appropriate SQL
  # operator is used. For example, a text column will use `like`, and a
  # jsonb column will use `@>`.
  #
  # @api public
  # @raise [ArgumentError]
  def where_object(args = T.unsafe(nil)); end

  # Given a hash of attributes like `name: 'Joan'`, query the
  # `versions.objects_changes` column.
  #
  # ```
  # SELECT "versions".*
  # FROM "versions"
  # WHERE .. ("versions"."object_changes" LIKE '%
  # name:
  # - Joan
  # %' OR "versions"."object_changes" LIKE '%
  # name:
  # -%
  # - Joan
  # %')
  # ```
  #
  # This is useful for finding versions immediately before and after a given
  # attribute had a given value. Imagine, in the example above, that someone
  # changed their name to Joan and we wanted to find the versions
  # immediately before and after that change.
  #
  # Based on the data type of the `object` column, the appropriate SQL
  # operator is used. For example, a text column will use `like`, and a
  # jsonb column will use `@>`.
  #
  # @api public
  # @raise [ArgumentError]
  def where_object_changes(args = T.unsafe(nil)); end

  # Given a hash of attributes like `name: 'Joan'`, query the
  # `versions.objects_changes` column for changes where the version changed
  # from the hash of attributes to other values.
  #
  # This is useful for finding versions where the attribute started with a
  # known value and changed to something else. This is in comparison to
  # `where_object_changes` which will find both the changes before and
  # after.
  #
  # @api public
  # @raise [ArgumentError]
  def where_object_changes_from(args = T.unsafe(nil)); end

  # Given a hash of attributes like `name: 'Joan'`, query the
  # `versions.objects_changes` column for changes where the version changed
  # to the hash of attributes from other values.
  #
  # This is useful for finding versions where the attribute started with an
  # unknown value and changed to a known value. This is in comparison to
  # `where_object_changes` which will find both the changes before and
  # after.
  #
  # @api public
  # @raise [ArgumentError]
  def where_object_changes_to(args = T.unsafe(nil)); end

  def with_item_keys(item_type, item_id); end

  private

  # @api private
  def preceding_by_id(obj); end

  # @api private
  def preceding_by_timestamp(obj); end

  # @api private
  def subsequent_by_id(version); end

  # @api private
  def subsequent_by_timestamp(obj); end
end

PaperTrail::VersionConcern::E_YAML_PERMITTED_CLASSES = T.let(T.unsafe(nil), String)
