# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_storage_validations` gem.
# Please instead update this file by running `bin/tapioca gem active_storage_validations`.

# Big thank you to the paperclip validation matchers:
# https://github.com/thoughtbot/paperclip/blob/v6.1.0/lib/paperclip/matchers/validate_attachment_size_matcher.rb
module ActiveStorageValidations; end

# :nodoc
class ActiveStorageValidations::AspectRatioValidator < ::ActiveModel::EachValidator
  # @return [AspectRatioValidator] a new instance of AspectRatioValidator
  def initialize(options); end

  # @raise [ArgumentError]
  def check_validity!; end

  # Rails 5
  def validate_each(record, attribute, _value); end

  private

  def add_error(record, attribute, type, interpolate = T.unsafe(nil)); end

  # @return [Boolean]
  def is_valid?(record, attribute, metadata); end
end

ActiveStorageValidations::AspectRatioValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::AspectRatioValidator::PRECISION = T.let(T.unsafe(nil), Integer)

class ActiveStorageValidations::AttachedValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, _value); end
end

class ActiveStorageValidations::ContentTypeValidator < ::ActiveModel::EachValidator
  def content_type(file); end

  # @return [Boolean]
  def is_valid?(file); end

  def types; end
  def types_to_human_format; end
  def validate_each(record, attribute, _value); end
end

# :nodoc
class ActiveStorageValidations::DimensionValidator < ::ActiveModel::EachValidator
  # @return [DimensionValidator] a new instance of DimensionValidator
  def initialize(options); end

  def add_error(record, attribute, type, **attrs); end

  # @raise [ArgumentError]
  def check_validity!; end

  # @return [Boolean]
  def is_valid?(record, attribute, file_metadata); end

  # Rails 5
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::DimensionValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
class ActiveStorageValidations::Engine < ::Rails::Engine; end

class ActiveStorageValidations::LimitValidator < ::ActiveModel::EachValidator
  # @raise [ArgumentError]
  def check_validity!; end

  # @return [Boolean]
  def files_count_valid?(count); end

  def validate_each(record, attribute, _); end
end

ActiveStorageValidations::LimitValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

module ActiveStorageValidations::Matchers
  def validate_attached_of(name); end
  def validate_content_type_of(name); end
  def validate_dimensions_of(name); end
  def validate_size_of(name); end

  class << self
    def mock_metadata(attachment, width, height); end

    # Helper to stub a method with either RSpec or Minitest (whatever is available)
    def stub_method(object, method, result); end
  end
end

class ActiveStorageValidations::Matchers::AttachedValidatorMatcher
  # @return [AttachedValidatorMatcher] a new instance of AttachedValidatorMatcher
  def initialize(attribute_name); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(subject); end

  private

  def attachable; end
  def invalid_when_not_attached; end
  def responds_to_methods; end
  def valid_when_attached; end
end

class ActiveStorageValidations::Matchers::ContentTypeValidatorMatcher
  # @return [ContentTypeValidatorMatcher] a new instance of ContentTypeValidatorMatcher
  def initialize(attribute_name); end

  def allowing(*types); end
  def description; end
  def failure_message; end

  # @return [Boolean]
  def matches?(subject); end

  def rejecting(*types); end

  protected

  def accepted_types_and_failures; end
  def allowed_types; end

  # @return [Boolean]
  def allowed_types_allowed?; end

  def attachment_for(type); end
  def rejected_types; end
  def rejected_types_and_failures; end

  # @return [Boolean]
  def rejected_types_rejected?; end

  def responds_to_methods; end

  # @return [Boolean]
  def type_allowed?(type); end

  private

  def content_type_keys; end
end

class ActiveStorageValidations::Matchers::DimensionValidatorMatcher
  # @return [DimensionValidatorMatcher] a new instance of DimensionValidatorMatcher
  def initialize(attribute_name); end

  def description; end
  def failure_message; end
  def height(height); end
  def height_between(range); end
  def height_max(height); end
  def height_min(height); end

  # @return [Boolean]
  def matches?(subject); end

  def width(width); end
  def width_between(range); end
  def width_max(width); end
  def width_min(width); end
  def with_message(message); end

  protected

  def attachment_for(width, height); end

  # @return [Boolean]
  def height_equals?; end

  # @return [Boolean]
  def height_larger_than_max?; end

  # @return [Boolean]
  def height_larger_than_min?; end

  # @return [Boolean]
  def height_smaller_than_max?; end

  # @return [Boolean]
  def height_smaller_than_min?; end

  def passes_validation_with_dimensions(width, height, check); end
  def responds_to_methods; end
  def valid_height; end
  def valid_width; end

  # @return [Boolean]
  def width_equals?; end

  # @return [Boolean]
  def width_larger_than_max?; end

  # @return [Boolean]
  def width_larger_than_min?; end

  # @return [Boolean]
  def width_smaller_than_max?; end

  # @return [Boolean]
  def width_smaller_than_min?; end
end

class ActiveStorageValidations::Matchers::SizeValidatorMatcher
  # @return [SizeValidatorMatcher] a new instance of SizeValidatorMatcher
  def initialize(attribute_name); end

  def between(range); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def greater_than(size); end
  def greater_than_or_equal_to(size); end
  def less_than(size); end
  def less_than_or_equal_to(size); end

  # @return [Boolean]
  def matches?(subject); end

  protected

  # @return [Boolean]
  def higher_than_high?; end

  # @return [Boolean]
  def higher_than_low?; end

  # @return [Boolean]
  def lower_than_high?; end

  # @return [Boolean]
  def lower_than_low?; end

  def passes_validation_with_size(new_size); end
  def responds_to_methods; end
end

class ActiveStorageValidations::Metadata
  # @return [Metadata] a new instance of Metadata
  def initialize(file); end

  def exception_class; end

  # Returns the value of attribute file.
  def file; end

  def image_processor; end
  def metadata; end
  def require_image_processor; end

  private

  def logger; end
  def read_file_path; end
  def read_image; end

  # @return [Boolean]
  def rotated_image?(image); end

  # @return [Boolean]
  def valid_image?(image); end
end

class ActiveStorageValidations::Railtie < ::Rails::Railtie; end

class ActiveStorageValidations::SizeValidator < ::ActiveModel::EachValidator
  # @raise [ArgumentError]
  def check_validity!; end

  # @return [Boolean]
  def content_size_valid?(file_size); end

  def max_size; end
  def min_size; end
  def number_to_human_size(*_arg0, &_arg1); end
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::SizeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
