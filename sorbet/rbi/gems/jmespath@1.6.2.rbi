# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `jmespath` gem.
# Please instead update this file by running `bin/tapioca gem jmespath`.

module JMESPath
  class << self
    # @api private
    def load_json(path); end

    # @param expression [String] A valid
    #   [JMESPath](https://github.com/boto/jmespath) expression.
    # @param data [Hash]
    # @return [Mixed, nil] Returns the matched values. Returns `nil` if the
    #   expression does not resolve inside `data`.
    def search(expression, data, runtime_options = T.unsafe(nil)); end
  end
end

class JMESPath::CachingParser
  # @return [CachingParser] a new instance of CachingParser
  def initialize(options = T.unsafe(nil)); end

  def parse(expression); end

  private

  def cache_expression(expression); end
end

module JMESPath::Errors; end
class JMESPath::Errors::Error < ::StandardError; end
class JMESPath::Errors::InvalidArityError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::InvalidTypeError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::InvalidValueError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::RuntimeError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::SyntaxError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::UnknownFunctionError < ::JMESPath::Errors::Error; end

# @api private
class JMESPath::Lexer
  # @api private
  # @param expression [String<JMESPath>]
  # @return [Array<Hash>]
  def tokenize(expression); end

  private

  # @api private
  def inside(chars, delim, type); end

  # @api private
  def match_or(chars, current, expected, type, or_type); end

  # @api private
  def parse_json(token, quoted = T.unsafe(nil)); end

  class << self
    # Certain versions of Ruby and of the pure_json gem not support loading
    # scalar JSON values, such a numbers, booleans, strings, etc. These
    # simple values must be first wrapped inside a JSON object before calling
    # `JSON.parse`.
    #
    #    # works in most JSON versions, raises in some versions
    #    JSON.parse("true")
    #    JSON.parse("123")
    #    JSON.parse("\"abc\"")
    #
    # This is an known issue for:
    #
    # * Ruby 1.9.3 bundled v1.5.5 of json; Ruby 1.9.3 defaults to bundled
    #   version despite newer versions being available.
    #
    # * json_pure v2.0.0+
    #
    # It is not possible to change the version of JSON loaded in the
    # user's application. Adding an explicit dependency on json gem
    # causes issues in environments that cannot compile the gem. We previously
    # had a direct dependency on `json_pure`, but this broke with the v2 update.
    #
    # This method allows us to detect how the `JSON.parse` behaves so we know
    # if we have to wrap scalar JSON values to parse them or not.
    #
    # @api private
    # @return [Boolean]
    def requires_wrapping?; end
  end
end

# @api private
class JMESPath::Lexer::CharacterStream
  # @api private
  # @return [CharacterStream] a new instance of CharacterStream
  def initialize(chars); end

  # @api private
  def current; end

  # @api private
  def next; end

  # @api private
  def position; end
end

# @api private
JMESPath::Lexer::NUMBERS = T.let(T.unsafe(nil), Set)

# @api private
JMESPath::Lexer::SIMPLE_TOKENS = T.let(T.unsafe(nil), Hash)

# @api private
JMESPath::Lexer::STATE_AND = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_EQ = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_GT = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_IDENTIFIER = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_JSON_LITERAL = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_LBRACKET = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_LT = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_NOT = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_NUMBER = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_PIPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_QUOTED_STRING = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_SINGLE_CHAR = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_STRING_LITERAL = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::STATE_WHITESPACE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Lexer::TRANSLATION_TABLE = T.let(T.unsafe(nil), Hash)

# @api private
JMESPath::Lexer::T_AND = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_COLON = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_COMMA = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_COMPARATOR = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_CURRENT = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_DOT = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_EOF = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_EXPREF = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_FILTER = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_FLATTEN = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_IDENTIFIER = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_LBRACE = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_LBRACKET = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_LITERAL = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_LPAREN = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_NOT = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_NUMBER = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_OR = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_PIPE = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_QUOTED_IDENTIFIER = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_RBRACE = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_RBRACKET = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_RPAREN = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_STAR = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::T_UNKNOWN = T.let(T.unsafe(nil), Symbol)

# @api private
JMESPath::Lexer::VALID_IDENTIFIERS = T.let(T.unsafe(nil), Set)

# @api private
module JMESPath::Nodes; end

# @api private
class JMESPath::Nodes::AbsFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

class JMESPath::Nodes::And < ::JMESPath::Nodes::Node
  # @return [And] a new instance of And
  def initialize(left, right); end

  def optimize; end
  def visit(value); end
end

# @api private
class JMESPath::Nodes::ArrayProjection < ::JMESPath::Nodes::Projection
  # @api private
  def extract_targets(target); end

  # @api private
  def fast_instance; end
end

# @api private
class JMESPath::Nodes::AvgFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::CeilFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::Chain
  # @api private
  # @return [Chain] a new instance of Chain
  def initialize(children); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::ChainedField < ::JMESPath::Nodes::Field
  # @api private
  # @return [ChainedField] a new instance of ChainedField
  def initialize(keys); end

  # @api private
  def chain(other); end

  # @api private
  def visit(obj); end

  private

  # @api private
  def keys; end
end

# @api private
class JMESPath::Nodes::Comparator < ::JMESPath::Nodes::Node
  # @api private
  # @return [Comparator] a new instance of Comparator
  def initialize(left, right); end

  # @api private
  def left; end

  # @api private
  def optimize; end

  # @api private
  def right; end

  # @api private
  def visit(value); end

  private

  # @api private
  def check(_left_value, _right_value); end

  # @api private
  # @return [Boolean]
  def comparable?(left_value, right_value); end

  class << self
    # @api private
    def create(relation, left, right); end
  end
end

# @api private
JMESPath::Nodes::Comparator::COMPARABLE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
class JMESPath::Nodes::ComparatorCondition < ::JMESPath::Nodes::Node
  # @api private
  # @return [ComparatorCondition] a new instance of ComparatorCondition
  def initialize(left, right, child); end

  # @api private
  def visit(_value); end

  private

  # @api private
  # @return [Boolean]
  def comparable?(left_value, right_value); end
end

# @api private
JMESPath::Nodes::ComparatorCondition::COMPARABLE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
JMESPath::Nodes::ComparatorCondition::COMPARATOR_TO_CONDITION = T.let(T.unsafe(nil), Hash)

# @api private
module JMESPath::Nodes::Comparators; end

# @api private
class JMESPath::Nodes::Comparators::Eq < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
class JMESPath::Nodes::Comparators::Gt < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
class JMESPath::Nodes::Comparators::Gte < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
class JMESPath::Nodes::Comparators::Lt < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
class JMESPath::Nodes::Comparators::Lte < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
class JMESPath::Nodes::Comparators::Neq < ::JMESPath::Nodes::Comparator
  # @api private
  def check(left_value, right_value); end
end

# @api private
module JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def compare_by(mode, *args); end
end

# @api private
class JMESPath::Nodes::Condition < ::JMESPath::Nodes::Node
  # @api private
  # @return [Condition] a new instance of Condition
  def initialize(test, child); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::ContainsFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::Current < ::JMESPath::Nodes::Node
  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::EndsWithFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::EqCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Expression < ::JMESPath::Nodes::Node
  # @api private
  # @return [Expression] a new instance of Expression
  def initialize(expression); end

  # @api private
  def eval(value); end

  # @api private
  def expression; end

  # @api private
  def optimize; end

  # @api private
  def visit(_value); end
end

# @api private
class JMESPath::Nodes::FastArrayProjection < ::JMESPath::Nodes::ArrayProjection
  include ::JMESPath::Nodes::FastProjector
end

# @api private
class JMESPath::Nodes::FastObjectProjection < ::JMESPath::Nodes::ObjectProjection
  include ::JMESPath::Nodes::FastProjector
end

# @api private
module JMESPath::Nodes::FastProjector
  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Field < ::JMESPath::Nodes::Node
  # @api private
  # @return [Field] a new instance of Field
  def initialize(key); end

  # @api private
  def chain(other); end

  # @api private
  # @return [Boolean]
  def chains_with?(other); end

  # @api private
  def visit(value); end

  protected

  # @api private
  def keys; end
end

# @api private
class JMESPath::Nodes::Flatten < ::JMESPath::Nodes::Node
  # @api private
  # @return [Flatten] a new instance of Flatten
  def initialize(child); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::FloorFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::Function < ::JMESPath::Nodes::Node
  # @api private
  # @return [Function] a new instance of Function
  def initialize(children, options = T.unsafe(nil)); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end

  private

  # @api private
  def call(_args); end

  # @api private
  # @raise [error_type]
  def maybe_raise(error_type, message); end

  class << self
    # @api private
    def create(name, children, options = T.unsafe(nil)); end
  end
end

# @api private
JMESPath::Nodes::Function::FUNCTIONS = T.let(T.unsafe(nil), Hash)

# @api private
class JMESPath::Nodes::Function::FunctionName
  # @api private
  # @return [FunctionName] a new instance of FunctionName
  def initialize(name); end

  # @api private
  def name; end
end

# @api private
class JMESPath::Nodes::GtCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::GteCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def visit(value); end
end

# @api private
JMESPath::Nodes::Index = JMESPath::Nodes::Field

# @api private
class JMESPath::Nodes::JoinFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::KeysFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::LengthFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::Literal < ::JMESPath::Nodes::Node
  # @api private
  # @return [Literal] a new instance of Literal
  def initialize(value); end

  # @api private
  def value; end

  # @api private
  def visit(_value); end
end

# @api private
class JMESPath::Nodes::LiteralRightEqCondition < ::JMESPath::Nodes::EqCondition
  # @api private
  # @return [LiteralRightEqCondition] a new instance of LiteralRightEqCondition
  def initialize(left, right, child); end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::LiteralRightNeqCondition < ::JMESPath::Nodes::NeqCondition
  # @api private
  # @return [LiteralRightNeqCondition] a new instance of LiteralRightNeqCondition
  def initialize(left, right, child); end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::LtCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::LteCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Map < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MaxByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker
  include ::JMESPath::Nodes::CompareBy

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MaxFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MergeFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MinByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker
  include ::JMESPath::Nodes::CompareBy

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MinFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::MultiSelectHash < ::JMESPath::Nodes::Node
  # @api private
  # @return [MultiSelectHash] a new instance of MultiSelectHash
  def initialize(kv_pairs); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::MultiSelectHash::KeyValuePair
  # @api private
  # @return [KeyValuePair] a new instance of KeyValuePair
  def initialize(key, value); end

  # @api private
  def key; end

  # @api private
  def optimize; end

  # @api private
  def value; end
end

# @api private
class JMESPath::Nodes::MultiSelectList < ::JMESPath::Nodes::Node
  # @api private
  # @return [MultiSelectList] a new instance of MultiSelectList
  def initialize(children); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::NeqCondition < ::JMESPath::Nodes::ComparatorCondition
  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Node
  # @api private
  # @return [Boolean]
  def chains_with?(_other); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Not < ::JMESPath::Nodes::Node
  # @api private
  # @return [Not] a new instance of Not
  def initialize(expression); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::NotNullFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::ObjectProjection < ::JMESPath::Nodes::Projection
  # @api private
  def extract_targets(target); end

  # @api private
  def fast_instance; end
end

# @api private
class JMESPath::Nodes::Or < ::JMESPath::Nodes::Node
  # @api private
  # @return [Or] a new instance of Or
  def initialize(left, right); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end
end

# @api private
JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

# @api private
class JMESPath::Nodes::Projection < ::JMESPath::Nodes::Node
  # @api private
  # @return [Projection] a new instance of Projection
  def initialize(target, projection); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end

  private

  # @api private
  def extract_targets(_left_value); end
end

# @api private
class JMESPath::Nodes::ReverseFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::SimpleSlice < ::JMESPath::Nodes::Slice
  # @api private
  # @return [SimpleSlice] a new instance of SimpleSlice
  def initialize(start, stop); end

  # @api private
  def visit(value); end
end

# @api private
class JMESPath::Nodes::Slice < ::JMESPath::Nodes::Node
  # @api private
  # @raise [Errors::InvalidValueError]
  # @return [Slice] a new instance of Slice
  def initialize(start, stop, step); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end

  private

  # @api private
  def adjust_endpoint(length, endpoint, step); end

  # @api private
  def adjust_slice(length, start, stop, step); end
end

# @api private
class JMESPath::Nodes::SortByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::SortFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::StartsWithFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::Subexpression < ::JMESPath::Nodes::Node
  # @api private
  # @return [Subexpression] a new instance of Subexpression
  def initialize(left, right); end

  # @api private
  def optimize; end

  # @api private
  def visit(value); end

  protected

  # @api private
  def flatten; end

  # @api private
  def left; end

  # @api private
  def right; end
end

# @api private
class JMESPath::Nodes::SumFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::ToArrayFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::ToNumberFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::ToStringFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
module JMESPath::Nodes::TypeChecker
  # @api private
  def get_type(value); end
end

# @api private
JMESPath::Nodes::TypeChecker::ARRAY_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::BOOLEAN_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::EXPRESSION_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::NULL_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::NUMBER_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::OBJECT_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::STRING_TYPE = T.let(T.unsafe(nil), Integer)

# @api private
JMESPath::Nodes::TypeChecker::TYPE_NAMES = T.let(T.unsafe(nil), Hash)

# @api private
class JMESPath::Nodes::TypeFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  # @api private
  def call(args); end
end

# @api private
class JMESPath::Nodes::ValuesFunction < ::JMESPath::Nodes::Function
  # @api private
  def call(args); end
end

# @api private
class JMESPath::Parser
  # @api private
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Parser] a new instance of Parser
  def initialize(options = T.unsafe(nil)); end

  # @api private
  def method_missing(method_name, *args); end

  # @api private
  # @param expression [String<JMESPath>]
  def parse(expression); end

  private

  # @api private
  # @param stream [TokenStream]
  # @param rbp [Integer] Right binding power
  def expr(stream, rbp = T.unsafe(nil)); end

  # @api private
  def led_and(stream, left); end

  # @api private
  def led_comparator(stream, left); end

  # @api private
  def led_dot(stream, left); end

  # @api private
  def led_filter(stream, left); end

  # @api private
  def led_flatten(stream, left); end

  # @api private
  def led_lbracket(stream, left); end

  # @api private
  def led_lparen(stream, left); end

  # @api private
  def led_or(stream, left); end

  # @api private
  def led_pipe(stream, left); end

  # @api private
  def nud_current(stream); end

  # @api private
  def nud_expref(stream); end

  # @api private
  def nud_filter(stream); end

  # @api private
  def nud_flatten(stream); end

  # @api private
  def nud_identifier(stream); end

  # @api private
  def nud_lbrace(stream); end

  # @api private
  def nud_lbracket(stream); end

  # @api private
  def nud_literal(stream); end

  # @api private
  def nud_lparen(stream); end

  # @api private
  def nud_not(stream); end

  # @api private
  def nud_quoted_identifier(stream); end

  # @api private
  def nud_star(stream); end

  # @api private
  # @raise [Errors::SyntaxError]
  def nud_unknown(stream); end

  # parse array index expressions, for example [0], [1:2:3], etc.
  #
  # @api private
  def parse_array_index_expression(stream); end

  # @api private
  def parse_dot(stream, binding_power); end

  # @api private
  def parse_key_value_pair(stream); end

  # @api private
  def parse_multi_select_list(stream); end

  # @api private
  def parse_projection(stream, binding_power); end

  # @api private
  def parse_wildcard_array(stream, left = T.unsafe(nil)); end

  # @api private
  def parse_wildcard_object(stream, left = T.unsafe(nil)); end
end

# @api private
JMESPath::Parser::AFTER_DOT = T.let(T.unsafe(nil), Set)

# @api private
JMESPath::Parser::COLON_RBRACKET = T.let(T.unsafe(nil), Set)

# @api private
JMESPath::Parser::CURRENT_NODE = T.let(T.unsafe(nil), JMESPath::Nodes::Current)

# @api private
JMESPath::Parser::NUM_COLON_RBRACKET = T.let(T.unsafe(nil), Set)

# @api private
class JMESPath::Runtime
  # Constructs a new runtime object for evaluating JMESPath expressions.
  #
  #     runtime = JMESPath::Runtime.new
  #     runtime.search(expression, data)
  #     #=> ...
  #
  # ## Caching
  #
  # When constructing a {Runtime}, the default parser caches expressions.
  # This significantly speeds up calls to {#search} multiple times
  # with the same expression but different data. To disable caching, pass
  # `:cache_expressions => false` to the constructor or pass a custom
  # `:parser`.
  #
  # @api private
  # @example Re-use a Runtime, caching enabled by default
  #
  #   runtime = JMESPath::Runtime.new
  #   runtime.parser
  #   #=> #<JMESPath::CachingParser ...>
  # @example Disable caching
  #
  #   runtime = JMESPath::Runtime.new(cache_expressions: false)
  #   runtime.parser
  #   #=> #<JMESPath::Parser ...>
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Runtime] a new instance of Runtime
  def initialize(options = T.unsafe(nil)); end

  # @api private
  # @return [Parser, CachingParser]
  def parser; end

  # @api private
  # @param expression [String<JMESPath>]
  # @param data [Hash]
  # @return [Mixed, nil]
  def search(expression, data); end

  private

  # @api private
  def default_parser(options); end
end

# @api private
JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

# @api private
class JMESPath::Token < ::Struct
  # @api private
  # @param type [Symbol]
  # @param value [Mixed]
  # @param position [Integer]
  # @return [Token] a new instance of Token
  def initialize(type, value, position); end
end

# @api private
JMESPath::Token::BINDING_POWER = T.let(T.unsafe(nil), Hash)

# @api private
JMESPath::Token::NULL_TOKEN = T.let(T.unsafe(nil), JMESPath::Token)

# @api private
class JMESPath::TokenStream
  # @api private
  # @param expression [String<JMESPath>]
  # @param tokens [Array<Token>]
  # @return [TokenStream] a new instance of TokenStream
  def initialize(expression, tokens); end

  # @api private
  # @return [String<JMESPath>]
  def expression; end

  # @api private
  def inspect; end

  # @api private
  def lookahead(count); end

  # @api private
  # @option options
  # @param options [Hash] a customizable set of options
  def next(options = T.unsafe(nil)); end

  # @api private
  # @return [Integer]
  def position; end

  # @api private
  # @return [Token]
  def token; end

  private

  # @api private
  def _next; end

  # @api private
  def validate_match(token, match); end
end

# @api private
module JMESPath::Util
  class << self
    # @api private
    def as_json(value); end

    # Determines if a value is false as defined by JMESPath:
    #
    #   https://github.com/jmespath/jmespath.site/blob/master/docs/proposals/improved-filters.rst#and-expressions-1
    #
    # @api private
    # @return [Boolean]
    def falsey?(value); end
  end
end

JMESPath::VERSION = T.let(T.unsafe(nil), String)
