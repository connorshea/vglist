# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `matrix` gem.
# Please instead update this file by running `bin/tapioca gem matrix`.

module ExceptionForMatrix; end

class ExceptionForMatrix::ErrDimensionMismatch < ::StandardError
  def initialize(val = T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrNotRegular < ::StandardError
  def initialize(val = T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrOperationNotDefined < ::StandardError
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotImplemented < ::StandardError
  def initialize(vals); end
end

class Matrix
  include ::Enumerable
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  extend ::Matrix::ConversionHelper

  def initialize(rows, column_count = T.unsafe(nil)); end

  def *(m); end
  def **(exp); end
  def +(m); end
  def +@; end
  def -(m); end
  def -@; end
  def /(other); end
  def ==(other); end
  def [](i, j); end
  def []=(i, j, v); end
  def abs; end
  def adjoint; end
  def adjugate; end
  def antisymmetric?; end
  def coerce(other); end
  def cofactor(row, column); end
  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end
  def collect(which = T.unsafe(nil), &block); end
  def collect!(which = T.unsafe(nil)); end
  def column(j); end
  def column_count; end
  def column_size; end
  def column_vectors; end
  def combine(*matrices, &block); end
  def component(i, j); end
  def conj; end
  def conjugate; end
  def det; end
  def det_e; end
  def determinant; end
  def determinant_e; end
  def diagonal?; end
  def each(which = T.unsafe(nil), &block); end
  def each_with_index(which = T.unsafe(nil)); end
  def eigen; end
  def eigensystem; end
  def element(i, j); end
  def elements_to_f; end
  def elements_to_i; end
  def elements_to_r; end
  def empty?; end
  def entrywise_product(m); end
  def eql?(other); end
  def find_index(*args); end
  def first_minor(row, column); end
  def freeze; end
  def hadamard_product(m); end
  def hash; end
  def hermitian?; end
  def hstack(*matrices); end
  def imag; end
  def imaginary; end
  def index(*args); end
  def inspect; end
  def inv; end
  def inverse; end
  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end
  def lower_triangular?; end
  def lup; end
  def lup_decomposition; end
  def map(which = T.unsafe(nil), &block); end
  def map!(which = T.unsafe(nil)); end
  def minor(*param); end
  def normal?; end
  def orthogonal?; end
  def permutation?; end
  def rank; end
  def rank_e; end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def regular?; end
  def rotate_entries(rotation = T.unsafe(nil)); end
  def round(ndigits = T.unsafe(nil)); end
  def row(i, &block); end
  def row_count; end
  def row_size; end
  def row_vectors; end
  def singular?; end
  def skew_symmetric?; end
  def square?; end
  def symmetric?; end
  def t; end
  def to_a; end
  def to_matrix; end
  def to_s; end
  def tr; end
  def trace; end
  def transpose; end
  def unitary?; end
  def upper_triangular?; end
  def vstack(*matrices); end
  def zero?; end

  protected

  def power_int(exp); end
  def rows; end

  private

  def check_int(val, direction); end
  def check_range(val, direction); end
  def determinant_bareiss; end
  def initialize_copy(m); end
  def inverse_from(src); end
  def new_matrix(rows, column_count = T.unsafe(nil)); end
  def set_col_range(row, col_range, value); end
  def set_column_vector(row_range, col, value); end
  def set_component(i, j, v); end
  def set_element(i, j, v); end
  def set_row_and_col_range(row_range, col_range, value); end
  def set_row_range(row_range, col, value); end
  def set_value(row, col, value); end

  class << self
    def I(n); end
    def [](*rows); end
    def build(row_count, column_count = T.unsafe(nil)); end
    def column_vector(column); end
    def columns(columns); end
    def combine(*matrices); end
    def diagonal(*values); end
    def empty(row_count = T.unsafe(nil), column_count = T.unsafe(nil)); end
    def hstack(x, *matrices); end
    def identity(n); end
    def row_vector(row); end
    def rows(rows, copy = T.unsafe(nil)); end
    def scalar(n, value); end
    def unit(n); end
    def vstack(x, *matrices); end
    def zero(row_count, column_count = T.unsafe(nil)); end
  end
end

module Matrix::CoercionHelper
  private

  def apply_through_coercion(obj, oper); end

  class << self
    def check_int(val, count, kind); end
    def check_range(val, count, kind); end
    def coerce_to(obj, cls, meth); end
    def coerce_to_int(obj); end
    def coerce_to_matrix(obj); end
  end
end

module Matrix::ConversionHelper
  private

  def convert_to_array(obj, copy = T.unsafe(nil)); end
end

class Matrix::EigenvalueDecomposition
  def initialize(a); end

  def d; end
  def eigenvalue_matrix; end
  def eigenvalues; end
  def eigenvector_matrix; end
  def eigenvector_matrix_inv; end
  def eigenvectors; end
  def to_a; end
  def to_ary; end
  def v; end
  def v_inv; end

  private

  def build_eigenvectors; end
  def cdiv(xr, xi, yr, yi); end
  def diagonalize; end
  def hessenberg_to_real_schur; end
  def reduce_to_hessenberg; end
  def tridiagonalize; end
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper

  def initialize(a); end

  def det; end
  def determinant; end
  def l; end
  def p; end
  def pivots; end
  def singular?; end
  def solve(b); end
  def to_a; end
  def to_ary; end
  def u; end
end

Matrix::SELECTORS = T.let(T.unsafe(nil), Hash)

class Matrix::Scalar < ::Numeric
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper

  def initialize(value); end

  def *(other); end
  def **(other); end
  def +(other); end
  def -(other); end
  def /(other); end
end

Matrix::VERSION = T.let(T.unsafe(nil), String)

class Vector
  include ::ExceptionForMatrix
  include ::Enumerable
  include ::Matrix::CoercionHelper
  extend ::Matrix::ConversionHelper

  def initialize(array); end

  def *(x); end
  def +(v); end
  def +@; end
  def -(v); end
  def -@; end
  def /(x); end
  def ==(other); end
  def [](i); end
  def []=(i, v); end
  def angle_with(v); end
  def coerce(other); end
  def collect(&block); end
  def collect!(&block); end
  def collect2(v); end
  def component(i); end
  def covector; end
  def cross(*vs); end
  def cross_product(*vs); end
  def dot(v); end
  def each(&block); end
  def each2(v); end
  def element(i); end
  def elements_to_f; end
  def elements_to_i; end
  def elements_to_r; end
  def eql?(other); end
  def freeze; end
  def hash; end
  def independent?(*vs); end
  def inner_product(v); end
  def inspect; end
  def magnitude; end
  def map(&block); end
  def map!(&block); end
  def map2(v, &block); end
  def norm; end
  def normalize; end
  def r; end
  def round(ndigits = T.unsafe(nil)); end
  def size; end
  def to_a; end
  def to_matrix; end
  def to_s; end
  def zero?; end

  protected

  def elements; end

  private

  def initialize_copy(v); end
  def set_component(i, v); end
  def set_element(i, v); end
  def set_range(range, value); end
  def set_value(index, value); end

  class << self
    def [](*array); end
    def basis(size:, index:); end
    def elements(array, copy = T.unsafe(nil)); end
    def independent?(*vs); end
    def zero(size); end
  end
end

class Vector::ZeroVectorError < ::StandardError; end
