# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rdf-xsd` gem.
# Please instead update this file by running `bin/tapioca gem rdf-xsd`.

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def c14nxl(options = T.unsafe(nil)); end
  def to_s; end
  def to_s_with_c14nxl; end
end

module Nokogiri::XML
  class << self
    def Reader(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end
    def RelaxNG(string_or_io, options = T.unsafe(nil)); end
    def Schema(string_or_io, options = T.unsafe(nil)); end
    def fragment(string, options = T.unsafe(nil), &block); end
    def parse(thing, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class Nokogiri::XML::Comment < ::Nokogiri::XML::CharacterData
  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::Document < ::Nokogiri::XML::Node
  def initialize(*args); end

  def <<(node_or_tags); end
  def add_child(node_or_tags); end
  def canonicalize(*_arg0); end
  def clone(*_arg0); end
  def collect_namespaces; end
  def create_cdata(string, &block); end
  def create_comment(string, &block); end
  def create_element(name, *contents_or_attrs, &block); end
  def create_entity(*_arg0); end
  def create_text_node(string, &block); end
  def decorate(node); end
  def decorators(key); end
  def doctype; end
  def document; end
  def dup(*_arg0); end
  def encoding; end
  def encoding=(_arg0); end
  def errors; end
  def errors=(_arg0); end
  def fragment(tags = T.unsafe(nil)); end
  def name; end
  def namespace_inheritance; end
  def namespace_inheritance=(_arg0); end
  def namespaces; end
  def remove_namespaces!; end
  def root; end
  def root=(_arg0); end
  def slop!; end
  def to_xml(*args, &block); end
  def url; end
  def validate; end
  def version; end
  def xpath_doctype; end

  private

  def inspect_attributes; end

  class << self
    def empty_doc?(string_or_io); end
    def new(*_arg0); end
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end
    def read_io(_arg0, _arg1, _arg2, _arg3); end
    def read_memory(_arg0, _arg1, _arg2, _arg3); end
  end
end

Nokogiri::XML::Document::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)
Nokogiri::XML::Document::NCNAME_CHAR = T.let(T.unsafe(nil), String)
Nokogiri::XML::Document::NCNAME_RE = T.let(T.unsafe(nil), Regexp)
Nokogiri::XML::Document::NCNAME_START_CHAR = T.let(T.unsafe(nil), String)

class Nokogiri::XML::Element < ::Nokogiri::XML::Node
  def c14nxl(options = T.unsafe(nil)); end
end

class Nokogiri::XML::Node
  include ::Nokogiri::HTML5::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Nokogiri::ClassResolver
  include ::Enumerable

  def initialize(name, document); end

  def <<(node_or_tags); end
  def <=>(other); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def accept(visitor); end
  def add_child(node_or_tags); end
  def add_class(names); end
  def add_namespace(_arg0, _arg1); end
  def add_namespace_definition(_arg0, _arg1); end
  def add_next_sibling(node_or_tags); end
  def add_previous_sibling(node_or_tags); end
  def after(node_or_tags); end
  def ancestors(selector = T.unsafe(nil)); end
  def append_class(names); end
  def attr(name); end
  def attribute(_arg0); end
  def attribute_nodes; end
  def attribute_with_ns(_arg0, _arg1); end
  def attributes; end
  def before(node_or_tags); end
  def blank?; end
  def c14nxl(options = T.unsafe(nil)); end
  def canonicalize(mode = T.unsafe(nil), inclusive_namespaces = T.unsafe(nil), with_comments = T.unsafe(nil)); end
  def cdata?; end
  def child; end
  def children; end
  def children=(node_or_tags); end
  def classes; end
  def clone(*_arg0); end
  def comment?; end
  def content; end
  def content=(string); end
  def create_external_subset(_arg0, _arg1, _arg2); end
  def create_internal_subset(_arg0, _arg1, _arg2); end
  def css_path; end
  def decorate!; end
  def default_namespace=(url); end
  def delete(name); end
  def description; end
  def do_xinclude(options = T.unsafe(nil)); end
  def document; end
  def document?; end
  def dup(*_arg0); end
  def each; end
  def elem?; end
  def element?; end
  def element_children; end
  def elements; end
  def encode_special_chars(_arg0); end
  def external_subset; end
  def first_element_child; end
  def fragment?; end
  def get_attribute(name); end
  def has_attribute?(_arg0); end
  def html?; end
  def inner_html=(node_or_tags); end
  def inner_text; end
  def internal_subset; end
  def key?(_arg0); end
  def keys; end
  def kwattr_add(attribute_name, keywords); end
  def kwattr_append(attribute_name, keywords); end
  def kwattr_remove(attribute_name, keywords); end
  def kwattr_values(attribute_name); end
  def lang; end
  def lang=(_arg0); end
  def last_element_child; end
  def line; end
  def line=(_arg0); end
  def matches?(selector); end
  def name; end
  def name=(_arg0); end
  def namespace; end
  def namespace=(ns); end
  def namespace_definitions; end
  def namespace_scopes; end
  def namespaced_key?(_arg0, _arg1); end
  def namespaces; end
  def native_content=(_arg0); end
  def next; end
  def next=(node_or_tags); end
  def next_element; end
  def next_sibling; end
  def node_name; end
  def node_name=(_arg0); end
  def node_type; end
  def parent; end
  def parent=(parent_node); end
  def parse(string_or_io, options = T.unsafe(nil)); end
  def path; end
  def pointer_id; end
  def prepend_child(node_or_tags); end
  def previous; end
  def previous=(node_or_tags); end
  def previous_element; end
  def previous_sibling; end
  def processing_instruction?; end
  def read_only?; end
  def remove; end
  def remove_attribute(name); end
  def remove_class(names = T.unsafe(nil)); end
  def replace(node_or_tags); end
  def serialize(*args, &block); end
  def set_attribute(name, value); end
  def swap(node_or_tags); end
  def text; end
  def text?; end
  def to_html(options = T.unsafe(nil)); end
  def to_s; end
  def to_s_with_c14nxl; end
  def to_s_without_c14nxl; end
  def to_str; end
  def to_xhtml(options = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end
  def traverse(&block); end
  def type; end
  def unlink; end
  def value?(value); end
  def values; end
  def wrap(html); end
  def write_html_to(io, options = T.unsafe(nil)); end
  def write_xhtml_to(io, options = T.unsafe(nil)); end
  def write_xml_to(io, options = T.unsafe(nil)); end
  def xml?; end

  protected

  def coerce(data); end

  private

  def add_child_node(_arg0); end
  def add_next_sibling_node(_arg0); end
  def add_previous_sibling_node(_arg0); end
  def add_sibling(next_or_previous, node_or_tags); end
  def compare(_arg0); end
  def dump_html; end
  def get(_arg0); end
  def in_context(_arg0, _arg1); end
  def inspect_attributes; end
  def keywordify(keywords); end
  def native_write_to(_arg0, _arg1, _arg2, _arg3); end
  def process_xincludes(_arg0); end
  def replace_node(_arg0); end
  def set(_arg0, _arg1); end
  def set_namespace(_arg0); end
  def to_format(save_option, options); end
  def write_format_to(save_option, io, options); end

  class << self
    def new(*_arg0); end
  end
end

Nokogiri::XML::Node::ATTRIBUTE_DECL = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ATTRIBUTE_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::CDATA_SECTION_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::COMMENT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::DOCB_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::DOCUMENT_FRAG_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::DOCUMENT_TYPE_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::DTD_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ELEMENT_DECL = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ELEMENT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ENTITY_DECL = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ENTITY_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::ENTITY_REF_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::HTML_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)
Nokogiri::XML::Node::NAMESPACE_DECL = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::NOTATION_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::PI_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::TEXT_NODE = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::XINCLUDE_END = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::Node::XINCLUDE_START = T.let(T.unsafe(nil), Integer)

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable

  def initialize(document, list = T.unsafe(nil)); end

  def %(*args); end
  def &(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def ==(other); end
  def [](*_arg0); end
  def add_class(name); end
  def after(datum); end
  def append_class(name); end
  def at(*args); end
  def attr(key, value = T.unsafe(nil), &block); end
  def attribute(key, value = T.unsafe(nil), &block); end
  def before(datum); end
  def c14nxl(options = T.unsafe(nil)); end
  def children; end
  def clone; end
  def css(*args); end
  def delete(_arg0); end
  def document; end
  def document=(_arg0); end
  def dup; end
  def each; end
  def empty?; end
  def filter(expr); end
  def first(n = T.unsafe(nil)); end
  def include?(_arg0); end
  def index(node = T.unsafe(nil)); end
  def inner_html(*args); end
  def inner_text; end
  def inspect; end
  def last; end
  def length; end
  def pop; end
  def push(_arg0); end
  def remove; end
  def remove_attr(name); end
  def remove_attribute(name); end
  def remove_class(name = T.unsafe(nil)); end
  def reverse; end
  def set(key, value = T.unsafe(nil), &block); end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def text; end
  def to_a; end
  def to_ary; end
  def to_html(*args); end
  def to_s; end
  def to_s_with_c14nxl; end
  def to_s_without_c14nxl; end
  def to_xhtml(*args); end
  def to_xml(*args); end
  def unlink; end
  def wrap(html); end
  def xpath(*args); end
  def |(_arg0); end
end

Nokogiri::XML::NodeSet::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)
Nokogiri::XML::XML_C14N_1_0 = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::XML_C14N_1_1 = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0 = T.let(T.unsafe(nil), Integer)

module RDF
  class << self
    def Graph(**options, &block); end
    def List(*args); end
    def Literal(literal, **options); end
    def Node(*args); end
    def Resource(*args); end
    def Statement(*args, **options); end
    def StrictVocabulary(uri); end
    def URI(*args); end
    def Vocabulary(uri); end
    def [](property); end
    def config; end
    def enum_for(method = T.unsafe(nil), *args); end
    def method_missing(property, *args, &block); end
    def respond_to?(method, include_all = T.unsafe(nil)); end
    def to_enum(method = T.unsafe(nil), *args); end
  end
end

RDF::IRI = RDF::URI

class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype2?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(_arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = T.unsafe(nil)); end
  def inspect; end
  def language; end
  def language=(_arg0); end
  def language?; end
  def literal?; end
  def object; end
  def plain?; end
  def simple?; end
  def squish(*other_string); end
  def squish!; end
  def to_s; end
  def to_sxp(**options); end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end

  protected

  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def datatype_map; end
    def datatyped_class(uri); end
    def inherited(child); end
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

class RDF::Literal::AnyURI < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def canonicalize!; end
  def valid?; end
end

RDF::Literal::AnyURI::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::Base64Binary < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def canonicalize!; end
  def to_s; end
  def valid?; end
end

RDF::Literal::Base64Binary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::Byte < ::RDF::Literal::Short
  def valid?; end
end

RDF::Literal::Byte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
class RDF::Literal::DateTimeStamp < ::RDF::Literal::DateTime; end
RDF::Literal::DateTimeStamp::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DateTimeStamp::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::DateTimeStamp::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Day < ::RDF::Literal::Date
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Day::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Day::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Day::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::DayTimeDuration < ::RDF::Literal::Duration
  def *(other); end
  def +(other); end
  def -(other); end
  def /(other); end
  def <=>(other); end
  def to_r; end
end

RDF::Literal::DayTimeDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DayTimeDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Duration < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def ==(other); end
  def canonicalize!; end
  def days; end
  def hours; end
  def humanize(lang = T.unsafe(nil)); end
  def minutes; end
  def months; end
  def plural(v, str); end
  def seconds; end
  def to_h; end
  def to_s; end
  def valid?; end
  def years; end

  private

  def parse(value); end
  def sec_str; end
end

RDF::Literal::Duration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Duration::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::FALSE = T.let(T.unsafe(nil), RDF::Literal::Boolean)
class RDF::Literal::Float < ::RDF::Literal::Double; end
RDF::Literal::Float::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
class RDF::Literal::HTML < ::RDF::Literal::XML; end

class RDF::Literal::HexBinary < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def canonicalize!; end
  def to_s; end

  private

  def bin_to_hex(value); end
  def hex_to_bin(value); end
end

RDF::Literal::HexBinary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::HexBinary::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Int < ::RDF::Literal::Long
  def valid?; end
end

RDF::Literal::Int::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::Long < ::RDF::Literal::Integer
  def valid?; end
end

RDF::Literal::Long::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::Month < ::RDF::Literal::Date
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Month::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Month::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Month::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::MonthDay < ::RDF::Literal::Date
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::MonthDay::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::MonthDay::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::MonthDay::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::NegativeInteger < ::RDF::Literal::NonPositiveInteger
  def -@; end
  def valid?; end
end

RDF::Literal::NegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::NonNegativeInteger < ::RDF::Literal::Integer
  def valid?; end
end

RDF::Literal::NonNegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonNegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::NonPositiveInteger < ::RDF::Literal::Integer
  def -@; end
  def valid?; end
end

RDF::Literal::NonPositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonPositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::PositiveInteger < ::RDF::Literal::NonNegativeInteger
  def valid?; end
end

RDF::Literal::PositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::PositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::Short < ::RDF::Literal::Int
  def valid?; end
end

RDF::Literal::Short::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::TRUE = T.let(T.unsafe(nil), RDF::Literal::Boolean)

class RDF::Literal::UnsignedByte < ::RDF::Literal::UnsignedShort
  def valid?; end
end

RDF::Literal::UnsignedByte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::UnsignedInt < ::RDF::Literal::UnsignedLong
  def valid?; end
end

RDF::Literal::UnsignedInt::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::UnsignedLong < ::RDF::Literal::NonNegativeInteger
  def valid?; end
end

RDF::Literal::UnsignedLong::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::UnsignedLong::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::UnsignedShort < ::RDF::Literal::UnsignedInt
  def valid?; end
end

RDF::Literal::UnsignedShort::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::XML < ::RDF::Literal
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def eql?(other); end
  def object; end
  def to_s; end

  private

  def equivalent_nokogiri(other); end
  def equivalent_rexml(other); end
  def parse_nokogiri(value); end
  def parse_rexml(value); end
end

RDF::Literal::XML::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

class RDF::Literal::Year < ::RDF::Literal::Date
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Year::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Year::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Year::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::YearMonth < ::RDF::Literal::Date
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::YearMonth::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonth::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::YearMonth::GRAMMAR = T.let(T.unsafe(nil), Regexp)

class RDF::Literal::YearMonthDuration < ::RDF::Literal::Duration
  def *(other); end
  def +(other); end
  def -(other); end
  def /(other); end
  def <=>(other); end
  def to_i; end
end

RDF::Literal::YearMonthDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonthDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::ZERO = T.let(T.unsafe(nil), RDF::Literal::Integer)

class RDF::OWL < ::RDF::StrictVocabulary
  class << self
    def AllDifferent; end
    def AllDisjointClasses; end
    def AllDisjointProperties; end
    def Annotation; end
    def AnnotationProperty; end
    def AsymmetricProperty; end
    def Axiom; end
    def Class; end
    def DataRange; end
    def DatatypeProperty; end
    def DeprecatedClass; end
    def DeprecatedProperty; end
    def FunctionalProperty; end
    def InverseFunctionalProperty; end
    def IrreflexiveProperty; end
    def NamedIndividual; end
    def NegativePropertyAssertion; end
    def Nothing; end
    def ObjectProperty; end
    def Ontology; end
    def OntologyProperty; end
    def ReflexiveProperty; end
    def Restriction; end
    def SymmetricProperty; end
    def Thing; end
    def TransitiveProperty; end
    def allValuesFrom; end
    def annotatedProperty; end
    def annotatedSource; end
    def annotatedTarget; end
    def assertionProperty; end
    def backwardCompatibleWith; end
    def bottomDataProperty; end
    def bottomObjectProperty; end
    def cardinality; end
    def complementOf; end
    def datatypeComplementOf; end
    def deprecated; end
    def differentFrom; end
    def disjointUnionOf; end
    def disjointWith; end
    def distinctMembers; end
    def equivalentClass; end
    def equivalentProperty; end
    def hasKey; end
    def hasSelf; end
    def hasValue; end
    def imports; end
    def incompatibleWith; end
    def intersectionOf; end
    def inverseOf; end
    def maxCardinality; end
    def maxQualifiedCardinality; end
    def members; end
    def minCardinality; end
    def minQualifiedCardinality; end
    def onClass; end
    def onDataRange; end
    def onDatatype; end
    def onProperties; end
    def onProperty; end
    def oneOf; end
    def priorVersion; end
    def propertyChainAxiom; end
    def propertyDisjointWith; end
    def qualifiedCardinality; end
    def sameAs; end
    def someValuesFrom; end
    def sourceIndividual; end
    def targetIndividual; end
    def targetValue; end
    def topDataProperty; end
    def topObjectProperty; end
    def unionOf; end
    def versionIRI; end
    def versionInfo; end
    def withRestrictions; end
  end
end

class RDF::RDFS < ::RDF::StrictVocabulary
  class << self
    def Class; end
    def Container; end
    def ContainerMembershipProperty; end
    def Datatype; end
    def Literal; end
    def Resource; end
    def comment; end
    def domain; end
    def isDefinedBy; end
    def label; end
    def member; end
    def range; end
    def seeAlso; end
    def subClassOf; end
    def subPropertyOf; end
  end
end

class RDF::RDFV < ::RDF::StrictVocabulary
  class << self
    def Alt; end
    def Bag; end
    def CompoundLiteral; end
    def Description; end
    def HTML; end
    def ID; end
    def JSON; end
    def List; end
    def PlainLiteral; end
    def Property; end
    def Seq; end
    def Statement; end
    def XMLLiteral; end
    def __name__; end
    def about; end
    def datatype; end
    def direction; end
    def first; end
    def langString; end
    def language; end
    def li; end
    def name; end
    def nil; end
    def nodeID; end
    def object; end
    def parseType; end
    def predicate; end
    def resource; end
    def rest; end
    def subject; end
    def type; end
    def value; end
  end
end

RDF::RDF_N_REGEXP = T.let(T.unsafe(nil), Regexp)
RDF::VOCABS = T.let(T.unsafe(nil), Hash)

class RDF::XSD < ::RDF::Vocabulary
  class << self
    def ENTITIES; end
    def ENTITY; end
    def ID; end
    def IDREF; end
    def IDREFS; end
    def NCName; end
    def NMTOKEN; end
    def NMTOKENS; end
    def NOTATION; end
    def Name; end
    def QName; end
    def anyAtomicType; end
    def anySimpleType; end
    def anyType; end
    def anyURI; end
    def base64Binary; end
    def boolean; end
    def byte; end
    def date; end
    def dateTime; end
    def dateTimeStamp; end
    def dayTimeDuration; end
    def decimal; end
    def double; end
    def duration; end
    def float; end
    def gDay; end
    def gMonth; end
    def gMonthDay; end
    def gYear; end
    def gYearMonth; end
    def hexBinary; end
    def int; end
    def integer; end
    def language; end
    def long; end
    def negativeInteger; end
    def nonNegativeInteger; end
    def nonPositiveInteger; end
    def normalizedString; end
    def positiveInteger; end
    def short; end
    def string; end
    def time; end
    def token; end
    def unsignedByte; end
    def unsignedInt; end
    def unsignedLong; end
    def unsignedShort; end
    def yearMonthDuration; end
  end
end

module RDF::XSD::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

RDF::XSD::VERSION::MAJOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::MINOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::STRING = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::TINY = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

class REXML::Element < ::REXML::Parent
  include ::REXML::XMLTokens
  include ::REXML::Namespace

  def c14nxl(options = T.unsafe(nil)); end
end
