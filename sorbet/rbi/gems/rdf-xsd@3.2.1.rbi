# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rdf-xsd` gem.
# Please instead update this file by running `bin/tapioca gem rdf-xsd`.

# REXML C14N
class Array
  include ::Enumerable

  # Canonicalize the NodeSet. Return a new NodeSet marked
  # as being canonical with all child nodes canonicalized.
  #
  # @param options [Hash{Symbol => Object}] Passed to {Nokogiri::XML::Node#c14nxl}
  def c14nxl(options = T.unsafe(nil)); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end
end

module Nokogiri::XML
  class << self
    # Parse an XML document using the Nokogiri::XML::Reader API.  See
    # Nokogiri::XML::Reader for mor information
    #
    # @yield [options]
    def Reader(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.
    # See Nokogiri::XML::RelaxNG for an example.
    def RelaxNG(string_or_io, options = T.unsafe(nil)); end

    # Create a new Nokogiri::XML::Schema object using a +string_or_io+
    # object.
    def Schema(string_or_io, options = T.unsafe(nil)); end

    # Parse a fragment from +string+ in to a NodeSet.
    def fragment(string, options = T.unsafe(nil), &block); end

    # Parse XML.  Convenience method for Nokogiri::XML::Document.parse
    def parse(thing, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class Nokogiri::XML::Comment < ::Nokogiri::XML::CharacterData
  class << self
    def new(*_arg0); end
  end
end

# Nokogiri::XML::Document is the main entry point for dealing with XML documents.  The Document
# is created by parsing an XML document.  See Nokogiri::XML::Document.parse for more information
# on parsing.
#
# For searching a Document, see Nokogiri::XML::Searchable#css and
# Nokogiri::XML::Searchable#xpath
class Nokogiri::XML::Document < ::Nokogiri::XML::Node
  # @return [Document] a new instance of Document
  def initialize(*args); end

  def <<(node_or_tags); end
  def add_child(node_or_tags); end
  def canonicalize(*_arg0); end
  def clone(*_arg0); end

  # :call-seq:
  #   collect_namespaces() → Hash<String(Namespace#prefix) ⇒ String(Namespace#href)>
  #
  # Recursively get all namespaces from this node and its subtree and return them as a
  # hash.
  #
  # ⚠ This method will not handle duplicate namespace prefixes, since the return value is a hash.
  #
  # Note that this method does an xpath lookup for nodes with namespaces, and as a result the
  # order (and which duplicate prefix "wins") may be dependent on the implementation of the
  # underlying XML library.
  #
  # *Example:* Basic usage
  #
  # Given this document:
  #
  #   <root xmlns="default" xmlns:foo="bar">
  #     <bar xmlns:hello="world" />
  #   </root>
  #
  # This method will return:
  #
  #   {"xmlns:foo"=>"bar", "xmlns"=>"default", "xmlns:hello"=>"world"}
  #
  # *Example:* Duplicate prefixes
  #
  # Given this document:
  #
  #   <root xmlns:foo="bar">
  #     <bar xmlns:foo="baz" />
  #   </root>
  #
  # The hash returned will be something like:
  #
  #   {"xmlns:foo" => "baz"}
  def collect_namespaces; end

  # Create a CDATA Node containing +string+
  def create_cdata(string, &block); end

  # Create a Comment Node containing +string+
  def create_comment(string, &block); end

  # :call-seq:
  #   create_element(name, *contents_or_attrs, &block) → Nokogiri::XML::Element
  #
  # Create a new Element with `name` belonging to this document, optionally setting contents or
  # attributes.
  #
  # This method is _not_ the most user-friendly option if your intention is to add a node to the
  # document tree. Prefer one of the Nokogiri::XML::Node methods like Node#add_child,
  # Node#add_next_sibling, Node#replace, etc. which will both create an element (or subtree) and
  # place it in the document tree.
  #
  # Arguments may be passed to initialize the element:
  #
  # - a Hash argument will be used to set attributes
  # - a non-Hash object that responds to \#to_s will be used to set the new node's contents
  #
  # A block may be passed to mutate the node.
  #
  # [Parameters]
  # - `name` (String)
  # - `contents_or_attrs` (\#to_s, Hash)
  # [Yields] `node` (Nokogiri::XML::Element)
  # [Returns] Nokogiri::XML::Element
  #
  # *Example:* An empty element without attributes
  #
  #   doc.create_element("div")
  #   # => <div></div>
  #
  # *Example:* An element with contents
  #
  #   doc.create_element("div", "contents")
  #   # => <div>contents</div>
  #
  # *Example:* An element with attributes
  #
  #   doc.create_element("div", {"class" => "container"})
  #   # => <div class='container'></div>
  #
  # *Example:* An element with contents and attributes
  #
  #   doc.create_element("div", "contents", {"class" => "container"})
  #   # => <div class='container'>contents</div>
  #
  # *Example:* Passing a block to mutate the element
  #
  #   doc.create_element("div") { |node| node["class"] = "blue" if before_noon? }
  def create_element(name, *contents_or_attrs, &block); end

  def create_entity(*_arg0); end

  # Create a Text Node with +string+
  def create_text_node(string, &block); end

  # Apply any decorators to +node+
  def decorate(node); end

  # Get the list of decorators given +key+
  def decorators(key); end

  def doctype; end

  # A reference to +self+
  def document; end

  def dup(*_arg0); end
  def encoding; end
  def encoding=(_arg0); end

  # The errors found while parsing a document.
  #
  # [Returns] Array<Nokogiri::XML::SyntaxError>
  def errors; end

  # The errors found while parsing a document.
  #
  # [Returns] Array<Nokogiri::XML::SyntaxError>
  def errors=(_arg0); end

  # Create a Nokogiri::XML::DocumentFragment from +tags+
  # Returns an empty fragment if +tags+ is nil.
  def fragment(tags = T.unsafe(nil)); end

  # The name of this document.  Always returns "document"
  def name; end

  # When `true`, reparented elements without a namespace will inherit their new parent's
  # namespace (if one exists). Defaults to `false`.
  #
  # [Returns] Boolean
  #
  # *Example:* Default behavior of namespace inheritance
  #
  #   xml = <<~EOF
  #           <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #             <foo:parent>
  #             </foo:parent>
  #           </root>
  #         EOF
  #   doc = Nokogiri::XML(xml)
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <child/>
  #   #      </foo:parent>
  #   #    </root>
  #
  # *Example:* Setting namespace inheritance to `true`
  #
  #   xml = <<~EOF
  #           <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #             <foo:parent>
  #             </foo:parent>
  #           </root>
  #         EOF
  #   doc = Nokogiri::XML(xml)
  #   doc.namespace_inheritance = true
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <foo:child/>
  #   #      </foo:parent>
  #   #    </root>
  #
  # Since v1.12.4
  def namespace_inheritance; end

  # When `true`, reparented elements without a namespace will inherit their new parent's
  # namespace (if one exists). Defaults to `false`.
  #
  # [Returns] Boolean
  #
  # *Example:* Default behavior of namespace inheritance
  #
  #   xml = <<~EOF
  #           <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #             <foo:parent>
  #             </foo:parent>
  #           </root>
  #         EOF
  #   doc = Nokogiri::XML(xml)
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <child/>
  #   #      </foo:parent>
  #   #    </root>
  #
  # *Example:* Setting namespace inheritance to `true`
  #
  #   xml = <<~EOF
  #           <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #             <foo:parent>
  #             </foo:parent>
  #           </root>
  #         EOF
  #   doc = Nokogiri::XML(xml)
  #   doc.namespace_inheritance = true
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <foo:child/>
  #   #      </foo:parent>
  #   #    </root>
  #
  # Since v1.12.4
  def namespace_inheritance=(_arg0); end

  # Get the hash of namespaces on the root Nokogiri::XML::Node
  def namespaces; end

  def remove_namespaces!; end
  def root; end
  def root=(_arg0); end

  # Explore a document with shortcut methods. See Nokogiri::Slop for details.
  #
  # Note that any nodes that have been instantiated before #slop!
  # is called will not be decorated with sloppy behavior. So, if you're in
  # irb, the preferred idiom is:
  #
  #   irb> doc = Nokogiri::Slop my_markup
  #
  # and not
  #
  #   irb> doc = Nokogiri::HTML my_markup
  #   ... followed by irb's implicit inspect (and therefore instantiation of every node) ...
  #   irb> doc.slop!
  #   ... which does absolutely nothing.
  def slop!; end

  def to_xml(*args, &block); end
  def url; end

  # Validate this Document against it's DTD.  Returns a list of errors on
  # the document or +nil+ when there is no DTD.
  def validate; end

  def version; end

  # :call-seq:
  #   xpath_doctype() → Nokogiri::CSS::XPathVisitor::DoctypeConfig
  #
  # [Returns] The document type which determines CSS-to-XPath translation.
  #
  # See XPathVisitor for more information.
  def xpath_doctype; end

  private

  def inspect_attributes; end

  class << self
    # @return [Boolean]
    def empty_doc?(string_or_io); end

    def new(*_arg0); end

    # Parse an XML file.
    #
    # +string_or_io+ may be a String, or any object that responds to
    # _read_ and _close_ such as an IO, or StringIO.
    #
    # +url+ (optional) is the URI where this document is located.
    #
    # +encoding+ (optional) is the encoding that should be used when processing
    # the document.
    #
    # +options+ (optional) is a configuration object that sets options during
    # parsing, such as Nokogiri::XML::ParseOptions::RECOVER. See the
    # Nokogiri::XML::ParseOptions for more information.
    #
    # +block+ (optional) is passed a configuration object on which
    # parse options may be set.
    #
    # By default, Nokogiri treats documents as untrusted, and so
    # does not attempt to load DTDs or access the network. See
    # Nokogiri::XML::ParseOptions for a complete list of options;
    # and that module's DEFAULT_XML constant for what's set (and not
    # set) by default.
    #
    # Nokogiri.XML() is a convenience method which will call this method.
    #
    # @yield [options]
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    def read_io(_arg0, _arg1, _arg2, _arg3); end
    def read_memory(_arg0, _arg1, _arg2, _arg3); end
  end
end

Nokogiri::XML::Document::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)
Nokogiri::XML::Document::NCNAME_CHAR = T.let(T.unsafe(nil), String)
Nokogiri::XML::Document::NCNAME_RE = T.let(T.unsafe(nil), Regexp)

# See http://www.w3.org/TR/REC-xml-names/#ns-decl for more details. Note that we're not
# attempting to handle unicode characters partly because libxml2 doesn't handle unicode
# characters in NCNAMEs.
Nokogiri::XML::Document::NCNAME_START_CHAR = T.let(T.unsafe(nil), String)

class Nokogiri::XML::Element < ::Nokogiri::XML::Node
  # Canonicalize the Element. Return a new instance of this node
  # which is canonicalized and marked as such.
  #
  # Apply namespaces either passed as an option, or that are in scope.
  #
  # @param options [Hash{Symbol => Object}] From {Nokogiri::XML::Node#c14nxl}
  def c14nxl(options = T.unsafe(nil)); end
end

# XML Exclusive Canonicalization (c14n) for Nokogiri.
#
# Classes mixin this module to implement canonicalization methods.
#
# This implementation acts in two parts, first to canonicalize the Node
# or NoteSet in the context of its containing document, and second to
# serialize to a lexical representation.
#
# @see # @see   https://www.w3.org/TR/xml-exc-c14n/
class Nokogiri::XML::Node
  # :call-seq:
  #   new(name, document) -> Nokogiri::XML::Node
  #   new(name, document) { |node| ... } -> Nokogiri::XML::Node
  #
  # Create a new node with +name+ that belongs to +document+.
  #
  # If you intend to add a node to a document tree, it's likely that you will prefer one of the
  # Nokogiri::XML::Node methods like #add_child, #add_next_sibling, #replace, etc. which will
  # both create an element (or subtree) and place it in the document tree.
  #
  # Another alternative, if you are concerned about performance, is
  # Nokogiri::XML::Document#create_element which accepts additional arguments for contents or
  # attributes but (like this method) avoids parsing markup.
  #
  # [Parameters]
  # - +name+ (String)
  # - +document+ (Nokogiri::XML::Document) The document to which the the returned node will belong.
  # [Yields] Nokogiri::XML::Node
  # [Returns] Nokogiri::XML::Node
  #
  # @return [Node] a new instance of Node
  def initialize(name, document); end

  # Add +node_or_tags+ as a child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls (e.g., root << child1 << child2)
  #
  # Also see related method +add_child+.
  def <<(node_or_tags); end

  # Compare two Node objects with respect to their Document.  Nodes from
  # different documents cannot be compared.
  def <=>(other); end

  # Test to see if this Node is equal to +other+
  def ==(other); end

  # :call-seq: [](name) → (String, nil)
  #
  # Fetch an attribute from this node.
  #
  # ⚠ Note that attributes with namespaces cannot be accessed with this method. To access
  # namespaced attributes, use #attribute_with_ns.
  #
  # [Returns] (String, nil) value of the attribute +name+, or +nil+ if no matching attribute exists
  #
  # *Example*
  #
  #   doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
  #   child = doc.at_css("child")
  #   child["size"] # => "large"
  #   child["class"] # => "big wide tall"
  #
  # *Example:* Namespaced attributes will not be returned.
  #
  # ⚠ Note namespaced attributes may be accessed with #attribute or #attribute_with_ns
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'>
  #       <child width:size='broad'/>
  #     </root>
  #   EOF
  #   doc.at_css("child")["size"] # => nil
  #   doc.at_css("child").attribute("size").value # => "broad"
  #   doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
  #   # => "broad"
  def [](name); end

  # :call-seq: []=(name, value) → value
  #
  # Update the attribute +name+ to +value+, or create the attribute if it does not exist.
  #
  # ⚠ Note that attributes with namespaces cannot be accessed with this method. To access
  # namespaced attributes for update, use #attribute_with_ns. To add a namespaced attribute,
  # see the example below.
  #
  # [Returns] +value+
  #
  # *Example*
  #
  #   doc = Nokogiri::XML("<root><child/></root>")
  #   child = doc.at_css("child")
  #   child["size"] = "broad"
  #   child.to_html
  #   # => "<child size=\"broad\"></child>"
  #
  # *Example:* Add a namespaced attribute.
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'>
  #       <child/>
  #     </root>
  #   EOF
  #   child = doc.at_css("child")
  #   child["size"] = "broad"
  #   ns = doc.root.namespace_definitions.find { |ns| ns.prefix == "width" }
  #   child.attribute("size").namespace = ns
  #   doc.to_html
  #   # => "<root xmlns:width=\"http://example.com/widths\">\n" +
  #   #    "  <child width:size=\"broad\"></child>\n" +
  #   #    "</root>\n"
  def []=(name, value); end

  # Accept a visitor.  This method calls "visit" on +visitor+ with self.
  def accept(visitor); end

  # Add +node_or_tags+ as a child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +<<+.
  def add_child(node_or_tags); end

  # :call-seq: add_class(names) → self
  #
  # Ensure HTML CSS classes are present on +self+. Any CSS classes in +names+ that already exist
  # in the "class" attribute are _not_ added. Note that any existing duplicates in the
  # "class" attribute are not removed. Compare with #append_class.
  #
  # This is a convenience function and is equivalent to:
  #
  #   node.kwattr_add("class", names)
  #
  # See related: #kwattr_add, #classes, #append_class, #remove_class
  #
  # [Parameters]
  # - +names+ (String, Array<String>)
  #
  #   CSS class names to be added to the Node's "class" attribute. May be a string containing
  #   whitespace-delimited names, or an Array of String names. Any class names already present
  #   will not be added. Any class names not present will be added. If no "class" attribute
  #   exists, one is created.
  #
  # [Returns] +self+ (Node) for ease of chaining method calls.
  #
  # *Example:* Ensure that the node has CSS class "section"
  #
  #   node                      # => <div></div>
  #   node.add_class("section") # => <div class="section"></div>
  #   node.add_class("section") # => <div class="section"></div> # duplicate not added
  #
  # *Example:* Ensure that the node has CSS classes "section" and "header", via a String argument
  #
  # Note that the CSS class "section" is not added because it is already present.
  # Note also that the pre-existing duplicate CSS class "section" is not removed.
  #
  #   node                             # => <div class="section section"></div>
  #   node.add_class("section header") # => <div class="section section header"></div>
  #
  # *Example:* Ensure that the node has CSS classes "section" and "header", via an Array argument
  #
  #   node                                  # => <div></div>
  #   node.add_class(["section", "header"]) # => <div class="section header"></div>
  def add_class(names); end

  def add_namespace(_arg0, _arg1); end
  def add_namespace_definition(_arg0, _arg1); end

  # Insert +node_or_tags+ after this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +after+.
  #
  # @raise [ArgumentError]
  def add_next_sibling(node_or_tags); end

  # Insert +node_or_tags+ before this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +before+.
  #
  # @raise [ArgumentError]
  def add_previous_sibling(node_or_tags); end

  # Insert +node_or_tags+ after this node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +add_next_sibling+.
  def after(node_or_tags); end

  # Get a list of ancestor Node for this Node.  If +selector+ is given,
  # the ancestors must match +selector+
  def ancestors(selector = T.unsafe(nil)); end

  # :call-seq: append_class(names) → self
  #
  # Add HTML CSS classes to +self+, regardless of duplication. Compare with #add_class.
  #
  # This is a convenience function and is equivalent to:
  #
  #   node.kwattr_append("class", names)
  #
  # See related: #kwattr_append, #classes, #add_class, #remove_class
  #
  # [Parameters]
  # - +names+ (String, Array<String>)
  #
  #   CSS class names to be appended to the Node's "class" attribute. May be a string containing
  #   whitespace-delimited names, or an Array of String names. All class names passed in will be
  #   appended to the "class" attribute even if they are already present in the attribute
  #   value. If no "class" attribute exists, one is created.
  #
  # [Returns] +self+ (Node) for ease of chaining method calls.
  #
  # *Example:* Append "section" to the node's CSS "class" attribute
  #
  #   node                         # => <div></div>
  #   node.append_class("section") # => <div class="section"></div>
  #   node.append_class("section") # => <div class="section section"></div> # duplicate added!
  #
  # *Example:* Append "section" and "header" to the noded's CSS "class" attribute, via a String argument
  #
  # Note that the CSS class "section" is appended even though it is already present
  #
  #   node                                # => <div class="section section"></div>
  #   node.append_class("section header") # => <div class="section section section header"></div>
  #
  # *Example:* Append "section" and "header" to the node's CSS "class" attribute, via an Array argument
  #
  #   node                                     # => <div></div>
  #   node.append_class(["section", "header"]) # => <div class="section header"></div>
  #   node.append_class(["section", "header"]) # => <div class="section header section header"></div>
  def append_class(names); end

  # :call-seq: [](name) → (String, nil)
  #
  # Fetch an attribute from this node.
  #
  # ⚠ Note that attributes with namespaces cannot be accessed with this method. To access
  # namespaced attributes, use #attribute_with_ns.
  #
  # [Returns] (String, nil) value of the attribute +name+, or +nil+ if no matching attribute exists
  #
  # *Example*
  #
  #   doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
  #   child = doc.at_css("child")
  #   child["size"] # => "large"
  #   child["class"] # => "big wide tall"
  #
  # *Example:* Namespaced attributes will not be returned.
  #
  # ⚠ Note namespaced attributes may be accessed with #attribute or #attribute_with_ns
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'>
  #       <child width:size='broad'/>
  #     </root>
  #   EOF
  #   doc.at_css("child")["size"] # => nil
  #   doc.at_css("child").attribute("size").value # => "broad"
  #   doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
  #   # => "broad"
  def attr(name); end

  def attribute(_arg0); end
  def attribute_nodes; end
  def attribute_with_ns(_arg0, _arg1); end

  # :call-seq: attributes() → Hash<String ⇒ Nokogiri::XML::Attr>
  #
  # Fetch this node's attributes.
  #
  # ⚠ Because the keys do not include any namespace information for the attribute, in case of a
  # simple name collision, not all attributes will be returned. In this case, you will need to
  # use #attribute_nodes.
  #
  # [Returns]
  #   Hash containing attributes belonging to +self+. The hash keys are String attribute
  #   names (without the namespace), and the hash values are Nokogiri::XML::Attr.
  #
  # *Example* with no namespaces:
  #
  #   doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
  #   doc.at_css("child").attributes
  #   # => {"size"=>#(Attr:0x550 { name = "size", value = "large" }),
  #   #     "class"=>#(Attr:0x564 { name = "class", value = "big wide tall" })}
  #
  # *Example* with a namespace:
  #
  #   doc = Nokogiri::XML("<root xmlns:desc='http://example.com/sizes'><child desc:size='large'/></root>")
  #   doc.at_css("child").attributes
  #   # => {"size"=>
  #   #      #(Attr:0x550 {
  #   #        name = "size",
  #   #        namespace = #(Namespace:0x564 {
  #   #          prefix = "desc",
  #   #          href = "http://example.com/sizes"
  #   #          }),
  #   #        value = "large"
  #   #        })}
  #
  # *Example* with an attribute name collision:
  #
  # ⚠ Note that only one of the attributes is returned in the Hash.
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'
  #           xmlns:height='http://example.com/heights'>
  #       <child width:size='broad' height:size='tall'/>
  #     </root>
  #   EOF
  #   doc.at_css("child").attributes
  #   # => {"size"=>
  #   #      #(Attr:0x550 {
  #   #        name = "size",
  #   #        namespace = #(Namespace:0x564 {
  #   #          prefix = "height",
  #   #          href = "http://example.com/heights"
  #   #          }),
  #   #        value = "tall"
  #   #        })}
  def attributes; end

  # Insert +node_or_tags+ before this node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +add_previous_sibling+.
  def before(node_or_tags); end

  def blank?; end

  # Canonicalize the Node. Return a new instance of this node
  # which is canonicalized and marked as such
  #
  # @option options
  # @option options
  # @param options [Hash{Symbol => Object}]
  def c14nxl(options = T.unsafe(nil)); end

  def canonicalize(mode = T.unsafe(nil), inclusive_namespaces = T.unsafe(nil), with_comments = T.unsafe(nil)); end

  # Returns true if this is a CDATA
  #
  # @return [Boolean]
  def cdata?; end

  def child; end
  def children; end

  # Set the inner html for this Node +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Also see related method +inner_html=+
  def children=(node_or_tags); end

  # :call-seq: classes() → Array<String>
  #
  # Fetch CSS class names of a Node.
  #
  # This is a convenience function and is equivalent to:
  #
  #   node.kwattr_values("class")
  #
  # See related: #kwattr_values, #add_class, #append_class, #remove_class
  #
  # [Returns]
  #   The CSS classes (Array of String) present in the Node's "class" attribute. If the
  #   attribute is empty or non-existent, the return value is an empty array.
  #
  # *Example*
  #
  #   node         # => <div class="section title header"></div>
  #   node.classes # => ["section", "title", "header"]
  def classes; end

  def clone(*_arg0); end

  # Returns true if this is a Comment
  #
  # @return [Boolean]
  def comment?; end

  def content; end

  # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
  def content=(string); end

  def create_external_subset(_arg0, _arg1, _arg2); end
  def create_internal_subset(_arg0, _arg1, _arg2); end

  # Get the path to this node as a CSS expression
  def css_path; end

  # Decorate this node with the decorators set up in this node's Document
  def decorate!; end

  # Adds a default namespace supplied as a string +url+ href, to self.
  # The consequence is as an xmlns attribute with supplied argument were
  # present in parsed XML.  A default namespace set with this method will
  # now show up in #attributes, but when this node is serialized to XML an
  # "xmlns" attribute will appear. See also #namespace and #namespace=
  def default_namespace=(url); end

  # Remove the attribute named +name+
  def delete(name); end

  # Fetch the Nokogiri::HTML4::ElementDescription for this node.  Returns
  # nil on XML documents and on unknown tags.
  def description; end

  # Do xinclude substitution on the subtree below node. If given a block, a
  # Nokogiri::XML::ParseOptions object initialized from +options+, will be
  # passed to it, allowing more convenient modification of the parser options.
  #
  # @yield [options]
  def do_xinclude(options = T.unsafe(nil)); end

  def document; end

  # Returns true if this is a Document
  #
  # @return [Boolean]
  def document?; end

  def dup(*_arg0); end

  # Iterate over each attribute name and value pair for this Node.
  def each; end

  # Returns true if this is an Element node
  #
  # @return [Boolean]
  def elem?; end

  # Returns true if this is an Element node
  #
  # @return [Boolean]
  def element?; end

  def element_children; end
  def elements; end
  def encode_special_chars(_arg0); end
  def external_subset; end
  def first_element_child; end

  # Create a DocumentFragment containing +tags+ that is relative to _this_
  # context node.
  def fragment(tags); end

  # Returns true if this is a DocumentFragment
  #
  # @return [Boolean]
  def fragment?; end

  # :call-seq: [](name) → (String, nil)
  #
  # Fetch an attribute from this node.
  #
  # ⚠ Note that attributes with namespaces cannot be accessed with this method. To access
  # namespaced attributes, use #attribute_with_ns.
  #
  # [Returns] (String, nil) value of the attribute +name+, or +nil+ if no matching attribute exists
  #
  # *Example*
  #
  #   doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
  #   child = doc.at_css("child")
  #   child["size"] # => "large"
  #   child["class"] # => "big wide tall"
  #
  # *Example:* Namespaced attributes will not be returned.
  #
  # ⚠ Note namespaced attributes may be accessed with #attribute or #attribute_with_ns
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'>
  #       <child width:size='broad'/>
  #     </root>
  #   EOF
  #   doc.at_css("child")["size"] # => nil
  #   doc.at_css("child").attribute("size").value # => "broad"
  #   doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
  #   # => "broad"
  def get_attribute(name); end

  def has_attribute?(_arg0); end

  # Returns true if this is an HTML4::Document or HTML5::Document node
  #
  # @return [Boolean]
  def html?; end

  # Get the inner_html for this node's Node#children
  def inner_html(options = T.unsafe(nil)); end

  # Set the inner html for this Node to +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Also see related method +children=+
  def inner_html=(node_or_tags); end

  # :section:
  def inner_text; end

  def internal_subset; end
  def key?(_arg0); end

  # Get the attribute names for this Node.
  def keys; end

  # :call-seq:
  #   kwattr_add(attribute_name, keywords) → self
  #
  # Ensure that values are present in a keyword attribute.
  #
  # Any values in +keywords+ that already exist in the Node's attribute values are _not_
  # added. Note that any existing duplicates in the attribute values are not removed. Compare
  # with #kwattr_append.
  #
  # A "keyword attribute" is a node attribute that contains a set of space-delimited
  # values. Perhaps the most familiar example of this is the HTML "class" attribute used to
  # contain CSS classes. But other keyword attributes exist, for instance
  # {the "rel" attribute}[https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel].
  #
  # See also #add_class, #kwattr_values, #kwattr_append, #kwattr_remove
  #
  # [Parameters]
  # - +attribute_name+ (String) The name of the keyword attribute to be modified.
  # - +keywords+ (String, Array<String>)
  #   Keywords to be added to the attribute named +attribute_name+. May be a string containing
  #   whitespace-delimited values, or an Array of String values. Any values already present will
  #   not be added. Any values not present will be added. If the named attribute does not exist,
  #   it is created.
  #
  # [Returns] +self+ (Nokogiri::XML::Node) for ease of chaining method calls.
  #
  # *Example:* Ensure that a +Node+ has "nofollow" in its +rel+ attribute.
  #
  # Note that duplicates are not added.
  #
  #   node                               # => <a></a>
  #   node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a>
  #   node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a>
  #
  # *Example:* Ensure that a +Node+ has "nofollow" and "noreferrer" in its +rel+ attribute, via a
  # String argument.
  #
  #  Note that "nofollow" is not added because it is already present. Note also that the
  #  pre-existing duplicate "nofollow" is not removed.
  #
  #   node                                          # => <a rel="nofollow nofollow"></a>
  #   node.kwattr_add("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>
  #
  # *Example:* Ensure that a +Node+ has "nofollow" and "noreferrer" in its +rel+ attribute, via
  # an Array argument.
  #
  #   node                                               # => <a></a>
  #   node.kwattr_add("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
  #
  # Since v1.11.0
  def kwattr_add(attribute_name, keywords); end

  # :call-seq:
  #   kwattr_append(attribute_name, keywords) → self
  #
  # Add keywords to a Node's keyword attribute, regardless of duplication. Compare with
  # #kwattr_add.
  #
  # A "keyword attribute" is a node attribute that contains a set of space-delimited
  # values. Perhaps the most familiar example of this is the HTML "class" attribute used to
  # contain CSS classes. But other keyword attributes exist, for instance
  # {the "rel" attribute}[https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel].
  #
  # See also #append_class, #kwattr_values, #kwattr_add, #kwattr_remove
  #
  # [Parameters]
  # - +attribute_name+ (String) The name of the keyword attribute to be modified.
  # - +keywords+ (String, Array<String>)
  #   Keywords to be added to the attribute named +attribute_name+. May be a string containing
  #   whitespace-delimited values, or an Array of String values. All values passed in will be
  #   appended to the named attribute even if they are already present in the attribute. If the
  #   named attribute does not exist, it is created.
  #
  # [Returns] +self+ (Node) for ease of chaining method calls.
  #
  # *Example:* Append "nofollow" to the +rel+ attribute.
  #
  # Note that duplicates are added.
  #
  #   node                                  # => <a></a>
  #   node.kwattr_append("rel", "nofollow") # => <a rel="nofollow"></a>
  #   node.kwattr_append("rel", "nofollow") # => <a rel="nofollow nofollow"></a>
  #
  # *Example:* Append "nofollow" and "noreferrer" to the +rel+ attribute, via a String argument.
  #
  # Note that "nofollow" is appended even though it is already present.
  #
  #   node                                             # => <a rel="nofollow"></a>
  #   node.kwattr_append("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>
  #
  #
  # *Example:* Append "nofollow" and "noreferrer" to the +rel+ attribute, via an Array argument.
  #
  #   node                                                  # => <a></a>
  #   node.kwattr_append("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
  #
  # Since v1.11.0
  def kwattr_append(attribute_name, keywords); end

  # :call-seq:
  #   kwattr_remove(attribute_name, keywords) → self
  #
  # Remove keywords from a keyword attribute. Any matching keywords that exist in the named
  # attribute are removed, including any multiple entries.
  #
  # If no keywords remain after this operation, or if +keywords+ is +nil+, the attribute is
  # deleted from the node.
  #
  # A "keyword attribute" is a node attribute that contains a set of space-delimited
  # values. Perhaps the most familiar example of this is the HTML "class" attribute used to
  # contain CSS classes. But other keyword attributes exist, for instance
  # {the "rel" attribute}[https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel].
  #
  # See also #remove_class, #kwattr_values, #kwattr_add, #kwattr_append
  #
  # [Parameters]
  # - +attribute_name+ (String) The name of the keyword attribute to be modified.
  # - +keywords+ (String, Array<String>)
  #   Keywords to be removed from the attribute named +attribute_name+. May be a string
  #   containing whitespace-delimited values, or an Array of String values. Any keywords present
  #   in the named attribute will be removed. If no keywords remain, or if +keywords+ is nil,
  #   the attribute is deleted.
  #
  # [Returns] +self+ (Node) for ease of chaining method calls.
  #
  # *Example:*
  #
  # Note that the +rel+ attribute is deleted when empty.
  #
  #   node                                    # => <a rel="nofollow noreferrer">link</a>
  #   node.kwattr_remove("rel", "nofollow")   # => <a rel="noreferrer">link</a>
  #   node.kwattr_remove("rel", "noreferrer") # => <a>link</a>
  #
  # Since v1.11.0
  def kwattr_remove(attribute_name, keywords); end

  # :call-seq:
  #   kwattr_values(attribute_name) → Array<String>
  #
  # Fetch values from a keyword attribute of a Node.
  #
  # A "keyword attribute" is a node attribute that contains a set of space-delimited
  # values. Perhaps the most familiar example of this is the HTML "class" attribute used to
  # contain CSS classes. But other keyword attributes exist, for instance
  # {the "rel" attribute}[https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel].
  #
  # See also #classes, #kwattr_add, #kwattr_append, #kwattr_remove
  #
  # [Parameters]
  # - +attribute_name+ (String) The name of the keyword attribute to be inspected.
  #
  # [Returns]
  #   (Array<String>) The values present in the Node's +attribute_name+ attribute. If the
  #   attribute is empty or non-existent, the return value is an empty array.
  #
  # *Example:*
  #
  #   node                      # => <a rel="nofollow noopener external">link</a>
  #   node.kwattr_values("rel") # => ["nofollow", "noopener", "external"]
  #
  # Since v1.11.0
  def kwattr_values(attribute_name); end

  def lang; end
  def lang=(_arg0); end
  def last_element_child; end
  def line; end
  def line=(_arg0); end

  # Returns true if this Node matches +selector+
  #
  # @return [Boolean]
  def matches?(selector); end

  def name; end
  def name=(_arg0); end
  def namespace; end

  # Set the default namespace on this node (as would be defined with an
  # "xmlns=" attribute in XML source), as a Namespace object +ns+. Note that
  # a Namespace added this way will NOT be serialized as an xmlns attribute
  # for this node. You probably want #default_namespace= instead, or perhaps
  # #add_namespace_definition with a nil prefix argument.
  def namespace=(ns); end

  def namespace_definitions; end
  def namespace_scopes; end
  def namespaced_key?(_arg0, _arg1); end

  # :call-seq:
  #   namespaces() → Hash<String(Namespace#prefix) ⇒ String(Namespace#href)>
  #
  # Fetch all the namespaces on this node and its ancestors.
  #
  # Note that the keys in this hash XML attributes that would be used to define this namespace,
  # such as "xmlns:prefix", not just the prefix.
  #
  # The default namespace for this node will be included with key "xmlns".
  #
  # See also #namespace_scopes
  #
  # [Returns]
  #   Hash containing all the namespaces on this node and its ancestors. The hash keys are the
  #   namespace prefix, and the hash value for each key is the namespace URI.
  #
  # *Example:*
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns="http://example.com/root" xmlns:in_scope="http://example.com/in_scope">
  #       <first/>
  #       <second xmlns="http://example.com/child"/>
  #       <third xmlns:foo="http://example.com/foo"/>
  #     </root>
  #   EOF
  #   doc.at_xpath("//root:first", "root" => "http://example.com/root").namespaces
  #   # => {"xmlns"=>"http://example.com/root",
  #   #     "xmlns:in_scope"=>"http://example.com/in_scope"}
  #   doc.at_xpath("//child:second", "child" => "http://example.com/child").namespaces
  #   # => {"xmlns"=>"http://example.com/child",
  #   #     "xmlns:in_scope"=>"http://example.com/in_scope"}
  #   doc.at_xpath("//root:third", "root" => "http://example.com/root").namespaces
  #   # => {"xmlns:foo"=>"http://example.com/foo",
  #   #     "xmlns"=>"http://example.com/root",
  #   #     "xmlns:in_scope"=>"http://example.com/in_scope"}
  def namespaces; end

  def native_content=(_arg0); end
  def next; end

  # Insert +node_or_tags+ after this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +after+.
  #
  # @raise [ArgumentError]
  def next=(node_or_tags); end

  def next_element; end
  def next_sibling; end
  def node_name; end
  def node_name=(_arg0); end
  def node_type; end
  def parent; end

  # Set the parent Node for this Node
  def parent=(parent_node); end

  # Parse +string_or_io+ as a document fragment within the context of
  # *this* node.  Returns a XML::NodeSet containing the nodes parsed from
  # +string_or_io+.
  #
  # @yield [options]
  def parse(string_or_io, options = T.unsafe(nil)); end

  def path; end
  def pointer_id; end

  # Add +node_or_tags+ as the first child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +add_child+.
  def prepend_child(node_or_tags); end

  def previous; end

  # Insert +node_or_tags+ before this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +before+.
  #
  # @raise [ArgumentError]
  def previous=(node_or_tags); end

  def previous_element; end
  def previous_sibling; end

  # Returns true if this is a ProcessingInstruction node
  #
  # @return [Boolean]
  def processing_instruction?; end

  # Is this a read only node?
  #
  # @return [Boolean]
  def read_only?; end

  def remove; end

  # Remove the attribute named +name+
  def remove_attribute(name); end

  # :call-seq:
  #   remove_class(css_classes) → self
  #
  # Remove HTML CSS classes from this node. Any CSS class names in +css_classes+ that exist in
  # this node's "class" attribute are removed, including any multiple entries.
  #
  # If no CSS classes remain after this operation, or if +css_classes+ is +nil+, the "class"
  # attribute is deleted from the node.
  #
  # This is a convenience function and is equivalent to:
  #
  #   node.kwattr_remove("class", css_classes)
  #
  # Also see #kwattr_remove, #classes, #add_class, #append_class
  #
  # [Parameters]
  # - +css_classes+ (String, Array<String>)
  #
  #   CSS class names to be removed from the Node's
  #   "class" attribute. May be a string containing whitespace-delimited names, or an Array of
  #   String names. Any class names already present will be removed. If no CSS classes remain,
  #   the "class" attribute is deleted.
  #
  # [Returns] +self+ (Nokogiri::XML::Node) for ease of chaining method calls.
  #
  # *Example*: Deleting a CSS class
  #
  # Note that all instances of the class "section" are removed from the "class" attribute.
  #
  #   node                         # => <div class="section header section"></div>
  #   node.remove_class("section") # => <div class="header"></div>
  #
  # *Example*: Deleting the only remaining CSS class
  #
  # Note that the attribute is removed once there are no remaining classes.
  #
  #   node                         # => <div class="section"></div>
  #   node.remove_class("section") # => <div></div>
  #
  # *Example*: Deleting multiple CSS classes
  #
  # Note that the "class" attribute is deleted once it's empty.
  #
  #   node                                    # => <div class="section header float"></div>
  #   node.remove_class(["section", "float"]) # => <div class="header"></div>
  def remove_class(names = T.unsafe(nil)); end

  # Replace this Node with +node_or_tags+.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +swap+.
  def replace(node_or_tags); end

  # Serialize Node using +options+. Save options can also be set using a block.
  #
  # See also Nokogiri::XML::Node::SaveOptions and Node@Serialization+and+Generating+Output.
  #
  # These two statements are equivalent:
  #
  #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
  #
  # or
  #
  #   node.serialize(:encoding => 'UTF-8') do |config|
  #     config.format.as_xml
  #   end
  def serialize(*args, &block); end

  # :call-seq: []=(name, value) → value
  #
  # Update the attribute +name+ to +value+, or create the attribute if it does not exist.
  #
  # ⚠ Note that attributes with namespaces cannot be accessed with this method. To access
  # namespaced attributes for update, use #attribute_with_ns. To add a namespaced attribute,
  # see the example below.
  #
  # [Returns] +value+
  #
  # *Example*
  #
  #   doc = Nokogiri::XML("<root><child/></root>")
  #   child = doc.at_css("child")
  #   child["size"] = "broad"
  #   child.to_html
  #   # => "<child size=\"broad\"></child>"
  #
  # *Example:* Add a namespaced attribute.
  #
  #   doc = Nokogiri::XML(<<~EOF)
  #     <root xmlns:width='http://example.com/widths'>
  #       <child/>
  #     </root>
  #   EOF
  #   child = doc.at_css("child")
  #   child["size"] = "broad"
  #   ns = doc.root.namespace_definitions.find { |ns| ns.prefix == "width" }
  #   child.attribute("size").namespace = ns
  #   doc.to_html
  #   # => "<root xmlns:width=\"http://example.com/widths\">\n" +
  #   #    "  <child width:size=\"broad\"></child>\n" +
  #   #    "</root>\n"
  def set_attribute(name, value); end

  # Swap this Node for +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +replace+.
  def swap(node_or_tags); end

  def text; end

  # Returns true if this is a Text node
  #
  # @return [Boolean]
  def text?; end

  # Serialize this Node to HTML
  #
  #   doc.to_html
  #
  # See Node#write_to for a list of +options+.  For formatted output,
  # use Node#to_xhtml instead.
  def to_html(options = T.unsafe(nil)); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end

  # Turn this node in to a string.  If the document is HTML, this method
  # returns html.  If the document is XML, this method returns XML.
  def to_s_without_c14nxl; end

  def to_str; end

  # Serialize this Node to XHTML using +options+
  #
  #   doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
  #
  # See Node#write_to for a list of +options+
  def to_xhtml(options = T.unsafe(nil)); end

  # Serialize this Node to XML using +options+
  #
  #   doc.to_xml(:indent => 5, :encoding => 'UTF-8')
  #
  # See Node#write_to for a list of +options+
  def to_xml(options = T.unsafe(nil)); end

  # Yields self and all children to +block+ recursively.
  #
  # @yield [_self]
  # @yieldparam _self [Nokogiri::XML::Node] the object that the method was called on
  def traverse(&block); end

  def type; end
  def unlink; end

  # Does this Node's attributes include <value>
  #
  # @return [Boolean]
  def value?(value); end

  # Get the attribute values for this Node.
  def values; end

  # Add html around this node
  #
  # Returns self
  def wrap(html); end

  # Write Node as HTML to +io+ with +options+
  #
  # See Node#write_to for a list of +options+
  def write_html_to(io, options = T.unsafe(nil)); end

  # Write Node to +io+ with +options+. +options+ modify the output of
  # this method.  Valid options are:
  #
  # * +:encoding+ for changing the encoding
  # * +:indent_text+ the indentation text, defaults to one space
  # * +:indent+ the number of +:indent_text+ to use, defaults to 2
  # * +:save_with+ a combination of SaveOptions constants.
  #
  # To save with UTF-8 indented twice:
  #
  #   node.write_to(io, :encoding => 'UTF-8', :indent => 2)
  #
  # To save indented with two dashes:
  #
  #   node.write_to(io, :indent_text => '-', :indent => 2)
  #
  # @yield [config]
  def write_to(io, *options); end

  # Write Node as XHTML to +io+ with +options+
  #
  # See Node#write_to for a list of +options+
  def write_xhtml_to(io, options = T.unsafe(nil)); end

  # Write Node as XML to +io+ with +options+
  #
  #   doc.write_xml_to io, :encoding => 'UTF-8'
  #
  # See Node#write_to for a list of options
  def write_xml_to(io, options = T.unsafe(nil)); end

  # Returns true if this is an XML::Document node
  #
  # @return [Boolean]
  def xml?; end

  protected

  # @raise [ArgumentError]
  def coerce(data); end

  private

  def add_child_node(_arg0); end
  def add_child_node_and_reparent_attrs(node); end
  def add_next_sibling_node(_arg0); end
  def add_previous_sibling_node(_arg0); end
  def add_sibling(next_or_previous, node_or_tags); end
  def compare(_arg0); end
  def dump_html; end
  def get(_arg0); end
  def in_context(_arg0, _arg1); end
  def inspect_attributes; end
  def keywordify(keywords); end
  def native_write_to(_arg0, _arg1, _arg2, _arg3); end
  def process_xincludes(_arg0); end
  def replace_node(_arg0); end
  def set(_arg0, _arg1); end
  def set_namespace(_arg0); end
  def to_format(save_option, options); end
  def write_format_to(save_option, io, options); end

  class << self
    def new(*_arg0); end
  end
end

# Attribute declaration type
Nokogiri::XML::Node::ATTRIBUTE_DECL = T.let(T.unsafe(nil), Integer)

# Attribute node type
Nokogiri::XML::Node::ATTRIBUTE_NODE = T.let(T.unsafe(nil), Integer)

# CDATA node type, see Nokogiri::XML::Node#cdata?
Nokogiri::XML::Node::CDATA_SECTION_NODE = T.let(T.unsafe(nil), Integer)

# Comment node type, see Nokogiri::XML::Node#comment?
Nokogiri::XML::Node::COMMENT_NODE = T.let(T.unsafe(nil), Integer)

# DOCB document node type
Nokogiri::XML::Node::DOCB_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# Document fragment node type
Nokogiri::XML::Node::DOCUMENT_FRAG_NODE = T.let(T.unsafe(nil), Integer)

# Document node type, see Nokogiri::XML::Node#xml?
Nokogiri::XML::Node::DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# Document type node type
Nokogiri::XML::Node::DOCUMENT_TYPE_NODE = T.let(T.unsafe(nil), Integer)

# DTD node type
Nokogiri::XML::Node::DTD_NODE = T.let(T.unsafe(nil), Integer)

# Element declaration type
Nokogiri::XML::Node::ELEMENT_DECL = T.let(T.unsafe(nil), Integer)

# Element node type, see Nokogiri::XML::Node#element?
Nokogiri::XML::Node::ELEMENT_NODE = T.let(T.unsafe(nil), Integer)

# Entity declaration type
Nokogiri::XML::Node::ENTITY_DECL = T.let(T.unsafe(nil), Integer)

# Entity node type
Nokogiri::XML::Node::ENTITY_NODE = T.let(T.unsafe(nil), Integer)

# Entity reference node type
Nokogiri::XML::Node::ENTITY_REF_NODE = T.let(T.unsafe(nil), Integer)

# HTML document node type, see Nokogiri::XML::Node#html?
Nokogiri::XML::Node::HTML_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

Nokogiri::XML::Node::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)

# Namespace declaration type
Nokogiri::XML::Node::NAMESPACE_DECL = T.let(T.unsafe(nil), Integer)

# Notation node type
Nokogiri::XML::Node::NOTATION_NODE = T.let(T.unsafe(nil), Integer)

# PI node type
Nokogiri::XML::Node::PI_NODE = T.let(T.unsafe(nil), Integer)

# Text node type, see Nokogiri::XML::Node#text?
Nokogiri::XML::Node::TEXT_NODE = T.let(T.unsafe(nil), Integer)

# XInclude end type
Nokogiri::XML::Node::XINCLUDE_END = T.let(T.unsafe(nil), Integer)

# XInclude start type
Nokogiri::XML::Node::XINCLUDE_START = T.let(T.unsafe(nil), Integer)

# A NodeSet contains a list of Nokogiri::XML::Node objects.  Typically
# a NodeSet is return as a result of searching a Document via
# Nokogiri::XML::Searchable#css or Nokogiri::XML::Searchable#xpath
class Nokogiri::XML::NodeSet
  # Create a NodeSet with +document+ defaulting to +list+
  #
  # @return [NodeSet] a new instance of NodeSet
  # @yield [_self]
  # @yieldparam _self [Nokogiri::XML::NodeSet] the object that the method was called on
  def initialize(document, list = T.unsafe(nil)); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  #
  # Or, if passed an integer, index into the NodeSet:
  #
  #   node_set.at(3) # same as node_set[3]
  def %(*args); end

  def &(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end

  # Equality -- Two NodeSets are equal if the contain the same number
  # of elements and if each element is equal to the corresponding
  # element in the other NodeSet
  def ==(other); end

  def [](*_arg0); end

  # Add the class attribute +name+ to all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#add_class for more information.
  def add_class(name); end

  # Insert +datum+ after the last Node in this NodeSet
  def after(datum); end

  # Append the class attribute +name+ to all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#append_class for more information.
  def append_class(name); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  #
  # Or, if passed an integer, index into the NodeSet:
  #
  #   node_set.at(3) # same as node_set[3]
  def at(*args); end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def attr(key, value = T.unsafe(nil), &block); end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def attribute(key, value = T.unsafe(nil), &block); end

  # Insert +datum+ before the first Node in this NodeSet
  def before(datum); end

  # Canonicalize the NodeSet. Return a new NodeSet marked
  # as being canonical with all child nodes canonicalized.
  #
  # @param options [Hash{Symbol => Object}] Passed to `Nokogiri::XML::Node#c14nxl`
  def c14nxl(options = T.unsafe(nil)); end

  # Returns a new NodeSet containing all the children of all the nodes in
  # the NodeSet
  def children; end

  def clone; end

  # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
  #
  # Search this node set for CSS +rules+. +rules+ must be one or more CSS
  # selectors. For example:
  #
  # For more information see Nokogiri::XML::Searchable#css
  def css(*args); end

  def delete(_arg0); end

  # The Document this NodeSet is associated with
  def document; end

  # The Document this NodeSet is associated with
  def document=(_arg0); end

  def dup; end

  # Iterate over each node, yielding  to +block+
  def each; end

  # Is this NodeSet empty?
  #
  # @return [Boolean]
  def empty?; end

  # Filter this list for nodes that match +expr+
  def filter(expr); end

  # Get the first element of the NodeSet.
  def first(n = T.unsafe(nil)); end

  def include?(_arg0); end

  # Returns the index of the first node in self that is == to +node+ or meets the given block. Returns nil if no match is found.
  def index(node = T.unsafe(nil)); end

  # Get the inner html of all contained Node objects
  def inner_html(*args); end

  # Get the inner text of all contained Node objects
  #
  # Note: This joins the text of all Node objects in the NodeSet:
  #
  #    doc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')
  #    doc.css('d').text # => "foobar"
  #
  # Instead, if you want to return the text of all nodes in the NodeSet:
  #
  #    doc.css('d').map(&:text) # => ["foo", "bar"]
  #
  # See Nokogiri::XML::Node#content for more information.
  def inner_text; end

  # Return a nicely formated string representation
  def inspect; end

  # Get the last element of the NodeSet.
  def last; end

  def length; end

  # Removes the last element from set and returns it, or +nil+ if
  # the set is empty
  def pop; end

  def push(_arg0); end
  def remove; end

  # Remove the attributed named +name+ from all Node objects in the NodeSet
  def remove_attr(name); end

  # Remove the attributed named +name+ from all Node objects in the NodeSet
  def remove_attribute(name); end

  # Remove the class attribute +name+ from all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#remove_class for more information.
  def remove_class(name = T.unsafe(nil)); end

  # Returns a new NodeSet containing all the nodes in the NodeSet
  # in reverse order
  def reverse; end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def set(key, value = T.unsafe(nil), &block); end

  # Returns the first element of the NodeSet and removes it.  Returns
  # +nil+ if the set is empty.
  def shift; end

  def size; end
  def slice(*_arg0); end

  # Get the inner text of all contained Node objects
  #
  # Note: This joins the text of all Node objects in the NodeSet:
  #
  #    doc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')
  #    doc.css('d').text # => "foobar"
  #
  # Instead, if you want to return the text of all nodes in the NodeSet:
  #
  #    doc.css('d').map(&:text) # => ["foo", "bar"]
  #
  # See Nokogiri::XML::Node#content for more information.
  def text; end

  def to_a; end
  def to_ary; end

  # Convert this NodeSet to HTML
  def to_html(*args); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end

  # Convert this NodeSet to a string.
  def to_s_without_c14nxl; end

  # Convert this NodeSet to XHTML
  def to_xhtml(*args); end

  # Convert this NodeSet to XML
  def to_xml(*args); end

  def unlink; end

  # Wrap this NodeSet with +html+
  def wrap(html); end

  # call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]
  #
  # Search this node set for XPath +paths+. +paths+ must be one or more XPath
  # queries.
  #
  # For more information see Nokogiri::XML::Searchable#xpath
  def xpath(*args); end

  def |(_arg0); end
end

Nokogiri::XML::NodeSet::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)

# Original C14N 1.0 spec canonicalization
Nokogiri::XML::XML_C14N_1_0 = T.let(T.unsafe(nil), Integer)

# C14N 1.1 spec canonicalization
Nokogiri::XML::XML_C14N_1_1 = T.let(T.unsafe(nil), Integer)

# Exclusive C14N 1.0 spec canonicalization
Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0 = T.let(T.unsafe(nil), Integer)

module RDF
  class << self
    # Alias for `RDF::Graph.new`.
    #
    # @param graph_name [RDF::Resource] The graph_name from the associated {RDF::Queryable} associated
    #   with this graph as provided with the `:data` option
    #   (only for {RDF::Queryable} instances supporting
    #   named graphs).
    # @param data [RDF::Queryable] (RDF::Repository.new)
    #   Storage behind this graph.
    # @return [RDF::Graph]
    def Graph(**options, &block); end

    # @overload List
    # @overload List
    # @overload List
    # @overload List
    def List(*args); end

    # Alias for `RDF::Literal.new`.
    #
    # @param value [Object]
    # @param language [Symbol] (nil)
    #   Language is downcased to ensure proper matching
    # @param lexical [String] (nil)
    #   Supplied lexical representation of this literal,
    #   otherwise it comes from transforming `value` to a string form..
    # @param datatype [URI] (nil)
    # @param validate [Boolean] (false)
    # @param canonicalize [Boolean] (false)
    # @return [RDF::Literal]
    def Literal(literal, **options); end

    # Alias for `RDF::Node.new`.
    #
    # @param id [#to_s]
    # @return [RDF::Node]
    def Node(*args); end

    # Alias for `RDF::Resource.new`.
    #
    # @return [RDF::Resource]
    def Resource(*args); end

    # @overload Statement
    # @overload Statement
    # @overload Statement
    def Statement(*args, **options); end

    # Alias for `RDF::StrictVocabulary.create`.
    #
    # @param uri [RDF::URI, String, #to_s]
    # @return [Class]
    def StrictVocabulary(uri); end

    # Cast to a URI. If already a URI, return the passed argument.
    #
    # @return [RDF::URI]
    def URI(*args); end

    # Alias for `RDF::Vocabulary.create`.
    #
    # @param uri [RDF::URI, String, #to_s]
    # @return [Class]
    def Vocabulary(uri); end

    # @return [#to_s] property
    # @return [URI]
    def [](property); end

    # Configuration, used open for configuring constants used within the codebase.
    #
    # Defaults:
    #   * `cache_size`: -1
    #   * `uri_cache_size`: `cache_size`
    #   * `node_cache_size`: `cache_size`
    #
    # @example set default cache size to be at most 10,000 entries
    #
    #   RDF.config.cache_size = 10_000
    # @example set cache size for interned URIs to 5,000 entries
    #
    #   RDF.config.uri_cache_size = 5_000
    # @note cache configurations must be set before initial use, when the caches are allocated.
    # @return [Object]
    # @see RDF::Util::Cache.new
    def config; end

    # Return an enumerator over {RDF::Statement} defined for this vocabulary.
    #
    # @return [RDF::Enumerable::Enumerator]
    # @see Object#enum_for
    def enum_for(method = T.unsafe(nil), *args); end

    # Delegate other methods to RDF::RDFV
    def method_missing(property, *args, &block); end

    # respond to module or RDFV
    #
    # @return [Boolean]
    def respond_to?(method, include_all = T.unsafe(nil)); end

    # Return an enumerator over {RDF::Statement} defined for this vocabulary.
    #
    # @return [RDF::Enumerable::Enumerator]
    # @see Object#enum_for
    def to_enum(method = T.unsafe(nil), *args); end
  end
end

# RDF::IRI is a synonym for RDF::URI
RDF::IRI = RDF::URI

# An RDF literal.
#
# Subclasses of {RDF::Literal} should define DATATYPE and GRAMMAR constants, which are used for identifying the appropriate class to use for a datatype URI and to perform lexical matching on the value.
#
# Literal comparison with other {RDF::Value} instances call {RDF::Value#type_error}, which, returns false. Implementations wishing to have {RDF::TypeError} raised should mix-in {RDF::TypeCheck}. This is required for strict SPARQL conformance.
#
# Specific typed literals may have behavior different from the default implementation. See the following defined sub-classes for specific documentation. Additional sub-classes may be defined, and will interoperate by defining `DATATYPE` and `GRAMMAR` constants, in addition other required overrides of RDF::Literal behavior.
#
# In RDF 1.1, all literals are typed, including plain literals and language tagged literals. Internally, plain literals are given the `xsd:string` datatype and language tagged literals are given the `rdf:langString` datatype. Creating a plain literal, without a datatype or language, will automatically provide the `xsd:string` datatype; similar for language tagged literals. Note that most serialization formats will remove this datatype. Code which depends on a literal having the `xsd:string` datatype being different from a plain literal (formally, without a datatype) may break. However note that the `#has\_datatype?` will continue to return `false` for plain or language-tagged literals.
#
# * {RDF::Literal::Boolean}
# * {RDF::Literal::Date}
# * {RDF::Literal::DateTime}
# * {RDF::Literal::Decimal}
# * {RDF::Literal::Double}
# * {RDF::Literal::Integer}
# * {RDF::Literal::Time}
#
# @example Creating a plain literal
#   value = RDF::Literal.new("Hello, world!")
#   value.plain?                                   #=> true`
# @example Creating a language-tagged literal (1)
#   value = RDF::Literal.new("Hello!", language: :en)
#   value.language?                                #=> true
#   value.language                                 #=> :en
# @example Creating a language-tagged literal (2)
#   RDF::Literal.new("Wazup?", language: :"en-US")
#   RDF::Literal.new("Hej!",   language: :sv)
#   RDF::Literal.new("¡Hola!", language: :es)
# @example Creating an explicitly datatyped literal
#   value = RDF::Literal.new("2009-12-31", datatype: RDF::XSD.date)
#   value.datatype?                                #=> true
#   value.datatype                                 #=> RDF::XSD.date
# @example Creating an implicitly datatyped literal
#   value = RDF::Literal.new(Date.today)
#   value.datatype?                                #=> true
#   value.datatype                                 #=> RDF::XSD.date
# @example Creating implicitly datatyped literals
#   RDF::Literal.new(false).datatype               #=> XSD.boolean
#   RDF::Literal.new(true).datatype                #=> XSD.boolean
#   RDF::Literal.new(123).datatype                 #=> XSD.integer
#   RDF::Literal.new(9223372036854775807).datatype #=> XSD.integer
#   RDF::Literal.new(3.1415).datatype              #=> XSD.double
#   RDF::Literal.new(Time.now).datatype            #=> XSD.dateTime
#   RDF::Literal.new(Date.new(2010)).datatype      #=> XSD.date
#   RDF::Literal.new(DateTime.new(2010)).datatype  #=> XSD.dateTime
# @see http://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal
# @see http://www.w3.org/TR/rdf11-concepts/#section-Datatypes
class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  # Literals without a datatype are given either xsd:string or rdf:langString
  # depending on if there is language
  #
  # @param value [Object]
  # @param language [Symbol] (nil)
  #   Language is downcased to ensure proper matching
  # @param lexical [String] (nil)
  #   Supplied lexical representation of this literal,
  #   otherwise it comes from transforming `value` to a string form..
  # @param datatype [URI] (nil)
  # @param validate [Boolean] (false)
  # @param canonicalize [Boolean] (false)
  # @raise [ArgumentError] if there is a language and datatype is no rdf:langString
  #   or datatype is rdf:langString and there is no language
  # @return [Literal] a new instance of Literal
  # @see http://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal
  # @see http://www.w3.org/TR/rdf11-concepts/#section-Datatypes
  # @see #to_s
  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  # Compares `self` to `other` for sorting purposes (with type check).
  #
  # @param other [Object]
  # @return [Integer] `-1`, `0`, or `1`
  def <=>(other); end

  # Returns `true` if this literal is equivalent to `other` (with type check).
  #
  # @example
  #   RDF::Literal(1) == RDF::Literal(1.0)     #=> true
  # @param other [Object]
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-sparql-query/#func-RDFterm-equal
  # @see http://www.w3.org/TR/rdf-concepts/#section-Literal-Equality
  def ==(other); end

  # Returns `true` if this literal is equivalent to `other` (with type check).
  #
  # @example
  #   RDF::Literal(1) == RDF::Literal(1.0)     #=> true
  # @param other [Object]
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-sparql-query/#func-RDFterm-equal
  # @see http://www.w3.org/TR/rdf-concepts/#section-Literal-Equality
  def ===(other); end

  # Converts this literal into its canonical lexical representation.
  #
  # Subclasses should override this as needed and appropriate.
  #
  # @return [RDF::Literal] `self`
  # @since 0.3.0
  def canonicalize!; end

  # Term compatibility according to SPARQL
  #
  # Compatibility of two arguments is defined as:
  # * The arguments are simple literals or literals typed as xsd:string
  # * The arguments are plain literals with identical language tags
  # * The first argument is a plain literal with language tag and the second argument is a simple literal or literal typed as xsd:string
  #
  # @example
  #   compatible?("abc"	"b")                         #=> true
  #   compatible?("abc"	"b"^^xsd:string)             #=> true
  #   compatible?("abc"^^xsd:string	"b")             #=> true
  #   compatible?("abc"^^xsd:string	"b"^^xsd:string) #=> true
  #   compatible?("abc"@en	"b")                     #=> true
  #   compatible?("abc"@en	"b"^^xsd:string)         #=> true
  #   compatible?("abc"@en	"b"@en)                  #=> true
  #   compatible?("abc"@fr	"b"@ja)                  #=> false
  #   compatible?("abc"	"b"@ja)                      #=> false
  #   compatible?("abc"	"b"@en)                      #=> false
  #   compatible?("abc"^^xsd:string	"b"@en)          #=> false
  # @return [Boolean]
  # @see http://www.w3.org/TR/sparql11-query/#func-arg-compatibility
  # @since 2.0
  def compatible?(other); end

  # Returns `true` if the literals are comperable.
  #
  # Used for <=> operator.
  #
  # @return [Boolean]
  def comperable_datatype2?(other); end

  # Returns `true` if the literal has a datatype and the comparison should
  # return false instead of raise a type error.
  #
  # This behavior is intuited from SPARQL data-r2/expr-equal/eq-2-2
  #
  # @return [Boolean]
  def comperable_datatype?(other); end

  # @return [URI] The XML Schema datatype URI (optional).
  def datatype; end

  # @return [URI] The XML Schema datatype URI (optional).
  def datatype=(_arg0); end

  # Returns `true` if this is a datatyped literal.
  #
  # For historical reasons, this excludes xsd:string and rdf:langString
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-typed-literal
  def datatype?; end

  # Returns `true` if this is a datatyped literal.
  #
  # For historical reasons, this excludes xsd:string and rdf:langString
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-typed-literal
  def datatyped?; end

  # Determins if `self` is the same term as `other`.
  #
  # @example
  #   RDF::Literal(1).eql?(RDF::Literal(1.0))  #=> false
  # @param other [Object]
  # @return [Boolean] `true` or `false`
  def eql?(other); end

  # Escape a literal using ECHAR escapes.
  #
  #    ECHAR ::= '\' [tbnrf"'\]
  #
  # @note N-Triples only requires '\"\n\r' to be escaped.
  # @param string [String]
  # @return [String]
  # @see RDF::Term#escape
  def escape(string); end

  # @private
  def freeze; end

  # Returns `true` if this is a datatyped literal.
  #
  # For historical reasons, this excludes xsd:string and rdf:langString
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-typed-literal
  def has_datatype?; end

  # Returns `true` if this is a language-tagged literal.
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-plain-literal
  def has_language?; end

  # Returns a hash code for this literal.
  #
  # @return [Integer]
  def hash; end

  # Returns a human-readable value for the literal
  #
  # @return [String]
  # @since 1.1.6
  def humanize(lang = T.unsafe(nil)); end

  # Returns a developer-friendly representation of `self`.
  #
  # @return [String]
  def inspect; end

  # @return [Symbol] The language tag (optional).
  def language; end

  # @return [Symbol] The language tag (optional).
  def language=(_arg0); end

  # Returns `true` if this is a language-tagged literal.
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-plain-literal
  def language?; end

  # Returns `true`.
  #
  # @return [Boolean] `true` or `false`
  def literal?; end

  # @return [Object]
  def object; end

  # Returns `true` if this is a plain literal. A plain literal
  # may have a language, but may not have a datatype. For
  # all practical purposes, this includes xsd:string literals
  # too.
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-plain-literal
  def plain?; end

  # Returns `true` if this is a simple literal.
  # A simple literal has no datatype or language.
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/sparql11-query/#simple_literal
  def simple?; end

  # Returns the literal, first removing all whitespace on both ends of the value, and then changing remaining consecutive whitespace groups into one space each.
  #
  # Note that it handles both ASCII and Unicode whitespace.
  #
  # @return [RDF::Literal] a new literal based on `self`.
  # @see [String#squish](http://apidock.com/rails/String/squish)
  def squish(*other_string); end

  # Performs a destructive {#squish}.
  #
  # @return self
  # @see [String#squish!](http://apidock.com/rails/String/squish%21)
  def squish!; end

  # Returns the value as a string.
  #
  # @return [String]
  def to_s; end

  def to_sxp(**options); end

  # Returns `true` if this is a datatyped literal.
  #
  # For historical reasons, this excludes xsd:string and rdf:langString
  #
  # @return [Boolean] `true` or `false`
  # @see http://www.w3.org/TR/rdf-concepts/#dfn-typed-literal
  def typed?; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # @return [Boolean] `true` or `false`
  # @since 0.2.1
  def valid?; end

  # Validates the value using {RDF::Value#valid?}, raising an error if the value is
  # invalid.
  #
  # @raise [ArgumentError] if the value is invalid
  # @return [RDF::Literal] `self`
  # @since 0.2.1
  def validate!; end

  # Returns the value as a string.
  #
  # @return [String]
  def value; end

  # Returns a hash code for the value.
  #
  # @return [Integer]
  def value_hash; end

  protected

  # @overload
  def method_missing(name, *args); end

  private

  # @return [Boolean]
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # Return Hash mapping from datatype URI to class
    #
    # @private
    def datatype_map; end

    # Return datatype class for uri, or nil if none is found
    #
    # @private
    def datatyped_class(uri); end

    # @private
    # @return [void]
    def inherited(child); end

    # @private
    # @raise [ArgumentError]
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

# anyURI represents a Uniform Resource Identifier Reference (URI).
# An anyURI value can be absolute or relative, and may have an
# optional fragment identifier (i.e., it may be a URI Reference).
# This type should be used to specify the intention that the value fulfills
# the role of a URI as defined by [RFC 2396], as amended by [RFC 2732].
#
# @see https://www.w3.org/TR/xmlschema11-2/#anyURI
# @see https://www.ietf.org/rfc/rfc2396.txt
# @see https://www.ietf.org/rfc/rfc2732.txt
class RDF::Literal::AnyURI < ::RDF::Literal
  # @param value [String, Object] If given a string, it will decode it as an object value.
  #   Otherwise, it will take the value as the object and encode to retrieve a value
  # @param lexical [String] (nil)
  # @return [AnyURI] a new instance of AnyURI
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  def canonicalize!; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::AnyURI::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# base64Binary represents Base64-encoded arbitrary binary data. The ·value space· of base64Binary is the set of
# finite-length sequences of binary octets. For base64Binary data the entire binary stream is encoded using the Base64
# Alphabet in [RFC 2045].
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#hexBinary
class RDF::Literal::Base64Binary < ::RDF::Literal
  # @option options
  # @param value [String, Object] If given a string, it will decode it as an object value.
  #   Otherwise, it will take the value as the object and encode to retrieve a value
  # @param options [Hash] a customizable set of options
  # @return [Base64Binary] a new instance of Base64Binary
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  # @see https://www.w3.org/TR/xmlschema-2/#dateTime
  def canonicalize!; end

  # Returns the value as a string.
  #
  # @return [String]
  def to_s; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Base64Binary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# byte is derived from short by setting the value of maxInclusive to be 127 and minInclusive to be -128.
# The base type of byte is short.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#byte
class RDF::Literal::Byte < ::RDF::Literal::Short
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Byte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# dateTimeStamp
#
# The dateTimeStamp datatype is ·derived· from dateTime by giving the value required to its explicitTimezone facet. The result is that all values of dateTimeStamp are required to have explicit time zone offsets and the datatype is totally ordered.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dateTimeStamp
class RDF::Literal::DateTimeStamp < ::RDF::Literal::DateTime; end

RDF::Literal::DateTimeStamp::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DateTimeStamp::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::DateTimeStamp::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gDay is a gregorian day that recurs, specifically a day of the month such as the 5th of the month. Arbitrary
# recurring days are not supported by this datatype. The value space of gDay is the space of a set of calendar
# dates as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-day long, monthly periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gDay
class RDF::Literal::Day < ::RDF::Literal::Date
  # @return [Day] a new instance of Day
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Day::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Day::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Day::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A DayTimeDuration literal.
#
# `dayTimeDuration` is a datatype ·derived· from `duration` by restricting its ·lexical representations· to instances of `dayTimeDurationLexicalRep`. The ·value space· of `dayTimeDuration` is therefore that of `duration` restricted to those whose ·months· property is 0.  This results in a duration datatype which is totally ordered.
#
# @see https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration
class RDF::Literal::DayTimeDuration < ::RDF::Literal::Duration
  # Returns the result of multiplying the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery function [op:multiply-dayTimeDuration](https://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration).
  #
  # @param other [Literal::Numeric, ::Numeric]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration
  def *(other); end

  # Returns the sum of two xs:dayTimeDuration values.
  #
  # From the XQuery function [op:add-dayTimeDurations](https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations).
  #
  # @param other [DayTimeDuration]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations
  def +(other); end

  # Returns the result of subtracting one xs:dayTimeDuration value from another.
  #
  # From the XQuery function [op:subtract-dayTimeDurationss](https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations).
  #
  # @param other [DayTimeDuration]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations
  def -(other); end

  # Returns the result of dividing the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery functions [op:divide-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration) and [op:divide-yearMonthDuration-by-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration-by-dayTimeDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, DayTimeDuration]
  # @return [DayTimeDuration, Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration-by-dayTimeDuration
  def /(other); end

  # Compares this literal to `other` for sorting purposes.
  #
  # From the XQuery function [op:dayTimeDuration-less-than](https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than).
  #
  # @param other [DayTimeDuration]
  # @return [Boolean] `true` if less than other for defined datatypes
  # @see https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than
  # @see https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-greater-than
  def <=>(other); end

  # Converts the dayTimeDuration into rational seconds.
  #
  # @return [Rational]
  def to_r; end
end

RDF::Literal::DayTimeDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DayTimeDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A duration literal.
#
# `duration` is a datatype that represents durations of time.  The concept of duration being captured is drawn from those of [ISO 8601](https://www.w3.org/TR/xmlschema11-2/#ISO8601), specifically durations without fixed endpoints.
#
# @see https://www.w3.org/TR/xmlschema11-2/#duration
class RDF::Literal::Duration < ::RDF::Literal
  # Creates a new Duration instance.
  #
  # * Given a `String`, parse as `xsd:duration` into months and seconds
  # * Given a `Hash` containing any of `:yr`, `:mo`, :da`, `:hr`, `:mi` and `:si`, it is transformed into months and seconds
  # * Given a Rational, the result is interpreted as days, hours, minutes, and seconds.
  # * Given an Integer, the result is interpreted as years and months.
  # * Object representation is the `Array(months, seconds)`
  #
  # @option options
  # @option options
  # @param value [Literal::Duration, Hash, Array, Literal::Numeric, #to_s] If provided an Array, it is the same as the object form of this literal, an array of two integers, the first of which may be negative.
  # @param lexical [String] (nil)
  #   Supplied lexical representation of this literal,
  #   otherwise it comes from transforming `value` to a string form..
  # @param datatype [URI] (nil)
  # @param options [Hash{Symbol => Object}] other options passed to `RDF::Literal#initialize`.
  # @return [Duration] a new instance of Duration
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Returns `true` if `self` and `other` are durations of the same length.
  #
  # From the XQuery function [op:duration-equal](https://www.w3.org/TR/xpath-functions/#func-duration-equal).
  #
  # @see https://www.w3.org/TR/xpath-functions/#func-duration-equal
  def ==(other); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [Literal] `self`
  # @see https://www.w3.org/TR/xmlschema11-2/#dateTime
  def canonicalize!; end

  # Days
  #
  # From the XQuery function [fn:days-from-duration](https://www.w3.org/TR/xpath-functions/#func-days-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-days-from-duration
  def days; end

  # Hours
  #
  # From the XQuery function [fn:hours-from-duration](https://www.w3.org/TR/xpath-functions/#func-hours-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-hours-from-duration
  def hours; end

  # Returns a human-readable value for the interval
  def humanize(lang = T.unsafe(nil)); end

  # Minutes
  #
  # From the XQuery function [fn:minutes-from-duration](https://www.w3.org/TR/xpath-functions/#func-minutes-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-minutes-from-duration
  def minutes; end

  # Months
  #
  # From the XQuery function [fn:months-from-duration](https://www.w3.org/TR/xpath-functions/#func-months-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-months-from-duration
  def months; end

  def plural(v, str); end

  # Seconds
  #
  # From the XQuery function [fn:seconds-from-duration](https://www.w3.org/TR/xpath-functions/#func-seconds-from-duration).
  #
  # @return [Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-seconds-from-duration
  def seconds; end

  # Returns a hash representation.
  #
  # @return [Hash]
  def to_h; end

  # Returns the value as a string.
  #
  # @return [String]
  def to_s; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # Special case for date and dateTime, for which '0000' is not a valid year
  #
  # @return [Boolean]
  def valid?; end

  # Years
  #
  # From the XQuery function [fn:years-from-duration](https://www.w3.org/TR/xpath-functions/#func-years-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-years-from-duration
  def years; end

  private

  # Reverse convert from XSD version of duration
  # XSD allows -P1111Y22M33DT44H55M66.666S with any combination in regular order
  # We assume 1M == 30D, but are out of spec in this regard
  # We only output up to hours
  #
  # @param value [String] XSD formatted duration
  # @return [Duration]
  def parse(value); end

  def sec_str; end
end

RDF::Literal::Duration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Duration::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::FALSE = T.let(T.unsafe(nil), RDF::Literal::Boolean)

# Note that in XML Schema, Float is not really derived from Double,
# but implementations are identical in Ruby
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#float
class RDF::Literal::Float < ::RDF::Literal::Double; end

RDF::Literal::Float::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# An HTML literal.
#
# HTML Literals are managed equivalent to XML Literals. Processors
# are responsible for coercing the input to an
# [DOM DocumentFragment](https://www.w3.org/TR/dom/#interface-documentfragment).
#
# @see https://dvcs.w3.org/hg/rdf/raw-file/default/rdf-concepts/index.html#section-html
class RDF::Literal::HTML < ::RDF::Literal::XML; end

# hexBinary represents arbitrary hex-encoded binary data. The value space of hexBinary is the set of finite-length
# sequences of binary octets.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#hexBinary
class RDF::Literal::HexBinary < ::RDF::Literal
  # @option options
  # @param value [String] The encoded form of the literal
  # @param options [Hash] a customizable set of options
  # @return [HexBinary] a new instance of HexBinary
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  def canonicalize!; end

  # Returns the encoded value as a string.
  #
  # @return [String]
  def to_s; end

  private

  def bin_to_hex(value); end
  def hex_to_bin(value); end
end

RDF::Literal::HexBinary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::HexBinary::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# int is derived from long by setting the value of maxInclusive to be 2147483647 and minInclusive to be
# -2147483648. The base type of int is long.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#int
class RDF::Literal::Int < ::RDF::Literal::Long
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Int::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# long is derived from integer by setting the value of maxInclusive to be 9223372036854775807
# and minInclusive to be -9223372036854775808.
#
# The base type of long is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#long
class RDF::Literal::Long < ::RDF::Literal::Integer
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Long::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# gMonth is a gregorian month that recurs every year. The value space of gMonth is the space of a set of calendar
# months as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-month long, yearly periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gMonth
class RDF::Literal::Month < ::RDF::Literal::Date
  # @return [Month] a new instance of Month
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Month::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Month::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Month::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gMonthDay is a gregorian date that recurs, specifically a day of the year such as the third of May. Arbitrary
# recurring dates are not supported by this datatype. The value space of gMonthDay is the set of calendar dates,
# as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-day long, annually periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gMonthDay
class RDF::Literal::MonthDay < ::RDF::Literal::Date
  # @return [MonthDay] a new instance of MonthDay
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::MonthDay::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::MonthDay::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::MonthDay::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# negativeInteger is derived from nonPositiveInteger by setting the value of maxInclusive to be -1. This
# results in the standard mathematical concept of the negative integers. The value space of negativeInteger is
# the infinite set `{...,-2,-1}`. The base type of negativeInteger is nonPositiveInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#negativeInteger
class RDF::Literal::NegativeInteger < ::RDF::Literal::NonPositiveInteger
  # Returns `self` negated.
  #
  # @return [RDF::Literal::Numeric]
  def -@; end

  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# nonNegativeInteger is derived from integer by setting the value of minInclusive to be 0. This results in
# the standard mathematical concept of the non-negative integers. The value space of nonNegativeInteger is the
# infinite set [0,1,2,...]. The base type of nonNegativeInteger is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#nonNegativeInteger
class RDF::Literal::NonNegativeInteger < ::RDF::Literal::Integer
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NonNegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonNegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# nonPositiveInteger is derived from integer by setting the value of maxInclusive to be 0. This results in
# the standard mathematical concept of the non-positive integers. The value space of nonPositiveInteger is the
# infinite set `{...,-2,-1,0}`. The base type of nonPositiveInteger is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#nonPositiveInteger
class RDF::Literal::NonPositiveInteger < ::RDF::Literal::Integer
  # Returns `self` negated.
  #
  # @return [RDF::Literal::Numeric]
  def -@; end

  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NonPositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonPositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# positiveInteger is derived from nonNegativeInteger by setting the value of minInclusive to be 1. This
# results in the standard mathematical concept of the positive integer numbers. The value space of
# positiveInteger is the infinite set [1,2,...]. The base type of positiveInteger is nonNegativeInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#positiveInteger
class RDF::Literal::PositiveInteger < ::RDF::Literal::NonNegativeInteger
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::PositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::PositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# short is derived from int by setting the value of maxInclusive to be 32767 and minInclusive to be
# -32768. The base type of short is int.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#short
class RDF::Literal::Short < ::RDF::Literal::Int
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Short::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::TRUE = T.let(T.unsafe(nil), RDF::Literal::Boolean)

# unsignedByte is derived from unsignedShort by setting the value of maxInclusive to be 255. The base
# type of unsignedByte is unsignedShort.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedByte
class RDF::Literal::UnsignedByte < ::RDF::Literal::UnsignedShort
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedByte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# unsignedInt is derived from unsignedLong by setting the value of maxInclusive to be 4294967295. The base
# type of unsignedInt is unsignedLong.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedInt
class RDF::Literal::UnsignedInt < ::RDF::Literal::UnsignedLong
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedInt::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# unsignedLong is derived from nonNegativeInteger by setting the value of maxInclusive to be
# 18446744073709551615. The base type of unsignedLong is nonNegativeInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedLong
class RDF::Literal::UnsignedLong < ::RDF::Literal::NonNegativeInteger
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedLong::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::UnsignedLong::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# unsignedShort is derived from unsignedInt by setting the value of maxInclusive to be 65535. The base
# type of unsignedShort is unsignedInt.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedShort
class RDF::Literal::UnsignedShort < ::RDF::Literal::UnsignedInt
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedShort::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# An XML literal.
#
# XML Literals are maintained in a lexical form, unless an object form is provided.
# The both lexical and object forms are presumed to be in Exclusive Canonical XML.
# As generating this form is dependent on the context of the XML Literal from the
# original document, canonicalization cannot be performed directly within this
# class.
#
# This gem includes Exclusive Canonical XML extensions `Nokogiri::XML::Node#c14nxl`,
# `Nokogiri::XML::NodeSet#c14nxl`, `REXML::Element#c14nxl` and `Array#c14nxl` (necessary
# for REXML node children, which is the REXML implementation of a NodeSet)
#
# @see https://www.w3.org/TR/rdf-concepts/#section-XMLLiteral
# @see https://www.w3.org/TR/rdfa-core/#s_xml_literals
# @see https://www.w3.org/TR/xml-exc-c14n/
class RDF::Literal::XML < ::RDF::Literal
  # @option options
  # @param value [Object]
  # @param lexical [String] (nil)
  # @param options [Hash] a customizable set of options
  # @return [XML] a new instance of XML
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # XML Equivalence. XML Literals can be compared with each other or with xsd:strings
  #
  # @param other [Object]
  # @return [Boolean] `true` or `false`
  # @see https://www.w3.org/TR/rdf-concepts/#section-XMLLiteral
  def eql?(other); end

  # Parse value, if necessary
  #
  # @return [Object]
  def object; end

  def to_s; end

  private

  # Use equivalent-xml to determine equivalence
  def equivalent_nokogiri(other); end

  # Simple equivalence test for REXML
  def equivalent_rexml(other); end

  # Parse the value either as a NodeSet, as results are equivalent if it is just a node
  def parse_nokogiri(value); end

  # Parse the value either as a NodeSet, as results are equivalent if it is just a node
  def parse_rexml(value); end
end

RDF::Literal::XML::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# gYear represents a gregorian calendar year. The value space of gYear is the set of Gregorian calendar years as
# defined in § 5.2.1 of [ISO 8601]. Specifically, it is a set of one-year long, non-periodic instances e.g. lexical
# 1999 to represent the whole year 1999, independent of how many months and days this year has.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gYear
class RDF::Literal::Year < ::RDF::Literal::Date
  # @return [Year] a new instance of Year
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Year::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Year::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Year::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gYearMonth represents a specific gregorian month in a specific gregorian year. The value space of gYearMonth is
# the set of Gregorian calendar months as defined in § 5.2.1 of [ISO 8601]. Specifically, it is a set of one-month
# long, non-periodic instances e.g. 1999-10 to represent the whole month of 1999-10, independent of how many days this
# month has.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gYearMonth
class RDF::Literal::YearMonth < ::RDF::Literal::Date
  # @return [YearMonth] a new instance of YearMonth
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::YearMonth::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonth::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::YearMonth::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A `YearMonthDuration` literal.
#
# `yearMonthDuration` is a datatype ·derived· from `xsd:duration` by restricting its ·lexical representations· to instances of `yearMonthDurationLexicalRep`.  The ·value space· of `yearMonthDuration` is therefore that of `duration` restricted to those whose ·seconds· property is 0.  This results in a `duration` datatype which is totally ordered.
#
# @see https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration
class RDF::Literal::YearMonthDuration < ::RDF::Literal::Duration
  # Returns the result of multiplying the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery function [op:multiply-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, DayTimeDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration
  def *(other); end

  # Returns the sum of two xs:yearMonthDuration values.
  #
  # From the XQuery function [op:add-yearMonthDurations](https://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations).
  #
  # @param other [YearMonthDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations
  def +(other); end

  # Returns the result of subtracting one xs:yearMonthDuration value from another.
  #
  # From the XQuery function [op:subtract-yearMonthDurations](https://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations).
  #
  # @param other [YearMonthDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations
  def -(other); end

  # Returns the result of dividing the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery functions [op:divide-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration) and [op:divide-yearMonthDuration-by-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration-by-yearMonthDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, YearMonthDuration]
  # @return [YearMonthDuration, Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration-by-yearMonthDuration
  def /(other); end

  # Compares this literal to `other` for sorting purposes.
  #
  # From the XQuery function [op:yearMonthDuration-greater-than](https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than).
  #
  # @param other [Literal::YearMonthDuration]
  # @return [Boolean] `true` if less than other for defined datatypes
  # @see https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than
  # @see https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-greater-than
  def <=>(other); end

  # Converts the dayTimeDuration into rational seconds.
  #
  # @return [Rational]
  def to_i; end
end

RDF::Literal::YearMonthDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonthDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::ZERO = T.let(T.unsafe(nil), RDF::Literal::Integer)
RDF::RDF_N_REGEXP = T.let(T.unsafe(nil), Regexp)
RDF::VOCABS = T.let(T.unsafe(nil), Hash)

module RDF::XSD::VERSION
  class << self
    # @return [Array(Integer, Integer, Integer)]
    def to_a; end

    # @return [String]
    def to_s; end

    # @return [String]
    def to_str; end
  end
end

RDF::XSD::VERSION::MAJOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::MINOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::STRING = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::TINY = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

class REXML::Element < ::REXML::Parent
  include ::REXML::XMLTokens

  # Canonicalize the Element. Return a new instance of this node
  # which is canonicalized and marked as such.
  #
  # Apply namespaces either passed as an option, or that are in scope.
  #
  # @param options [Hash{Symbol => Object}] From `Nokogiri::XML::Node#c14nxl`
  def c14nxl(options = T.unsafe(nil)); end
end
