# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rouge` gem.
# Please instead update this file by running `bin/tapioca gem rouge`.

# The containing module for Rouge
module Rouge
  class << self
    # Highlight some text with a given lexer and formatter.
    #
    # @example
    #   Rouge.highlight('@foo = 1', 'ruby', 'html')
    #   Rouge.highlight('var foo = 1;', 'js', 'terminal256')
    #
    #   # streaming - chunks become available as they are lexed
    #   Rouge.highlight(large_string, 'ruby', 'html') do |chunk|
    #   $stdout.print chunk
    #   end
    def highlight(text, lexer, formatter, &b); end

    # Load a file relative to the `lib/rouge` path.
    #
    # @api private
    def load_file(path); end

    # Load the lexers in the `lib/rouge/lexers` directory.
    #
    # @api private
    def load_lexers; end

    def reload!; end
    def version; end
  end
end

class Rouge::CSSTheme < ::Rouge::Theme
  # @return [CSSTheme] a new instance of CSSTheme
  def initialize(opts = T.unsafe(nil)); end

  # @yield ["#{@scope} table td { padding: 5px; }"]
  def render(&b); end

  def render_base(selector, &b); end
  def style_for(tok); end

  private

  def css_selector(token); end

  # yield all of the tokens that should be styled the same
  # as the given token.  Essentially this recursively all of
  # the subtokens, except those which are more specifically
  # styled.
  #
  # @yield [tok]
  def inflate_token(tok, &b); end

  def single_css_selector(token); end
end

# A Formatter takes a token stream and formats it for human viewing.
class Rouge::Formatter
  # @return [Formatter] a new instance of Formatter
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  def escape?(tok); end

  def filter_escapes(tokens); end

  # Format a token stream.
  def format(tokens, &b); end

  # @deprecated Use {#format} instead.
  def render(tokens); end

  # yield strings that, when concatenated, form the formatted output
  #
  # @abstract
  def stream(tokens, &b); end

  protected

  # @yield [out]
  def token_lines(tokens, &b); end

  class << self
    def disable_escape!; end
    def enable_escape!; end

    # @return [Boolean]
    def escape_enabled?; end

    # Find a formatter class given a unique tag.
    def find(tag); end

    # Format a token stream.  Delegates to {#format}.
    def format(tokens, *args, **kwargs, &b); end

    # Specify or get the unique tag for this formatter.  This is used
    # for specifying a formatter in `rougify`.
    def tag(tag = T.unsafe(nil)); end

    def with_escape; end
  end
end

# @private
Rouge::Formatter::REGISTRY = T.let(T.unsafe(nil), Hash)

module Rouge::Formatters; end

# Transforms a token stream into HTML output.
class Rouge::Formatters::HTML < ::Rouge::Formatter
  def safe_span(tok, safe_val); end
  def span(tok, val); end

  # @yield the html output.
  def stream(tokens, &b); end

  private

  # A performance-oriented helper method to escape `&`, `<` and `>` for the rendered
  # HTML from this formatter.
  #
  # `String#gsub` will always return a new string instance irrespective of whether
  # a substitution occurs. This method however invokes `String#gsub` only if
  # a substitution is imminent.
  #
  # Returns either the given `value` argument string as is or a new string with the
  # special characters replaced with their escaped counterparts.
  def escape_special_html_chars(value); end
end

Rouge::Formatters::HTML::TABLE_FOR_ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

class Rouge::Formatters::HTMLInline < ::Rouge::Formatters::HTML
  # @return [HTMLInline] a new instance of HTMLInline
  def initialize(theme); end

  def safe_span(tok, safe_val); end
end

# Transforms a token stream into HTML output.
class Rouge::Formatters::HTMLLegacy < ::Rouge::Formatter
  # Initialize with options.
  #
  # If `:inline_theme` is given, then instead of rendering the
  # tokens as <span> tags with CSS classes, the styles according to
  # the given theme will be inlined in "style" attributes.  This is
  # useful for formats in which stylesheets are not available.
  #
  # Content will be wrapped in a tag (`div` if tableized, `pre` if
  # not) with the given `:css_class` unless `:wrap` is set to `false`.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [HTMLLegacy] a new instance of HTMLLegacy
  def initialize(opts = T.unsafe(nil)); end

  # @yield the html output.
  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLLineHighlighter < ::Rouge::Formatter
  # @return [HTMLLineHighlighter] a new instance of HTMLLineHighlighter
  def initialize(delegate, opts = T.unsafe(nil)); end

  def stream(tokens); end
end

class Rouge::Formatters::HTMLLineTable < ::Rouge::Formatter
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param formatter [Rouge::Formatters::Formatter] An instance of a
  #   `Rouge::Formatters::HTML` or `Rouge::Formatters::HTMLInline`
  # @param opts [Hash] options for HTMLLineTable instance.
  # @return [HTMLLineTable] a new instance of HTMLLineTable
  def initialize(formatter, opts = T.unsafe(nil)); end

  # @yield [buffer.join]
  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLLinewise < ::Rouge::Formatter
  # @return [HTMLLinewise] a new instance of HTMLLinewise
  def initialize(formatter, opts = T.unsafe(nil)); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLPygments < ::Rouge::Formatter
  # @return [HTMLPygments] a new instance of HTMLPygments
  def initialize(inner, css_class = T.unsafe(nil)); end

  # @yield [%(<div class="highlight"><pre class="#{@css_class}"><code>)]
  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLTable < ::Rouge::Formatter
  # @return [HTMLTable] a new instance of HTMLTable
  def initialize(inner, opts = T.unsafe(nil)); end

  # @yield [buffer.join]
  def stream(tokens, &b); end

  # @yield [%(#{scope} .rouge-table { border-spacing: 0 })]
  def style(scope); end
end

# A formatter which renders nothing.
class Rouge::Formatters::Null < ::Rouge::Formatter
  # @return [Null] a new instance of Null
  def initialize(*_arg0); end

  def stream(tokens, &b); end
end

# A formatter for 256-color terminals
class Rouge::Formatters::Terminal256 < ::Rouge::Formatter
  # @param theme [Hash, Rouge::Theme] the theme to render with.
  # @return [Terminal256] a new instance of Terminal256
  def initialize(theme = T.unsafe(nil)); end

  # private
  def escape_sequence(token); end

  def get_style(token); end
  def make_escape_sequence(style); end
  def stream(tokens, &b); end
  def text_style; end

  # @private
  def theme; end
end

class Rouge::Formatters::Terminal256::EscapeSequence
  # @return [EscapeSequence] a new instance of EscapeSequence
  def initialize(style); end

  def bg; end
  def fg; end
  def reset_string; end

  # @yield [style_string]
  def stream_value(val, &b); end

  # Returns the value of attribute style.
  def style; end

  def style_string; end

  private

  def escape(attrs); end

  class << self
    def closest_color(r, g, b); end
    def color_index(color); end
    def get_rgb(color); end
    def xterm_colors; end
  end
end

# max distance between two colors, #000000 to #ffffff
Rouge::Formatters::Terminal256::EscapeSequence::MAX_DISTANCE = T.let(T.unsafe(nil), Integer)

class Rouge::Formatters::Terminal256::Unescape < ::Rouge::Formatters::Terminal256::EscapeSequence
  # @return [Unescape] a new instance of Unescape
  def initialize(*_arg0); end

  def reset_string(*_arg0); end

  # @yield [val]
  def stream_value(val); end

  def style_string(*_arg0); end
end

class Rouge::Formatters::TerminalTruecolor < ::Rouge::Formatters::Terminal256
  def make_escape_sequence(style); end
end

class Rouge::Formatters::TerminalTruecolor::TruecolorEscapeSequence < ::Rouge::Formatters::Terminal256::EscapeSequence
  def get_rgb(color); end
  def style_string; end
end

class Rouge::Formatters::Tex < ::Rouge::Formatter
  # @return [Tex] a new instance of Tex
  def initialize(opts = T.unsafe(nil)); end

  def escape_tex(str); end

  # Special handling for leading spaces, since they may be gobbled
  # by a previous command.  We replace all initial spaces with
  # \hphantom{xxxx}, which renders an empty space equal to the size
  # of the x's.
  #
  # @yield ["\\hphantom{#{'x' * leading}}"]
  def hphantom_tag(tok, val); end

  def render_line(line, &b); end

  # @yield ["\\begin{#{@prefix}*}%\n"]
  def stream(tokens, &b); end

  def tag(tok, val); end
end

# A map of TeX escape characters.
# Newlines are handled specially by using #token_lines
# spaces are preserved as long as they aren't at the beginning
# of a line. see #tag_first for our initial-space strategy
Rouge::Formatters::Tex::ESCAPE = T.let(T.unsafe(nil), Hash)

Rouge::Formatters::Tex::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

class Rouge::Guesser
  def collect_best(lexers, opts = T.unsafe(nil), &scorer); end
  def filter(lexers); end

  class << self
    def guess(guessers, lexers); end
  end
end

class Rouge::Guesser::Ambiguous < ::StandardError
  # @return [Ambiguous] a new instance of Ambiguous
  def initialize(alternatives); end

  # Returns the value of attribute alternatives.
  def alternatives; end

  def message; end
end

module Rouge::Guessers; end

class Rouge::Guessers::Disambiguation < ::Rouge::Guesser
  include ::Rouge::Guessers::Util
  include ::Rouge::Lexers

  # @return [Disambiguation] a new instance of Disambiguation
  def initialize(filename, source); end

  # @return [Boolean]
  def contains?(text); end

  def filter(lexers); end

  # @return [Boolean]
  def matches?(re); end

  class << self
    def disambiguate(*patterns, &decider); end
    def disambiguators; end
  end
end

class Rouge::Guessers::Disambiguation::Disambiguator
  include ::Rouge::Guessers::Util

  # @return [Disambiguator] a new instance of Disambiguator
  def initialize(patterns, &decider); end

  def decide!(guesser); end

  # @return [Boolean]
  def match?(filename); end
end

class Rouge::Guessers::Filename < ::Rouge::Guesser
  # @return [Filename] a new instance of Filename
  def initialize(filename); end

  # returns a list of lexers that match the given filename with
  # equal specificity (i.e. number of wildcards in the pattern).
  # This helps disambiguate between, e.g. the Nginx lexer, which
  # matches `nginx.conf`, and the Conf lexer, which matches `*.conf`.
  # In this case, nginx will win because the pattern has no wildcards,
  # while `*.conf` has one.
  def filter(lexers); end

  # Returns the value of attribute fname.
  def fname; end
end

# This class allows for custom behavior
# with glob -> lexer name mappings
class Rouge::Guessers::GlobMapping < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [GlobMapping] a new instance of GlobMapping
  def initialize(glob_map, filename); end

  # Returns the value of attribute filename.
  def filename; end

  def filter(lexers); end

  # Returns the value of attribute glob_map.
  def glob_map; end

  class << self
    def by_pairs(mapping, filename); end
  end
end

class Rouge::Guessers::Mimetype < ::Rouge::Guesser
  # @return [Mimetype] a new instance of Mimetype
  def initialize(mimetype); end

  def filter(lexers); end

  # Returns the value of attribute mimetype.
  def mimetype; end
end

class Rouge::Guessers::Modeline < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [Modeline] a new instance of Modeline
  def initialize(source, opts = T.unsafe(nil)); end

  def filter(lexers); end
end

# [jneen] regexen stolen from linguist
Rouge::Guessers::Modeline::EMACS_MODELINE = T.let(T.unsafe(nil), Regexp)

Rouge::Guessers::Modeline::MODELINES = T.let(T.unsafe(nil), Array)

# First form vim modeline
# [text]{white}{vi:|vim:|ex:}[white]{options}
# ex: 'vim: syntax=ruby'
Rouge::Guessers::Modeline::VIM_MODELINE_1 = T.let(T.unsafe(nil), Regexp)

# Second form vim modeline (compatible with some versions of Vi)
# [text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]
# ex: 'vim set syntax=ruby:'
Rouge::Guessers::Modeline::VIM_MODELINE_2 = T.let(T.unsafe(nil), Regexp)

class Rouge::Guessers::Source < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [Source] a new instance of Source
  def initialize(source); end

  def filter(lexers); end

  # Returns the value of attribute source.
  def source; end
end

module Rouge::Guessers::Util
  # @param source [String, IO]
  # @return [String]
  def get_source(source); end

  def test_glob(pattern, path); end
end

module Rouge::Guessers::Util::SourceNormalizer
  class << self
    # @param source [String, nil]
    # @return [String, nil]
    def normalize(source); end
  end
end

Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM = T.let(T.unsafe(nil), String)
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM_RE = T.let(T.unsafe(nil), Regexp)

module Rouge::HasModes
  def get_mode(mode); end
  def mode(arg = T.unsafe(nil)); end
  def mode!(arg); end
  def set_mode!(mode); end
end

# shared methods for some indentation-sensitive lexers
module Rouge::Indentation
  # handle a single indented line
  def indentation(indent_str); end

  def reset!; end

  # push a state for the next indented block
  def starts_block(block_state); end
end

class Rouge::InheritableHash < ::Hash
  # @return [InheritableHash] a new instance of InheritableHash
  def initialize(parent = T.unsafe(nil)); end

  def [](k); end
  def each(&b); end

  # @return [Boolean]
  def include?(k); end

  def keys; end
  def own_keys; end
  def parent; end
end

class Rouge::InheritableList
  include ::Enumerable

  # @return [InheritableList] a new instance of InheritableList
  def initialize(parent = T.unsafe(nil)); end

  def <<(o); end
  def each(&b); end
  def own_entries; end
  def parent; end
  def push(o); end
end

# cache value in a constant since `__dir__` allocates a new string
# on every call.
Rouge::LIB_DIR = T.let(T.unsafe(nil), String)

# A lexer transforms text into a stream of `[token, chunk]` pairs.
#
# @abstract
class Rouge::Lexer
  include ::Rouge::Token::Tokens

  # Create a new lexer with the given options.  Individual lexers may
  # specify extra options.  The only current globally accepted option
  # is `:debug`.
  #
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Lexer] a new instance of Lexer
  def initialize(opts = T.unsafe(nil)); end

  def as_bool(val); end
  def as_lexer(val); end
  def as_list(val); end
  def as_string(val); end
  def as_token(val); end
  def bool_option(name, &default); end

  # Continue the lex from the the current state without resetting
  def continue_lex(string, &b); end

  def hash_option(name, defaults, &val_cast); end

  # Given a string, yield [token, chunk] pairs.  If no block is given,
  # an enumerator is returned.
  #
  # @note The use of :continue => true has been deprecated. A warning is
  #   issued if run with `$VERBOSE` set to true.
  # @note The use of arbitrary `opts` has never been supported, but we
  #   previously ignored them with no error. We now warn unconditionally.
  # @option opts
  # @param opts [Hash] a customizable set of options
  def lex(string, opts = T.unsafe(nil), &b); end

  def lexer_option(name, &default); end
  def list_option(name, &default); end

  # -*- instance methods -*- #
  def options; end

  # Called after each lex is finished.  The default implementation
  # is a noop.
  #
  # @abstract
  def reset!; end

  # Yield `[token, chunk]` pairs, given a prepared input stream.  This
  # must be implemented.
  #
  # @abstract
  # @param stream [StringScanner] the stream
  def stream_tokens(stream, &b); end

  def string_option(name, &default); end

  # delegated to {Lexer.tag}
  def tag; end

  def token_option(name, &default); end

  # Returns a new lexer with the given options set. Useful for e.g. setting
  # debug flags post hoc, or providing global overrides for certain options
  def with(opts = T.unsafe(nil)); end

  class << self
    # Used to specify alternate names this lexer class may be found by.
    #
    # @example
    #   class Erb < Lexer
    #   tag 'erb'
    #   aliases 'eruby', 'rhtml'
    #   end
    #
    #   Lexer.find('eruby') # => Erb
    def aliases(*args); end

    # @return a list of all lexers.
    def all; end

    # @private
    # @raise [EncodingError]
    def assert_utf8!(str); end

    # In case #continue_lex is called statically, we simply
    # begin a new lex from the beginning, since there is no state.
    #
    # @see #continue_lex
    def continue_lex(*a, &b); end

    # @return [Boolean]
    def debug_enabled?; end

    # Specify or get a small demo string for this lexer
    def demo(arg = T.unsafe(nil)); end

    # Specify or get the path name containing a small demo for
    # this lexer (can be overriden by {demo}).
    def demo_file(arg = T.unsafe(nil)); end

    # Specify or get this lexer's description.
    def desc(arg = T.unsafe(nil)); end

    # Return true if there is an in-text indication (such as a shebang
    # or DOCTYPE declaration) that this lexer should be used.
    #
    # @abstract
    # @param text [TextAnalyzer] the text to be analyzed, with a couple of handy methods on it,
    #   like {TextAnalyzer#shebang?} and {TextAnalyzer#doctype?}
    # @return [Boolean]
    def detect?(text); end

    # Determine if a lexer has a method named +:detect?+ defined in its
    # singleton class.
    #
    # @return [Boolean]
    def detectable?; end

    def disable_debug!; end
    def enable_debug!; end

    # Specify a list of filename globs associated with this lexer.
    #
    # If a filename glob is associated with more than one lexer, this can
    # cause a Guesser::Ambiguous error to be raised in various guessing
    # methods. These errors can be avoided by disambiguation. Filename globs
    # are disambiguated in one of two ways. Either the lexer will define a
    # `self.detect?` method (intended for use with shebangs and doctypes) or a
    # manual rule will be specified in Guessers::Disambiguation.
    #
    # @example
    #   class Ruby < Lexer
    #   filenames '*.rb', '*.ruby', 'Gemfile', 'Rakefile'
    #   end
    def filenames(*fnames); end

    # Given a name in string, return the correct lexer class.
    #
    # @param name [String]
    # @return [Class<Rouge::Lexer>, nil]
    def find(name); end

    # Find a lexer, with fancy shiny features.
    #
    # * The string you pass can include CGI-style options
    #
    #     Lexer.find_fancy('erb?parent=tex')
    #
    # * You can pass the special name 'guess' so we guess for you,
    #   and you can pass a second argument of the code to guess by
    #
    #     Lexer.find_fancy('guess', "#!/bin/bash\necho Hello, world")
    #
    #   If the code matches more than one lexer then Guesser::Ambiguous
    #   is raised.
    #
    # This is used in the Redcarpet plugin as well as Rouge's own
    # markdown lexer for highlighting internal code blocks.
    def find_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # Guess which lexer to use based on a hash of info.
    #
    # @option info
    # @option info
    # @option info
    # @param info [Hash] a customizable set of options
    # @param fallback [Proc] called if multiple lexers are detected.
    #   If omitted, Guesser::Ambiguous is raised.
    # @return [Class<Rouge::Lexer>]
    # @see Lexer.detect?
    # @see Lexer.guesses
    def guess(info = T.unsafe(nil), &fallback); end

    def guess_by_filename(fname); end
    def guess_by_mimetype(mt); end
    def guess_by_source(source); end

    # Guess which lexer to use based on a hash of info.
    #
    # This accepts the same arguments as Lexer.guess, but will never throw
    # an error.  It will return a (possibly empty) list of potential lexers
    # to use.
    def guesses(info = T.unsafe(nil)); end

    # Lexes `stream` with the given options.  The lex is delegated to a
    # new instance.
    #
    # @see #lex
    def lex(stream, opts = T.unsafe(nil), &b); end

    # Same as ::find_fancy, except instead of returning an instantiated
    # lexer, returns a pair of [lexer_class, options], so that you can
    # modify or provide additional options to the lexer.
    #
    # Please note: the lexer class might be nil!
    def lookup_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # Specify a list of mimetypes associated with this lexer.
    #
    # @example
    #   class Html < Lexer
    #   mimetypes 'text/html', 'application/xhtml+xml'
    #   end
    def mimetypes(*mts); end

    def option(name, desc); end
    def option_docs; end

    # Used to specify or get the canonical name of this lexer class.
    #
    # @example
    #   class MyLexer < Lexer
    #   tag 'foo'
    #   end
    #
    #   MyLexer.tag # => 'foo'
    #
    #   Lexer.find('foo') # => MyLexer
    def tag(t = T.unsafe(nil)); end

    # Specify or get this lexer's title. Meant to be human-readable.
    def title(t = T.unsafe(nil)); end

    protected

    # @private
    def register(name, lexer); end

    private

    def registry; end
  end
end

module Rouge::Lexers
  class << self
    def load_lexer(relpath); end
  end
end

class Rouge::Lexers::ABAP < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def new_keywords; end
    def types; end
  end
end

class Rouge::Lexers::APIBlueprint < ::Rouge::Lexers::Markdown; end

class Rouge::Lexers::Actionscript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Ada < ::Rouge::RegexLexer
  class << self
    # Return a hash mapping lower-case identifiers to token classes.
    def idents; end
  end
end

Rouge::Lexers::Ada::EXP = T.let(T.unsafe(nil), Regexp)

# Ada identifiers are Unicode with underscores only allowed as separators.
Rouge::Lexers::Ada::ID = T.let(T.unsafe(nil), Regexp)

# Numerals can also contain underscores.
Rouge::Lexers::Ada::NUM = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Ada::XNUM = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Apache < ::Rouge::RegexLexer
  def name_for_token(token, tktype); end

  class << self
    # self-modifying method that loads the keywords file
    def directives; end

    def sections; end
    def values; end
  end
end

class Rouge::Lexers::Apex < ::Rouge::RegexLexer
  class << self
    def constants; end
    def declarations; end
    def keywords; end
    def soql; end
    def types; end
  end
end

class Rouge::Lexers::AppleScript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def classes; end
    def commands; end
    def controls; end
    def declarations; end
    def handler_params; end
    def literals; end
    def operators; end
    def references; end
    def reserved; end
    def studio_classes; end
    def studio_commands; end
    def studio_events; end
    def studio_properties; end
  end
end

class Rouge::Lexers::ArmAsm < ::Rouge::RegexLexer
  class << self
    def builtin; end
    def file_directive; end
    def general_directive; end
    def operator; end
    def preproc_keyword; end
    def shift_or_condition; end
  end
end

class Rouge::Lexers::Augeas < ::Rouge::RegexLexer
  class << self
    def reserved; end
  end
end

class Rouge::Lexers::Awk < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
    def reserved; end
  end
end

Rouge::Lexers::BASE_DIR = T.let(T.unsafe(nil), String)

class Rouge::Lexers::BBCBASIC < ::Rouge::RegexLexer
  class << self
    def constant; end
    def function; end
    def operator; end
    def punctuation; end
    def statement; end
  end
end

class Rouge::Lexers::BIML < ::Rouge::Lexers::XML
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::BPF < ::Rouge::RegexLexer; end
Rouge::Lexers::BPF::MISC_KEYWORDS = T.let(T.unsafe(nil), String)
Rouge::Lexers::BPF::TYPE_KEYWORDS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Batchfile < ::Rouge::RegexLexer
  class << self
    def attributes; end
    def builtin_commands; end
    def devices; end
    def keywords; end
    def operator_words; end
    def other_commands; end
  end
end

class Rouge::Lexers::BibTeX < ::Rouge::RegexLexer; end
class Rouge::Lexers::Brainfuck < ::Rouge::RegexLexer; end

class Rouge::Lexers::Brightscript < ::Rouge::RegexLexer
  class << self
    # Scene graph components configured as builtins. See BrightScript component documentation e.g.
    # https://developer.roku.com/en-ca/docs/references/brightscript/components/roappinfo.md
    def builtins; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/reserved-words.md
    def keyword_reserved; end

    # These keywords are present in BrightScript, but not supported in standard .brs files
    def keyword_reserved_unsupported; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/expressions-variables-types.md
    def keyword_type; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-utility-functions.md
    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-string-functions.md
    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-math-functions.md
    def name_builtin; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/expressions-variables-types.md#operators
    def operator_word; end
  end
end

class Rouge::Lexers::Bsl < ::Rouge::RegexLexer; end
Rouge::Lexers::Bsl::BUILTINS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Bsl::KEYWORDS = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::C < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::CMHG < ::Rouge::RegexLexer
  class << self
    def preproc_keyword; end
  end
end

class Rouge::Lexers::CMake < ::Rouge::RegexLexer; end
Rouge::Lexers::CMake::BRACKET_OPEN = T.let(T.unsafe(nil), String)
Rouge::Lexers::CMake::BUILTIN_COMMANDS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CMake::SPACE = T.let(T.unsafe(nil), String)
Rouge::Lexers::CMake::STATES_MAP = T.let(T.unsafe(nil), Hash)

class Rouge::Lexers::CSS < ::Rouge::RegexLexer
  class << self
    def attributes; end
    def builtins; end
    def constants; end

    # source: http://www.w3.org/TR/CSS21/syndata.html#vendor-keyword-history
    def vendor_prefixes; end
  end
end

class Rouge::Lexers::CSVS < ::Rouge::RegexLexer; end
class Rouge::Lexers::CSharp < ::Rouge::RegexLexer; end

class Rouge::Lexers::CUDA < ::Rouge::Lexers::Cpp
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Ceylon < ::Rouge::RegexLexer; end

class Rouge::Lexers::Cfscript < ::Rouge::RegexLexer
  class << self
    def declarations; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::Clean < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Clojure < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::Coffeescript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::CommonLisp < ::Rouge::RegexLexer; end
Rouge::Lexers::CommonLisp::BUILTIN_CLASSES = T.let(T.unsafe(nil), Set)

# 638 functions
Rouge::Lexers::CommonLisp::BUILTIN_FUNCTIONS = T.let(T.unsafe(nil), Set)

Rouge::Lexers::CommonLisp::BUILTIN_TYPES = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::DECLARATIONS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::LAMBDA_LIST_KEYWORDS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::MACROS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::SPECIAL_FORMS = T.let(T.unsafe(nil), Set)
class Rouge::Lexers::Conf < ::Rouge::RegexLexer; end

# The {ConsoleLexer} class is intended to lex content that represents the
# text that would display in a console/terminal. As distinct from the
# {Shell} lexer, {ConsoleLexer} will try to parse out the prompt from each
# line before passing the remainder of the line to the language lexer for
# the shell (by default, the {Shell} lexer).
#
# The {ConsoleLexer} class accepts five options:
# 1. **lang**: the shell language to lex (default: `shell`);
# 2. **output**: the output language (default: `plaintext?token=Generic.Output`);
# 3. **prompt**: comma-separated list of strings that indicate the end of a
#    prompt (default: `$,#,>,;`);
# 4. **comments**: whether to enable comments.
# 5. **error**: comma-separated list of strings that indicate the start of an
#    error message
#
# The comments option, if enabled, will lex lines that begin with a `#` as a
# comment. Please note that this option will only work if the prompt is
# either not manually specified or, if manually specified, does not include
# the `#` character.
#
# Most Markdown lexers that recognise GitHub-Flavored Markdown syntax, will
# pass the language string to Rouge as written in the original document.
# This allows an end user to pass options to {ConsoleLexer} by passing them
# as CGI-style parameters as in the example below.
#
# <pre>Here's some regular text.
#
# ```console?comments=true
# # This is a comment
# $ cp foo bar
# ```
#
# Some more regular text.</pre>
class Rouge::Lexers::ConsoleLexer < ::Rouge::Lexer
  # @return [ConsoleLexer] a new instance of ConsoleLexer
  def initialize(*_arg0); end

  # whether to allow comments. if manually specifying a prompt that isn't
  # simply "#", we flag this to on
  #
  # @return [Boolean]
  def allow_comments?; end

  def comment_regex; end
  def end_chars; end
  def error_regex; end
  def lang_lexer; end
  def line_regex; end
  def output_lexer; end
  def process_line(input, &output); end
  def prompt_prefix_regex; end
  def prompt_regex; end
  def stream_tokens(input, &output); end
end

class Rouge::Lexers::Coq < ::Rouge::RegexLexer
  class << self
    def classify(x); end
    def coq; end
    def end_sentence; end
    def gallina; end
    def keyopts; end
    def ltac; end
    def tacticals; end
    def terminators; end
  end
end

class Rouge::Lexers::Cpp < ::Rouge::Lexers::C
  class << self
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Crystal < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Cypher < ::Rouge::RegexLexer
  class << self
    def functions; end
    def keywords; end
    def predicates; end
  end
end

class Rouge::Lexers::Cython < ::Rouge::Lexers::Python
  # @return [Cython] a new instance of Cython
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def c_keywords; end
    def keywords; end
  end
end

class Rouge::Lexers::D < ::Rouge::RegexLexer; end
class Rouge::Lexers::Dafny < ::Rouge::RegexLexer; end
class Rouge::Lexers::Dart < ::Rouge::RegexLexer; end

class Rouge::Lexers::Datastudio < ::Rouge::RegexLexer
  class << self
    def sql_keywords; end
  end
end

class Rouge::Lexers::Diff < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Digdag < ::Rouge::Lexers::YAML; end

# http://docs.digdag.io/operators.html
# as of digdag v0.9.10
Rouge::Lexers::Digdag::KEYWORD_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Docker < ::Rouge::RegexLexer; end
Rouge::Lexers::Docker::KEYWORDS = T.let(T.unsafe(nil), String)
class Rouge::Lexers::Dot < ::Rouge::RegexLexer; end

class Rouge::Lexers::ECL < ::Rouge::RegexLexer
  class << self
    def class_first; end
    def class_second; end
    def functions; end
    def keywords; end
    def template; end
    def type; end
    def typed; end
  end
end

class Rouge::Lexers::EEX < ::Rouge::TemplateLexer
  # @return [EEX] a new instance of EEX
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::EPP < ::Rouge::TemplateLexer
  # @return [EPP] a new instance of EPP
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::ERB < ::Rouge::TemplateLexer
  # @return [ERB] a new instance of ERB
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::Eiffel < ::Rouge::RegexLexer; end
Rouge::Lexers::Eiffel::BooleanConstants = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::LanguageKeywords = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::LanguageVariables = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::SimpleString = T.let(T.unsafe(nil), Regexp)

# Direct port of pygments Lexer.
# See: https://bitbucket.org/birkenfeld/pygments-main/src/7304e4759ae65343d89a51359ca538912519cc31/pygments/lexers/functional.py?at=default#cl-2362
class Rouge::Lexers::Elixir < ::Rouge::RegexLexer; end

class Rouge::Lexers::Elm < ::Rouge::RegexLexer; end
class Rouge::Lexers::Email < ::Rouge::RegexLexer; end
class Rouge::Lexers::Erlang < ::Rouge::RegexLexer; end

class Rouge::Lexers::Escape < ::Rouge::Lexer
  # @return [Escape] a new instance of Escape
  def initialize(*_arg0); end

  # Returns the value of attribute end.
  def end; end

  # Returns the value of attribute lang.
  def lang; end

  # Returns the value of attribute start.
  def start; end

  def stream_tokens(str, &b); end
  def to_end_regex; end
  def to_start_regex; end
end

class Rouge::Lexers::FSharp < ::Rouge::RegexLexer
  class << self
    def keyopts; end
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::Factor < ::Rouge::RegexLexer
  class << self
    def builtins; end

    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Fluent < ::Rouge::RegexLexer; end

class Rouge::Lexers::Fortran < ::Rouge::RegexLexer
  class << self
    def intrinsics; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::FreeFEM < ::Rouge::Lexers::Cpp
  class << self
    def attributes; end
    def builtins; end

    # Override C/C++ ones (for example, `do` does not exists)
    def keywords; end

    # Override C/C++ ones (for example, `double` does not exists)
    def keywords_type; end

    # Override C/C++ ones (totally different)
    def reserved; end
  end
end

class Rouge::Lexers::GDScript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def builtins_type; end
    def keywords; end

    # Reserved for future implementation
    def keywords_reserved; end
  end
end

class Rouge::Lexers::GHCCmm < ::Rouge::RegexLexer; end
class Rouge::Lexers::GHCCore < ::Rouge::RegexLexer; end

class Rouge::Lexers::Gherkin < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end

    # self-modifying method that loads the keywords file
    def keywords; end

    def step_regex; end
  end
end

# This file defines the GLSL language lexer to the Rouge
# syntax highlighter.
#
# Author: Sri Harsha Chilakapati
class Rouge::Lexers::Glsl < ::Rouge::Lexers::C
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Go < ::Rouge::RegexLexer; end
Rouge::Lexers::Go::BIG_U_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::CHAR_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::COMMENT = T.let(T.unsafe(nil), Regexp)

# Floating-point literals
Rouge::Lexers::Go::DECIMALS = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::DECIMAL_DIGIT = T.let(T.unsafe(nil), Regexp)

# Integer literals
Rouge::Lexers::Go::DECIMAL_LIT = T.let(T.unsafe(nil), Regexp)

# Rune literals
Rouge::Lexers::Go::ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::ESCAPE_SEQUENCE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::EXPONENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::FLOAT_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::GENERAL_COMMENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_LIT = T.let(T.unsafe(nil), Regexp)

# Identifiers
Rouge::Lexers::Go::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# Imaginary literals
Rouge::Lexers::Go::IMAGINARY_LIT = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::INTERPRETED_STRING_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::INT_LIT = T.let(T.unsafe(nil), Regexp)

# Keywords
Rouge::Lexers::Go::KEYWORD = T.let(T.unsafe(nil), Regexp)

# Letters and digits
Rouge::Lexers::Go::LETTER = T.let(T.unsafe(nil), Regexp)

# Comments
Rouge::Lexers::Go::LINE_COMMENT = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::LITTLE_U_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::NEWLINE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_LIT = T.let(T.unsafe(nil), Regexp)

# Operators and delimiters
Rouge::Lexers::Go::OPERATOR = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::PREDECLARED_CONSTANTS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::PREDECLARED_FUNCTIONS = T.let(T.unsafe(nil), Regexp)

# Predeclared identifiers
Rouge::Lexers::Go::PREDECLARED_TYPES = T.let(T.unsafe(nil), Regexp)

# String literals
Rouge::Lexers::Go::RAW_STRING_LIT = T.let(T.unsafe(nil), Regexp)

Rouge::Lexers::Go::SEPARATOR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::STRING_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_CHAR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_LETTER = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_VALUE = T.let(T.unsafe(nil), Regexp)

# Characters
Rouge::Lexers::Go::WHITE_SPACE = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Gradle < ::Rouge::Lexers::Groovy
  class << self
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::GraphQL < ::Rouge::RegexLexer; end

class Rouge::Lexers::Groovy < ::Rouge::RegexLexer
  class << self
    def constants; end
    def declarations; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::HLSL < ::Rouge::Lexers::C
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::HOCON < ::Rouge::Lexers::JSON; end

class Rouge::Lexers::HQL < ::Rouge::Lexers::SQL
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::HTML < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::HTTP < ::Rouge::RegexLexer
  def content_lexer; end
  def guess_content_lexer; end

  class << self
    def http_methods; end
  end
end

class Rouge::Lexers::Hack < ::Rouge::Lexers::PHP
  class << self
    # @return [Boolean]
    def detect?(text); end

    def keywords; end
  end
end

# A lexer for the Haml templating system for Ruby.
#
# @see http://haml.info
class Rouge::Lexers::Haml < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Haml] a new instance of Haml
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute filters.
  def filters; end

  def html; end
  def ruby; end
  def ruby!(state); end
end

class Rouge::Lexers::Handlebars < ::Rouge::TemplateLexer; end

class Rouge::Lexers::Haskell < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Haxe < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end

    # @return [Boolean]
    def detect?(text); end

    def imports; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Hcl < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::HyLang < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::IDLang < ::Rouge::RegexLexer
  class << self
    def conditionals; end
    def decorators; end
    def exec_unit; end
    def keywords; end
    def operators; end
    def routines; end
    def standalone_statements; end
  end
end

class Rouge::Lexers::INI < ::Rouge::RegexLexer; end

class Rouge::Lexers::IO < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end

    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::IRBLexer < ::Rouge::Lexers::ConsoleLexer
  # @return [Boolean]
  def allow_comments?; end

  def lang_lexer; end
  def output_lexer; end
  def prompt_regex; end
end

class Rouge::Lexers::IRBOutputLexer < ::Rouge::Lexers::Ruby; end

class Rouge::Lexers::ISBL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def globals; end
    def interfaces; end
    def keywords; end
  end
end

class Rouge::Lexers::Idris < ::Rouge::RegexLexer
  class << self
    def ascii; end
    def prelude_functions; end
    def reserved_keywords; end
  end
end

class Rouge::Lexers::IgorPro < ::Rouge::RegexLexer
  class << self
    def igorConstants; end
    def igorDeclarations; end
    def igorFunction; end
    def igorOperation; end
    def keywords; end
    def object_name; end
    def preprocessor; end
  end
end

class Rouge::Lexers::J < ::Rouge::RegexLexer
  class << self
    def control_words; end
    def control_words_id; end

    # https://code.jsoftware.com/wiki/NuVoc
    def inflection_list; end

    def primitive(char, inflection); end
    def primitive_table; end

    # https://code.jsoftware.com/wiki/Vocabulary/PartsOfSpeech
    def token_map; end
  end
end

class Rouge::Lexers::JSL < ::Rouge::RegexLexer; end
class Rouge::Lexers::JSON < ::Rouge::RegexLexer; end
class Rouge::Lexers::JSONDOC < ::Rouge::Lexers::JSON; end

class Rouge::Lexers::JSP < ::Rouge::TemplateLexer
  # @return [JSP] a new instance of JSP
  def initialize(*_arg0); end
end

class Rouge::Lexers::JSX < ::Rouge::Lexers::Javascript; end

class Rouge::Lexers::Janet < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def bundled; end
    def specials; end
  end
end

class Rouge::Lexers::Java < ::Rouge::RegexLexer; end

# IMPORTANT NOTICE:
#
# Please do not copy this lexer and open a pull request
# for a new language. It will not get merged, you will
# be unhappy, and kittens will cry.
class Rouge::Lexers::Javascript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end

    # Pseudo-documentation: https://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names
    #
    # @return [Boolean]
    def detect?(text); end

    def id_regex; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Jinja < ::Rouge::TemplateLexer
  class << self
    def keywords; end
    def pseudo_keywords; end
    def tests; end
    def word_operators; end
  end
end

class Rouge::Lexers::Jsonnet < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
  end
end

class Rouge::Lexers::Julia < ::Rouge::RegexLexer
  class << self
    # Documentation: https://docs.julialang.org/en/v1/manual/variables/#Allowed-Variable-Names-1
    #
    # @return [Boolean]
    def detect?(text); end
  end
end

Rouge::Lexers::Julia::BUILTINS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::KEYWORDS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::OPERATORS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::PUNCTUATION = T.let(T.unsafe(nil), Regexp)

# NOTE: The list of types was generated automatically using the following script:
# using Pkg, InteractiveUtils
#
# allnames = [names(Core); names(Base, imported=true)]
#
# for stdlib in readdir(Pkg.Types.stdlib_dir())
#     mod = Symbol(basename(stdlib))
#     @eval begin
#         using $mod
#         append!(allnames, names($mod))
#     end
# end
#
# sort!(unique!(allnames))
#
# i = 1
# for sym in allnames
#     global i # needed at the top level, e.g. in the REPL
#     isdefined(Main, sym) || continue
#     getfield(which(Main, sym), sym) isa Type || continue
#     sym === :(=>) && continue # Actually an alias for Pair
#     print("| ", sym)
#     i % 3 == 0 ? println() : print(" ") # print 3 to a line
#     i += 1
# end
Rouge::Lexers::Julia::TYPES = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Kotlin < ::Rouge::RegexLexer; end

class Rouge::Lexers::LLVM < ::Rouge::RegexLexer
  class << self
    def instructions; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::Lasso < ::Rouge::TemplateLexer
  # @return [Lasso] a new instance of Lasso
  def initialize(*_arg0); end

  # @return [Boolean]
  def start_inline?; end

  class << self
    # @return [Boolean]
    def detect?(text); end

    # self-modifying method that loads the keywords file
    def keywords; end
  end
end

class Rouge::Lexers::Lean < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def operators; end
    def types; end
  end
end

class Rouge::Lexers::Liquid < ::Rouge::RegexLexer; end

class Rouge::Lexers::LiterateCoffeescript < ::Rouge::RegexLexer
  def coffee; end
  def markdown; end
end

class Rouge::Lexers::LiterateHaskell < ::Rouge::RegexLexer
  def haskell; end
end

class Rouge::Lexers::Livescript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
    def loop_control_keywords; end
  end
end

class Rouge::Lexers::Lua < ::Rouge::RegexLexer
  # @return [Lua] a new instance of Lua
  def initialize(opts = T.unsafe(nil)); end

  def builtins; end

  class << self
    def builtins; end

    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Lustre < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::Lutin < ::Rouge::Lexers::Lustre
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::M68k < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::MXML < ::Rouge::RegexLexer; end

class Rouge::Lexers::Magik < ::Rouge::RegexLexer
  class << self
    def character; end
    def decimal; end
    def digits; end
    def exponent; end
    def global_ref; end
    def identifier; end
    def keywords; end
    def label; end
    def number; end
    def package_identifier; end
    def piped_identifier; end
    def radix; end
    def simple_identifier; end
    def string_double; end
    def string_single; end
    def symbol; end
  end
end

class Rouge::Lexers::Make < ::Rouge::RegexLexer
  # TODO: Add support for special keywords
  # bsd_special = %w(
  #   include undef error warning if else elif endif for endfor
  # )
  #
  # @return [Make] a new instance of Make
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def functions; end
  end
end

class Rouge::Lexers::Markdown < ::Rouge::RegexLexer
  def html; end
end

class Rouge::Lexers::Mason < ::Rouge::TemplateLexer
  # @return [Mason] a new instance of Mason
  def initialize(*_arg0); end
end

Rouge::Lexers::Mason::COMPONENTS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Mason::PERL_BLOCKS = T.let(T.unsafe(nil), Array)

# Note: If you add a tag in the lines below, you also need to modify "disambiguate '*.m'" in file disambiguation.rb
Rouge::Lexers::Mason::TEXT_BLOCKS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::Mathematica < ::Rouge::RegexLexer
  class << self
    # The list of built-in symbols comes from a wolfram server and is created automatically by rake
    def builtins; end

    # Although Module, With and Block are normal built-in symbols, we give them a special treatment as they are
    # the most important expressions for defining local variables
    def keywords; end
  end
end

class Rouge::Lexers::Matlab < ::Rouge::RegexLexer
  class << self
    # self-modifying method that loads the builtins file
    def builtins; end

    def keywords; end
  end
end

class Rouge::Lexers::MiniZinc < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def operators; end
  end
end

class Rouge::Lexers::Moonscript < ::Rouge::RegexLexer
  # @return [Moonscript] a new instance of Moonscript
  def initialize(*_arg0); end

  def builtins; end

  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Mosel < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::MsgTrans < ::Rouge::RegexLexer; end
class Rouge::Lexers::Nasm < ::Rouge::RegexLexer; end

class Rouge::Lexers::NesAsm < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_reserved; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Nginx < ::Rouge::RegexLexer; end

class Rouge::Lexers::Nim < ::Rouge::RegexLexer
  class << self
    def underscorize(words); end
  end
end

Rouge::Lexers::Nim::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::NAMESPACE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::OPWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::PSEUDOKEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::TYPES = T.let(T.unsafe(nil), Array)
class Rouge::Lexers::Nix < ::Rouge::RegexLexer; end

class Rouge::Lexers::OCL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def functions; end
    def keywords; end
    def keywords_type; end
    def operators; end
  end
end

class Rouge::Lexers::OCaml < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
  end
end

# shared states with Reasonml and ReScript
class Rouge::Lexers::OCamlCommon < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::ObjectiveC < ::Rouge::Lexers::C
  extend ::Rouge::Lexers::ObjectiveCCommon
end

module Rouge::Lexers::ObjectiveCCommon
  def at_builtins; end
  def at_keywords; end
  def builtins; end

  class << self
    # @private
    def extended(base); end
  end
end

class Rouge::Lexers::ObjectiveCpp < ::Rouge::Lexers::Cpp
  extend ::Rouge::Lexers::ObjectiveCCommon
end

class Rouge::Lexers::OpenEdge < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::OpenTypeFeatureFile < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::PHP < ::Rouge::TemplateLexer
  # @return [PHP] a new instance of PHP
  def initialize(*_arg0); end

  def builtins; end

  class << self
    def builtins; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
  end
end

class Rouge::Lexers::PLSQL < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_func; end
    def keywords_reserved; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Pascal < ::Rouge::RegexLexer; end

class Rouge::Lexers::Perl < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::PlainText < ::Rouge::Lexer
  # @return [PlainText] a new instance of PlainText
  def initialize(*_arg0); end

  # @yield [self.token, string]
  def stream_tokens(string, &b); end

  # Returns the value of attribute token.
  def token; end
end

class Rouge::Lexers::Plist < ::Rouge::RegexLexer; end
class Rouge::Lexers::Pony < ::Rouge::RegexLexer; end

class Rouge::Lexers::PostScript < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Powershell < ::Rouge::RegexLexer; end

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-6
Rouge::Lexers::Powershell::ATTRIBUTES = T.let(T.unsafe(nil), Array)

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-6
Rouge::Lexers::Powershell::AUTO_VARS = T.let(T.unsafe(nil), String)

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_reserved_words?view=powershell-6
Rouge::Lexers::Powershell::KEYWORDS = T.let(T.unsafe(nil), String)

# https://devblogs.microsoft.com/scripting/powertip-find-a-list-of-powershell-type-accelerators/
# ([PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get).Keys -join ' '
Rouge::Lexers::Powershell::KEYWORDS_TYPE = T.let(T.unsafe(nil), String)

Rouge::Lexers::Powershell::MULTILINE_KEYWORDS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Powershell::OPERATORS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Praat < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Prolog < ::Rouge::RegexLexer; end

class Rouge::Lexers::Prometheus < ::Rouge::RegexLexer
  class << self
    def functions; end
  end
end

class Rouge::Lexers::Properties < ::Rouge::RegexLexer; end
class Rouge::Lexers::Protobuf < ::Rouge::RegexLexer; end

class Rouge::Lexers::Puppet < ::Rouge::RegexLexer
  class << self
    def constants; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
    def metaparameters; end
  end
end

class Rouge::Lexers::Python < ::Rouge::RegexLexer
  def current_string; end

  class << self
    def builtins; end
    def builtins_pseudo; end

    # @return [Boolean]
    def detect?(text); end

    def exceptions; end
    def keywords; end
  end
end

class Rouge::Lexers::Python::StringRegister < ::Array
  # @return [Boolean]
  def delim?(delim); end

  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end
  def remove; end

  # @return [Boolean]
  def type?(type); end
end

class Rouge::Lexers::Q < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def word_operators; end
  end
end

class Rouge::Lexers::Qml < ::Rouge::Lexers::Javascript; end

class Rouge::Lexers::R < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

Rouge::Lexers::R::BUILTIN_CONSTANTS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::R::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::R::KEYWORD_CONSTANTS = T.let(T.unsafe(nil), Array)

# These are all the functions in `base` that are implemented as a
# `.Primitive`, minus those functions that are also keywords.
Rouge::Lexers::R::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::Racket < ::Rouge::RegexLexer
  class << self
    def builtins; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
  end
end

class Rouge::Lexers::ReScript < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
    def types; end
    def word_operators; end
  end
end

class Rouge::Lexers::ReasonML < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Rego < ::Rouge::RegexLexer
  class << self
    def constants; end
    def operators; end
  end
end

class Rouge::Lexers::RobotFramework < ::Rouge::RegexLexer
  # @return [RobotFramework] a new instance of RobotFramework
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def settings_with_args; end
    def settings_with_keywords; end
  end
end

class Rouge::Lexers::Ruby < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Rust < ::Rouge::RegexLexer
  # @return [Boolean]
  def macro_closed?; end

  class << self
    def builtins; end

    # @return [Boolean]
    def detect?(text); end

    def keywords; end
  end
end

class Rouge::Lexers::SAS < ::Rouge::RegexLexer
  class << self
    def data_step_statements; end
    def proc_keywords; end
    def sas_auto_macro_vars; end
    def sas_functions; end
    def sas_macro_functions; end
    def sas_macro_statements; end
    def sas_proc_names; end
  end
end

class Rouge::Lexers::SML < ::Rouge::RegexLexer
  def token_for_final_id(id); end
  def token_for_id(id); end
  def token_for_id_with_dot(id); end

  class << self
    def keywords; end
    def symbolic_reserved; end
  end
end

class Rouge::Lexers::SPARQL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::SQF < ::Rouge::RegexLexer
  class << self
    def commands; end
    def constants; end
    def controlflow; end
    def diag_commands; end
    def initializers; end
    def namespaces; end
    def wordoperators; end
  end
end

class Rouge::Lexers::SQL < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::SSH < ::Rouge::RegexLexer; end

class Rouge::Lexers::Sass < ::Rouge::Lexers::SassCommon
  include ::Rouge::Indentation
end

# shared states with SCSS
class Rouge::Lexers::SassCommon < ::Rouge::RegexLexer; end

class Rouge::Lexers::Scala < ::Rouge::RegexLexer; end

class Rouge::Lexers::Scheme < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::Scss < ::Rouge::Lexers::SassCommon; end

class Rouge::Lexers::Sed < ::Rouge::RegexLexer
  def regex; end
  def replacement; end

  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Sed::Regex < ::Rouge::RegexLexer; end
class Rouge::Lexers::Sed::Replacement < ::Rouge::RegexLexer; end

class Rouge::Lexers::Shell < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

Rouge::Lexers::Shell::BUILTINS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Shell::KEYWORDS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Sieve < ::Rouge::RegexLexer
  class << self
    def actions; end

    # control commands (rfc5228  3)
    def controls; end

    def tests; end
  end
end

class Rouge::Lexers::Slice < ::Rouge::Lexers::C
  class << self
    def keywords; end
    def keywords_type; end
  end
end

# A lexer for the Slim tempalte language
#
# @see http://slim-lang.org
class Rouge::Lexers::Slim < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  def filters; end
  def html; end
  def ruby; end
end

class Rouge::Lexers::Smalltalk < ::Rouge::RegexLexer; end

class Rouge::Lexers::Smarty < ::Rouge::TemplateLexer
  class << self
    def builtins; end
  end
end

class Rouge::Lexers::Solidity < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end

    # @return [Boolean]
    def detect?(text); end

    # TODO: seperate by "type"
    def keywords; end

    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Stan < ::Rouge::RegexLexer
  class << self
    def builtin_functions; end
    def constants; end
    def distributions; end
    def keywords; end
    def reserved; end
    def types; end
  end
end

Rouge::Lexers::Stan::ID = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Stan::OP = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Stan::RT = T.let(T.unsafe(nil), Regexp)

# optional comment or whitespace
Rouge::Lexers::Stan::WS = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Stata < ::Rouge::RegexLexer
  class << self
    # Stata commands used with braces. Includes all valid abbreviations for 'forvalues'.
    def reserved_keywords; end

    # Note: types `str1-str2045` handled separately below
    def type_keywords; end
  end
end

# Partial list of common programming and estimation commands, as of Stata 16
# Note: not all abbreviations are included
Rouge::Lexers::Stata::KEYWORDS = T.let(T.unsafe(nil), Array)

# Complete list of functions by name, as of Stata 16
Rouge::Lexers::Stata::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::SuperCollider < ::Rouge::RegexLexer
  class << self
    def constants; end
    def keywords; end

    # these aren't technically keywords, but we treat
    # them as such because it makes things clearer 99%
    # of the time
    def reserved; end
  end
end

class Rouge::Lexers::Swift < ::Rouge::RegexLexer; end
class Rouge::Lexers::SystemD < ::Rouge::RegexLexer; end

class Rouge::Lexers::Syzlang < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Syzprog < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::TCL < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end

    def gen_command_state(name = T.unsafe(nil)); end
    def gen_delimiter_states(name, close, opts = T.unsafe(nil)); end
  end
end

Rouge::Lexers::TCL::ALL = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::BUILTINS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::CHARS = T.let(T.unsafe(nil), Proc)
Rouge::Lexers::TCL::CLOSE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::END_LINE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::END_WORD = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::NOT_CHARS = T.let(T.unsafe(nil), Proc)
Rouge::Lexers::TCL::OPEN = T.let(T.unsafe(nil), Array)
class Rouge::Lexers::TOML < ::Rouge::RegexLexer; end

class Rouge::Lexers::TSX < ::Rouge::Lexers::JSX
  extend ::Rouge::Lexers::TypescriptCommon
end

class Rouge::Lexers::TTCN3 < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def reserved; end
    def types; end
  end
end

class Rouge::Lexers::Tap < ::Rouge::RegexLexer; end

class Rouge::Lexers::TeX < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Terraform < ::Rouge::Lexers::Hcl
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Tulip < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::Turtle < ::Rouge::RegexLexer; end

class Rouge::Lexers::Twig < ::Rouge::Lexers::Jinja
  class << self
    def keywords; end
    def pseudo_keywords; end
    def tests; end
    def word_operators; end
  end
end

class Rouge::Lexers::Typescript < ::Rouge::Lexers::Javascript
  extend ::Rouge::Lexers::TypescriptCommon
end

module Rouge::Lexers::TypescriptCommon
  def builtins; end
  def declarations; end
  def keywords; end
  def reserved; end

  class << self
    # @private
    def extended(base); end
  end
end

class Rouge::Lexers::VHDL < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
    def operator_words; end
  end
end

class Rouge::Lexers::Vala < ::Rouge::RegexLexer; end

class Rouge::Lexers::Varnish < ::Rouge::RegexLexer
  class << self
    def functions; end

    # backend acl
    def keywords; end

    def variables; end
  end
end

Rouge::Lexers::Varnish::SPACE = T.let(T.unsafe(nil), String)
class Rouge::Lexers::Velocity < ::Rouge::TemplateLexer; end

class Rouge::Lexers::Verilog < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_system_task; end
    def keywords_type; end
  end
end

class Rouge::Lexers::VimL < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::VisualBasic < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def operator_words; end
  end
end

class Rouge::Lexers::Vue < ::Rouge::Lexers::HTML
  # @return [Vue] a new instance of Vue
  def initialize(*_arg0); end

  def lookup_lang(lang); end
end

class Rouge::Lexers::Wollok < ::Rouge::RegexLexer; end

class Rouge::Lexers::XML < ::Rouge::RegexLexer
  class << self
    # Documentation: https://www.w3.org/TR/xml11/#charsets and https://www.w3.org/TR/xml11/#sec-suggested-names
    #
    # @return [Boolean]
    def detect?(text); end
  end
end

class Rouge::Lexers::XPath < ::Rouge::RegexLexer
  class << self
    def axes; end
    def commentStart; end
    def constructorTypes; end
    def decimalLiteral; end

    # Terminal literals:
    # https://www.w3.org/TR/xpath-31/#terminal-symbols
    def digits; end

    def doubleLiteral; end
    def eqName; end
    def keywords; end

    # Terminal symbols:
    # https://www.w3.org/TR/xpath-30/#id-terminal-delimitation
    def kindTest; end

    def kindTestForPI; end
    def ncName; end
    def openParen; end
    def operators; end
    def qName; end
    def stringLiteral; end
    def uriQName; end
    def word_operators; end
  end
end

class Rouge::Lexers::XQuery < ::Rouge::Lexers::XPath
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Xojo < ::Rouge::RegexLexer; end

class Rouge::Lexers::YAML < ::Rouge::RegexLexer
  def continue_indent(match); end

  # @return [Boolean]
  def dedent?(level); end

  def indent; end

  # @return [Boolean]
  def indent?(level); end

  # reset the indentation levels
  def reset_indent; end

  # Save a possible indentation level
  def save_indent(match); end

  def set_indent(match, opts = T.unsafe(nil)); end

  class << self
    # Documentation: https://yaml.org/spec/1.2/spec.html
    #
    # @return [Boolean]
    def detect?(text); end
  end
end

Rouge::Lexers::YAML::SPECIAL_VALUES = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::YANG < ::Rouge::RegexLexer
  class << self
    def body_stmts_keywords; end

    # RFC7950 other keywords
    def constants_keywords; end

    def data_def_stmts_keywords; end
    def linkage_stmts_keywords; end
    def list_stmts_keywords; end
    def meta_stmts_keywords; end
    def module_header_stmts_keywords; end

    # Keywords from RFC7950 ; oriented at BNF style
    def top_stmts_keywords; end

    def type_stmts_keywords; end

    # RFC7950 Built-In Types
    def types; end
  end
end

class Rouge::Lexers::Zig < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

# A stateful lexer that uses sets of regular expressions to
# tokenize a string.  Most lexers are instances of RegexLexer.
#
# @abstract
class Rouge::RegexLexer < ::Rouge::Lexer
  # Delegate the lex to another lexer. We use the `continue_lex` method
  # so that #reset! will not be called.  In this way, a single lexer
  # can be repeatedly delegated to while maintaining its own internal
  # state stack.
  #
  # @param lexer [#lex] The lexer or lexer class to delegate to
  # @param text [String] The text to delegate.  This defaults to the last matched string.
  def delegate(lexer, text = T.unsafe(nil)); end

  # @private
  def get_state(state_name); end

  # replace the head of the stack with the given state
  def goto(state_name); end

  # Yield a token with the next matched group.  Subsequent calls
  # to this method will yield subsequent groups.
  #
  # @deprecated
  def group(tok); end

  # Yield tokens corresponding to the matched groups of the current
  # match.
  def groups(*tokens); end

  # Check if `state_name` is in the state stack.
  #
  # @return [Boolean]
  def in_state?(state_name); end

  # Pop the state stack.  If a number is passed in, it will be popped
  # that number of times.
  def pop!(times = T.unsafe(nil)); end

  # Push a state onto the stack.  If no state name is given and you've
  # passed a block, a state will be dynamically created using the
  # {StateDSL}.
  def push(state_name = T.unsafe(nil), &b); end

  def recurse(text = T.unsafe(nil)); end

  # reset this lexer to its initial state.  This runs all of the
  # start_procs.
  def reset!; end

  # reset the stack back to `[:root]`.
  def reset_stack; end

  # The state stack.  This is initially the single state `[:root]`.
  # It is an error for this stack to be empty.
  #
  # @see #state
  def stack; end

  # The current state - i.e. one on top of the state stack.
  #
  # NB: if the state stack is empty, this will throw an error rather
  # than returning nil.
  def state; end

  # Check if `state_name` is the state on top of the state stack.
  #
  # @return [Boolean]
  def state?(state_name); end

  # Runs one step of the lex.  Rules in the current state are tried
  # until one matches, at which point its callback is called.
  #
  # @return true if a rule was tried successfully
  # @return false otherwise.
  def step(state, stream); end

  # This implements the lexer protocol, by yielding [token, value] pairs.
  #
  # The process for lexing works as follows, until the stream is empty:
  #
  # 1. We look at the state on top of the stack (which by default is
  #    `[:root]`).
  # 2. Each rule in that state is tried until one is successful.  If one
  #    is found, that rule's callback is evaluated - which may yield
  #    tokens and manipulate the state stack.  Otherwise, one character
  #    is consumed with an `'Error'` token, and we continue at (1.)
  #
  # @see #step #step (where (2.) is implemented)
  def stream_tokens(str, &b); end

  # Yield a token.
  #
  # @param tok the token type
  # @param val (optional) the string value to yield.  If absent, this defaults
  #   to the entire last match.
  def token(tok, val = T.unsafe(nil)); end

  private

  def yield_token(tok, val); end

  class << self
    def append(name, &b); end

    # @private
    def get_state(name); end

    def prepend(name, &b); end
    def replace_state(name, new_defn); end

    # Specify an action to be run every fresh lex.
    #
    # @example
    #   start { puts "I'm lexing a new string!" }
    def start(&b); end

    # The routines to run at the beginning of a fresh lex.
    #
    # @see start
    def start_procs; end

    # Define a new state for this lexer with the given name.
    # The block will be evaluated in the context of a {StateDSL}.
    def state(name, &b); end

    def state_definitions; end

    # The states hash for this lexer.
    #
    # @see state
    def states; end
  end
end

class Rouge::RegexLexer::ClosedState < ::StandardError
  # @return [ClosedState] a new instance of ClosedState
  def initialize(state); end

  def rule; end

  # Returns the value of attribute state.
  def state; end

  def to_s; end
end

class Rouge::RegexLexer::InvalidRegex < ::StandardError
  # @return [InvalidRegex] a new instance of InvalidRegex
  def initialize(re); end

  def to_s; end
end

# The number of successive scans permitted without consuming
# the input stream.  If this is exceeded, the match fails.
Rouge::RegexLexer::MAX_NULL_SCANS = T.let(T.unsafe(nil), Integer)

# A rule is a tuple of a regular expression to test, and a callback
# to perform if the test succeeds.
#
# @see StateDSL#rule
class Rouge::RegexLexer::Rule
  # @return [Rule] a new instance of Rule
  def initialize(re, callback); end

  # Returns the value of attribute beginning_of_line.
  def beginning_of_line; end

  # Returns the value of attribute callback.
  def callback; end

  def inspect; end

  # Returns the value of attribute re.
  def re; end
end

# a State is a named set of rules that can be tested for or
# mixed in.
#
# @see RegexLexer.state
class Rouge::RegexLexer::State
  # @return [State] a new instance of State
  def initialize(name, rules); end

  def inspect; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute rules.
  def rules; end
end

class Rouge::RegexLexer::StateDSL
  # @return [StateDSL] a new instance of StateDSL
  def initialize(name, &defn); end

  def appended(&defn); end

  # Returns the value of attribute name.
  def name; end

  def prepended(&defn); end

  # Returns the value of attribute rules.
  def rules; end

  def to_state(lexer_class); end

  protected

  def close!; end

  # @return [Boolean]
  def context_sensitive?(re); end

  # Mix in the rules from another state into this state.  The rules
  # from the mixed-in state will be tried in order before moving on
  # to the rest of the rules in this state.
  def mixin(state); end

  # Define a new rule for this state.
  #
  # @overload rule
  # @overload rule
  # @param re [Regexp] a regular expression for this rule to test.
  # @param tok [String] the token type to yield if `re` matches.
  # @param next_state [#to_s] (optional) a state to push onto the stack if `re` matches.
  #   If `next_state` is `:pop!`, the state stack will be popped
  #   instead.
  # @param callback [Proc] a block that will be evaluated in the context of the lexer
  #   if `re` matches.  This block has access to a number of lexer
  #   methods, including {RegexLexer#push}, {RegexLexer#pop!},
  #   {RegexLexer#token}, and {RegexLexer#delegate}.  The first
  #   argument can be used to access the match groups.
  # @raise [ClosedState]
  def rule(re, tok = T.unsafe(nil), next_state = T.unsafe(nil), &callback); end

  private

  def load!; end
end

# A TemplateLexer is one that accepts a :parent option, to specify
# which language is being templated.  The lexer class can specify its
# own default for the parent lexer, which is otherwise defaulted to
# HTML.
#
# @abstract
class Rouge::TemplateLexer < ::Rouge::RegexLexer
  # the parent lexer - the one being templated.
  def parent; end
end

class Rouge::TexThemeRenderer
  # @return [TexThemeRenderer] a new instance of TexThemeRenderer
  def initialize(theme, opts = T.unsafe(nil)); end

  def camelize(name); end
  def gen_inline(name, &b); end
  def inline_name(color); end
  def palette_name(name); end

  # Our general strategy is this:
  #
  # * First, define the \RG{tokname}{content} command, which will
  #   expand into \RG@tok@tokname{content}. We use \csname...\endcsname
  #   to interpolate into a command.
  #
  # * Define the default RG* environment, which will enclose the whole
  #   thing. By default this will simply set \ttfamily (select monospace font)
  #   but it can be overridden with \renewcommand by the user to be
  #   any other formatting.
  #
  # * Define all the colors using xcolors \definecolor command. First we define
  #   every palette color with a name such as RG@palette@themneame@colorname.
  #   Then we find all foreground and background colors that have literal html
  #   colors embedded in them and define them with names such as
  #   RG@palette@themename@000000. While html allows three-letter colors such
  #   as #FFF, xcolor requires all six characters to be present, so we make sure
  #   to normalize that as well as the case convention in #inline_name.
  #
  # * Define the token commands RG@tok@xx. These will take the content as the
  #   argument and format it according to the theme, referring to the color
  #   in the palette.
  #
  # @yield [<<'END'.gsub('RG', @prefix)
  # \makeatletter
  # \def\RG#1#2{\csname RG@tok@#1\endcsname{#2}}%
  # \newenvironment{RG*}{\ttfamily}{\relax}%
  # END]
  def render(&b); end

  def render_blank(tok, &b); end
  def render_inline_pallete(style, &b); end
  def render_palette(palette, &b); end

  # @yield [out]
  def render_style(tok, style, &b); end

  def token_name(tok); end
end

class Rouge::TextAnalyzer < ::String
  # Return the contents of the doctype tag if present, nil otherwise.
  def doctype; end

  # Check if the doctype matches a given regexp or string
  #
  # @return [Boolean]
  def doctype?(type = T.unsafe(nil)); end

  # Return true if the result of lexing with the given lexer contains no
  # error tokens.
  #
  # @return [Boolean]
  def lexes_cleanly?(lexer); end

  # Find a shebang.  Returns nil if no shebang is present.
  def shebang; end

  # Check if the given shebang is present.
  #
  # This normalizes things so that `text.shebang?('bash')` will detect
  # `#!/bash`, '#!/bin/bash', '#!/usr/bin/env bash', and '#!/bin/bash -x'
  #
  # @return [Boolean]
  def shebang?(match); end
end

class Rouge::Theme
  include ::Rouge::Token::Tokens

  def get_own_style(token); end
  def get_style(token); end
  def name; end
  def palette(*a); end
  def styles; end

  class << self
    def base_style; end
    def find(n); end
    def get_own_style(token); end
    def get_style(token); end
    def name(n = T.unsafe(nil)); end
    def palette(arg = T.unsafe(nil)); end
    def register(name); end
    def registry; end
    def render(opts = T.unsafe(nil), &b); end
    def style(*tokens); end
    def styles; end
  end
end

class Rouge::Theme::Style < ::Hash
  # @return [Style] a new instance of Style
  def initialize(theme, hsh = T.unsafe(nil)); end

  def bg; end
  def fg; end

  # @yield ["#{selector} {"]
  def render(selector, &b); end

  # @yield ["color: #{fg}"]
  def rendered_rules(&b); end
end

module Rouge::Themes; end

# default base16 theme
# by Chris Kempson (http://chriskempson.com)
class Rouge::Themes::Base16 < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    def dark!; end
    def light!; end
    def make_dark!; end
    def make_light!; end
  end
end

class Rouge::Themes::Base16::Monokai < ::Rouge::Themes::Base16; end
class Rouge::Themes::Base16::Solarized < ::Rouge::Themes::Base16; end

# A port of the bw style from Pygments.
# See https://bitbucket.org/birkenfeld/pygments-main/src/default/pygments/styles/bw.py
class Rouge::Themes::BlackWhiteTheme < ::Rouge::CSSTheme; end

# stolen from pygments
class Rouge::Themes::Colorful < ::Rouge::CSSTheme; end

class Rouge::Themes::Github < ::Rouge::CSSTheme; end

# Based on https://github.com/morhetz/gruvbox, with help from
# https://github.com/daveyarwood/gruvbox-pygments
class Rouge::Themes::Gruvbox < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    def dark!; end
    def light!; end
    def make_dark!; end
    def make_light!; end
  end
end

Rouge::Themes::Gruvbox::C_bright_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_yellow = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark0 = T.let(T.unsafe(nil), String)

# global Gruvbox colours {{{
Rouge::Themes::Gruvbox::C_dark0_hard = T.let(T.unsafe(nil), String)

Rouge::Themes::Gruvbox::C_dark0_soft = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark1 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark2 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark3 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark4 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark4_256 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_yellow = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_gray_244 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_gray_245 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0_hard = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0_soft = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light1 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light2 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light3 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light4 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light4_256 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_yellow = T.let(T.unsafe(nil), String)
class Rouge::Themes::IgorPro < ::Rouge::CSSTheme; end
class Rouge::Themes::Magritte < ::Rouge::CSSTheme; end
class Rouge::Themes::Molokai < ::Rouge::CSSTheme; end
class Rouge::Themes::Monokai < ::Rouge::CSSTheme; end
class Rouge::Themes::MonokaiSublime < ::Rouge::CSSTheme; end

# A port of the pastie style from Pygments.
# See https://bitbucket.org/birkenfeld/pygments-main/src/default/pygments/styles/pastie.py
class Rouge::Themes::Pastie < ::Rouge::CSSTheme; end

class Rouge::Themes::ThankfulEyes < ::Rouge::CSSTheme; end
class Rouge::Themes::Tulip < ::Rouge::CSSTheme; end

class Rouge::Token
  class << self
    def [](qualname); end
    def cache; end
    def each_token(&b); end
    def inspect; end
    def make_token(name, shortname, &b); end

    # @return [Boolean]
    def matches?(other); end

    # Returns the value of attribute name.
    def name; end

    # Returns the value of attribute parent.
    def parent; end

    def qualname; end
    def register!; end

    # Returns the value of attribute shortname.
    def shortname; end

    def sub_tokens; end
    def token(name, shortname, &b); end
    def token_chain; end
  end
end

module Rouge::Token::Tokens
  class << self
    def token(name, shortname, &b); end
  end
end

class Rouge::Token::Tokens::Comment < ::Rouge::Token; end
class Rouge::Token::Tokens::Comment::Doc < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Hashbang < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Multiline < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Preproc < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::PreprocFile < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Single < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Special < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Error < ::Rouge::Token; end
class Rouge::Token::Tokens::Escape < ::Rouge::Token; end
class Rouge::Token::Tokens::Generic < ::Rouge::Token; end
class Rouge::Token::Tokens::Generic::Deleted < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Emph < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Error < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Heading < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Inserted < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Lineno < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Output < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Prompt < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Strong < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Subheading < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Traceback < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Keyword < ::Rouge::Token; end
class Rouge::Token::Tokens::Keyword::Constant < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Declaration < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Namespace < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Pseudo < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Reserved < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Type < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Variable < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Literal < ::Rouge::Token; end
class Rouge::Token::Tokens::Literal::Date < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::Number < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::Number::Bin < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Float < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Hex < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Integer < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Integer::Long < ::Rouge::Token::Tokens::Literal::Number::Integer; end
class Rouge::Token::Tokens::Literal::Number::Oct < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Other < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::String < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::String::Affix < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Backtick < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Char < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Delimiter < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Doc < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Double < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Escape < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Heredoc < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Interpol < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Other < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Regex < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Single < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Symbol < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Name < ::Rouge::Token; end
class Rouge::Token::Tokens::Name::Attribute < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Builtin < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Builtin::Pseudo < ::Rouge::Token::Tokens::Name::Builtin; end
class Rouge::Token::Tokens::Name::Class < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Constant < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Decorator < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Entity < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Exception < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Function < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Function::Magic < ::Rouge::Token::Tokens::Name::Function; end
class Rouge::Token::Tokens::Name::Label < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Namespace < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Other < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Property < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Tag < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Variable < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Variable::Class < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Global < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Instance < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Magic < ::Rouge::Token::Tokens::Name::Variable; end

# convenience
Rouge::Token::Tokens::Num = Rouge::Token::Tokens::Literal::Number

class Rouge::Token::Tokens::Operator < ::Rouge::Token; end
class Rouge::Token::Tokens::Operator::Word < ::Rouge::Token::Tokens::Operator; end
class Rouge::Token::Tokens::Other < ::Rouge::Token; end
class Rouge::Token::Tokens::Punctuation < ::Rouge::Token; end
class Rouge::Token::Tokens::Punctuation::Indicator < ::Rouge::Token::Tokens::Punctuation; end
Rouge::Token::Tokens::Str = Rouge::Token::Tokens::Literal::String
class Rouge::Token::Tokens::Text < ::Rouge::Token; end
class Rouge::Token::Tokens::Text::Whitespace < ::Rouge::Token::Tokens::Text; end
