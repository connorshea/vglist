# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rouge` gem.
# Please instead update this file by running `bin/tapioca gem rouge`.

module Rouge
  class << self
    def highlight(text, lexer, formatter, &b); end
    def load_file(path); end
    def load_lexers; end
    def reload!; end
    def version; end
  end
end

class Rouge::CSSTheme < ::Rouge::Theme
  def initialize(opts = T.unsafe(nil)); end

  def render(&b); end
  def render_base(selector, &b); end
  def style_for(tok); end

  private

  def css_selector(token); end
  def inflate_token(tok, &b); end
  def single_css_selector(token); end
end

class Rouge::Formatter
  def initialize(opts = T.unsafe(nil)); end

  def escape?(tok); end
  def filter_escapes(tokens); end
  def format(tokens, &b); end
  def render(tokens); end
  def stream(tokens, &b); end

  protected

  def token_lines(tokens, &b); end

  class << self
    def disable_escape!; end
    def enable_escape!; end
    def escape_enabled?; end
    def find(tag); end
    def format(tokens, *args, **kwargs, &b); end
    def tag(tag = T.unsafe(nil)); end
    def with_escape; end
  end
end

Rouge::Formatter::REGISTRY = T.let(T.unsafe(nil), Hash)
module Rouge::Formatters; end

class Rouge::Formatters::HTML < ::Rouge::Formatter
  def safe_span(tok, safe_val); end
  def span(tok, val); end
  def stream(tokens, &b); end

  private

  def escape_special_html_chars(value); end
end

Rouge::Formatters::HTML::TABLE_FOR_ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

class Rouge::Formatters::HTMLInline < ::Rouge::Formatters::HTML
  def initialize(theme); end

  def safe_span(tok, safe_val); end
end

class Rouge::Formatters::HTMLLegacy < ::Rouge::Formatter
  def initialize(opts = T.unsafe(nil)); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLLineHighlighter < ::Rouge::Formatter
  def initialize(delegate, opts = T.unsafe(nil)); end

  def stream(tokens); end
end

class Rouge::Formatters::HTMLLineTable < ::Rouge::Formatter
  def initialize(formatter, opts = T.unsafe(nil)); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLLinewise < ::Rouge::Formatter
  def initialize(formatter, opts = T.unsafe(nil)); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLPygments < ::Rouge::Formatter
  def initialize(inner, css_class = T.unsafe(nil)); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::HTMLTable < ::Rouge::Formatter
  def initialize(inner, opts = T.unsafe(nil)); end

  def stream(tokens, &b); end
  def style(scope); end
end

class Rouge::Formatters::Null < ::Rouge::Formatter
  def initialize(*_arg0); end

  def stream(tokens, &b); end
end

class Rouge::Formatters::Terminal256 < ::Rouge::Formatter
  def initialize(theme = T.unsafe(nil)); end

  def escape_sequence(token); end
  def get_style(token); end
  def make_escape_sequence(style); end
  def stream(tokens, &b); end
  def text_style; end
  def theme; end
end

class Rouge::Formatters::Terminal256::EscapeSequence
  def initialize(style); end

  def bg; end
  def fg; end
  def reset_string; end
  def stream_value(val, &b); end
  def style; end
  def style_string; end

  private

  def escape(attrs); end

  class << self
    def closest_color(r, g, b); end
    def color_index(color); end
    def get_rgb(color); end
    def xterm_colors; end
  end
end

Rouge::Formatters::Terminal256::EscapeSequence::MAX_DISTANCE = T.let(T.unsafe(nil), Integer)

class Rouge::Formatters::Terminal256::Unescape < ::Rouge::Formatters::Terminal256::EscapeSequence
  def initialize(*_arg0); end

  def reset_string(*_arg0); end
  def stream_value(val); end
  def style_string(*_arg0); end
end

class Rouge::Formatters::TerminalTruecolor < ::Rouge::Formatters::Terminal256
  def make_escape_sequence(style); end
end

class Rouge::Formatters::TerminalTruecolor::TruecolorEscapeSequence < ::Rouge::Formatters::Terminal256::EscapeSequence
  def get_rgb(color); end
  def style_string; end
end

class Rouge::Formatters::Tex < ::Rouge::Formatter
  def initialize(opts = T.unsafe(nil)); end

  def escape_tex(str); end
  def hphantom_tag(tok, val); end
  def render_line(line, &b); end
  def stream(tokens, &b); end
  def tag(tok, val); end
end

Rouge::Formatters::Tex::ESCAPE = T.let(T.unsafe(nil), Hash)
Rouge::Formatters::Tex::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

class Rouge::Guesser
  def collect_best(lexers, opts = T.unsafe(nil), &scorer); end
  def filter(lexers); end

  class << self
    def guess(guessers, lexers); end
  end
end

class Rouge::Guesser::Ambiguous < ::StandardError
  def initialize(alternatives); end

  def alternatives; end
  def message; end
end

module Rouge::Guessers; end

class Rouge::Guessers::Disambiguation < ::Rouge::Guesser
  include ::Rouge::Guessers::Util
  include ::Rouge::Lexers

  def initialize(filename, source); end

  def contains?(text); end
  def filter(lexers); end
  def matches?(re); end

  class << self
    def disambiguate(*patterns, &decider); end
    def disambiguators; end
  end
end

class Rouge::Guessers::Disambiguation::Disambiguator
  include ::Rouge::Guessers::Util

  def initialize(patterns, &decider); end

  def decide!(guesser); end
  def match?(filename); end
end

class Rouge::Guessers::Filename < ::Rouge::Guesser
  def initialize(filename); end

  def filter(lexers); end
  def fname; end
end

class Rouge::Guessers::GlobMapping < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  def initialize(glob_map, filename); end

  def filename; end
  def filter(lexers); end
  def glob_map; end

  class << self
    def by_pairs(mapping, filename); end
  end
end

class Rouge::Guessers::Mimetype < ::Rouge::Guesser
  def initialize(mimetype); end

  def filter(lexers); end
  def mimetype; end
end

class Rouge::Guessers::Modeline < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  def initialize(source, opts = T.unsafe(nil)); end

  def filter(lexers); end
end

Rouge::Guessers::Modeline::EMACS_MODELINE = T.let(T.unsafe(nil), Regexp)
Rouge::Guessers::Modeline::MODELINES = T.let(T.unsafe(nil), Array)
Rouge::Guessers::Modeline::VIM_MODELINE_1 = T.let(T.unsafe(nil), Regexp)
Rouge::Guessers::Modeline::VIM_MODELINE_2 = T.let(T.unsafe(nil), Regexp)

class Rouge::Guessers::Source < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  def initialize(source); end

  def filter(lexers); end
  def source; end
end

module Rouge::Guessers::Util
  def get_source(source); end
  def test_glob(pattern, path); end
end

module Rouge::Guessers::Util::SourceNormalizer
  class << self
    def normalize(source); end
  end
end

Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM = T.let(T.unsafe(nil), String)
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM_RE = T.let(T.unsafe(nil), Regexp)

module Rouge::HasModes
  def get_mode(mode); end
  def mode(arg = T.unsafe(nil)); end
  def mode!(arg); end
  def set_mode!(mode); end
end

module Rouge::Indentation
  def indentation(indent_str); end
  def reset!; end
  def starts_block(block_state); end
end

class Rouge::InheritableHash < ::Hash
  def initialize(parent = T.unsafe(nil)); end

  def [](k); end
  def each(&b); end
  def include?(k); end
  def keys; end
  def own_keys; end
  def parent; end
end

class Rouge::InheritableList
  include ::Enumerable

  def initialize(parent = T.unsafe(nil)); end

  def <<(o); end
  def each(&b); end
  def own_entries; end
  def parent; end
  def push(o); end
end

Rouge::LIB_DIR = T.let(T.unsafe(nil), String)

class Rouge::Lexer
  include ::Rouge::Token::Tokens

  def initialize(opts = T.unsafe(nil)); end

  def as_bool(val); end
  def as_lexer(val); end
  def as_list(val); end
  def as_string(val); end
  def as_token(val); end
  def bool_option(name, &default); end
  def continue_lex(string, &b); end
  def hash_option(name, defaults, &val_cast); end
  def lex(string, opts = T.unsafe(nil), &b); end
  def lexer_option(name, &default); end
  def list_option(name, &default); end
  def options; end
  def reset!; end
  def stream_tokens(stream, &b); end
  def string_option(name, &default); end
  def tag; end
  def token_option(name, &default); end
  def with(opts = T.unsafe(nil)); end

  class << self
    def aliases(*args); end
    def all; end
    def assert_utf8!(str); end
    def continue_lex(*a, &b); end
    def debug_enabled?; end
    def demo(arg = T.unsafe(nil)); end
    def demo_file(arg = T.unsafe(nil)); end
    def desc(arg = T.unsafe(nil)); end
    def detect?(text); end
    def detectable?; end
    def disable_debug!; end
    def enable_debug!; end
    def filenames(*fnames); end
    def find(name); end
    def find_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end
    def guess(info = T.unsafe(nil), &fallback); end
    def guess_by_filename(fname); end
    def guess_by_mimetype(mt); end
    def guess_by_source(source); end
    def guesses(info = T.unsafe(nil)); end
    def lex(stream, opts = T.unsafe(nil), &b); end
    def lookup_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end
    def mimetypes(*mts); end
    def option(name, desc); end
    def option_docs; end
    def tag(t = T.unsafe(nil)); end
    def title(t = T.unsafe(nil)); end

    protected

    def register(name, lexer); end

    private

    def registry; end
  end
end

module Rouge::Lexers
  class << self
    def load_lexer(relpath); end
  end
end

class Rouge::Lexers::ABAP < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def new_keywords; end
    def types; end
  end
end

class Rouge::Lexers::APIBlueprint < ::Rouge::Lexers::Markdown; end

class Rouge::Lexers::Actionscript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Ada < ::Rouge::RegexLexer
  class << self
    def idents; end
  end
end

Rouge::Lexers::Ada::EXP = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Ada::ID = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Ada::NUM = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Ada::XNUM = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Apache < ::Rouge::RegexLexer
  def name_for_token(token, tktype); end

  class << self
    def directives; end
    def sections; end
    def values; end
  end
end

class Rouge::Lexers::Apex < ::Rouge::RegexLexer
  class << self
    def constants; end
    def declarations; end
    def keywords; end
    def soql; end
    def types; end
  end
end

class Rouge::Lexers::AppleScript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def classes; end
    def commands; end
    def controls; end
    def declarations; end
    def handler_params; end
    def literals; end
    def operators; end
    def references; end
    def reserved; end
    def studio_classes; end
    def studio_commands; end
    def studio_events; end
    def studio_properties; end
  end
end

class Rouge::Lexers::ArmAsm < ::Rouge::RegexLexer
  class << self
    def builtin; end
    def file_directive; end
    def general_directive; end
    def operator; end
    def preproc_keyword; end
    def shift_or_condition; end
  end
end

class Rouge::Lexers::Augeas < ::Rouge::RegexLexer
  class << self
    def reserved; end
  end
end

class Rouge::Lexers::Awk < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def detect?(text); end
    def keywords; end
    def reserved; end
  end
end

Rouge::Lexers::BASE_DIR = T.let(T.unsafe(nil), String)

class Rouge::Lexers::BBCBASIC < ::Rouge::RegexLexer
  class << self
    def constant; end
    def function; end
    def operator; end
    def punctuation; end
    def statement; end
  end
end

class Rouge::Lexers::BIML < ::Rouge::Lexers::XML
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::BPF < ::Rouge::RegexLexer; end
Rouge::Lexers::BPF::MISC_KEYWORDS = T.let(T.unsafe(nil), String)
Rouge::Lexers::BPF::TYPE_KEYWORDS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Batchfile < ::Rouge::RegexLexer
  class << self
    def attributes; end
    def builtin_commands; end
    def devices; end
    def keywords; end
    def operator_words; end
    def other_commands; end
  end
end

class Rouge::Lexers::BibTeX < ::Rouge::RegexLexer; end
class Rouge::Lexers::Brainfuck < ::Rouge::RegexLexer; end

class Rouge::Lexers::Brightscript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keyword_reserved; end
    def keyword_reserved_unsupported; end
    def keyword_type; end
    def name_builtin; end
    def operator_word; end
  end
end

class Rouge::Lexers::Bsl < ::Rouge::RegexLexer; end
Rouge::Lexers::Bsl::BUILTINS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Bsl::KEYWORDS = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::C < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::CMHG < ::Rouge::RegexLexer
  class << self
    def preproc_keyword; end
  end
end

class Rouge::Lexers::CMake < ::Rouge::RegexLexer; end
Rouge::Lexers::CMake::BRACKET_OPEN = T.let(T.unsafe(nil), String)
Rouge::Lexers::CMake::BUILTIN_COMMANDS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CMake::SPACE = T.let(T.unsafe(nil), String)
Rouge::Lexers::CMake::STATES_MAP = T.let(T.unsafe(nil), Hash)

class Rouge::Lexers::CSS < ::Rouge::RegexLexer
  class << self
    def attributes; end
    def builtins; end
    def constants; end
    def vendor_prefixes; end
  end
end

class Rouge::Lexers::CSVS < ::Rouge::RegexLexer; end
class Rouge::Lexers::CSharp < ::Rouge::RegexLexer; end

class Rouge::Lexers::CUDA < ::Rouge::Lexers::Cpp
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Ceylon < ::Rouge::RegexLexer; end

class Rouge::Lexers::Cfscript < ::Rouge::RegexLexer
  class << self
    def declarations; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::Clean < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Clojure < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::Coffeescript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def detect?(text); end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::CommonLisp < ::Rouge::RegexLexer; end
Rouge::Lexers::CommonLisp::BUILTIN_CLASSES = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::BUILTIN_FUNCTIONS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::BUILTIN_TYPES = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::DECLARATIONS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::LAMBDA_LIST_KEYWORDS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::MACROS = T.let(T.unsafe(nil), Set)
Rouge::Lexers::CommonLisp::SPECIAL_FORMS = T.let(T.unsafe(nil), Set)
class Rouge::Lexers::Conf < ::Rouge::RegexLexer; end

class Rouge::Lexers::ConsoleLexer < ::Rouge::Lexer
  def initialize(*_arg0); end

  def allow_comments?; end
  def comment_regex; end
  def end_chars; end
  def error_regex; end
  def lang_lexer; end
  def line_regex; end
  def output_lexer; end
  def process_line(input, &output); end
  def prompt_prefix_regex; end
  def prompt_regex; end
  def stream_tokens(input, &output); end
end

class Rouge::Lexers::Coq < ::Rouge::RegexLexer
  class << self
    def classify(x); end
    def coq; end
    def end_sentence; end
    def gallina; end
    def keyopts; end
    def ltac; end
    def tacticals; end
    def terminators; end
  end
end

class Rouge::Lexers::Cpp < ::Rouge::Lexers::C
  class << self
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Crystal < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Cypher < ::Rouge::RegexLexer
  class << self
    def functions; end
    def keywords; end
    def predicates; end
  end
end

class Rouge::Lexers::Cython < ::Rouge::Lexers::Python
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def c_keywords; end
    def keywords; end
  end
end

class Rouge::Lexers::D < ::Rouge::RegexLexer; end
class Rouge::Lexers::Dafny < ::Rouge::RegexLexer; end
class Rouge::Lexers::Dart < ::Rouge::RegexLexer; end

class Rouge::Lexers::Datastudio < ::Rouge::RegexLexer
  class << self
    def sql_keywords; end
  end
end

class Rouge::Lexers::Diff < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Digdag < ::Rouge::Lexers::YAML; end
Rouge::Lexers::Digdag::KEYWORD_PATTERN = T.let(T.unsafe(nil), Regexp)
class Rouge::Lexers::Docker < ::Rouge::RegexLexer; end
Rouge::Lexers::Docker::KEYWORDS = T.let(T.unsafe(nil), String)
class Rouge::Lexers::Dot < ::Rouge::RegexLexer; end

class Rouge::Lexers::ECL < ::Rouge::RegexLexer
  class << self
    def class_first; end
    def class_second; end
    def functions; end
    def keywords; end
    def template; end
    def type; end
    def typed; end
  end
end

class Rouge::Lexers::EEX < ::Rouge::TemplateLexer
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::EPP < ::Rouge::TemplateLexer
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::ERB < ::Rouge::TemplateLexer
  def initialize(opts = T.unsafe(nil)); end
end

class Rouge::Lexers::Eiffel < ::Rouge::RegexLexer; end
Rouge::Lexers::Eiffel::BooleanConstants = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::LanguageKeywords = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::LanguageVariables = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Eiffel::SimpleString = T.let(T.unsafe(nil), Regexp)
class Rouge::Lexers::Elixir < ::Rouge::RegexLexer; end
class Rouge::Lexers::Elm < ::Rouge::RegexLexer; end
class Rouge::Lexers::Email < ::Rouge::RegexLexer; end
class Rouge::Lexers::Erlang < ::Rouge::RegexLexer; end

class Rouge::Lexers::Escape < ::Rouge::Lexer
  def initialize(*_arg0); end

  def end; end
  def lang; end
  def start; end
  def stream_tokens(str, &b); end
  def to_end_regex; end
  def to_start_regex; end
end

class Rouge::Lexers::FSharp < ::Rouge::RegexLexer
  class << self
    def keyopts; end
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::Factor < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def detect?(text); end
  end
end

class Rouge::Lexers::Fluent < ::Rouge::RegexLexer; end

class Rouge::Lexers::Fortran < ::Rouge::RegexLexer
  class << self
    def intrinsics; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::FreeFEM < ::Rouge::Lexers::Cpp
  class << self
    def attributes; end
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::GDScript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def builtins_type; end
    def keywords; end
    def keywords_reserved; end
  end
end

class Rouge::Lexers::GHCCmm < ::Rouge::RegexLexer; end
class Rouge::Lexers::GHCCore < ::Rouge::RegexLexer; end

class Rouge::Lexers::Gherkin < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
    def keywords; end
    def step_regex; end
  end
end

class Rouge::Lexers::Glsl < ::Rouge::Lexers::C
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Go < ::Rouge::RegexLexer; end
Rouge::Lexers::Go::BIG_U_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::CHAR_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::COMMENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::DECIMALS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::DECIMAL_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::DECIMAL_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::ESCAPE_SEQUENCE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::EXPONENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::FLOAT_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::GENERAL_COMMENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::HEX_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::IDENTIFIER = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::IMAGINARY_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::INTERPRETED_STRING_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::INT_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::KEYWORD = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::LETTER = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::LINE_COMMENT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::LITTLE_U_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::NEWLINE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OCTAL_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::OPERATOR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::PREDECLARED_CONSTANTS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::PREDECLARED_FUNCTIONS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::PREDECLARED_TYPES = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::RAW_STRING_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::SEPARATOR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::STRING_LIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_CHAR = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_DIGIT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_LETTER = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::UNICODE_VALUE = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Go::WHITE_SPACE = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Gradle < ::Rouge::Lexers::Groovy
  class << self
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::GraphQL < ::Rouge::RegexLexer; end

class Rouge::Lexers::Groovy < ::Rouge::RegexLexer
  class << self
    def constants; end
    def declarations; end
    def detect?(text); end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::HLSL < ::Rouge::Lexers::C
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::HOCON < ::Rouge::Lexers::JSON; end

class Rouge::Lexers::HQL < ::Rouge::Lexers::SQL
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::HTML < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::HTTP < ::Rouge::RegexLexer
  def content_lexer; end
  def guess_content_lexer; end

  class << self
    def http_methods; end
  end
end

class Rouge::Lexers::Hack < ::Rouge::Lexers::PHP
  class << self
    def detect?(text); end
    def keywords; end
  end
end

class Rouge::Lexers::Haml < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  def initialize(opts = T.unsafe(nil)); end

  def filters; end
  def html; end
  def ruby; end
  def ruby!(state); end
end

class Rouge::Lexers::Handlebars < ::Rouge::TemplateLexer; end

class Rouge::Lexers::Haskell < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Haxe < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def detect?(text); end
    def imports; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Hcl < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::HyLang < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::IDLang < ::Rouge::RegexLexer
  class << self
    def conditionals; end
    def decorators; end
    def exec_unit; end
    def keywords; end
    def operators; end
    def routines; end
    def standalone_statements; end
  end
end

class Rouge::Lexers::INI < ::Rouge::RegexLexer; end

class Rouge::Lexers::IO < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def detect?(text); end
  end
end

class Rouge::Lexers::IRBLexer < ::Rouge::Lexers::ConsoleLexer
  def allow_comments?; end
  def lang_lexer; end
  def output_lexer; end
  def prompt_regex; end
end

class Rouge::Lexers::IRBOutputLexer < ::Rouge::Lexers::Ruby; end

class Rouge::Lexers::ISBL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def globals; end
    def interfaces; end
    def keywords; end
  end
end

class Rouge::Lexers::IgorPro < ::Rouge::RegexLexer
  class << self
    def igorConstants; end
    def igorDeclarations; end
    def igorFunction; end
    def igorOperation; end
    def keywords; end
    def object_name; end
    def preprocessor; end
  end
end

class Rouge::Lexers::J < ::Rouge::RegexLexer
  class << self
    def control_words; end
    def control_words_id; end
    def inflection_list; end
    def primitive(char, inflection); end
    def primitive_table; end
    def token_map; end
  end
end

class Rouge::Lexers::JSL < ::Rouge::RegexLexer; end
class Rouge::Lexers::JSON < ::Rouge::RegexLexer; end
class Rouge::Lexers::JSONDOC < ::Rouge::Lexers::JSON; end

class Rouge::Lexers::JSP < ::Rouge::TemplateLexer
  def initialize(*_arg0); end
end

class Rouge::Lexers::JSX < ::Rouge::Lexers::Javascript; end

class Rouge::Lexers::Janet < ::Rouge::RegexLexer
  def name_token(name); end

  class << self
    def bundled; end
    def specials; end
  end
end

class Rouge::Lexers::Java < ::Rouge::RegexLexer; end

class Rouge::Lexers::Javascript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def detect?(text); end
    def id_regex; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Jinja < ::Rouge::TemplateLexer
  class << self
    def keywords; end
    def pseudo_keywords; end
    def tests; end
    def word_operators; end
  end
end

class Rouge::Lexers::Jsonnet < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
  end
end

class Rouge::Lexers::Julia < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

Rouge::Lexers::Julia::BUILTINS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::KEYWORDS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::OPERATORS = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::PUNCTUATION = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Julia::TYPES = T.let(T.unsafe(nil), Regexp)
class Rouge::Lexers::Kotlin < ::Rouge::RegexLexer; end

class Rouge::Lexers::LLVM < ::Rouge::RegexLexer
  class << self
    def instructions; end
    def keywords; end
    def types; end
  end
end

class Rouge::Lexers::Lasso < ::Rouge::TemplateLexer
  def initialize(*_arg0); end

  def start_inline?; end

  class << self
    def detect?(text); end
    def keywords; end
  end
end

class Rouge::Lexers::Liquid < ::Rouge::RegexLexer; end

class Rouge::Lexers::LiterateCoffeescript < ::Rouge::RegexLexer
  def coffee; end
  def markdown; end
end

class Rouge::Lexers::LiterateHaskell < ::Rouge::RegexLexer
  def haskell; end
end

class Rouge::Lexers::Livescript < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def detect?(text); end
    def keywords; end
    def loop_control_keywords; end
  end
end

class Rouge::Lexers::Lua < ::Rouge::RegexLexer
  def initialize(opts = T.unsafe(nil)); end

  def builtins; end

  class << self
    def builtins; end
    def detect?(text); end
  end
end

class Rouge::Lexers::Lustre < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::Lutin < ::Rouge::Lexers::Lustre
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::M68k < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::MXML < ::Rouge::RegexLexer; end

class Rouge::Lexers::Magik < ::Rouge::RegexLexer
  class << self
    def character; end
    def decimal; end
    def digits; end
    def exponent; end
    def global_ref; end
    def identifier; end
    def keywords; end
    def label; end
    def number; end
    def package_identifier; end
    def piped_identifier; end
    def radix; end
    def simple_identifier; end
    def string_double; end
    def string_single; end
    def symbol; end
  end
end

class Rouge::Lexers::Make < ::Rouge::RegexLexer
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def functions; end
  end
end

class Rouge::Lexers::Markdown < ::Rouge::RegexLexer
  def html; end
end

class Rouge::Lexers::Mason < ::Rouge::TemplateLexer
  def initialize(*_arg0); end
end

Rouge::Lexers::Mason::COMPONENTS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Mason::PERL_BLOCKS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Mason::TEXT_BLOCKS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::Mathematica < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::Matlab < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::MiniZinc < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def operators; end
  end
end

class Rouge::Lexers::Moonscript < ::Rouge::RegexLexer
  def initialize(*_arg0); end

  def builtins; end

  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Mosel < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::MsgTrans < ::Rouge::RegexLexer; end
class Rouge::Lexers::Nasm < ::Rouge::RegexLexer; end

class Rouge::Lexers::NesAsm < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_reserved; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Nginx < ::Rouge::RegexLexer; end

class Rouge::Lexers::Nim < ::Rouge::RegexLexer
  class << self
    def underscorize(words); end
  end
end

Rouge::Lexers::Nim::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::NAMESPACE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::OPWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::PSEUDOKEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Nim::TYPES = T.let(T.unsafe(nil), Array)
class Rouge::Lexers::Nix < ::Rouge::RegexLexer; end

class Rouge::Lexers::OCL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def functions; end
    def keywords; end
    def keywords_type; end
    def operators; end
  end
end

class Rouge::Lexers::OCaml < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::OCamlCommon < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def primitives; end
    def word_operators; end
  end
end

class Rouge::Lexers::ObjectiveC < ::Rouge::Lexers::C
  extend ::Rouge::Lexers::ObjectiveCCommon
end

module Rouge::Lexers::ObjectiveCCommon
  def at_builtins; end
  def at_keywords; end
  def builtins; end

  class << self
    def extended(base); end
  end
end

class Rouge::Lexers::ObjectiveCpp < ::Rouge::Lexers::Cpp
  extend ::Rouge::Lexers::ObjectiveCCommon
end

class Rouge::Lexers::OpenEdge < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::OpenTypeFeatureFile < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::PHP < ::Rouge::TemplateLexer
  def initialize(*_arg0); end

  def builtins; end

  class << self
    def builtins; end
    def detect?(text); end
    def keywords; end
  end
end

class Rouge::Lexers::Pascal < ::Rouge::RegexLexer; end

class Rouge::Lexers::Perl < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::PlainText < ::Rouge::Lexer
  def initialize(*_arg0); end

  def stream_tokens(string, &b); end
  def token; end
end

class Rouge::Lexers::Plist < ::Rouge::RegexLexer; end
class Rouge::Lexers::Pony < ::Rouge::RegexLexer; end

class Rouge::Lexers::PostScript < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Powershell < ::Rouge::RegexLexer; end
Rouge::Lexers::Powershell::ATTRIBUTES = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Powershell::AUTO_VARS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Powershell::KEYWORDS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Powershell::KEYWORDS_TYPE = T.let(T.unsafe(nil), String)
Rouge::Lexers::Powershell::MULTILINE_KEYWORDS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Powershell::OPERATORS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Praat < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Prolog < ::Rouge::RegexLexer; end

class Rouge::Lexers::Prometheus < ::Rouge::RegexLexer
  class << self
    def functions; end
  end
end

class Rouge::Lexers::Properties < ::Rouge::RegexLexer; end
class Rouge::Lexers::Protobuf < ::Rouge::RegexLexer; end

class Rouge::Lexers::Puppet < ::Rouge::RegexLexer
  class << self
    def constants; end
    def detect?(text); end
    def keywords; end
    def metaparameters; end
  end
end

class Rouge::Lexers::Python < ::Rouge::RegexLexer
  def current_string; end

  class << self
    def builtins; end
    def builtins_pseudo; end
    def detect?(text); end
    def exceptions; end
    def keywords; end
  end
end

class Rouge::Lexers::Python::StringRegister < ::Array
  def delim?(delim); end
  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end
  def remove; end
  def type?(type); end
end

class Rouge::Lexers::Q < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def word_operators; end
  end
end

class Rouge::Lexers::Qml < ::Rouge::Lexers::Javascript; end

class Rouge::Lexers::R < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

Rouge::Lexers::R::BUILTIN_CONSTANTS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::R::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::R::KEYWORD_CONSTANTS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::R::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::Racket < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def detect?(text); end
    def keywords; end
  end
end

class Rouge::Lexers::ReScript < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
    def types; end
    def word_operators; end
  end
end

class Rouge::Lexers::ReasonML < ::Rouge::Lexers::OCamlCommon
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Rego < ::Rouge::RegexLexer
  class << self
    def constants; end
    def operators; end
  end
end

class Rouge::Lexers::RobotFramework < ::Rouge::RegexLexer
  def initialize(opts = T.unsafe(nil)); end

  class << self
    def settings_with_args; end
    def settings_with_keywords; end
  end
end

class Rouge::Lexers::Ruby < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Rust < ::Rouge::RegexLexer
  def macro_closed?; end

  class << self
    def builtins; end
    def detect?(text); end
    def keywords; end
  end
end

class Rouge::Lexers::SAS < ::Rouge::RegexLexer
  class << self
    def data_step_statements; end
    def proc_keywords; end
    def sas_auto_macro_vars; end
    def sas_functions; end
    def sas_macro_functions; end
    def sas_macro_statements; end
    def sas_proc_names; end
  end
end

class Rouge::Lexers::SML < ::Rouge::RegexLexer
  def token_for_final_id(id); end
  def token_for_id(id); end
  def token_for_id_with_dot(id); end

  class << self
    def keywords; end
    def symbolic_reserved; end
  end
end

class Rouge::Lexers::SPARQL < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::SQF < ::Rouge::RegexLexer
  class << self
    def commands; end
    def constants; end
    def controlflow; end
    def diag_commands; end
    def initializers; end
    def namespaces; end
    def wordoperators; end
  end
end

class Rouge::Lexers::SQL < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::SSH < ::Rouge::RegexLexer; end

class Rouge::Lexers::Sass < ::Rouge::Lexers::SassCommon
  include ::Rouge::Indentation
end

class Rouge::Lexers::SassCommon < ::Rouge::RegexLexer; end
class Rouge::Lexers::Scala < ::Rouge::RegexLexer; end

class Rouge::Lexers::Scheme < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::Lexers::Scss < ::Rouge::Lexers::SassCommon; end

class Rouge::Lexers::Sed < ::Rouge::RegexLexer
  def regex; end
  def replacement; end

  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Sed::Regex < ::Rouge::RegexLexer; end
class Rouge::Lexers::Sed::Replacement < ::Rouge::RegexLexer; end

class Rouge::Lexers::Shell < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

Rouge::Lexers::Shell::BUILTINS = T.let(T.unsafe(nil), String)
Rouge::Lexers::Shell::KEYWORDS = T.let(T.unsafe(nil), String)

class Rouge::Lexers::Sieve < ::Rouge::RegexLexer
  class << self
    def actions; end
    def controls; end
    def tests; end
  end
end

class Rouge::Lexers::Slice < ::Rouge::Lexers::C
  class << self
    def keywords; end
    def keywords_type; end
  end
end

class Rouge::Lexers::Slim < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  def filters; end
  def html; end
  def ruby; end
end

class Rouge::Lexers::Smalltalk < ::Rouge::RegexLexer; end

class Rouge::Lexers::Smarty < ::Rouge::TemplateLexer
  class << self
    def builtins; end
  end
end

class Rouge::Lexers::Solidity < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def constants; end
    def detect?(text); end
    def keywords; end
    def keywords_type; end
    def reserved; end
  end
end

class Rouge::Lexers::Stan < ::Rouge::RegexLexer
  class << self
    def builtin_functions; end
    def constants; end
    def distributions; end
    def keywords; end
    def reserved; end
    def types; end
  end
end

Rouge::Lexers::Stan::ID = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Stan::OP = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Stan::RT = T.let(T.unsafe(nil), Regexp)
Rouge::Lexers::Stan::WS = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::Stata < ::Rouge::RegexLexer
  class << self
    def reserved_keywords; end
    def type_keywords; end
  end
end

Rouge::Lexers::Stata::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::Stata::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

class Rouge::Lexers::SuperCollider < ::Rouge::RegexLexer
  class << self
    def constants; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Swift < ::Rouge::RegexLexer; end
class Rouge::Lexers::SystemD < ::Rouge::RegexLexer; end

class Rouge::Lexers::TCL < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
    def gen_command_state(name = T.unsafe(nil)); end
    def gen_delimiter_states(name, close, opts = T.unsafe(nil)); end
  end
end

Rouge::Lexers::TCL::ALL = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::BUILTINS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::CHARS = T.let(T.unsafe(nil), Proc)
Rouge::Lexers::TCL::CLOSE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::END_LINE = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::END_WORD = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::KEYWORDS = T.let(T.unsafe(nil), Array)
Rouge::Lexers::TCL::NOT_CHARS = T.let(T.unsafe(nil), Proc)
Rouge::Lexers::TCL::OPEN = T.let(T.unsafe(nil), Array)
class Rouge::Lexers::TOML < ::Rouge::RegexLexer; end

class Rouge::Lexers::TSX < ::Rouge::Lexers::JSX
  extend ::Rouge::Lexers::TypescriptCommon
end

class Rouge::Lexers::TTCN3 < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def reserved; end
    def types; end
  end
end

class Rouge::Lexers::Tap < ::Rouge::RegexLexer; end

class Rouge::Lexers::TeX < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Terraform < ::Rouge::Lexers::Hcl
  class << self
    def builtins; end
    def constants; end
    def declarations; end
    def keywords; end
    def reserved; end
  end
end

class Rouge::Lexers::Tulip < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::Turtle < ::Rouge::RegexLexer; end

class Rouge::Lexers::Twig < ::Rouge::Lexers::Jinja
  class << self
    def keywords; end
    def pseudo_keywords; end
    def tests; end
    def word_operators; end
  end
end

class Rouge::Lexers::Typescript < ::Rouge::Lexers::Javascript
  extend ::Rouge::Lexers::TypescriptCommon
end

module Rouge::Lexers::TypescriptCommon
  def builtins; end
  def declarations; end
  def keywords; end
  def reserved; end

  class << self
    def extended(base); end
  end
end

class Rouge::Lexers::VHDL < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_type; end
    def operator_words; end
  end
end

class Rouge::Lexers::Vala < ::Rouge::RegexLexer; end

class Rouge::Lexers::Varnish < ::Rouge::RegexLexer
  class << self
    def functions; end
    def keywords; end
    def variables; end
  end
end

Rouge::Lexers::Varnish::SPACE = T.let(T.unsafe(nil), String)
class Rouge::Lexers::Velocity < ::Rouge::TemplateLexer; end

class Rouge::Lexers::Verilog < ::Rouge::RegexLexer
  class << self
    def keywords; end
    def keywords_system_task; end
    def keywords_type; end
  end
end

class Rouge::Lexers::VimL < ::Rouge::RegexLexer
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::VisualBasic < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
    def keywords_type; end
    def operator_words; end
  end
end

class Rouge::Lexers::Vue < ::Rouge::Lexers::HTML
  def initialize(*_arg0); end

  def lookup_lang(lang); end
end

class Rouge::Lexers::Wollok < ::Rouge::RegexLexer; end

class Rouge::Lexers::XML < ::Rouge::RegexLexer
  class << self
    def detect?(text); end
  end
end

class Rouge::Lexers::XPath < ::Rouge::RegexLexer
  class << self
    def axes; end
    def commentStart; end
    def constructorTypes; end
    def decimalLiteral; end
    def digits; end
    def doubleLiteral; end
    def eqName; end
    def keywords; end
    def kindTest; end
    def kindTestForPI; end
    def ncName; end
    def openParen; end
    def operators; end
    def qName; end
    def stringLiteral; end
    def uriQName; end
    def word_operators; end
  end
end

class Rouge::Lexers::XQuery < ::Rouge::Lexers::XPath
  class << self
    def keywords; end
  end
end

class Rouge::Lexers::Xojo < ::Rouge::RegexLexer; end

class Rouge::Lexers::YAML < ::Rouge::RegexLexer
  def continue_indent(match); end
  def dedent?(level); end
  def indent; end
  def indent?(level); end
  def reset_indent; end
  def save_indent(match); end
  def set_indent(match, opts = T.unsafe(nil)); end

  class << self
    def detect?(text); end
  end
end

Rouge::Lexers::YAML::SPECIAL_VALUES = T.let(T.unsafe(nil), Regexp)

class Rouge::Lexers::YANG < ::Rouge::RegexLexer
  class << self
    def body_stmts_keywords; end
    def constants_keywords; end
    def data_def_stmts_keywords; end
    def linkage_stmts_keywords; end
    def list_stmts_keywords; end
    def meta_stmts_keywords; end
    def module_header_stmts_keywords; end
    def top_stmts_keywords; end
    def type_stmts_keywords; end
    def types; end
  end
end

class Rouge::Lexers::Zig < ::Rouge::RegexLexer
  class << self
    def builtins; end
    def keywords; end
  end
end

class Rouge::RegexLexer < ::Rouge::Lexer
  def delegate(lexer, text = T.unsafe(nil)); end
  def get_state(state_name); end
  def goto(state_name); end
  def group(tok); end
  def groups(*tokens); end
  def in_state?(state_name); end
  def pop!(times = T.unsafe(nil)); end
  def push(state_name = T.unsafe(nil), &b); end
  def recurse(text = T.unsafe(nil)); end
  def reset!; end
  def reset_stack; end
  def stack; end
  def state; end
  def state?(state_name); end
  def step(state, stream); end
  def stream_tokens(str, &b); end
  def token(tok, val = T.unsafe(nil)); end

  private

  def yield_token(tok, val); end

  class << self
    def append(name, &b); end
    def get_state(name); end
    def prepend(name, &b); end
    def replace_state(name, new_defn); end
    def start(&b); end
    def start_procs; end
    def state(name, &b); end
    def state_definitions; end
    def states; end
  end
end

class Rouge::RegexLexer::ClosedState < ::StandardError
  def initialize(state); end

  def rule; end
  def state; end
  def to_s; end
end

class Rouge::RegexLexer::InvalidRegex < ::StandardError
  def initialize(re); end

  def to_s; end
end

Rouge::RegexLexer::MAX_NULL_SCANS = T.let(T.unsafe(nil), Integer)

class Rouge::RegexLexer::Rule
  def initialize(re, callback); end

  def beginning_of_line; end
  def callback; end
  def inspect; end
  def re; end
end

class Rouge::RegexLexer::State
  def initialize(name, rules); end

  def inspect; end
  def name; end
  def rules; end
end

class Rouge::RegexLexer::StateDSL
  def initialize(name, &defn); end

  def appended(&defn); end
  def name; end
  def prepended(&defn); end
  def rules; end
  def to_state(lexer_class); end

  protected

  def close!; end
  def context_sensitive?(re); end
  def mixin(state); end
  def rule(re, tok = T.unsafe(nil), next_state = T.unsafe(nil), &callback); end

  private

  def load!; end
end

class Rouge::TemplateLexer < ::Rouge::RegexLexer
  def parent; end
end

class Rouge::TexThemeRenderer
  def initialize(theme, opts = T.unsafe(nil)); end

  def camelize(name); end
  def gen_inline(name, &b); end
  def inline_name(color); end
  def palette_name(name); end
  def render(&b); end
  def render_blank(tok, &b); end
  def render_inline_pallete(style, &b); end
  def render_palette(palette, &b); end
  def render_style(tok, style, &b); end
  def token_name(tok); end
end

class Rouge::TextAnalyzer < ::String
  def doctype; end
  def doctype?(type = T.unsafe(nil)); end
  def lexes_cleanly?(lexer); end
  def shebang; end
  def shebang?(match); end
end

class Rouge::Theme
  include ::Rouge::Token::Tokens

  def get_own_style(token); end
  def get_style(token); end
  def name; end
  def palette(*a); end
  def styles; end

  class << self
    def base_style; end
    def find(n); end
    def get_own_style(token); end
    def get_style(token); end
    def name(n = T.unsafe(nil)); end
    def palette(arg = T.unsafe(nil)); end
    def register(name); end
    def registry; end
    def render(opts = T.unsafe(nil), &b); end
    def style(*tokens); end
    def styles; end
  end
end

class Rouge::Theme::Style < ::Hash
  def initialize(theme, hsh = T.unsafe(nil)); end

  def bg; end
  def fg; end
  def render(selector, &b); end
  def rendered_rules(&b); end
end

module Rouge::Themes; end

class Rouge::Themes::Base16 < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    def dark!; end
    def light!; end
    def make_dark!; end
    def make_light!; end
  end
end

class Rouge::Themes::Base16::Monokai < ::Rouge::Themes::Base16; end
class Rouge::Themes::Base16::Solarized < ::Rouge::Themes::Base16; end
class Rouge::Themes::BlackWhiteTheme < ::Rouge::CSSTheme; end
class Rouge::Themes::Colorful < ::Rouge::CSSTheme; end
class Rouge::Themes::Github < ::Rouge::CSSTheme; end

class Rouge::Themes::Gruvbox < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    def dark!; end
    def light!; end
    def make_dark!; end
    def make_light!; end
  end
end

Rouge::Themes::Gruvbox::C_bright_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_bright_yellow = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark0 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark0_hard = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark0_soft = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark1 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark2 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark3 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark4 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_dark4_256 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_faded_yellow = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_gray_244 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_gray_245 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0_hard = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light0_soft = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light1 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light2 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light3 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light4 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_light4_256 = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_aqua = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_blue = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_green = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_orange = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_purple = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_red = T.let(T.unsafe(nil), String)
Rouge::Themes::Gruvbox::C_neutral_yellow = T.let(T.unsafe(nil), String)
class Rouge::Themes::IgorPro < ::Rouge::CSSTheme; end
class Rouge::Themes::Magritte < ::Rouge::CSSTheme; end
class Rouge::Themes::Molokai < ::Rouge::CSSTheme; end
class Rouge::Themes::Monokai < ::Rouge::CSSTheme; end
class Rouge::Themes::MonokaiSublime < ::Rouge::CSSTheme; end
class Rouge::Themes::Pastie < ::Rouge::CSSTheme; end
class Rouge::Themes::ThankfulEyes < ::Rouge::CSSTheme; end
class Rouge::Themes::Tulip < ::Rouge::CSSTheme; end

class Rouge::Token
  class << self
    def [](qualname); end
    def cache; end
    def each_token(&b); end
    def inspect; end
    def make_token(name, shortname, &b); end
    def matches?(other); end
    def name; end
    def parent; end
    def qualname; end
    def register!; end
    def shortname; end
    def sub_tokens; end
    def token(name, shortname, &b); end
    def token_chain; end
  end
end

module Rouge::Token::Tokens
  class << self
    def token(name, shortname, &b); end
  end
end

class Rouge::Token::Tokens::Comment < ::Rouge::Token; end
class Rouge::Token::Tokens::Comment::Doc < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Hashbang < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Multiline < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Preproc < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::PreprocFile < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Single < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Comment::Special < ::Rouge::Token::Tokens::Comment; end
class Rouge::Token::Tokens::Error < ::Rouge::Token; end
class Rouge::Token::Tokens::Escape < ::Rouge::Token; end
class Rouge::Token::Tokens::Generic < ::Rouge::Token; end
class Rouge::Token::Tokens::Generic::Deleted < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Emph < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Error < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Heading < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Inserted < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Lineno < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Output < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Prompt < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Strong < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Subheading < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Generic::Traceback < ::Rouge::Token::Tokens::Generic; end
class Rouge::Token::Tokens::Keyword < ::Rouge::Token; end
class Rouge::Token::Tokens::Keyword::Constant < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Declaration < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Namespace < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Pseudo < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Reserved < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Type < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Keyword::Variable < ::Rouge::Token::Tokens::Keyword; end
class Rouge::Token::Tokens::Literal < ::Rouge::Token; end
class Rouge::Token::Tokens::Literal::Date < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::Number < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::Number::Bin < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Float < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Hex < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Integer < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Integer::Long < ::Rouge::Token::Tokens::Literal::Number::Integer; end
class Rouge::Token::Tokens::Literal::Number::Oct < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::Number::Other < ::Rouge::Token::Tokens::Literal::Number; end
class Rouge::Token::Tokens::Literal::String < ::Rouge::Token::Tokens::Literal; end
class Rouge::Token::Tokens::Literal::String::Affix < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Backtick < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Char < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Delimiter < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Doc < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Double < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Escape < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Heredoc < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Interpol < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Other < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Regex < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Single < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Literal::String::Symbol < ::Rouge::Token::Tokens::Literal::String; end
class Rouge::Token::Tokens::Name < ::Rouge::Token; end
class Rouge::Token::Tokens::Name::Attribute < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Builtin < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Builtin::Pseudo < ::Rouge::Token::Tokens::Name::Builtin; end
class Rouge::Token::Tokens::Name::Class < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Constant < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Decorator < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Entity < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Exception < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Function < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Function::Magic < ::Rouge::Token::Tokens::Name::Function; end
class Rouge::Token::Tokens::Name::Label < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Namespace < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Other < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Property < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Tag < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Variable < ::Rouge::Token::Tokens::Name; end
class Rouge::Token::Tokens::Name::Variable::Class < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Global < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Instance < ::Rouge::Token::Tokens::Name::Variable; end
class Rouge::Token::Tokens::Name::Variable::Magic < ::Rouge::Token::Tokens::Name::Variable; end
Rouge::Token::Tokens::Num = Rouge::Token::Tokens::Literal::Number
class Rouge::Token::Tokens::Operator < ::Rouge::Token; end
class Rouge::Token::Tokens::Operator::Word < ::Rouge::Token::Tokens::Operator; end
class Rouge::Token::Tokens::Other < ::Rouge::Token; end
class Rouge::Token::Tokens::Punctuation < ::Rouge::Token; end
class Rouge::Token::Tokens::Punctuation::Indicator < ::Rouge::Token::Tokens::Punctuation; end
Rouge::Token::Tokens::Str = Rouge::Token::Tokens::Literal::String
class Rouge::Token::Tokens::Text < ::Rouge::Token; end
class Rouge::Token::Tokens::Text::Whitespace < ::Rouge::Token::Tokens::Text; end
