# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack` gem.
# Please instead update this file by running `bin/tapioca gem rack`.


# The Rack main module, serving as a namespace for all core Rack
# modules and classes.
#
# All modules meant for use in your application are <tt>autoload</tt>ed here,
# so it should be enough just to <tt>require 'rack'</tt> in your code.
module Rack
  class << self
    # Return the Rack release as a dotted string.
    def release; end

    # The Rack protocol version number implemented.
    def version; end
  end
end

module Rack::Auth; end

# Rack::Auth::AbstractHandler implements common authentication functionality.
#
# +realm+ should be set for all handlers.
class Rack::Auth::AbstractHandler
  # @return [AbstractHandler] a new instance of AbstractHandler
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # Returns the value of attribute realm.
  def realm; end

  # Sets the attribute realm
  #
  # @param value the value to set the attribute realm to.
  def realm=(_arg0); end

  private

  def bad_request; end
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  # @return [AbstractRequest] a new instance of AbstractRequest
  def initialize(env); end

  def params; end
  def parts; end

  # @return [Boolean]
  def provided?; end

  def request; end
  def scheme; end

  # @return [Boolean]
  def valid?; end

  private

  def authorization_key; end
end

Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

# Rack::Auth::Basic implements HTTP Basic Authentication, as per RFC 2617.
#
# Initialize with the Rack application that you want protecting,
# and a block that checks if a username and password pair are valid.
class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  def call(env); end

  private

  def challenge; end

  # @return [Boolean]
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # @return [Boolean]
  def basic?; end

  def credentials; end
  def username; end
end

module Rack::Auth::Digest; end

# Rack::Auth::Digest::MD5 implements the MD5 algorithm version of
# HTTP Digest Authentication, as per RFC 2617.
#
# Initialize with the [Rack] application that you want protecting,
# and a block that looks up a plaintext password for a given username.
#
# +opaque+ needs to be set to a constant base64/hexadecimal string.
class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # @return [MD5] a new instance of MD5
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  def call(env); end

  # Returns the value of attribute opaque.
  def opaque; end

  # Sets the attribute opaque
  #
  # @param value the value to set the attribute opaque to.
  def opaque=(_arg0); end

  # Sets the attribute passwords_hashed
  #
  # @param value the value to set the attribute passwords_hashed to.
  def passwords_hashed=(_arg0); end

  # @return [Boolean]
  def passwords_hashed?; end

  private

  def A1(auth, password); end
  def A2(auth); end
  def H(data); end
  def KD(secret, data); end
  def challenge(hash = T.unsafe(nil)); end
  def digest(auth, password); end
  def md5(data); end
  def params(hash = T.unsafe(nil)); end

  # @return [Boolean]
  def valid?(auth); end

  # @return [Boolean]
  def valid_digest?(auth); end

  # @return [Boolean]
  def valid_nonce?(auth); end

  # @return [Boolean]
  def valid_opaque?(auth); end

  # @return [Boolean]
  def valid_qop?(auth); end
end

Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

# Rack::Auth::Digest::Nonce is the default nonce generator for the
# Rack::Auth::Digest::MD5 authentication handler.
#
# +private_key+ needs to set to a constant string.
#
# +time_limit+ can be optionally set to an integer (number of seconds),
# to limit the validity of the generated nonces.
class Rack::Auth::Digest::Nonce
  # @return [Nonce] a new instance of Nonce
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  def digest; end

  # @return [Boolean]
  def fresh?; end

  # @return [Boolean]
  def stale?; end

  def to_s; end

  # @return [Boolean]
  def valid?; end

  class << self
    def parse(string); end

    # Returns the value of attribute private_key.
    def private_key; end

    # Sets the attribute private_key
    #
    # @param value the value to set the attribute private_key to.
    def private_key=(_arg0); end

    # Returns the value of attribute time_limit.
    def time_limit; end

    # Sets the attribute time_limit
    #
    # @param value the value to set the attribute time_limit to.
    def time_limit=(_arg0); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  # @return [Params] a new instance of Params
  # @yield [_self]
  # @yieldparam _self [Rack::Auth::Digest::Params] the object that the method was called on
  def initialize; end

  def [](k); end
  def []=(k, v); end

  # From WEBrick::HTTPUtils
  def quote(str); end

  def to_s; end

  class << self
    # From WEBrick::HTTPUtils
    def dequote(str); end

    def parse(str); end
    def split_header_value(str); end
  end
end

Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # @return [Boolean]
  def correct_uri?; end

  # @return [Boolean]
  def digest?; end

  def method; end

  # @raise [ArgumentError]
  def method_missing(sym, *args); end

  def nonce; end
  def params; end

  # @return [Boolean]
  def respond_to?(sym, *_arg1); end
end

# Proxy for response bodies allowing calling a block when
# the response body is closed (after the response has been fully
# sent to the client).
class Rack::BodyProxy
  # Set the response body to wrap, and the block to call when the
  # response has been fully sent.
  #
  # @return [BodyProxy] a new instance of BodyProxy
  def initialize(body, &block); end

  # If not already closed, close the wrapped body and
  # then call the block the proxy was initialized with.
  def close; end

  # Whether the proxy is closed.  The proxy starts as not closed,
  # and becomes closed on the first call to close.
  #
  # @return [Boolean]
  def closed?; end

  # Delegate missing methods to the wrapped body.
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # Return whether the wrapped body responds to the method.
  #
  # @return [Boolean]
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

# Rack::Builder provides a domain-specific language (DSL) to construct Rack
# applications. It is primarily used to parse +config.ru+ files which
# instantiate several middleware and a final application which are hosted
# by a Rack-compatible web server.
#
# Example:
#
#   app = Rack::Builder.new do
#     use Rack::CommonLogger
#     map "/ok" do
#       run lambda { |env| [200, {'content-type' => 'text/plain'}, ['OK']] }
#     end
#   end
#
#   run app
#
# Or
#
#   app = Rack::Builder.app do
#     use Rack::CommonLogger
#     run lambda { |env| [200, {'content-type' => 'text/plain'}, ['OK']] }
#   end
#
#   run app
#
# +use+ adds middleware to the stack, +run+ dispatches to an application.
# You can use +map+ to construct a Rack::URLMap in a convenient way.
class Rack::Builder
  # Initialize a new Rack::Builder instance.  +default_app+ specifies the
  # default application if +run+ is not called later.  If a block
  # is given, it is evaluated in the context of the instance.
  #
  # @return [Builder] a new instance of Builder
  def initialize(default_app = T.unsafe(nil), &block); end

  # Call the Rack application generated by this builder instance. Note that
  # this rebuilds the Rack application and runs the warmup code (if any)
  # every time it is called, so it should not be used if performance is important.
  def call(env); end

  # Freeze the app (set using run) and all middleware instances when building the application
  # in to_app.
  def freeze_app; end

  # Creates a route within the application.  Routes under the mapped path will be sent to
  # the Rack application specified by run inside the block.  Other requests will be sent to the
  # default application specified by run outside the block.
  #
  #   class App
  #     def call(env)
  #       [200, {'content-type' => 'text/plain'}, ["Hello World"]]
  #     end
  #   end
  #
  #   class Heartbeat
  #     def call(env)
  #       [200, { "content-type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   app = Rack::Builder.app do
  #     map '/heartbeat' do
  #       run Heartbeat.new
  #     end
  #     run App.new
  #   end
  #
  #   run app
  #
  # The +use+ method can also be used inside the block to specify middleware to run under a specific path:
  #
  #   app = Rack::Builder.app do
  #     map '/heartbeat' do
  #       use Middleware
  #       run Heartbeat.new
  #     end
  #     run App.new
  #   end
  #
  # This example includes a piece of middleware which will run before +/heartbeat+ requests hit +Heartbeat+.
  #
  # Note that providing a +path+ of +/+ will ignore any default application given in a +run+ statement
  # outside the block.
  def map(path, &block); end

  # Takes a block or argument that is an object that responds to #call and
  # returns a Rack response.
  #
  # You can use a block:
  #
  #   run do |env|
  #     [200, { "content-type" => "text/plain" }, ["Hello World!"]]
  #   end
  #
  # You can also provide a lambda:
  #
  #   run lambda { |env| [200, { "content-type" => "text/plain" }, ["OK"]] }
  #
  # You can also provide a class instance:
  #
  #   class Heartbeat
  #     def call(env)
  #      [200, { "content-type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   run Heartbeat.new
  #
  # @raise [ArgumentError]
  def run(app = T.unsafe(nil), &block); end

  # Return the Rack application generated by this instance.
  def to_app; end

  # Specifies middleware to use in a stack.
  #
  #   class Middleware
  #     def initialize(app)
  #       @app = app
  #     end
  #
  #     def call(env)
  #       env["rack.some_header"] = "setting an example"
  #       @app.call(env)
  #     end
  #   end
  #
  #   use Middleware
  #   run lambda { |env| [200, { "content-type" => "text/plain" }, ["OK"]] }
  #
  # All requests through to this application will first be processed by the middleware class.
  # The +call+ method in this example sets an additional environment key which then can be
  # referenced in the application if required.
  def use(middleware, *args, **_arg2, &block); end

  # Takes a lambda or block that is used to warm-up the application. This block is called
  # before the Rack application is returned by to_app.
  #
  #   warmup do |app|
  #     client = Rack::MockRequest.new(app)
  #     client.get('/')
  #   end
  #
  #   use SomeMiddleware
  #   run MyApp
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # Generate a URLMap instance by generating new Rack applications for each
  # map block in this instance.
  def generate_map(default_app, mapping); end

  class << self
    # Create a new Rack::Builder instance and return the Rack application
    # generated from it.
    def app(default_app = T.unsafe(nil), &block); end

    # Load the given file as a rackup file, treating the
    # contents as if specified inside a Rack::Builder block.
    #
    # Ignores content in the file after +__END__+, so that
    # use of +__END__+ will not result in a syntax error.
    #
    # Example config.ru file:
    #
    #   $ cat config.ru
    #
    #   use Rack::ContentLength
    #   require './app.rb'
    #   run App
    def load_file(path); end

    # Evaluate the given +builder_script+ string in the context of
    # a Rack::Builder block, returning a Rack application.
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # Parse the given config file to get a Rack application.
    #
    # If the config file ends in +.ru+, it is treated as a
    # rackup file and the contents will be treated as if
    # specified inside a Rack::Builder block.
    #
    # If the config file does not end in +.ru+, it is
    # required and Rack will use the basename of the file
    # to guess which constant will be the Rack application to run.
    #
    # Examples:
    #
    #   Rack::Builder.parse_file('config.ru')
    #   # Rack application built using Rack::Builder.new
    #
    #   Rack::Builder.parse_file('app.rb')
    #   # requires app.rb, which can be anywhere in Ruby's
    #   # load path. After requiring, assumes App constant
    #   # contains Rack application
    #
    #   Rack::Builder.parse_file('./my_app.rb')
    #   # requires ./my_app.rb, which should be in the
    #   # process's current directory.  After requiring,
    #   # assumes MyApp constant contains Rack application
    def parse_file(path); end
  end
end

# https://stackoverflow.com/questions/2223882/whats-the-difference-between-utf-8-and-utf-8-without-bom
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# Response Header Keys
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Rack::Cascade tries a request on several apps, and returns the
# first response that is not 404 or 405 (or in a list of configured
# status codes).  If all applications tried return one of the configured
# status codes, return the last response.
class Rack::Cascade
  # Set the apps to send requests to, and what statuses result in
  # cascading.  Arguments:
  #
  # apps: An enumerable of rack applications.
  # cascade_for: The statuses to use cascading for.  If a response is received
  #              from an app, the next app is tried.
  #
  # @return [Cascade] a new instance of Cascade
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  def <<(app); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  def add(app); end

  # An array of applications to try in order.
  def apps; end

  # Call each app in order.  If the responses uses a status that requires
  # cascading, try the next app.  If all responses require cascading,
  # return the response from the last app.
  def call(env); end

  # Whether the given app is one of the apps to cascade to.
  #
  # @return [Boolean]
  def include?(app); end
end

# deprecated, no longer used
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

# Middleware that applies chunked transfer encoding to response bodies
# when the response does not include a content-length header.
#
# This supports the trailer response header to allow the use of trailing
# headers in the chunked encoding.  However, using this requires you manually
# specify a response body that supports a +trailers+ method.  Example:
#
#   [200, { 'trailer' => 'expires'}, ["Hello", "World"]]
#   # error raised
#
#   body = ["Hello", "World"]
#   def body.trailers
#     { 'expires' => Time.now.to_s }
#   end
#   [200, { 'trailer' => 'expires'}, body]
#   # No exception raised
class Rack::Chunked
  include ::Rack::Utils

  # @return [Chunked] a new instance of Chunked
  def initialize(app); end

  # If the rack app returns a response that should have a body,
  # but does not have content-length or transfer-encoding headers,
  # modify the response to use chunked transfer-encoding.
  def call(env); end

  # Whether the HTTP version supports chunked encoding (HTTP 1.1 does).
  #
  # @return [Boolean]
  def chunkable_version?(ver); end
end

# A body wrapper that emits chunked responses.
class Rack::Chunked::Body
  # Store the response body to be chunked.
  #
  # @return [Body] a new instance of Body
  def initialize(body); end

  # Close the response body if the response body supports it.
  def close; end

  # For each element yielded by the response body, yield
  # the element in chunked encoding.
  #
  # @yield [TAIL]
  def each(&block); end

  private

  # Do nothing as this class does not support trailer headers.
  def yield_trailers; end
end

Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

# A body wrapper that emits chunked responses and also supports
# sending Trailer headers.  Note that the response body provided to
# initialize must have a +trailers+ method that returns a hash
# of trailer headers, and the rack response itself should have a
# Trailer header listing the headers that the +trailers+ method
# will return.
class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # Yield strings for each trailer header.
  def yield_trailers; end
end

# Rack::CommonLogger forwards every request to the given +app+, and
# logs a line in the
# {Apache common log format}[http://httpd.apache.org/docs/1.3/logs.html#common]
# to the configured logger.
class Rack::CommonLogger
  # +logger+ can be any object that supports the +write+ or +<<+ methods,
  # which includes the standard library Logger.  These methods are called
  # with a single string argument, the log message.
  # If +logger+ is nil, CommonLogger will fall back <tt>env['rack.errors']</tt>.
  #
  # @return [CommonLogger] a new instance of CommonLogger
  def initialize(app, logger = T.unsafe(nil)); end

  # Log all requests in common_log format after a response has been
  # returned.  Note that if the app raises an exception, the request
  # will not be logged, so if exception handling middleware are used,
  # they should be loaded after this middleware.  Additionally, because
  # the logging happens after the request body has been fully sent, any
  # exceptions raised during the sending of the response body will
  # cause the request not to be logged.
  def call(env); end

  private

  # Attempt to determine the content length for the response to
  # include it in the logged data.
  def extract_content_length(headers); end

  # Log the request to the configured logger.
  def log(env, status, response_headers, began_at); end
end

# Common Log Format: http://httpd.apache.org/docs/1.3/logs.html#common
#
#   lilith.local - - [07/Aug/2006 23:58:02 -0400] "GET / HTTP/1.1" 500 -
#
#   %{%s - %s [%s] "%s %s%s %s" %d %s\n} %
#
# The actual format is slightly different than the above due to the
# separation of SCRIPT_NAME and PATH_INFO, and because the elapsed
# time in seconds is included at the end.
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

# Middleware that enables conditional GET using if-none-match and
# if-modified-since. The application should set either or both of the
# last-modified or etag response headers according to RFC 2616. When
# either of the conditions is met, the response body is set to be zero
# length and the response status is set to 304 Not Modified.
#
# Applications that defer response body generation until the body's each
# message is received will avoid response body generation completely when
# a conditional GET matches.
#
# Adapted from Michael Klishin's Merb implementation:
# https://github.com/wycats/merb/blob/master/merb-core/lib/merb-core/rack/middleware/conditional_get.rb
class Rack::ConditionalGet
  # @return [ConditionalGet] a new instance of ConditionalGet
  def initialize(app); end

  # Return empty 304 response if the response has not been
  # modified since the last request.
  def call(env); end

  private

  # Whether the etag response header matches the if-none-match request header.
  # If so, the request has not been modified.
  #
  # @return [Boolean]
  def etag_matches?(none_match, headers); end

  # Return whether the response has not been modified since the
  # last request.
  #
  # @return [Boolean]
  def fresh?(env, headers); end

  # Whether the last-modified response header matches the if-modified-since
  # request header.  If so, the request has not been modified.
  #
  # @return [Boolean]
  def modified_since?(modified_since, headers); end

  # Return a Time object for the given string (which should be in RFC2822
  # format), or nil if the string cannot be parsed.
  def to_rfc2822(since); end
end

# Rack::Config modifies the environment using the block given during
# initialization.
#
# Example:
#     use Rack::Config do |env|
#       env['my-key'] = 'some-value'
#     end
class Rack::Config
  # @return [Config] a new instance of Config
  def initialize(app, &block); end

  def call(env); end
end

# Sets the content-length header on responses that do not specify
# a content-length or transfer-encoding header.  Note that this
# does not fix responses that have an invalid content-length
# header specified.
class Rack::ContentLength
  include ::Rack::Utils

  # @return [ContentLength] a new instance of ContentLength
  def initialize(app); end

  def call(env); end
end

# Sets the content-type header on responses which don't have one.
#
# Builder Usage:
#   use Rack::ContentType, "text/plain"
#
# When no content type argument is provided, "text/html" is the
# default.
class Rack::ContentType
  include ::Rack::Utils

  # @return [ContentType] a new instance of ContentType
  def initialize(app, content_type = T.unsafe(nil)); end

  def call(env); end
end

Rack::DELETE = T.let(T.unsafe(nil), String)

# This middleware enables content encoding of http responses,
# usually for purposes of compression.
#
# Currently supported encodings:
#
# * gzip
# * identity (no transformation)
#
# This middleware automatically detects when encoding is supported
# and allowed. For example no encoding is made when a cache
# directive of 'no-transform' is present, when the response status
# code is one that doesn't allow an entity body, or when the body
# is empty.
#
# Note that despite the name, Deflater does not support the +deflate+
# encoding.
class Rack::Deflater
  # Creates Rack::Deflater middleware. Options:
  #
  # :if :: a lambda enabling / disabling deflation based on returned boolean value
  #        (e.g <tt>use Rack::Deflater, :if => lambda { |*, body| sum=0; body.each { |i| sum += i.length }; sum > 512 }</tt>).
  #        However, be aware that calling `body.each` inside the block will break cases where `body.each` is not idempotent,
  #        such as when it is an +IO+ instance.
  # :include :: a list of content types that should be compressed. By default, all content types are compressed.
  # :sync :: determines if the stream is going to be flushed after every chunk.  Flushing after every chunk reduces
  #          latency for time-sensitive streaming applications, but hurts compression and throughput.
  #          Defaults to +true+.
  #
  # @return [Deflater] a new instance of Deflater
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  # Whether the body should be compressed.
  #
  # @return [Boolean]
  def should_deflate?(env, status, headers, body); end
end

# Body class used for gzip encoded responses.
class Rack::Deflater::GzipStream
  # Initialize the gzip stream.  Arguments:
  # body :: Response body to compress with gzip
  # mtime :: The modification time of the body, used to set the
  #          modification time in the gzip header.
  # sync :: Whether to flush each gzip chunk as soon as it is ready.
  #
  # @return [GzipStream] a new instance of GzipStream
  def initialize(body, mtime, sync); end

  # Close the original body if possible.
  def close; end

  # Yield gzip compressed strings to the given block.
  def each(&block); end

  # Call the block passed to #each with the gzipped data.
  def write(data); end
end

Rack::Deflater::GzipStream::BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)

# Rack::Directory serves entries below the +root+ given, according to the
# path info of the Rack request. If a directory is found, the file's contents
# will be presented in an html based index. If a file is found, the env will
# be passed to the specified +app+.
#
# If +app+ is not specified, a Rack::Files of the same +root+ will be used.
class Rack::Directory
  # Set the root directory and application for serving files.
  #
  # @return [Directory] a new instance of Directory
  def initialize(root, app = T.unsafe(nil)); end

  def call(env); end

  # Rack response to use for requests with invalid paths, or nil if path is valid.
  def check_bad_request(path_info); end

  # Rack response to use for requests with paths outside the root, or nil if path is inside the root.
  def check_forbidden(path_info); end

  # Rack response to use for unreadable and non-file, non-directory entries.
  def entity_not_found(path_info); end

  # Provide human readable file sizes
  def filesize_format(int); end

  # Internals of request handling.  Similar to call but does
  # not remove body for HEAD requests.
  def get(env); end

  # Rack response to use for directories under the root.
  def list_directory(path_info, path, script_name); end

  # Rack response to use for files and directories under the root.
  # Unreadable and non-file, non-directory entries will get a 404 response.
  def list_path(env, path, path_info, script_name); end

  # The root of the directory hierarchy.  Only requests for files and
  # directories inside of the root directory are supported.
  def root; end

  # File::Stat for the given path, but return nil for missing/bad entries.
  def stat(path); end
end

Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

# Body class for directory entries, showing an index page with links
# to each file.
class Rack::Directory::DirectoryBody < ::Struct
  # Yield strings for each part of the directory entry
  #
  # @yield [DIR_PAGE_HEADER % [ show_path, show_path ]]
  def each; end

  private

  # Escape each element in the array of html strings.
  def DIR_FILE_escape(htmls); end
end

# Stolen from Ramaze
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

Rack::ETAG = T.let(T.unsafe(nil), String)

# Automatically sets the etag header on all String bodies.
#
# The etag header is skipped if etag or last-modified headers are sent or if
# a sendfile body (body.responds_to :to_path) is given (since such cases
# should be handled by apache/nginx).
#
# On initialization, you can pass two parameters: a cache-control directive
# used when etag is absent and a directive when it is present. The first
# defaults to nil, while the second defaults to "max-age=0, private, must-revalidate"
class Rack::ETag
  # @return [ETag] a new instance of ETag
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  def call(env); end

  private

  def digest_body(body); end

  # @return [Boolean]
  def etag_status?(status); end

  # @return [Boolean]
  def skip_caching?(headers); end
end

Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)

# This middleware provides hooks to certain places in the request /
# response lifecycle.  This is so that middleware that don't need to filter
# the response data can safely leave it alone and not have to send messages
# down the traditional "rack stack".
#
# The events are:
#
# * on_start(request, response)
#
#   This event is sent at the start of the request, before the next
#   middleware in the chain is called.  This method is called with a request
#   object, and a response object.  Right now, the response object is always
#   nil, but in the future it may actually be a real response object.
#
# * on_commit(request, response)
#
#   The response has been committed.  The application has returned, but the
#   response has not been sent to the webserver yet.  This method is always
#   called with a request object and the response object.  The response
#   object is constructed from the rack triple that the application returned.
#   Changes may still be made to the response object at this point.
#
# * on_send(request, response)
#
#   The webserver has started iterating over the response body and presumably
#   has started sending data over the wire. This method is always called with
#   a request object and the response object.  The response object is
#   constructed from the rack triple that the application returned.  Changes
#   SHOULD NOT be made to the response object as the webserver has already
#   started sending data.  Any mutations will likely result in an exception.
#
# * on_finish(request, response)
#
#   The webserver has closed the response, and all data has been written to
#   the response socket.  The request and response object should both be
#   read-only at this point.  The body MAY NOT be available on the response
#   object as it may have been flushed to the socket.
#
# * on_error(request, response, error)
#
#   An exception has occurred in the application or an `on_commit` event.
#   This method will get the request, the response (if available) and the
#   exception that was raised.
#
# ## Order
#
# `on_start` is called on the handlers in the order that they were passed to
# the constructor.  `on_commit`, on_send`, `on_finish`, and `on_error` are
# called in the reverse order.  `on_finish` handlers are called inside an
# `ensure` block, so they are guaranteed to be called even if something
# raises an exception.  If something raises an exception in a `on_finish`
# method, then nothing is guaranteed.
class Rack::Events
  # @return [Events] a new instance of Events
  def initialize(app, handlers); end

  def call(env); end

  private

  def make_request(env); end
  def make_response(status, headers, body); end
  def on_commit(request, response); end
  def on_error(request, response, e); end
  def on_finish(request, response); end
  def on_start(request, response); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end
  def on_error(req, res, e); end
  def on_finish(req, res); end
  def on_send(req, res); end
  def on_start(req, res); end
end

class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # @return [BufferedResponse] a new instance of BufferedResponse
  def initialize(status, headers, body); end

  # Returns the value of attribute body.
  def body; end

  def to_a; end
end

class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # @return [EventedBodyProxy] a new instance of EventedBodyProxy
  def initialize(body, request, response, handlers, &block); end

  def each; end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end
end

Rack::File = Rack::Files

# Rack::Files serves files below the +root+ directory given, according to the
# path info of the Rack request.
# e.g. when Rack::Files.new("/etc") is used, you can access 'passwd' file
# as http://localhost:9292/passwd
#
# Handlers can detect if bodies are a Rack::Files, and use mechanisms
# like sendfile on the +path+.
class Rack::Files
  # @return [Files] a new instance of Files
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  def call(env); end
  def get(env); end

  # Returns the value of attribute root.
  def root; end

  def serving(request, path); end

  private

  def fail(status, body, headers = T.unsafe(nil)); end
  def filesize(path); end

  # The MIME type for the contents of the file located at @path
  def mime_type(path, default_mime); end
end

Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

class Rack::Files::BaseIterator
  # @return [BaseIterator] a new instance of BaseIterator
  def initialize(path, ranges, options); end

  def bytesize; end
  def close; end
  def each; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute ranges.
  def ranges; end

  private

  def each_range_part(file, range); end

  # @return [Boolean]
  def multipart?; end

  def multipart_heading(range); end
end

class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  def to_path; end
end

Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# Rack::ForwardRequest gets caught by Rack::Recursive and redirects
# the current request to the app at +url+.
#
#   raise ForwardRequest.new("/not-found")
class Rack::ForwardRequest < ::Exception
  # @return [ForwardRequest] a new instance of ForwardRequest
  def initialize(url, env = T.unsafe(nil)); end

  # Returns the value of attribute env.
  def env; end

  # Returns the value of attribute url.
  def url; end
end

# HTTP method verbs
Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# Request env keys
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# Rack::Head returns an empty body for all HEAD requests. It leaves
# all other requests unchanged.
class Rack::Head
  # @return [Head] a new instance of Head
  def initialize(app); end

  def call(env); end
end

# Rack::Headers is a Hash subclass that downcases all keys.  It's designed
# to be used by rack applications that don't implement the Rack 3 SPEC
# (by using non-lowercase response header keys), automatically handling
# the downcasing of keys.
class Rack::Headers < ::Hash
  def [](key); end
  def []=(key, value); end
  def assoc(key); end

  # @raise [TypeError]
  def compare_by_identity; end

  def delete(key); end
  def dig(key, *a); end

  # :nocov:
  def except(*a); end

  def fetch(key, *default, &block); end
  def fetch_values(*a); end

  # @return [Boolean]
  def has_key?(key); end

  # @return [Boolean]
  def include?(key); end

  def invert; end

  # @return [Boolean]
  def key?(key); end

  # @return [Boolean]
  def member?(key); end

  def merge(hash, &block); end
  def merge!(hash, &block); end
  def reject(&block); end
  def replace(hash); end
  def select(&block); end

  # :nocov:
  def slice(*a); end

  def store(key, value); end
  def to_proc; end
  def transform_keys(&block); end
  def transform_keys!; end
  def transform_values(&block); end
  def update(hash, &block); end
  def values_at(*keys); end

  private

  def downcase_key(key); end

  class << self
    def [](*items); end
  end
end

Rack::LINK = T.let(T.unsafe(nil), String)

# Rack::Lint validates your application and the requests and
# responses according to the Rack spec.
class Rack::Lint
  # @return [Lint] a new instance of Lint
  def initialize(app); end

  # AUTHORS: n.b. The trailing whitespace between paragraphs is important and
  # should not be removed. The whitespace creates paragraphs in the RDoc
  # output.
  #
  # This specification aims to formalize the Rack protocol. You
  # can (and should) use Rack::Lint to enforce it.
  #
  # When you develop middleware, be sure to add a Lint before and
  # after to catch all mistakes.
  #
  # = Rack applications
  #
  # A Rack application is a Ruby object (not a class) that
  # responds to +call+.
  def call(env = T.unsafe(nil)); end
end

# :stopdoc:
class Rack::Lint::LintError < ::RuntimeError; end

class Rack::Lint::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  def initialize(app, env); end

  # ==== Streaming Body
  #
  # @raise [LintError]
  def call(stream); end

  # === The content-length
  def check_content_length(status, headers); end

  # === The content-type
  def check_content_type(status, headers); end

  # == The Environment
  #
  # @raise [LintError]
  def check_environment(env); end

  # === The Error Stream
  def check_error(error); end

  def check_header_value(key, value); end

  # === The Headers
  def check_headers(headers); end

  # === Hijacking
  #
  # The hijacking interfaces provides a means for an application to take
  # control of the HTTP connection. There are two distinct hijack
  # interfaces: full hijacking where the application takes over the raw
  # connection, and partial hijacking where the application takes over
  # just the response body stream. In both cases, the application is
  # responsible for closing the hijacked stream.
  #
  # Full hijacking only works with HTTP/1. Partial hijacking is functionally
  # equivalent to streaming bodies, and is still optionally supported for
  # backwards compatibility with older Rack versions.
  #
  # ==== Full Hijack
  #
  # Full hijack is used to completely take over an HTTP/1 connection. It
  # occurs before any headers are written and causes the request to
  # ignores any response generated by the application.
  #
  # It is intended to be used when applications need access to raw HTTP/1
  # connection.
  def check_hijack(env); end

  # ==== Partial Hijack
  #
  # Partial hijack is used for bi-directional streaming of the request and
  # response body. It occurs after the status and headers are written by
  # the server and causes the server to ignore the Body of the response.
  #
  # It is intended to be used when applications need bi-directional
  # streaming.
  def check_hijack_response(headers, env); end

  # === The Input Stream
  #
  # The input stream is an IO-like object which contains the raw HTTP
  # POST data.
  def check_input(input); end

  # == The Response
  #
  # === The Status
  def check_status(status); end

  # === The Body
  #
  # The Body is typically an +Array+ of +String+ instances, an enumerable
  # that yields +String+ instances, a +Proc+ instance, or a File-like
  # object.
  #
  # The Body must respond to +each+ or +call+. It may optionally respond
  # to +to_path+ or +to_ary+. A Body that responds to +each+ is considered
  # to be an Enumerable Body. A Body that responds to +call+ is considered
  # to be a Streaming Body.
  #
  # A Body that responds to both +each+ and +call+ must be treated as an
  # Enumerable Body, not a Streaming Body. If it responds to +each+, you
  # must call +each+ and not +call+. If the Body doesn't respond to
  # +each+, then you can assume it responds to +call+.
  #
  # The Body must either be consumed or returned. The Body is consumed by
  # optionally calling either +each+ or +call+.
  # Then, if the Body responds to +close+, it must be called to release
  # any resources associated with the generation of the body.
  # In other words, +close+ must always be called at least once; typically
  # after the web server has sent the response to the client, but also in
  # cases where the Rack application makes internal/virtual requests and
  # discards the response.
  def close; end

  # ==== Enumerable Body
  #
  # @raise [LintError]
  def each; end

  # @return [Boolean]
  def respond_to?(name, *_arg1); end

  # @raise [LintError]
  def response; end

  # If the Body responds to +to_ary+, it must return an +Array+ whose
  # contents are identical to that produced by calling +each+.
  # Middleware may call +to_ary+ directly on the Body and return a new
  # Body in its place. In other words, middleware can only process the
  # Body directly if it responds to +to_ary+. If the Body responds to both
  # +to_ary+ and +close+, its implementation of +to_ary+ must call
  # +close+.
  def to_ary; end

  def to_path; end
  def verify_content_length(size); end
  def verify_to_path; end
end

Rack::Lint::Wrapper::BODY_METHODS = T.let(T.unsafe(nil), Hash)

class Rack::Lint::Wrapper::ErrorWrapper
  # @return [ErrorWrapper] a new instance of ErrorWrapper
  def initialize(error); end

  # * +close+ must never be called on the error stream.
  #
  # @raise [LintError]
  def close(*args); end

  # * +flush+ must be called without arguments and must be called
  #   in order to make the error appear for sure.
  def flush; end

  # * +puts+ must be called with a single argument that responds to +to_s+.
  def puts(str); end

  # * +write+ must be called with a single argument that is a String.
  #
  # @raise [LintError]
  def write(str); end
end

class Rack::Lint::Wrapper::InputWrapper
  # @return [InputWrapper] a new instance of InputWrapper
  def initialize(input); end

  # * +close+ can be called on the input stream to indicate that the
  # any remaining input is not needed.
  def close(*args); end

  # * +each+ must be called without arguments and only yield Strings.
  #
  # @raise [LintError]
  def each(*args); end

  # * +gets+ must be called without arguments and return a string,
  #   or +nil+ on EOF.
  #
  # @raise [LintError]
  def gets(*args); end

  # * +read+ behaves like IO#read.
  #   Its signature is <tt>read([length, [buffer]])</tt>.
  #
  #   If given, +length+ must be a non-negative Integer (>= 0) or +nil+,
  #   and +buffer+ must be a String and may not be nil.
  #
  #   If +length+ is given and not nil, then this method reads at most
  #   +length+ bytes from the input stream.
  #
  #   If +length+ is not given or nil, then this method reads
  #   all data until EOF.
  #
  #   When EOF is reached, this method returns nil if +length+ is given
  #   and not nil, or "" if +length+ is not given or is nil.
  #
  #   If +buffer+ is given, then the read data will be placed
  #   into +buffer+ instead of a newly created String object.
  def read(*args); end
end

class Rack::Lint::Wrapper::StreamWrapper
  extend ::Forwardable

  # @return [StreamWrapper] a new instance of StreamWrapper
  def initialize(stream); end

  def <<(*args, **_arg1, &block); end
  def close(*args, **_arg1, &block); end
  def close_read(*args, **_arg1, &block); end
  def close_write(*args, **_arg1, &block); end
  def closed?(*args, **_arg1, &block); end
  def flush(*args, **_arg1, &block); end
  def read(*args, **_arg1, &block); end
  def write(*args, **_arg1, &block); end
end

# The semantics of these IO methods must be a best effort match to
# those of a normal Ruby IO or Socket object, using standard arguments
# and raising standard exceptions. Servers are encouraged to simply
# pass on real IO objects, although it is recognized that this approach
# is not directly compatible with HTTP/2.
Rack::Lint::Wrapper::StreamWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

# Rack::Lock locks every request inside a mutex, so that every request
# will effectively be executed synchronously.
class Rack::Lock
  # @return [Lock] a new instance of Lock
  def initialize(app, mutex = T.unsafe(nil)); end

  def call(env); end

  private

  def unlock; end
end

# Sets up rack.logger to write to rack.errors stream
class Rack::Logger
  # @return [Logger] a new instance of Logger
  def initialize(app, level = T.unsafe(nil)); end

  def call(env); end
end

# Rack::MediaType parse media type and parameters out of content_type string
class Rack::MediaType
  class << self
    # The media type parameters provided in CONTENT_TYPE as a Hash, or
    # an empty Hash if no CONTENT_TYPE or media-type parameters were
    # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
    # this method responds with the following Hash:
    #   { 'charset' => 'utf-8' }
    def params(content_type); end

    # The media type (type/subtype) portion of the CONTENT_TYPE header
    # without any media type parameters. e.g., when CONTENT_TYPE is
    # "text/plain;charset=utf-8", the media-type is "text/plain".
    #
    # For more information on the use of media types in HTTP, see:
    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
    def type(content_type); end

    private

    def strip_doublequotes(str); end
  end
end

Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rack::MethodOverride
  # @return [MethodOverride] a new instance of MethodOverride
  def initialize(app); end

  def call(env); end
  def method_override(env); end

  private

  def allowed_methods; end
  def method_override_param(req); end
end

Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime
  private

  # Returns true if the given value is a mime match for the given mime match
  # specification, false otherwise.
  #
  #    Rack::Mime.match?('text/html', 'text/*') => true
  #    Rack::Mime.match?('text/plain', '*') => true
  #    Rack::Mime.match?('text/html', 'application/json') => false
  #
  # @return [Boolean]
  def match?(value, matcher); end

  # Returns String with mime type if found, otherwise use +fallback+.
  # +ext+ should be filename extension in the '.ext' format that
  #       File.extname(file) returns.
  # +fallback+ may be any object
  #
  # Also see the documentation for MIME_TYPES
  #
  # Usage:
  #     Rack::Mime.mime_type('.foo')
  #
  # This is a shortcut for:
  #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # Returns true if the given value is a mime match for the given mime match
    # specification, false otherwise.
    #
    #    Rack::Mime.match?('text/html', 'text/*') => true
    #    Rack::Mime.match?('text/plain', '*') => true
    #    Rack::Mime.match?('text/html', 'application/json') => false
    #
    # @return [Boolean]
    def match?(value, matcher); end

    # Returns String with mime type if found, otherwise use +fallback+.
    # +ext+ should be filename extension in the '.ext' format that
    #       File.extname(file) returns.
    # +fallback+ may be any object
    #
    # Also see the documentation for MIME_TYPES
    #
    # Usage:
    #     Rack::Mime.mime_type('.foo')
    #
    # This is a shortcut for:
    #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# List of most common mime-types, selected various sources
# according to their usefulness in a webserving scope for Ruby
# users.
#
# To amend this list with your local mime.types list you can use:
#
#     require 'webrick/httputils'
#     list = WEBrick::HTTPUtils.load_mime_types('/etc/mime.types')
#     Rack::Mime::MIME_TYPES.merge!(list)
#
# N.B. On Ubuntu the mime.types file does not include the leading period, so
# users may need to modify the data before merging into the hash.
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

# Rack::MockRequest helps testing your Rack application without
# actually using HTTP.
#
# After performing a request on a URL with get/post/put/patch/delete, it
# returns a MockResponse with useful helper methods for effective
# testing.
#
# You can pass a hash with additional configuration to the
# get/post/put/patch/delete.
# <tt>:input</tt>:: A String or IO-like to be used as rack.input.
# <tt>:fatal</tt>:: Raise a FatalWarning if the app writes to rack.errors.
# <tt>:lint</tt>:: If true, wrap the application in a Rack::Lint.
class Rack::MockRequest
  # @return [MockRequest] a new instance of MockRequest
  def initialize(app); end

  # Make a DELETE request and return a MockResponse. See #request.
  def delete(uri, opts = T.unsafe(nil)); end

  # Make a GET request and return a MockResponse. See #request.
  def get(uri, opts = T.unsafe(nil)); end

  # Make a HEAD request and return a MockResponse. See #request.
  def head(uri, opts = T.unsafe(nil)); end

  # Make an OPTIONS request and return a MockResponse. See #request.
  def options(uri, opts = T.unsafe(nil)); end

  # Make a PATCH request and return a MockResponse. See #request.
  def patch(uri, opts = T.unsafe(nil)); end

  # Make a POST request and return a MockResponse. See #request.
  def post(uri, opts = T.unsafe(nil)); end

  # Make a PUT request and return a MockResponse. See #request.
  def put(uri, opts = T.unsafe(nil)); end

  # Make a request using the given request method for the given
  # uri to the rack application and return a MockResponse.
  # Options given are passed to MockRequest.env_for.
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # Return the Rack environment used for a request to +uri+.
    # All options that are strings are added to the returned environment.
    # Options:
    # :fatal :: Whether to raise an exception if request outputs to rack.errors
    # :input :: The rack.input to set
    # :http_version :: The SERVER_PROTOCOL to set
    # :method :: The HTTP request method to use
    # :params :: The params to use
    # :script_name :: The SCRIPT_NAME to set
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # For historical reasons, we're pinning to RFC 2396.
    # URI::Parser = URI::RFC2396_Parser
    def parse_uri_rfc2396(uri); end
  end
end

Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  def flush; end

  # @raise [FatalWarning]
  def puts(warning); end

  def string; end

  # @raise [FatalWarning]
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError; end

# Rack::MockResponse provides useful helpers for testing your apps.
# Usually, you don't create the MockResponse on your own, but use
# MockRequest.
class Rack::MockResponse < ::Rack::Response
  # @return [MockResponse] a new instance of MockResponse
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  def =~(other); end
  def body; end
  def cookie(name); end

  # Headers
  def cookies; end

  # @return [Boolean]
  def empty?; end

  # Errors
  def errors; end

  # Errors
  def errors=(_arg0); end

  def match(other); end

  # Headers
  def original_headers; end

  private

  def identify_cookie_attributes(cookie_filling); end
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

# A multipart form data parser, adapted from IOWA.
#
# Usually, Rack::Request#POST takes care of calling this.
module Rack::Multipart
  class << self
    def build_multipart(params, first = T.unsafe(nil)); end
    def extract_multipart(request, params = T.unsafe(nil)); end
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# Updated definitions from RFC 2231
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::BROKEN = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

# Use specific error class when parsing multipart request
# that ends early.
class Rack::Multipart::EmptyContentError < ::EOFError; end

# Base class for multipart exceptions that do not subclass from
# other exception classes for backwards compatibility.
class Rack::Multipart::Error < ::StandardError; end

class Rack::Multipart::Generator
  # @return [Generator] a new instance of Generator
  def initialize(params, first = T.unsafe(nil)); end

  def dump; end

  private

  def content_for_other(file, name); end
  def content_for_tempfile(io, file, name); end
  def flattened_params; end

  # @return [Boolean]
  def multipart?; end
end

Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)
class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end
class Rack::Multipart::MultipartTotalPartLimitError < ::StandardError; end

class Rack::Multipart::Parser
  # @return [Parser] a new instance of Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def parse(io); end
  def result; end

  # Returns the value of attribute state.
  def state; end

  private

  # Scan until the we find the start or end of the boundary.
  # If we find it, return the appropriate symbol for the start or
  # end of the boundary.  If we don't find the start or end of the
  # boundary, clear the buffer and return nil.
  def consume_boundary; end

  # From WEBrick::HTTPUtils
  def dequote(str); end

  def get_filename(head); end
  def handle_consume_token; end
  def handle_empty_content!(content); end

  # This handles the initial parser state.  We read until we find the starting
  # boundary, then we can transition to the next state. If we find the ending
  # boundary, this is an invalid multipart upload, but keep scanning for opening
  # boundary in that case. If no boundary found, we need to keep reading data
  # and retry. It's highly unlikely the initial read will not consume the
  # boundary.  The client would have to deliberately craft a response
  # with the opening boundary beyond the buffer size for that to happen.
  def handle_fast_forward; end

  def handle_mime_body; end
  def handle_mime_head; end
  def read_data(io, outbuf); end
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end
    def parse_boundary(content_type); end
  end
end

Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Rack::Multipart::Parser::BoundedIO
  # @return [BoundedIO] a new instance of BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf = T.unsafe(nil)); end
end

Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # @return [Collector] a new instance of Collector
  def initialize(tempfile); end

  def each; end
  def on_mime_body(mime_index, content); end
  def on_mime_finish(mime_index); end
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  def check_part_limits; end
end

class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  def close; end

  # @return [Boolean]
  def file?; end
end

class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # @yield [data]
  def get_data; end
end

class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  def close; end

  # @return [Boolean]
  def file?; end
end

Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

class Rack::Multipart::Parser::MultipartInfo < ::Struct
  # Returns the value of attribute params
  #
  # @return [Object] the current value of params
  def params; end

  # Sets the attribute params
  #
  # @param value [Object] the value to set the attribute params to.
  # @return [Object] the newly set value
  def params=(_); end

  # Returns the value of attribute tmp_files
  #
  # @return [Object] the current value of tmp_files
  def tmp_files; end

  # Sets the attribute tmp_files
  #
  # @param value [Object] the value to set the attribute tmp_files to.
  # @return [Object] the newly set value
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  # @return [UploadedFile] a new instance of UploadedFile
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # The content type of the "uploaded" file
  def content_type; end

  # The content type of the "uploaded" file
  def content_type=(_arg0); end

  def local_path; end
  def method_missing(method_name, *args, &block); end

  # The filename, *not* including the path, of the "uploaded" file
  def original_filename; end

  def path; end

  # @return [Boolean]
  def respond_to?(*args); end
end

Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

class Rack::NullLogger
  # @return [NullLogger] a new instance of NullLogger
  def initialize(app); end

  def <<(msg); end
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
  def call(env); end
  def close; end
  def datetime_format; end
  def datetime_format=(datetime_format); end
  def debug(progname = T.unsafe(nil), &block); end
  def debug!; end

  # @return [Boolean]
  def debug?; end

  def error(progname = T.unsafe(nil), &block); end
  def error!; end

  # @return [Boolean]
  def error?; end

  def fatal(progname = T.unsafe(nil), &block); end
  def fatal!; end

  # @return [Boolean]
  def fatal?; end

  def formatter; end
  def formatter=(formatter); end
  def info(progname = T.unsafe(nil), &block); end
  def info!; end

  # @return [Boolean]
  def info?; end

  def level; end
  def level=(level); end
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
  def progname; end
  def progname=(progname); end
  def reopen(logdev = T.unsafe(nil)); end
  def sev_threshold; end
  def sev_threshold=(sev_threshold); end
  def unknown(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end
  def warn!; end

  # @return [Boolean]
  def warn?; end
end

Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

class Rack::QueryParser
  # @return [QueryParser] a new instance of QueryParser
  def initialize(params_class, _key_space_limit = T.unsafe(nil), param_depth_limit); end

  def make_params; end
  def new_depth_limit(param_depth_limit); end

  # normalize_params recursively expands parameters into structural types. If
  # the structural types represented by two different parameter names are in
  # conflict, a ParameterTypeError is raised.  The depth argument is deprecated
  # and should no longer be used, it is kept for backwards compatibility with
  # earlier versions of rack.
  def normalize_params(params, name, v, _depth = T.unsafe(nil)); end

  # Returns the value of attribute param_depth_limit.
  def param_depth_limit; end

  # parse_nested_query expands a query string into structural types. Supported
  # types are Arrays, Hashes and basic value types. It is possible to supply
  # query strings with parameters of conflicting types, in this case a
  # ParameterTypeError is raised. Users are encouraged to return a 400 in this
  # case.
  def parse_nested_query(qs, separator = T.unsafe(nil)); end

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'.  You can also use this
  # to parse cookies by changing the characters used in the second parameter
  # (which defaults to '&').
  def parse_query(qs, separator = T.unsafe(nil), &unescaper); end

  private

  # @raise [ParamsTooDeepError]
  def _normalize_params(params, name, v, depth); end

  # @return [Boolean]
  def params_hash_has_key?(hash, key); end

  # @return [Boolean]
  def params_hash_type?(obj); end

  def unescape(string, encoding = T.unsafe(nil)); end

  class << self
    def make_default(_key_space_limit = T.unsafe(nil), param_depth_limit); end
  end
end

Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# InvalidParameterError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain invalid format or byte
# sequence.
class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end

# ParameterTypeError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain conflicting types.
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

class Rack::QueryParser::Params
  # @return [Params] a new instance of Params
  def initialize; end

  def [](key); end
  def []=(key, value); end

  # @return [Boolean]
  def key?(key); end

  # Recursively unwraps nested `Params` objects and constructs an object
  # of the same shape, but using the objects' internal representations
  # (Ruby hashes) in place of the objects. The result is a hash consisting
  # purely of Ruby primitives.
  #
  #   Mutation warning!
  #
  #   1. This method mutates the internal representation of the `Params`
  #      objects in order to save object allocations.
  #
  #   2. The value you get back is a reference to the internal hash
  #      representation, not a copy.
  #
  #   3. Because the `Params` object's internal representation is mutable
  #      through the `#[]=` method, it is not thread safe. The result of
  #      getting the hash representation while another thread is adding a
  #      key to it is non-deterministic.
  def to_h; end

  # Recursively unwraps nested `Params` objects and constructs an object
  # of the same shape, but using the objects' internal representations
  # (Ruby hashes) in place of the objects. The result is a hash consisting
  # purely of Ruby primitives.
  #
  #   Mutation warning!
  #
  #   1. This method mutates the internal representation of the `Params`
  #      objects in order to save object allocations.
  #
  #   2. The value you get back is a reference to the internal hash
  #      representation, not a copy.
  #
  #   3. Because the `Params` object's internal representation is mutable
  #      through the `#[]=` method, it is not thread safe. The result of
  #      getting the hash representation while another thread is adding a
  #      key to it is non-deterministic.
  def to_params_hash; end
end

# ParamsTooDeepError is the error that is raised when params are recursively
# nested over the specified limit.
class Rack::QueryParser::ParamsTooDeepError < ::RangeError; end

Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_ERROR = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

# Rack::Recursive allows applications called down the chain to
# include data from other applications (by using
# <tt>rack['rack.recursive.include'][...]</tt> or raise a
# ForwardRequest to redirect internally.
class Rack::Recursive
  # @return [Recursive] a new instance of Recursive
  def initialize(app); end

  def _call(env); end
  def call(env); end
  def include(env, path); end
end

# High performant source reloader
#
# This class acts as Rack middleware.
#
# What makes it especially suited for use in a production environment is that
# any file will only be checked once and there will only be made one system
# call stat(2).
#
# Please note that this will not reload files in the background, it does so
# only when actively called.
#
# It is performing a check/reload cycle at the start of every request, but
# also respects a cool down time, during which nothing will be done.
class Rack::Reloader
  # @return [Reloader] a new instance of Reloader
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  def call(env); end
  def reload!(stderr = T.unsafe(nil)); end

  # A safe Kernel::load, issuing the hooks depending on the results
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  # Takes a relative or absolute +file+ name, a couple possible +paths+ that
  # the +file+ might reside in. Returns the full path and File::Stat for the
  # path.
  def figure_path(file, paths); end

  def rotation; end
  def safe_stat(file); end
end

# Rack::Request provides a convenient interface to a Rack
# environment.  It is stateless, the environment +env+ passed to the
# constructor will be directly modified.
#
#   req = Rack::Request.new(env)
#   req.post?
#   req.params["data"]
class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # @return [Request] a new instance of Request
  def initialize(env); end

  def delete_param(k); end
  def params; end
  def query; end
  def update_param(k, v); end
  def version_supplied; end
  def version_supplied=(_arg0); end
  def xhr?; end

  class << self
    # The priority when checking forwarded headers. The default
    # is <tt>[:forwarded, :x_forwarded]</tt>, which means, check the
    # +Forwarded+ header first, followed by the appropriate
    # <tt>X-Forwarded-*</tt> header.  You can revert the priority by
    # reversing the priority, or remove checking of either
    # or both headers by removing elements from the array.
    #
    # This should be set as appropriate in your environment
    # based on what reverse proxies are in use.  If you are not
    # using reverse proxies, you should probably use an empty
    # array.
    def forwarded_priority; end

    # The priority when checking forwarded headers. The default
    # is <tt>[:forwarded, :x_forwarded]</tt>, which means, check the
    # +Forwarded+ header first, followed by the appropriate
    # <tt>X-Forwarded-*</tt> header.  You can revert the priority by
    # reversing the priority, or remove checking of either
    # or both headers by removing elements from the array.
    #
    # This should be set as appropriate in your environment
    # based on what reverse proxies are in use.  If you are not
    # using reverse proxies, you should probably use an empty
    # array.
    def forwarded_priority=(_arg0); end

    # Returns the value of attribute ip_filter.
    def ip_filter; end

    # Sets the attribute ip_filter
    #
    # @param value the value to set the attribute ip_filter to.
    def ip_filter=(_arg0); end

    # The priority when checking either the <tt>X-Forwarded-Proto</tt>
    # or <tt>X-Forwarded-Scheme</tt> header for the forwarded protocol.
    # The default is <tt>[:proto, :scheme]</tt>, to try the
    # <tt>X-Forwarded-Proto</tt> header before the
    # <tt>X-Forwarded-Scheme</tt> header.  Rack 2 had behavior
    # similar to <tt>[:scheme, :proto]</tt>.  You can remove either or
    # both of the entries in array to ignore that respective header.
    def x_forwarded_proto_priority; end

    # The priority when checking either the <tt>X-Forwarded-Proto</tt>
    # or <tt>X-Forwarded-Scheme</tt> header for the forwarded protocol.
    # The default is <tt>[:proto, :scheme]</tt>, to try the
    # <tt>X-Forwarded-Proto</tt> header before the
    # <tt>X-Forwarded-Scheme</tt> header.  Rack 2 had behavior
    # similar to <tt>[:scheme, :proto]</tt>.  You can remove either or
    # both of the entries in array to ignore that respective header.
    def x_forwarded_proto_priority=(_arg0); end
  end
end

Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

module Rack::Request::Env
  def initialize(env); end

  # Add a header that may have multiple values.
  #
  # Example:
  #   request.add_header 'Accept', 'image/png'
  #   request.add_header 'Accept', '*/*'
  #
  #   assert_equal 'image/png,*/*', request.get_header('Accept')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  def add_header(key, v); end

  # Delete a request specific value for `name`.
  def delete_header(name); end

  # Loops through each key / value pair in the request specific data.
  def each_header(&block); end

  # The environment of the request.
  def env; end

  # If a block is given, it yields to the block if the value hasn't been set
  # on the request.
  def fetch_header(name, &block); end

  # Get a request specific value for `name`.
  def get_header(name); end

  # Predicate method to test to see if `name` has been set as request
  # specific data
  #
  # @return [Boolean]
  def has_header?(name); end

  # Set a request specific value for `name` to `v`
  def set_header(name, v); end

  private

  def initialize_copy(other); end
end

module Rack::Request::Helpers
  # Returns the data received in the query string.
  def GET; end

  # Returns the data received in the request body.
  #
  # This method support both application/x-www-form-urlencoded and
  # multipart/form-data.
  def POST; end

  # shortcut for <tt>request.params[key]</tt>
  def [](key); end

  # shortcut for <tt>request.params[key] = value</tt>
  #
  # Note that modifications will not be persisted in the env. Use update_param or delete_param if you want to destructively modify params.
  def []=(key, value); end

  def accept_encoding; end
  def accept_language; end

  # The authority of the incoming request as defined by RFC3976.
  # https://tools.ietf.org/html/rfc3986#section-3.2
  #
  # In HTTP/1, this is the `host` header.
  # In HTTP/2, this is the `:authority` pseudo-header.
  def authority; end

  def base_url; end
  def body; end

  # The character set of the request body if a "charset" media type
  # parameter was given, or nil if no "charset" was specified. Note
  # that, per RFC2616, text/* media types that specify no explicit
  # charset are to be considered ISO-8859-1.
  def content_charset; end

  def content_length; end
  def content_type; end
  def cookies; end

  # Checks the HTTP request method (or verb) to see if it was of type DELETE
  #
  # @return [Boolean]
  def delete?; end

  # Destructively delete a parameter, whether it's in GET or POST. Returns the value of the deleted parameter.
  #
  # If the parameter is in both GET and POST, the POST value takes precedence since that's how #params works.
  #
  # <tt>env['rack.input']</tt> is not touched.
  def delete_param(k); end

  # Determine whether the request body contains form-data by checking
  # the request content-type for one of the media-types:
  # "application/x-www-form-urlencoded" or "multipart/form-data". The
  # list of form-data media types can be modified through the
  # +FORM_DATA_MEDIA_TYPES+ array.
  #
  # A request body is also assumed to contain form-data when no
  # content-type header is provided and the request_method is POST.
  #
  # @return [Boolean]
  def form_data?; end

  def forwarded_authority; end
  def forwarded_for; end
  def forwarded_port; end
  def fullpath; end

  # Checks the HTTP request method (or verb) to see if it was of type GET
  #
  # @return [Boolean]
  def get?; end

  # Checks the HTTP request method (or verb) to see if it was of type HEAD
  #
  # @return [Boolean]
  def head?; end

  # Returns a formatted host, suitable for being used in a URI.
  def host; end

  # The `HTTP_HOST` header.
  def host_authority; end

  def host_with_port(authority = T.unsafe(nil)); end

  # Returns an address suitable for being to resolve to an address.
  # In the case of a domain name or IPv4 address, the result is the same
  # as +host+. In the case of IPv6 or future address formats, the square
  # brackets are removed.
  def hostname; end

  def ip; end

  # Checks the HTTP request method (or verb) to see if it was of type LINK
  #
  # @return [Boolean]
  def link?; end

  def logger; end

  # The media type (type/subtype) portion of the CONTENT_TYPE header
  # without any media type parameters. e.g., when CONTENT_TYPE is
  # "text/plain;charset=utf-8", the media-type is "text/plain".
  #
  # For more information on the use of media types in HTTP, see:
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
  def media_type; end

  # The media type parameters provided in CONTENT_TYPE as a Hash, or
  # an empty Hash if no CONTENT_TYPE or media-type parameters were
  # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
  # this method responds with the following Hash:
  #   { 'charset' => 'utf-8' }
  def media_type_params; end

  # Checks the HTTP request method (or verb) to see if it was of type OPTIONS
  #
  # @return [Boolean]
  def options?; end

  # The union of GET and POST data.
  #
  # Note that modifications will not be persisted in the env. Use update_param or delete_param if you want to destructively modify params.
  def params; end

  # Determine whether the request body contains data by checking
  # the request media_type against registered parse-data media-types
  #
  # @return [Boolean]
  def parseable_data?; end

  # Checks the HTTP request method (or verb) to see if it was of type PATCH
  #
  # @return [Boolean]
  def patch?; end

  def path; end
  def path_info; end
  def path_info=(s); end
  def port; end

  # Checks the HTTP request method (or verb) to see if it was of type POST
  #
  # @return [Boolean]
  def post?; end

  # Checks the HTTP request method (or verb) to see if it was of type PUT
  #
  # @return [Boolean]
  def put?; end

  def query_string; end

  # the referer of the client
  def referer; end

  # the referer of the client
  def referrer; end

  def request_method; end
  def scheme; end
  def script_name; end
  def script_name=(s); end

  # The authority as defined by the `SERVER_NAME` and `SERVER_PORT`
  # variables.
  def server_authority; end

  def server_name; end
  def server_port; end
  def session; end
  def session_options; end

  # @return [Boolean]
  def ssl?; end

  # Checks the HTTP request method (or verb) to see if it was of type TRACE
  #
  # @return [Boolean]
  def trace?; end

  # @return [Boolean]
  def trusted_proxy?(ip); end

  # Checks the HTTP request method (or verb) to see if it was of type UNLINK
  #
  # @return [Boolean]
  def unlink?; end

  # Destructively update a parameter, whether it's in GET and/or POST. Returns nil.
  #
  # The parameter is updated wherever it was previous defined, so GET, POST, or both. If it wasn't previously defined, it's inserted into GET.
  #
  # <tt>env['rack.input']</tt> is not touched.
  def update_param(k, v); end

  # Tries to return a remake of the original request URL as a string.
  def url; end

  def user_agent; end

  # like Hash#values_at
  def values_at(*keys); end

  # @return [Boolean]
  def xhr?; end

  private

  def allowed_scheme(header); end
  def default_session; end
  def forwarded_priority; end
  def forwarded_scheme; end

  # Get an array of values set in the RFC 7239 `Forwarded` request header.
  def get_http_forwarded(token); end

  def parse_http_accept_header(header); end
  def parse_multipart; end
  def parse_query(qs, d = T.unsafe(nil)); end
  def query_parser; end
  def reject_trusted_ip_addresses(ip_addresses); end
  def split_authority(authority); end
  def split_header(value); end

  # Assist with compatibility when processing `X-Forwarded-For`.
  def wrap_ipv6(host); end

  def x_forwarded_proto_priority; end
end

Rack::Request::Helpers::AUTHORITY = T.let(T.unsafe(nil), Regexp)

# Default ports depending on scheme. Used to decide whether or not
# to include the port in a generated URI.
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# The set of form-data media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for form-data / param parsing.
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

Rack::Request::Helpers::FORWARDED_SCHEME_HEADERS = T.let(T.unsafe(nil), Hash)
Rack::Request::Helpers::HTTP_FORWARDED = T.let(T.unsafe(nil), String)

# The address of the client which connected to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# The contents of the host/:authority header sent to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# The port used to connect to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# The protocol used to connect to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# The value of the scheme sent to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# Another way for specifying https scheme was used.
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# The set of media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for param parsing like soap attachments or generic multiparts
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# Rack::Response provides a convenient interface to create a Rack
# response.
#
# It allows setting of headers and cookies, and provides useful
# defaults (an OK response with empty headers and body).
#
# You can use Response#write to iteratively generate your response,
# but note that this is buffered by Rack::Response until you call
# +finish+.  +finish+ however can take a block inside which calls to
# +write+ are synchronous with the Rack response.
#
# Your application's +call+ should end returning Response#finish.
class Rack::Response
  include ::Rack::Response::Helpers

  # Initialize the response object with the specified +body+, +status+
  # and +headers+.
  #
  # If the +body+ is +nil+, construct an empty response object with internal
  # buffering.
  #
  # If the +body+ responds to +to_str+, assume it's a string-like object and
  # construct a buffered response object containing using that string as the
  # initial contents of the buffer.
  #
  # Otherwise it is expected +body+ conforms to the normal requirements of a
  # Rack response body, typically implementing one of +each+ (enumerable
  # body) or +call+ (streaming body).
  #
  # The +status+ defaults to +200+ which is the "OK" HTTP status code. You
  # can provide any other valid status code.
  #
  # The +headers+ must be a +Hash+ of key-value header pairs which conform to
  # the Rack specification for response headers. The key must be a +String+
  # instance and the value can be either a +String+ or +Array+ instance.
  #
  # @return [Response] a new instance of Response
  # @yield [_self]
  # @yieldparam _self [Rack::Response] the object that the method was called on
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def [](key); end

  # @raise [ArgumentError]
  def []=(key, value); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # @return [Boolean]
  def chunked?; end

  def close; end

  # @raise [ArgumentError]
  def delete_header(key); end

  def each(&callback); end

  # @return [Boolean]
  def empty?; end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  def finish(&block); end

  # @raise [ArgumentError]
  def get_header(key); end

  # @raise [ArgumentError]
  # @return [Boolean]
  def has_header?(key); end

  # Deprecated, use headers instead.
  def header; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute length.
  def length; end

  # Sets the attribute length
  #
  # @param value the value to set the attribute length to.
  def length=(_arg0); end

  # @return [Boolean]
  def no_entity_body?; end

  def redirect(target, status = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def set_header(key, value); end

  # Returns the value of attribute status.
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  def status=(_arg0); end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  # For *response
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  def to_a(&block); end

  # Append to body and update content-length.
  #
  # NOTE: Do not mix #write and direct #body access!
  def write(chunk); end

  class << self
    def [](status, headers, body); end
  end
end

Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

module Rack::Response::Helpers
  # @return [Boolean]
  def accepted?; end

  # Add a header that may have multiple values.
  #
  # Example:
  #   response.add_header 'vary', 'accept-encoding'
  #   response.add_header 'vary', 'cookie'
  #
  #   assert_equal 'accept-encoding,cookie', response.get_header('vary')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  #
  # @raise [ArgumentError]
  def add_header(key, value); end

  # @return [Boolean]
  def bad_request?; end

  # Specify that the content should be cached.
  #
  # @option directive
  # @param duration [Integer] The number of seconds until the cache expires.
  # @param directive [Hash] a customizable set of options
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control; end
  def cache_control=(value); end

  # @return [Boolean]
  def client_error?; end

  def content_length; end

  # Get the content type of the response.
  def content_type; end

  # Set the content type of the response.
  def content_type=(content_type); end

  # @return [Boolean]
  def created?; end

  def delete_cookie(key, value = T.unsafe(nil)); end

  # Specifies that the content shouldn't be cached. Overrides `cache!` if already called.
  def do_not_cache!; end

  def etag; end
  def etag=(value); end

  # @return [Boolean]
  def forbidden?; end

  # @return [Boolean]
  def include?(header); end

  # @return [Boolean]
  def informational?; end

  # @return [Boolean]
  def invalid?; end

  def location; end
  def location=(location); end
  def media_type; end
  def media_type_params; end

  # @return [Boolean]
  def method_not_allowed?; end

  # @return [Boolean]
  def moved_permanently?; end

  # @return [Boolean]
  def no_content?; end

  # @return [Boolean]
  def not_acceptable?; end

  # @return [Boolean]
  def not_found?; end

  # @return [Boolean]
  def ok?; end

  # @return [Boolean]
  def precondition_failed?; end

  # @return [Boolean]
  def redirect?; end

  # @return [Boolean]
  def redirection?; end

  # @return [Boolean]
  def request_timeout?; end

  # @return [Boolean]
  def server_error?; end

  def set_cookie(key, value); end
  def set_cookie_header; end
  def set_cookie_header=(value); end

  # @return [Boolean]
  def successful?; end

  # @return [Boolean]
  def unauthorized?; end

  # @return [Boolean]
  def unprocessable?; end

  protected

  def append(chunk); end
  def buffered_body!; end
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # @return [Raw] a new instance of Raw
  def initialize(status, headers); end

  def delete_header(key); end
  def get_header(key); end

  # @return [Boolean]
  def has_header?(key); end

  # Returns the value of attribute headers.
  def headers; end

  def set_header(key, value); end

  # Returns the value of attribute status.
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  def status=(_arg0); end
end

Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# Class which can make any IO object rewindable, including non-rewindable ones. It does
# this by buffering the data into a tempfile, which is rewindable.
#
# Don't forget to call #close when you're done. This frees up temporary resources that
# RewindableInput uses, though it does *not* close the original IO object.
class Rack::RewindableInput
  # @return [RewindableInput] a new instance of RewindableInput
  def initialize(io); end

  # Closes this RewindableInput object without closing the originally
  # wrapped IO object. Cleans up any temporary resources that this RewindableInput
  # has created.
  #
  # This method may be called multiple times. It does nothing on subsequent calls.
  def close; end

  def each(&block); end
  def gets; end
  def read(*args); end
  def rewind; end
  def size; end

  private

  # @return [Boolean]
  def filesystem_has_posix_semantics?; end

  def make_rewindable; end
end

# Makes rack.input rewindable, for compatibility with applications and middleware
# designed for earlier versions of Rack (where rack.input was required to be
# rewindable).
class Rack::RewindableInput::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(app); end

  def call(env); end
end

# Sets an "x-runtime" response header, indicating the response
# time of the request, in seconds
#
# You can put it right before the application to see the processing
# time, or before all the other middlewares to include time for them,
# too.
class Rack::Runtime
  # @return [Runtime] a new instance of Runtime
  def initialize(app, name = T.unsafe(nil)); end

  def call(env); end
end

Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

# = Sendfile
#
# The Sendfile middleware intercepts responses whose body is being
# served from a file and replaces it with a server specific x-sendfile
# header. The web server is then responsible for writing the file contents
# to the client. This can dramatically reduce the amount of work required
# by the Ruby backend and takes advantage of the web server's optimized file
# delivery code.
#
# In order to take advantage of this middleware, the response body must
# respond to +to_path+ and the request must include an x-sendfile-type
# header. Rack::Files and other components implement +to_path+ so there's
# rarely anything you need to do in your application. The x-sendfile-type
# header is typically set in your web servers configuration. The following
# sections attempt to document
#
# === Nginx
#
# Nginx supports the x-accel-redirect header. This is similar to x-sendfile
# but requires parts of the filesystem to be mapped into a private URL
# hierarchy.
#
# The following example shows the Nginx configuration required to create
# a private "/files/" area, enable x-accel-redirect, and pass the special
# x-sendfile-type and x-accel-mapping headers to the backend:
#
#   location ~ /files/(.*) {
#     internal;
#     alias /var/www/$1;
#   }
#
#   location / {
#     proxy_redirect     off;
#
#     proxy_set_header   Host                $host;
#     proxy_set_header   X-Real-IP           $remote_addr;
#     proxy_set_header   X-Forwarded-For     $proxy_add_x_forwarded_for;
#
#     proxy_set_header   x-sendfile-type     x-accel-redirect;
#     proxy_set_header   x-accel-mapping     /var/www/=/files/;
#
#     proxy_pass         http://127.0.0.1:8080/;
#   }
#
# Note that the x-sendfile-type header must be set exactly as shown above.
# The x-accel-mapping header should specify the location on the file system,
# followed by an equals sign (=), followed name of the private URL pattern
# that it maps to. The middleware performs a simple substitution on the
# resulting path.
#
# See Also: https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile
#
# === lighttpd
#
# Lighttpd has supported some variation of the x-sendfile header for some
# time, although only recent version support x-sendfile in a reverse proxy
# configuration.
#
#   $HTTP["host"] == "example.com" {
#      proxy-core.protocol = "http"
#      proxy-core.balancer = "round-robin"
#      proxy-core.backends = (
#        "127.0.0.1:8000",
#        "127.0.0.1:8001",
#        ...
#      )
#
#      proxy-core.allow-x-sendfile = "enable"
#      proxy-core.rewrite-request = (
#        "x-sendfile-type" => (".*" => "x-sendfile")
#      )
#    }
#
# See Also: http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModProxyCore
#
# === Apache
#
# x-sendfile is supported under Apache 2.x using a separate module:
#
# https://tn123.org/mod_xsendfile/
#
# Once the module is compiled and installed, you can enable it using
# XSendFile config directive:
#
#   RequestHeader Set x-sendfile-type x-sendfile
#   ProxyPassReverse / http://localhost:8001/
#   XSendFile on
#
# === Mapping parameter
#
# The third parameter allows for an overriding extension of the
# x-accel-mapping header. Mappings should be provided in tuples of internal to
# external. The internal values may contain regular expression syntax, they
# will be matched with case indifference.
class Rack::Sendfile
  # @return [Sendfile] a new instance of Sendfile
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  def call(env); end

  private

  def map_accel_path(env, path); end
  def variation(env); end
end

# Rack::ShowExceptions catches all exceptions raised from the app it
# wraps.  It shows a useful backtrace with the sourcefile and
# clickable context, the whole Rack environment and the request
# data.
#
# Be careful when you use this on public-facing sites as it could
# reveal information helpful to attackers.
class Rack::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  def initialize(app); end

  def call(env); end
  def dump_exception(exception); end
  def h(obj); end

  # @return [Boolean]
  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  def template; end

  private

  # @return [Boolean]
  def accepts_html?(env); end
end

Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# Rack::ShowStatus catches all empty responses and replaces them
# with a site explaining the error.
#
# Additional details can be put into <tt>rack.showstatus.detail</tt>
# and will be shown as HTML.  If such details exist, the error page
# is always rendered, even if the reply was not empty.
class Rack::ShowStatus
  # @return [ShowStatus] a new instance of ShowStatus
  def initialize(app); end

  def call(env); end
  def h(obj); end
end

Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

# The Rack::Static middleware intercepts requests for static files
# (javascript files, images, stylesheets, etc) based on the url prefixes or
# route mappings passed in the options, and serves them using a Rack::Files
# object. This allows a Rack stack to serve both static and dynamic content.
#
# Examples:
#
# Serve all requests beginning with /media from the "media" folder located
# in the current directory (ie media/*):
#
#     use Rack::Static, :urls => ["/media"]
#
# Same as previous, but instead of returning 404 for missing files under
# /media, call the next middleware:
#
#     use Rack::Static, :urls => ["/media"], :cascade => true
#
# Serve all requests beginning with /css or /images from the folder "public"
# in the current directory (ie public/css/* and public/images/*):
#
#     use Rack::Static, :urls => ["/css", "/images"], :root => "public"
#
# Serve all requests to / with "index.html" from the folder "public" in the
# current directory (ie public/index.html):
#
#     use Rack::Static, :urls => {"/" => 'index.html'}, :root => 'public'
#
# Serve all requests normally from the folder "public" in the current
# directory but uses index.html as default route for "/"
#
#     use Rack::Static, :urls => [""], :root => 'public', :index =>
#     'index.html'
#
# Set custom HTTP Headers for based on rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           [rule, {header_field => content, header_field => content}],
#           [rule, {header_field => content}]
#         ]
#
#  Rules for selecting files:
#
#  1) All files
#     Provide the :all symbol
#     :all => Matches every file
#
#  2) Folders
#     Provide the folder path as a string
#     '/folder' or '/folder/subfolder' => Matches files in a certain folder
#
#  3) File Extensions
#     Provide the file extensions as an array
#     ['css', 'js'] or %w(css js) => Matches files ending in .css or .js
#
#  4) Regular Expressions / Regexp
#     Provide a regular expression
#     %r{\.(?:css|js)\z} => Matches files ending in .css or .js
#     /\.(?:eot|ttf|otf|woff2|woff|svg)\z/ => Matches files ending in
#       the most common web font formats (.eot, .ttf, .otf, .woff2, .woff, .svg)
#       Note: This Regexp is available as a shortcut, using the :fonts rule
#
#  5) Font Shortcut
#     Provide the :fonts symbol
#     :fonts => Uses the Regexp rule stated right above to match all common web font endings
#
#  Rule Ordering:
#    Rules are applied in the order that they are provided.
#    List rather general rules above special ones.
#
#  Complete example use case including HTTP header rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           # Cache all static files in public caches (e.g. Rack::Cache)
#           #  as well as in the browser
#           [:all, {'cache-control' => 'public, max-age=31536000'}],
#
#           # Provide web fonts with cross-origin access-control-headers
#           #  Firefox requires this when serving assets using a Content Delivery Network
#           [:fonts, {'access-control-allow-origin' => '*'}]
#         ]
class Rack::Static
  # @return [Static] a new instance of Static
  def initialize(app, options = T.unsafe(nil)); end

  # @return [Boolean]
  def add_index_root?(path); end

  # Convert HTTP header rules to HTTP headers
  def applicable_rules(path); end

  def call(env); end
  def can_serve(path); end
  def overwrite_file_path(path); end
  def route_file(path); end
end

Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# Middleware tracks and cleans Tempfiles created throughout a request (i.e. Rack::Multipart)
# Ideas/strategy based on posts by Eric Wong and Charles Oliver Nutter
# https://groups.google.com/forum/#!searchin/rack-devel/temp/rack-devel/brK8eh-MByw/sw61oJJCGRMJ
class Rack::TempfileReaper
  # @return [TempfileReaper] a new instance of TempfileReaper
  def initialize(app); end

  def call(env); end
end

Rack::UNLINK = T.let(T.unsafe(nil), String)

# Rack::URLMap takes a hash mapping urls or paths to apps, and
# dispatches accordingly.  Support for HTTP/1.1 host names exists if
# the URLs start with <tt>http://</tt> or <tt>https://</tt>.
#
# URLMap modifies the SCRIPT_NAME and PATH_INFO such that the part
# relevant for dispatch is in the SCRIPT_NAME, and the rest in the
# PATH_INFO.  This should be taken care of when you need to
# reconstruct the URL in order to create links.
#
# URLMap dispatches in such a way that the longest paths are tried
# first, since they are most specific.
class Rack::URLMap
  # @return [URLMap] a new instance of URLMap
  def initialize(map = T.unsafe(nil)); end

  def call(env); end
  def remap(map); end

  private

  # @return [Boolean]
  def casecmp?(v1, v2); end
end

# Rack::Utils contains a grab-bag of useful methods for writing web
# applications adopted from all kinds of Ruby libraries.
module Rack::Utils
  private

  def add_cookie_to_header(header, key, value); end
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # Return best accept value to use, based on the algorithm
  # in RFC 2616 Section 14.  If there are multiple best
  # matches (same specificity and quality), the value returned
  # is arbitrary.
  def best_q_match(q_value_header, available_mimes); end

  def build_nested_query(value, prefix = T.unsafe(nil)); end
  def build_query(params); end

  # Parses the "Range:" header, if present, into an array of Range objects.
  # Returns nil if the header is missing or syntactically invalid.
  # Returns an empty array if none of the ranges are satisfiable.
  def byte_ranges(env, size); end

  def clean_path_info(path_info); end

  # :nocov:
  def clock_time; end

  def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

  # :call-seq:
  #   delete_set_cookie_header(key, value = {}) -> encoded string
  #
  # Generate an encoded string based on the given +key+ and +value+ using
  # set_cookie_header for the purpose of causing the specified cookie to be
  # deleted. The +value+ may be an instance of +Hash+ and can include
  # attributes as outlined by set_cookie_header. The encoded cookie will have
  # a +max_age+ of 0 seconds, an +expires+ date in the past and an empty
  # +value+. When used with the +set-cookie+ header, it will cause the client
  # to *remove* any matching cookie.
  #
  #   delete_set_cookie_header("myname")
  #   # => "myname=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
  def delete_set_cookie_header(key, value = T.unsafe(nil)); end

  # :call-seq:
  #   delete_set_cookie_header!(header, key, value = {}) -> header value
  #
  # Set an expired cookie in the specified headers with the given cookie
  # +key+ and +value+ using delete_set_cookie_header. This causes
  # the client to immediately delete the specified cookie.
  #
  #   delete_set_cookie_header!(nil, "mycookie")
  #   # => "mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
  #
  # If the header is non-nil, it will be modified in place.
  #
  #   header = []
  #   delete_set_cookie_header!(header, "mycookie")
  #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
  #   header
  #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
  def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

  # URI escapes. (CGI style space to +)
  def escape(s); end

  # Escape ampersands, brackets and quotes to their HTML/XML entities.
  def escape_html(string); end

  # Like URI escaping, but with %20 instead of +. Strictly speaking this is
  # true URI escaping.
  def escape_path(s); end

  def forwarded_values(forwarded_header); end
  def get_byte_ranges(http_range, size); end
  def make_delete_cookie_header(header, key, value); end

  # :call-seq:
  #   parse_cookies(env) -> hash
  #
  # Parse cookies from the provided request environment using
  # parse_cookies_header. Returns a map of cookie +key+ to cookie +value+.
  #
  #   parse_cookies({'HTTP_COOKIE' => 'myname=myvalue'})
  #   # => {'myname' => 'myvalue'}
  def parse_cookies(env); end

  # :call-seq:
  #   parse_cookies_header(value) -> hash
  #
  # Parse cookies from the provided header +value+ according to RFC6265. The
  # syntax for cookie headers only supports semicolons. Returns a map of
  # cookie +key+ to cookie +value+.
  #
  #   parse_cookies_header('myname=myvalue; max-age=0')
  #   # => {"myname"=>"myvalue", "max-age"=>"0"}
  def parse_cookies_header(value); end

  def parse_nested_query(qs, d = T.unsafe(nil)); end
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end
  def q_values(q_value_header); end
  def rfc2822(time); end

  # :nocov:
  def secure_compare(a, b); end

  def select_best_encoding(available_encodings, accept_encoding); end

  # :call-seq:
  #   set_cookie_header(key, value) -> encoded string
  #
  # Generate an encoded string using the provided +key+ and +value+ suitable
  # for the +set-cookie+ header according to RFC6265. The +value+ may be an
  # instance of either +String+ or +Hash+.
  #
  # If the cookie +value+ is an instance of +Hash+, it considers the following
  # cookie attribute keys: +domain+, +max_age+, +expires+ (must be instance
  # of +Time+), +secure+, +http_only+, +same_site+ and +value+. For more
  # details about the interpretation of these fields, consult
  # [RFC6265 Section 5.2](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2).
  #
  # An extra cookie attribute +escape_key+ can be provided to control whether
  # or not the cookie key is URL encoded. If explicitly set to +false+, the
  # cookie key name will not be url encoded (escaped). The default is +true+.
  #
  #   set_cookie_header("myname", "myvalue")
  #   # => "myname=myvalue"
  #
  #   set_cookie_header("myname", {value: "myvalue", max_age: 10})
  #   # => "myname=myvalue; max-age=10"
  def set_cookie_header(key, value); end

  # :call-seq:
  #   set_cookie_header!(headers, key, value) -> header value
  #
  # Append a cookie in the specified headers with the given cookie +key+ and
  # +value+ using set_cookie_header.
  #
  # If the headers already contains a +set-cookie+ key, it will be converted
  # to an +Array+ if not already, and appended to.
  def set_cookie_header!(headers, key, value); end

  def status_code(status); end

  # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
  # target encoding of the string returned, and it defaults to UTF-8
  def unescape(s, encoding = T.unsafe(nil)); end

  # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
  # unescaping query parameters or form components.
  def unescape_path(s); end

  def valid_path?(path); end

  class << self
    def add_cookie_to_header(header, key, value); end
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # Return best accept value to use, based on the algorithm
    # in RFC 2616 Section 14.  If there are multiple best
    # matches (same specificity and quality), the value returned
    # is arbitrary.
    def best_q_match(q_value_header, available_mimes); end

    def build_nested_query(value, prefix = T.unsafe(nil)); end
    def build_query(params); end

    # Parses the "Range:" header, if present, into an array of Range objects.
    # Returns nil if the header is missing or syntactically invalid.
    # Returns an empty array if none of the ranges are satisfiable.
    def byte_ranges(env, size); end

    def clean_path_info(path_info); end
    def clock_time; end

    # Returns the value of attribute default_query_parser.
    def default_query_parser; end

    # Sets the attribute default_query_parser
    #
    # @param value the value to set the attribute default_query_parser to.
    def default_query_parser=(_arg0); end

    def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

    # :call-seq:
    #   delete_set_cookie_header(key, value = {}) -> encoded string
    #
    # Generate an encoded string based on the given +key+ and +value+ using
    # set_cookie_header for the purpose of causing the specified cookie to be
    # deleted. The +value+ may be an instance of +Hash+ and can include
    # attributes as outlined by set_cookie_header. The encoded cookie will have
    # a +max_age+ of 0 seconds, an +expires+ date in the past and an empty
    # +value+. When used with the +set-cookie+ header, it will cause the client
    # to *remove* any matching cookie.
    #
    #   delete_set_cookie_header("myname")
    #   # => "myname=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
    def delete_set_cookie_header(key, value = T.unsafe(nil)); end

    # :call-seq:
    #   delete_set_cookie_header!(header, key, value = {}) -> header value
    #
    # Set an expired cookie in the specified headers with the given cookie
    # +key+ and +value+ using delete_set_cookie_header. This causes
    # the client to immediately delete the specified cookie.
    #
    #   delete_set_cookie_header!(nil, "mycookie")
    #   # => "mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
    #
    # If the header is non-nil, it will be modified in place.
    #
    #   header = []
    #   delete_set_cookie_header!(header, "mycookie")
    #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
    #   header
    #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
    def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

    # URI escapes. (CGI style space to +)
    def escape(s); end

    # Escape ampersands, brackets and quotes to their HTML/XML entities.
    def escape_html(string); end

    # Like URI escaping, but with %20 instead of +. Strictly speaking this is
    # true URI escaping.
    def escape_path(s); end

    def forwarded_values(forwarded_header); end
    def get_byte_ranges(http_range, size); end
    def key_space_limit; end
    def key_space_limit=(v); end
    def make_delete_cookie_header(header, key, value); end

    # Returns the value of attribute multipart_file_limit.
    def multipart_file_limit; end

    # Sets the attribute multipart_file_limit
    #
    # @param value the value to set the attribute multipart_file_limit to.
    def multipart_file_limit=(_arg0); end

    # Returns the value of attribute multipart_file_limit.
    # multipart_part_limit is the original name of multipart_file_limit, but
    # the limit only counts parts with filenames.
    def multipart_part_limit; end

    # Sets the attribute multipart_file_limit
    #
    # @param value the value to set the attribute multipart_file_limit to.
    def multipart_part_limit=(_arg0); end

    # Returns the value of attribute multipart_total_part_limit.
    def multipart_total_part_limit; end

    # Sets the attribute multipart_total_part_limit
    #
    # @param value the value to set the attribute multipart_total_part_limit to.
    def multipart_total_part_limit=(_arg0); end

    def param_depth_limit; end
    def param_depth_limit=(v); end

    # :call-seq:
    #   parse_cookies(env) -> hash
    #
    # Parse cookies from the provided request environment using
    # parse_cookies_header. Returns a map of cookie +key+ to cookie +value+.
    #
    #   parse_cookies({'HTTP_COOKIE' => 'myname=myvalue'})
    #   # => {'myname' => 'myvalue'}
    def parse_cookies(env); end

    # :call-seq:
    #   parse_cookies_header(value) -> hash
    #
    # Parse cookies from the provided header +value+ according to RFC6265. The
    # syntax for cookie headers only supports semicolons. Returns a map of
    # cookie +key+ to cookie +value+.
    #
    #   parse_cookies_header('myname=myvalue; max-age=0')
    #   # => {"myname"=>"myvalue", "max-age"=>"0"}
    def parse_cookies_header(value); end

    def parse_nested_query(qs, d = T.unsafe(nil)); end
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end
    def q_values(q_value_header); end
    def rfc2822(time); end
    def secure_compare(a, b); end
    def select_best_encoding(available_encodings, accept_encoding); end

    # :call-seq:
    #   set_cookie_header(key, value) -> encoded string
    #
    # Generate an encoded string using the provided +key+ and +value+ suitable
    # for the +set-cookie+ header according to RFC6265. The +value+ may be an
    # instance of either +String+ or +Hash+.
    #
    # If the cookie +value+ is an instance of +Hash+, it considers the following
    # cookie attribute keys: +domain+, +max_age+, +expires+ (must be instance
    # of +Time+), +secure+, +http_only+, +same_site+ and +value+. For more
    # details about the interpretation of these fields, consult
    # [RFC6265 Section 5.2](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2).
    #
    # An extra cookie attribute +escape_key+ can be provided to control whether
    # or not the cookie key is URL encoded. If explicitly set to +false+, the
    # cookie key name will not be url encoded (escaped). The default is +true+.
    #
    #   set_cookie_header("myname", "myvalue")
    #   # => "myname=myvalue"
    #
    #   set_cookie_header("myname", {value: "myvalue", max_age: 10})
    #   # => "myname=myvalue; max-age=10"
    def set_cookie_header(key, value); end

    # :call-seq:
    #   set_cookie_header!(headers, key, value) -> header value
    #
    # Append a cookie in the specified headers with the given cookie +key+ and
    # +value+ using set_cookie_header.
    #
    # If the headers already contains a +set-cookie+ key, it will be converted
    # to an +Array+ if not already, and appended to.
    def set_cookie_header!(headers, key, value); end

    def status_code(status); end

    # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
    # target encoding of the string returned, and it defaults to UTF-8
    def unescape(s, encoding = T.unsafe(nil)); end

    # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
    # unescaping query parameters or form components.
    def unescape_path(s); end

    # @return [Boolean]
    def valid_path?(path); end
  end
end

Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# Context allows the use of a compatible middleware at different points
# in a request handling stack. A compatible middleware must define
# #context which should take the arguments env and app. The first of which
# would be the request environment. The second of which would be the rack
# application that the request would be forwarded to.
class Rack::Utils::Context
  # @return [Context] a new instance of Context
  def initialize(app_f, app_r); end

  # Returns the value of attribute app.
  def app; end

  def call(env); end
  def context(env, app = T.unsafe(nil)); end

  # Returns the value of attribute for.
  def for; end

  def recontext(app); end
end

Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
#   curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#     ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#               puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

# A wrapper around Headers
# header when set.
#
# @api private
class Rack::Utils::HeaderHash < ::Hash
  class << self
    # @api private
    def [](headers); end

    # @api private
    # @raise [TypeError]
    def allocate; end

    # @api private
    def new(hash = T.unsafe(nil)); end
  end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError
Rack::Utils::ParamsTooDeepError = Rack::QueryParser::ParamsTooDeepError

# Responses with HTTP status codes that should not have an entity body
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# The Rack protocol version number implemented.
Rack::VERSION = T.let(T.unsafe(nil), Array)

Rack::VERSION_STRING = T.let(T.unsafe(nil), String)
