# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sxp` gem.
# Please instead update this file by running `bin/tapioca gem sxp`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil), **options); end
end

class BigDecimal < ::Numeric
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat

  def to_sxp(**options); end
end

BigDecimal::EXCEPTION_NaN = T.let(T.unsafe(nil), Integer)
BigDecimal::VERSION = T.let(T.unsafe(nil), String)

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils
  include ::SafeType::BooleanMixin
end

class Float < ::Numeric
  include ::ActiveSupport::NumericWithFormat
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::MessagePack::CoreExt

  def to_sxp(**options); end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_sxp(**options); end
end

class Integer < ::Numeric
  include ::ActiveSupport::NumericWithFormat
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::MessagePack::CoreExt

  def to_sxp(**options); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils
end

class Object < ::BasicObject
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::Kernel
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::ActiveSupport::Dependencies::Loadable
  include ::FriendlyId::ObjectUtils
  include ::PP::ObjectMixin
  include ::MakeMakefile

  def to_sxp(**options); end
end

class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype2?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(_arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = T.unsafe(nil)); end
  def inspect; end
  def language; end
  def language=(_arg0); end
  def language?; end
  def literal?; end
  def object; end
  def plain?; end
  def simple?; end
  def squish(*other_string); end
  def squish!; end
  def to_s; end
  def to_sxp(**options); end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end

  protected

  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def datatype_map; end
    def datatyped_class(uri); end
    def inherited(child); end
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

class RDF::Literal::Double < ::RDF::Literal::Numeric
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def abs; end
  def canonicalize!; end
  def ceil; end
  def finite?; end
  def floor; end
  def infinite?; end
  def nan?; end
  def nonzero?; end
  def round; end
  def to_s; end
  def to_sxp(**options); end
  def zero?; end
end

RDF::Literal::Double::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Double::GRAMMAR = T.let(T.unsafe(nil), Regexp)
RDF::Literal::FALSE = T.let(T.unsafe(nil), RDF::Literal::Boolean)
RDF::Literal::TRUE = T.let(T.unsafe(nil), RDF::Literal::Boolean)
RDF::Literal::ZERO = T.let(T.unsafe(nil), RDF::Literal::Integer)

class RDF::Node
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(id = T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def anonymous?; end
  def dup; end
  def eql?(other); end
  def hash; end
  def id; end
  def id=(_arg0); end
  def labeled?; end
  def make_unique!; end
  def node?; end
  def original; end
  def original=(_arg0); end
  def to_s; end
  def to_sxp(**options); end
  def to_sym; end
  def to_unique_base; end
  def unlabeled?; end

  class << self
    def cache; end
    def intern(id); end
    def uuid(format: T.unsafe(nil)); end
  end
end

class RDF::Query
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable

  def initialize(*patterns, solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def +(other); end
  def <<(pattern); end
  def ==(other); end
  def apply_graph_name(graph_name = T.unsafe(nil)); end
  def bind(solution); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def executable?; end
  def execute(queryable, bindings: T.unsafe(nil), solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_variables?(*args); end
  def matched?; end
  def named?; end
  def ndvars; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def optimize_without_expression!(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def rewrite(&block); end
  def solutions; end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), **options); end
  def to_sxp(**options); end
  def to_sxp_bin; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?(*args); end
  def variable_count; end
  def variables; end
  def variables?(*args); end
  def vars; end

  protected

  def compile_hash_patterns(hash_patterns); end

  class << self
    def Solutions(*args); end
    def execute(queryable, patterns = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class RDF::Query::Pattern < ::RDF::Statement
  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(_arg0); end
  def dup; end
  def eql?(other); end
  def executable?; end
  def execute(queryable, bindings = T.unsafe(nil), &block); end
  def has_variables?; end
  def initialize!; end
  def ndvars; end
  def optional?; end
  def options; end
  def solution(statement); end
  def to_s; end
  def to_sxp(**options); end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def var_values(var, statement); end
  def variable_count; end
  def variable_terms(name = T.unsafe(nil)); end
  def variables; end
  def variables?; end
  def vars; end

  class << self
    def from(pattern, graph_name: T.unsafe(nil), **options); end
  end
end

class RDF::Query::Variable
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(name = T.unsafe(nil), value = T.unsafe(nil), distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def bind(value); end
  def bind!(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def name; end
  def name=(_arg0); end
  def named?; end
  def optimize(**options); end
  def to_base; end
  def to_h; end
  def to_s; end
  def to_sparql(**options); end
  def to_sxp(**options); end
  def to_sym; end
  def unbind; end
  def unbind!; end
  def unbound?; end
  def value; end
  def value=(_arg0); end
  def var_values(var, term); end
  def variable?(*args); end
  def variables; end
end

class RDF::URI
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term
  include ::RDF::Resource

  def initialize(*args, validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def +(other); end
  def /(fragment); end
  def ==(other); end
  def ===(other); end
  def =~(pattern); end
  def _dump(level); end
  def absolute?; end
  def authority; end
  def authority=(value); end
  def canonicalize; end
  def canonicalize!; end
  def dup; end
  def end_with?(string); end
  def ends_with?(string); end
  def eql?(other); end
  def fragment; end
  def fragment=(value); end
  def freeze; end
  def has_parent?; end
  def hash; end
  def hier?; end
  def host; end
  def host=(value); end
  def inspect; end
  def join(*uris); end
  def length; end
  def lexical; end
  def lexical=(value); end
  def normalize; end
  def normalize!; end
  def normalized_authority; end
  def normalized_fragment; end
  def normalized_host; end
  def normalized_password; end
  def normalized_path; end
  def normalized_port; end
  def normalized_query; end
  def normalized_scheme; end
  def normalized_user; end
  def normalized_userinfo; end
  def object; end
  def parent; end
  def parent?; end
  def parse(value); end
  def password; end
  def password=(value); end
  def path; end
  def path=(value); end
  def pname(prefixes: T.unsafe(nil)); end
  def port; end
  def port=(value); end
  def qname(prefixes: T.unsafe(nil)); end
  def query; end
  def query=(value); end
  def query_values(return_type = T.unsafe(nil)); end
  def query_values=(value); end
  def relative?; end
  def relativize(base_uri); end
  def request_uri; end
  def root; end
  def root?; end
  def scheme; end
  def scheme=(value); end
  def size; end
  def to_h; end
  def to_s; end
  def to_str; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil), **options); end
  def to_uri; end
  def uri?; end
  def url?; end
  def urn?; end
  def user; end
  def user=(value); end
  def userinfo; end
  def userinfo=(value); end
  def valid?; end
  def validate!; end
  def value; end

  private

  def format_authority; end
  def format_userinfo(append = T.unsafe(nil)); end
  def normalize_segment(value, expr, downcase = T.unsafe(nil)); end

  class << self
    def _load(data); end
    def cache; end
    def decode(str); end
    def encode(str, expr); end
    def intern(str, *args, **options); end
    def normalize_path(path); end
    def parse(str); end
  end
end

RDF::URI::GEN_DELIMS = T.let(T.unsafe(nil), Regexp)
RDF::URI::HOST_FROM_AUTHORITY_RE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IAUTHORITY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IFRAGMENT = T.let(T.unsafe(nil), Regexp)
RDF::URI::IHIER_PART = T.let(T.unsafe(nil), Regexp)
RDF::URI::IHOST = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ABEMPTY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ABSOLUTE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_EMPTY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_NOSCHEME = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPATH_ROOTLESS = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPCHAR = T.let(T.unsafe(nil), Regexp)
RDF::URI::IPRIVATE = T.let(T.unsafe(nil), Regexp)
RDF::URI::IP_literal = T.let(T.unsafe(nil), Regexp)
RDF::URI::IQUERY = T.let(T.unsafe(nil), Regexp)
RDF::URI::IREG_NAME = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRELATIVE_PART = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRELATIVE_REF = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRI = T.let(T.unsafe(nil), Regexp)
RDF::URI::IRI_PARTS = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT_NZ = T.let(T.unsafe(nil), Regexp)
RDF::URI::ISEGMENT_NZ_NC = T.let(T.unsafe(nil), Regexp)
RDF::URI::IUNRESERVED = T.let(T.unsafe(nil), Regexp)
RDF::URI::IUSERINFO = T.let(T.unsafe(nil), Regexp)
RDF::URI::NON_HIER_SCHEMES = T.let(T.unsafe(nil), Array)
RDF::URI::PCT_ENCODED = T.let(T.unsafe(nil), Regexp)
RDF::URI::PN_ESCAPES = T.let(T.unsafe(nil), Regexp)
RDF::URI::PN_ESCAPE_CHARS = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT_FROM_AUTHORITY_RE = T.let(T.unsafe(nil), Regexp)
RDF::URI::PORT_MAPPING = T.let(T.unsafe(nil), Hash)
RDF::URI::RDS_2A = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2B1 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2B2 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2C1 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2C2 = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2D = T.let(T.unsafe(nil), Regexp)
RDF::URI::RDS_2E = T.let(T.unsafe(nil), Regexp)
RDF::URI::RESERVED = T.let(T.unsafe(nil), Regexp)
RDF::URI::SCHEME = T.let(T.unsafe(nil), Regexp)
RDF::URI::SUB_DELIMS = T.let(T.unsafe(nil), Regexp)
RDF::URI::UCSCHAR = T.let(T.unsafe(nil), Regexp)
RDF::URI::UNRESERVED = T.let(T.unsafe(nil), Regexp)

class Regexp
  def to_sxp(**options); end
end

Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)

class Regexp::Token < ::Struct
  def conditional_level; end
  def conditional_level=(_); end
  def length; end
  def level; end
  def level=(_); end
  def next; end
  def next=(_arg0); end
  def offset; end
  def previous; end
  def previous=(_arg0); end
  def set_level; end
  def set_level=(_); end
  def te; end
  def te=(_); end
  def text; end
  def text=(_); end
  def token; end
  def token=(_); end
  def ts; end
  def ts=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module SXP
  class << self
    def parse(input, **options); end
    def parse_all(input, **options); end
    def parse_file(filename, **options); end
    def parse_files(*filenames); end
    def parse_uri(url, **options); end
    def parse_url(url, **options); end
    def read(input, **options); end
    def read_all(input, **options); end
    def read_file(filename, **options); end
    def read_files(*filenames); end
    def read_uri(url, **options); end
    def read_url(url, **options); end
    def write(sxp, output = T.unsafe(nil)); end
  end
end

class SXP::Generator
  def initialize(buffer); end

  def render(sexp); end

  class << self
    def print(*sxps); end
    def string(*sxps); end
    def write(out, *sxps); end
  end
end

class SXP::Generator::Block
  def initialize(obj, indent, prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end

  def formatted; end
  def indent; end
  def length; end
  def sxp?; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end

  private

  def do_indent(offset = T.unsafe(nil)); end
end

SXP::Generator::Block::BLOCK_MIN_LENGTH = T.let(T.unsafe(nil), Integer)

class SXP::List < ::SXP::Pair
  include ::Enumerable

  def initialize(elements = T.unsafe(nil), &block); end

  def &(other); end
  def *(times); end
  def +(other); end
  def -(other); end
  def <<(object); end
  def <=>(other); end
  def ==(other); end
  def [](*args); end
  def []=(*args); end
  def assoc(object); end
  def at(index); end
  def clear; end
  def collect!(&block); end
  def compact; end
  def compact!; end
  def concat(other); end
  def delete(object, &block); end
  def delete_at(index); end
  def delete_if(&block); end
  def each(&block); end
  def each_index(&block); end
  def empty?; end
  def eql?(other); end
  def fetch(*args, &block); end
  def fill(*args, &block); end
  def first(count = T.unsafe(nil)); end
  def flatten; end
  def flatten!; end
  def head; end
  def include?(object); end
  def index(object); end
  def insert(index, *objects); end
  def inspect; end
  def join(separator = T.unsafe(nil)); end
  def last(count = T.unsafe(nil)); end
  def length; end
  def map!(&block); end
  def nitems; end
  def pack(template); end
  def pop; end
  def push(*objects); end
  def rassoc(key); end
  def reject!(&block); end
  def replace(other_list); end
  def rest; end
  def reverse; end
  def reverse!; end
  def reverse_each(&block); end
  def rindex(object); end
  def shift; end
  def size; end
  def slice(*args); end
  def slice!(*args); end
  def sort(&block); end
  def sort!; end
  def tail; end
  def to_list; end
  def to_pair; end
  def to_s; end
  def transpose; end
  def uniq; end
  def uniq!; end
  def unshift(*objects); end
  def values_at(*selector); end
  def |(other); end

  class << self
    def [](*elements); end
  end
end

class SXP::Pair
  def initialize(head = T.unsafe(nil), tail = T.unsafe(nil)); end

  def dotted?; end
  def empty?; end
  def head; end
  def head=(_arg0); end
  def inspect; end
  def proper?; end
  def tail; end
  def tail=(_arg0); end
  def to_a; end
end

class SXP::Reader
  include ::Enumerable

  def initialize(input, **options, &block); end

  def each(&block); end
  def input; end
  def options; end
  def read(eof: T.unsafe(nil), eol: T.unsafe(nil), list_term: T.unsafe(nil), **options); end
  def read_all(**options); end
  def read_atom; end
  def read_character; end
  def read_files(*filenames); end
  def read_integer(base = T.unsafe(nil)); end
  def read_list(list_term = T.unsafe(nil)); end
  def read_literal; end
  def read_sharp; end
  def read_string; end
  def read_token; end
  def skip(eof: T.unsafe(nil), eol: T.unsafe(nil), list_term: T.unsafe(nil), **options); end

  protected

  def eof?; end
  def peek_char; end
  def read_char; end
  def read_chars(count = T.unsafe(nil)); end
  def skip_char; end
  def skip_comments; end
  def skip_line; end
  def unread(string); end

  class << self
    def read(input, **options); end
    def read_all(input, **options); end
    def read_file(filename, **options); end
    def read_url(url, **options); end
  end
end

class SXP::Reader::Basic < ::SXP::Reader
  def read_atom; end
  def read_character; end
  def read_literal; end
  def read_string; end
  def read_token; end
end

SXP::Reader::Basic::ATOM = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::INTEGER = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::LPARENS = T.let(T.unsafe(nil), Array)
SXP::Reader::Basic::RATIONAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::RPARENS = T.let(T.unsafe(nil), Array)

class SXP::Reader::CommonLisp < ::SXP::Reader::Basic
  def initialize(input, **options, &block); end

  def read_character; end
  def read_function; end
  def read_quote; end
  def read_sharp; end
  def read_symbol(delimiter = T.unsafe(nil)); end
  def read_token; end
  def read_vector; end
  def skip_comments; end
end

SXP::Reader::CommonLisp::CHARACTERS = T.let(T.unsafe(nil), Hash)
SXP::Reader::CommonLisp::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_10 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_16 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_2 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_8 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::OPTIONS = T.let(T.unsafe(nil), Hash)
SXP::Reader::CommonLisp::RATIONAL = T.let(T.unsafe(nil), Regexp)
class SXP::Reader::EOF < ::SXP::Reader::Error; end
class SXP::Reader::Error < ::StandardError; end

class SXP::Reader::Extended < ::SXP::Reader::Basic
  def read_token; end
  def skip_comments; end
end

SXP::Reader::Extended::ATOM = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Extended::LPARENS = T.let(T.unsafe(nil), Array)
SXP::Reader::Extended::RPARENS = T.let(T.unsafe(nil), Array)

class SXP::Reader::SPARQL < ::SXP::Reader::Extended
  def initialize(input, **options, &block); end

  def base_uri; end
  def base_uri=(_arg0); end
  def prefix(name, uri = T.unsafe(nil)); end
  def prefixes; end
  def prefixes=(_arg0); end
  def read_atom; end
  def read_rdf_literal; end
  def read_rdf_uri; end
  def read_token; end
  def skip_comments; end
  def variable(id, distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end
end

SXP::Reader::SPARQL::A = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::BASE = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::BNODE_ID = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::BNODE_NEW = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::DOUBLE = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::EVAR_ID = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::EXPONENT = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::FALSE = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::ND_EVAR = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::ND_VAR = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::NIL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::PNAME = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::PREFIX = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::RDF_TYPE = T.let(T.unsafe(nil), RDF::URI)
SXP::Reader::SPARQL::TRUE = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::VAR_ID = T.let(T.unsafe(nil), Regexp)

class SXP::Reader::Scheme < ::SXP::Reader::Extended
  def initialize(input, version: T.unsafe(nil), **options, &block); end

  def read_atom; end
  def read_character; end
  def read_sharp; end
  def read_token; end
end

SXP::Reader::Scheme::CHARACTERS = T.let(T.unsafe(nil), Hash)
SXP::Reader::Scheme::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_10 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_16 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_2 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_8 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::RATIONAL = T.let(T.unsafe(nil), Regexp)

module SXP::VERSION
  class << self
    def to_a; end
    def to_s; end
    def to_str; end
  end
end

SXP::VERSION::MAJOR = T.let(T.unsafe(nil), String)
SXP::VERSION::MINOR = T.let(T.unsafe(nil), String)
SXP::VERSION::STRING = T.let(T.unsafe(nil), String)
SXP::VERSION::TINY = T.let(T.unsafe(nil), String)
SXP::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::MessagePack::CoreExt
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def to_sxp(**options); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)

class Symbol
  include ::Comparable
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def keyword?; end
  def to_sxp(**options); end
end

class Time
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility

  def to_sxp(**options); end
end

Time::COMMON_YEAR_DAYS_IN_MONTH = T.let(T.unsafe(nil), Array)
Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils
  include ::SafeType::BooleanMixin
end

class Vector
  include ::ExceptionForMatrix
  include ::Enumerable
  include ::Matrix::CoercionHelper
  extend ::Matrix::ConversionHelper

  def to_sxp(**options); end
end
