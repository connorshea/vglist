# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-rails` gem.
# Please instead update this file by running `bin/tapioca gem rspec-rails`.

# Namespace for all core RSpec projects.
module RSpec
  class << self
    def clear_examples; end
    def configuration; end
    def configuration=(_arg0); end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def current_scope; end
    def current_scope=(scope); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def feature(*args, &example_group_block); end
    def ffeature(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def world; end
    def world=(_arg0); end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
    def xfeature(*args, &example_group_block); end
  end
end

# Namespace for rspec-rails code.
module RSpec::Rails
  class << self
    # Sets up the different example group modules for the different spec types
    #
    # @api private
    def add_test_type_configurations(config); end

    # @private
    def initialize_configuration(config); end

    private

    # @private
    def disable_testunit_autorun; end
  end
end

# Fake class to document RSpec ActiveRecord configuration options. In practice,
# these are dynamically added to the normal RSpec configuration object.
class RSpec::Rails::ActiveRecordConfiguration
  class << self
    # @private
    def initialize_activerecord_configuration(config); end
  end
end

# @private
class RSpec::Rails::AssertionDelegator < ::Module
  # @return [AssertionDelegator] a new instance of AssertionDelegator
  def initialize(*assertion_modules); end
end

# Constant aliased to either Minitest or TestUnit, depending on what is
# loaded.
RSpec::Rails::Assertions = Minitest::Assertions

# Container module for channel spec functionality.
#
# @api public
module RSpec::Rails::ChannelExampleGroup
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Channel::TestCase::Behavior

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::ChannelExampleGroup::ClassMethods

  # Checks that the connection attempt has been rejected.
  #
  # @api public
  # @example
  #   expect { connect }.to have_rejected_connection
  def have_rejected_connection; end

  # Checks that the channel has been subscribed to a stream for the given model
  #
  # @api public
  # @example
  #   expect(subscription).to have_stream_for(user)
  def have_stream_for(object); end

  # Checks that the channel has been subscribed to the given stream
  #
  # @api public
  # @example
  #   expect(subscription).to have_stream_from("chat_1")
  def have_stream_from(stream); end

  # Checks that the subscription is subscribed to at least one stream.
  #
  # @api public
  # @example
  #   expect(subscription).to have_streams
  def have_streams; end

  module GeneratedClassMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Class-level DSL for channel specs.
#
# @api public
module RSpec::Rails::ChannelExampleGroup::ClassMethods
  # @api public
  # @private
  def channel_class; end

  # @api public
  # @private
  def connection_class; end
end

# Fake class to document RSpec Rails configuration options. In practice,
# these are dynamically added to the normal RSpec configuration object.
class RSpec::Rails::Configuration; end

# @private
module RSpec::Rails::ControllerAssertionDelegator
  def assert_generates(*args, &block); end
  def assert_recognizes(*args, &block); end
  def assert_routing(*args, &block); end
  def assertion_instance; end
  def build_assertion_instance; end
  def setup(*args, &block); end
  def with_routing(*args, &block); end
end

# Container module for controller spec functionality.
#
# @api public
module RSpec::Rails::ControllerExampleGroup
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::RSpec::Rails::Matchers::RoutingMatchers
  include ::RSpec::Rails::ControllerAssertionDelegator
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionController::TestCase::Behavior
  include ::RSpec::Rails::ViewRendering

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionController::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::ViewRendering::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::ControllerExampleGroup::ClassMethods

  # Extends the controller with a module that overrides
  # `rescue_with_handler` to raise the exception passed to it. Use this to
  # specify that an action _should_ raise an exception given appropriate
  # conditions.
  #
  # @api public
  # @example
  #   describe ProfilesController do
  #   it "raises a 403 when a non-admin user tries to view another user's profile" do
  #   profile = create_profile
  #   login_as profile.user
  #
  #   expect do
  #   bypass_rescue
  #   get :show, id: profile.id + 1
  #   end.to raise_error(/403 Forbidden/)
  #   end
  #   end
  def bypass_rescue; end

  # Returns the controller object instance under test.
  #
  # @api public
  def controller; end

  # If method is a named_route, delegates to the RouteSet associated with
  # this controller.
  #
  # @api public
  def method_missing(method, *args, **_arg2, &block); end

  # Returns the Rails routes used for the spec.
  #
  # @api public
  def routes; end

  # RSpec Rails uses this to make Rails routes easily available to specs.
  #
  # @api public
  # @private
  def routes=(routes); end

  private

  # @api public
  # @return [Boolean]
  def route_available?(method); end

  # @api public
  # @return [Boolean]
  def route_defined?(routes, method); end

  module GeneratedClassMethods
    def _controller_class; end
    def _controller_class=(value); end
    def _controller_class?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def _controller_class; end
    def _controller_class=(value); end
    def _controller_class?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# @api public
# @private
module RSpec::Rails::ControllerExampleGroup::BypassRescue
  # @api public
  def rescue_with_handler(exception); end
end

# Class-level DSL for controller specs.
#
# @api public
module RSpec::Rails::ControllerExampleGroup::ClassMethods
  # Supports a simple DSL for specifying behavior of ApplicationController.
  # Creates an anonymous subclass of ApplicationController and evals the
  # `body` in that context. Also sets up implicit routes for this
  # controller, that are separate from those defined in "config/routes.rb".
  #
  # If you would like to spec a subclass of ApplicationController, call
  # controller like so:
  #
  #     controller(ApplicationControllerSubclass) do
  #       # ....
  #     end
  #
  # @api public
  # @example
  #   describe ApplicationController do
  #   controller do
  #   def index
  #   raise ApplicationController::AccessDenied
  #   end
  #   end
  #
  #   describe "handling AccessDenied exceptions" do
  #   it "redirects to the /401.html page" do
  #   get :index
  #   response.should redirect_to("/401.html")
  #   end
  #   end
  #   end
  # @note Due to Ruby 1.8 scoping rules in anonymous subclasses, constants
  #   defined in `ApplicationController` must be fully qualified (e.g.
  #   `ApplicationController::AccessDenied`) in the block passed to the
  #   `controller` method. Any instance methods, filters, etc, that are
  #   defined in `ApplicationController`, however, are accessible from
  #   within the block.
  def controller(base_class = T.unsafe(nil), &body); end

  # @api public
  # @private
  def controller_class; end

  # Specifies the routeset that will be used for the example group. This
  # is most useful when testing Rails engines.
  #
  # @api public
  # @example
  #   describe MyEngine::PostsController do
  #   routes { MyEngine::Engine.routes }
  #
  #   # ...
  #   end
  def routes; end
end

# Mappings used by `infer_spec_type_from_file_location!`.
#
# @api private
RSpec::Rails::DIRECTORY_MAPPINGS = T.let(T.unsafe(nil), Hash)

# @private
module RSpec::Rails::FeatureCheck
  private

  def has_action_cable_testing?; end
  def has_action_mailbox?; end
  def has_action_mailer?; end
  def has_action_mailer_legacy_delivery_job?; end
  def has_action_mailer_parameterized?; end
  def has_action_mailer_preview?; end
  def has_action_mailer_unified_delivery?; end
  def has_active_job?; end
  def has_active_record?; end
  def has_active_record_migration?; end
  def type_metatag(type); end

  class << self
    # @return [Boolean]
    def has_action_cable_testing?; end

    # @return [Boolean]
    def has_action_mailbox?; end

    # @return [Boolean]
    def has_action_mailer?; end

    # @return [Boolean]
    def has_action_mailer_legacy_delivery_job?; end

    # @return [Boolean]
    def has_action_mailer_parameterized?; end

    # @return [Boolean]
    def has_action_mailer_preview?; end

    # @return [Boolean]
    def has_action_mailer_unified_delivery?; end

    # @return [Boolean]
    def has_active_job?; end

    # @return [Boolean]
    def has_active_record?; end

    # @return [Boolean]
    def has_active_record_migration?; end

    def type_metatag(type); end
  end
end

# Container module for routing spec functionality.
#
# @api public
module RSpec::Rails::FeatureExampleGroup
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  # Shim to check for presence of Capybara. Will delegate if present, raise
  # if not. We assume here that in most cases `visit` will be the first
  # Capybara method called in a spec.
  #
  # @api public
  def visit(*_arg0); end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Default host to be used in Rails route helpers if none is specified.
#
# @api public
RSpec::Rails::FeatureExampleGroup::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# @private
module RSpec::Rails::FileFixtureSupport
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::FileFixtures

  mixes_in_class_methods GeneratedClassMethods

  module GeneratedClassMethods
    def file_fixture_path; end
    def file_fixture_path=(value); end
    def file_fixture_path?; end
  end

  module GeneratedInstanceMethods
    def file_fixture_path; end
    def file_fixture_path?; end
  end
end

# @private
module RSpec::Rails::FixtureFileUploadSupport
  def fixture_file_upload(*_arg0, **_arg1, &_arg2); end

  private

  # In Rails 7.0 fixture file path needs to be relative to `file_fixture_path` instead, this change
  # was brought in with a deprecation warning on 6.1. In Rails 7.0 expect to rework this to remove
  # the old accessor.
  def rails_fixture_file_wrapper; end
end

class RSpec::Rails::FixtureFileUploadSupport::RailsFixtureFileWrapper
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::TestProcess
  include ::ActiveSupport::Testing::FileFixtures

  def file_fixture_path; end
  def file_fixture_path?; end

  class << self
    def file_fixture_path; end
    def file_fixture_path=(value); end
    def file_fixture_path?; end

    # Returns the value of attribute fixture_path.
    def fixture_path; end

    # Sets the attribute fixture_path
    #
    # @param value the value to set the attribute fixture_path to.
    def fixture_path=(_arg0); end

    # Get instance of wrapper
    def instance; end
  end
end

# @private
module RSpec::Rails::FixtureSupport
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  # Monkey patched to avoid collisions with 'let(:name)' in Rails 6.1 and after
  # and let(:method_name) before Rails 6.1.
  #
  # @private prevent ActiveSupport::TestFixtures to start a DB transaction.
  # @return [Boolean]
  def run_in_transaction?; end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

module RSpec::Rails::FixtureSupport::Fixtures
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
end

module RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  def fixtures(*args); end
  def proxy_method_warning_if_called_in_before_context_scope(method_name); end
end

# Container module for helper specs.
#
# @api public
module RSpec::Rails::HelperExampleGroup
  include ::RSpec::Rails::ViewAssigns
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::UrlHelper::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::SanitizeHelper::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionView::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::HelperExampleGroup::ClassMethods

  # Returns an instance of ActionView::Base with the helper being specified
  # mixed in, along with any of the built-in rails helpers.
  #
  # @api public
  def helper; end

  private

  # @api public
  def _controller_path(example); end

  module GeneratedClassMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# @api public
# @private
module RSpec::Rails::HelperExampleGroup::ClassMethods
  # @api public
  def determine_constant_from_test_name(_ignore); end
end

# Container module for job spec functionality.
module RSpec::Rails::JobExampleGroup
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Container module for mailbox spec functionality.
#
# @api public
module RSpec::Rails::MailboxExampleGroup
  extend ::ActiveSupport::Concern
  extend ::ActionMailbox::TestHelper

  mixes_in_class_methods ::RSpec::Rails::MailboxExampleGroup::ClassMethods

  # Passes if the inbound email was delivered
  #
  # @api public
  # @example
  #   inbound_email = process(args)
  #   expect(inbound_email).to have_been_delivered
  def have_been_delivered; end

  # Passes if the inbound email bounced during processing
  #
  # @api public
  # @example
  #   inbound_email = process(args)
  #   expect(inbound_email).to have_bounced
  def have_bounced; end

  # Passes if the inbound email failed to process
  #
  # @api public
  # @example
  #   inbound_email = process(args)
  #   expect(inbound_email).to have_failed
  def have_failed; end

  # Process an inbound email message directly, bypassing routing.
  #
  # @api public
  # @param message [Hash, Mail::Message] a mail message or hash of
  #   attributes used to build one
  # @return [ActionMaibox::InboundMessage]
  def process(message); end

  class << self
    # @api public
    # @private
    def create_inbound_email(arg); end
  end
end

module RSpec::Rails::MailboxExampleGroup::ClassMethods
  def mailbox_class; end
end

# Container module for mailer spec functionality.
module RSpec::Rails::MailerExampleGroup
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionDispatch::Routing::UrlFor

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionMailer::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MailerExampleGroup::ClassMethods

  module GeneratedClassMethods
    def _mailer_class; end
    def _mailer_class=(value); end
    def _mailer_class?; end
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def _mailer_class; end
    def _mailer_class=(value); end
    def _mailer_class?; end
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Class-level DSL for mailer specs.
module RSpec::Rails::MailerExampleGroup::ClassMethods
  # Alias for `described_class`.
  def mailer_class; end
end

# Container module for Rails specific matchers.
#
# @api public
module RSpec::Rails::Matchers
  # Passes if actual is an instance of `model_class` and returns `true` for
  # `new_record?`. Typically used to specify instance variables assigned to
  # views by controller actions
  #
  # Use the `with` method to specify the specific attributes to match on the
  # new record.
  #
  # @api public
  # @example
  #   get :new
  #   assigns(:thing).should be_a_new(Thing)
  #
  #   post :create, :thing => { :name => "Illegal Value" }
  #   assigns(:thing).should be_a_new(Thing).with(:name => nil)
  def be_a_new(model_class); end

  # Passes if actual returns `true` for `new_record?`.
  #
  # @api public
  # @example
  #   get :new
  #   expect(assigns(:thing)).to be_new_record
  def be_new_record; end

  # Passes if the given model instance's `valid?` method is true, meaning
  # all of the `ActiveModel::Validations` passed and no errors exist. If a
  # message is not given, a default message is shown listing each error.
  #
  # @api public
  # @example
  #   thing = Thing.new
  #   expect(thing).to be_valid
  def be_valid(*args); end

  # Passes if a message has been sent to a stream/object inside a block.
  # May chain `at_least`, `at_most` or `exactly` to specify a number of times.
  # To specify channel from which message has been broadcasted to object use `from_channel`.
  #
  # @api public
  # @example
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages")
  #
  #   expect {
  #   SomeChannel.broadcast_to(user)
  #   }.to have_broadcasted_to(user).from_channel(SomeChannel)
  #
  #   # Using alias
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to broadcast_to("messages")
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   ActionCable.server.broadcast "all", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").exactly(:once)
  #
  #   expect {
  #   3.times { ActionCable.server.broadcast "messages", text: 'Hi!' }
  #   }.to have_broadcasted_to("messages").at_least(2).times
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").at_most(:twice)
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").with(text: 'Hi!')
  def broadcast_to(target = T.unsafe(nil)); end

  # Passes if an email has been enqueued inside block.
  # May chain with to specify expected arguments.
  # May chain at_least, at_most or exactly to specify a number of times.
  # May chain at to specify a send time.
  # May chain on_queue to specify a queue.
  #
  # @api public
  # @example
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome)
  #
  #   # Using alias
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to enqueue_mail(MyMailer, :welcome)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).with(user)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_least(:once)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_most(:twice)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(wait_until: Date.tomorrow.noon)
  #   }.to have_enqueued_mail(MyMailer, :welcome).at(Date.tomorrow.noon)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(queue: :urgent_mail)
  #   }.to have_enqueued_mail(MyMailer, :welcome).on_queue(:urgent_mail)
  def enqueue_email(mailer_class = T.unsafe(nil), mail_method_name = T.unsafe(nil)); end

  # Passes if a job has been enqueued inside block. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   expect {
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job
  #
  #   # Using alias
  #   expect {
  #   HeavyLiftingJob.perform_later
  #   }.to enqueue_job
  #
  #   expect {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job(HelloJob).exactly(:once)
  #
  #   expect {
  #   3.times { HelloJob.perform_later }
  #   }.to have_enqueued_job(HelloJob).at_least(2).times
  #
  #   expect {
  #   HelloJob.perform_later
  #   }.to have_enqueued_job(HelloJob).at_most(:twice)
  #
  #   expect {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job(HelloJob).and have_enqueued_job(HeavyLiftingJob)
  #
  #   expect {
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   }.to have_enqueued_job.with(42).on_queue("low").at(Date.tomorrow.noon)
  #
  #   expect {
  #   HelloJob.set(queue: "low").perform_later(42)
  #   }.to have_enqueued_job.with(42).on_queue("low").at(:no_wait)
  #
  #   expect {
  #   HelloJob.perform_later('rspec_rails', 'rails', 42)
  #   }.to have_enqueued_job.with { |from, to, times|
  #   # Perform more complex argument matching using dynamic arguments
  #   expect(from).to include "_#{to}"
  #   }
  def enqueue_job(job = T.unsafe(nil)); end

  # Passes if an email has been enqueued inside block.
  # May chain with to specify expected arguments.
  # May chain at_least, at_most or exactly to specify a number of times.
  # May chain at to specify a send time.
  # May chain on_queue to specify a queue.
  #
  # @api public
  # @example
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome)
  #
  #   # Using alias
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to enqueue_mail(MyMailer, :welcome)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).with(user)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_least(:once)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_most(:twice)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(wait_until: Date.tomorrow.noon)
  #   }.to have_enqueued_mail(MyMailer, :welcome).at(Date.tomorrow.noon)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(queue: :urgent_mail)
  #   }.to have_enqueued_mail(MyMailer, :welcome).on_queue(:urgent_mail)
  def enqueue_mail(mailer_class = T.unsafe(nil), mail_method_name = T.unsafe(nil)); end

  # Passes if a job has been enqueued. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   before { ActiveJob::Base.queue_adapter.enqueued_jobs.clear }
  #
  #   HeavyLiftingJob.perform_later
  #   expect(HeavyLiftingJob).to have_been_enqueued
  #
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   expect(HeavyLiftingJob).to have_been_enqueued.exactly(:once)
  #
  #   3.times { HelloJob.perform_later }
  #   expect(HelloJob).to have_been_enqueued.at_least(2).times
  #
  #   HelloJob.perform_later
  #   expect(HelloJob).to enqueue_job(HelloJob).at_most(:twice)
  #
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   expect(HelloJob).to have_been_enqueued
  #   expect(HeavyLiftingJob).to have_been_enqueued
  #
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   expect(HelloJob).to have_been_enqueued.with(42).on_queue("low").at(Date.tomorrow.noon)
  #
  #   HelloJob.set(queue: "low").perform_later(42)
  #   expect(HelloJob).to have_been_enqueued.with(42).on_queue("low").at(:no_wait)
  def have_been_enqueued; end

  # Passes if a job has been performed. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   before do
  #   ActiveJob::Base.queue_adapter.performed_jobs.clear
  #   ActiveJob::Base.queue_adapter.perform_enqueued_jobs = true
  #   ActiveJob::Base.queue_adapter.perform_enqueued_at_jobs = true
  #   end
  #
  #   HeavyLiftingJob.perform_later
  #   expect(HeavyLiftingJob).to have_been_performed
  #
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   expect(HeavyLiftingJob).to have_been_performed.exactly(:once)
  #
  #   3.times { HelloJob.perform_later }
  #   expect(HelloJob).to have_been_performed.at_least(2).times
  #
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   expect(HelloJob).to have_been_performed
  #   expect(HeavyLiftingJob).to have_been_performed
  #
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   expect(HelloJob).to have_been_performed.with(42).on_queue("low").at(Date.tomorrow.noon)
  def have_been_performed; end

  # Passes if a message has been sent to a stream/object inside a block.
  # May chain `at_least`, `at_most` or `exactly` to specify a number of times.
  # To specify channel from which message has been broadcasted to object use `from_channel`.
  #
  # @api public
  # @example
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages")
  #
  #   expect {
  #   SomeChannel.broadcast_to(user)
  #   }.to have_broadcasted_to(user).from_channel(SomeChannel)
  #
  #   # Using alias
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to broadcast_to("messages")
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   ActionCable.server.broadcast "all", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").exactly(:once)
  #
  #   expect {
  #   3.times { ActionCable.server.broadcast "messages", text: 'Hi!' }
  #   }.to have_broadcasted_to("messages").at_least(2).times
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").at_most(:twice)
  #
  #   expect {
  #   ActionCable.server.broadcast "messages", text: 'Hi!'
  #   }.to have_broadcasted_to("messages").with(text: 'Hi!')
  def have_broadcasted_to(target = T.unsafe(nil)); end

  # Passes if an email has been enqueued inside block.
  # May chain with to specify expected arguments.
  # May chain at_least, at_most or exactly to specify a number of times.
  # May chain at to specify a send time.
  # May chain on_queue to specify a queue.
  #
  # @api public
  # @example
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome)
  #
  #   # Using alias
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to enqueue_mail(MyMailer, :welcome)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).with(user)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_least(:once)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_most(:twice)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(wait_until: Date.tomorrow.noon)
  #   }.to have_enqueued_mail(MyMailer, :welcome).at(Date.tomorrow.noon)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(queue: :urgent_mail)
  #   }.to have_enqueued_mail(MyMailer, :welcome).on_queue(:urgent_mail)
  def have_enqueued_email(mailer_class = T.unsafe(nil), mail_method_name = T.unsafe(nil)); end

  # Passes if a job has been enqueued inside block. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   expect {
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job
  #
  #   # Using alias
  #   expect {
  #   HeavyLiftingJob.perform_later
  #   }.to enqueue_job
  #
  #   expect {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job(HelloJob).exactly(:once)
  #
  #   expect {
  #   3.times { HelloJob.perform_later }
  #   }.to have_enqueued_job(HelloJob).at_least(2).times
  #
  #   expect {
  #   HelloJob.perform_later
  #   }.to have_enqueued_job(HelloJob).at_most(:twice)
  #
  #   expect {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }.to have_enqueued_job(HelloJob).and have_enqueued_job(HeavyLiftingJob)
  #
  #   expect {
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   }.to have_enqueued_job.with(42).on_queue("low").at(Date.tomorrow.noon)
  #
  #   expect {
  #   HelloJob.set(queue: "low").perform_later(42)
  #   }.to have_enqueued_job.with(42).on_queue("low").at(:no_wait)
  #
  #   expect {
  #   HelloJob.perform_later('rspec_rails', 'rails', 42)
  #   }.to have_enqueued_job.with { |from, to, times|
  #   # Perform more complex argument matching using dynamic arguments
  #   expect(from).to include "_#{to}"
  #   }
  def have_enqueued_job(job = T.unsafe(nil)); end

  # Passes if an email has been enqueued inside block.
  # May chain with to specify expected arguments.
  # May chain at_least, at_most or exactly to specify a number of times.
  # May chain at to specify a send time.
  # May chain on_queue to specify a queue.
  #
  # @api public
  # @example
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome)
  #
  #   # Using alias
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to enqueue_mail(MyMailer, :welcome)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).with(user)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_least(:once)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later
  #   }.to have_enqueued_mail(MyMailer, :welcome).at_most(:twice)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(wait_until: Date.tomorrow.noon)
  #   }.to have_enqueued_mail(MyMailer, :welcome).at(Date.tomorrow.noon)
  #
  #   expect {
  #   MyMailer.welcome(user).deliver_later(queue: :urgent_mail)
  #   }.to have_enqueued_mail(MyMailer, :welcome).on_queue(:urgent_mail)
  def have_enqueued_mail(mailer_class = T.unsafe(nil), mail_method_name = T.unsafe(nil)); end

  # Passes if `response` has a matching HTTP status code.
  #
  # The following symbolic status codes are allowed:
  #
  # - `Rack::Utils::SYMBOL_TO_STATUS_CODE`
  # - One of the defined `ActionDispatch::TestResponse` aliases:
  #   - `:error`
  #   - `:missing`
  #   - `:redirect`
  #   - `:success`
  #
  # @api public
  # @example Accepts numeric and symbol statuses
  #   expect(response).to have_http_status(404)
  #   expect(response).to have_http_status(:created)
  #   expect(response).to have_http_status(:success)
  #   expect(response).to have_http_status(:error)
  #   expect(response).to have_http_status(:missing)
  #   expect(response).to have_http_status(:redirect)
  # @example Works with standard `response` objects and Capybara's `page`
  #   expect(response).to have_http_status(404)
  #   expect(page).to     have_http_status(:created)
  # @raise [ArgumentError]
  # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
  # @see https://github.com/rack/rack/blob/master/lib/rack/utils.rb `Rack::Utils::SYMBOL_TO_STATUS_CODE`
  def have_http_status(target); end

  # Passes if a job has been performed inside block. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   expect {
  #   perform_jobs { HeavyLiftingJob.perform_later }
  #   }.to have_performed_job
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }
  #   }.to have_performed_job(HelloJob).exactly(:once)
  #
  #   expect {
  #   perform_jobs { 3.times { HelloJob.perform_later } }
  #   }.to have_performed_job(HelloJob).at_least(2).times
  #
  #   expect {
  #   perform_jobs { HelloJob.perform_later }
  #   }.to have_performed_job(HelloJob).at_most(:twice)
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }
  #   }.to have_performed_job(HelloJob).and have_performed_job(HeavyLiftingJob)
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   }
  #   }.to have_performed_job.with(42).on_queue("low").at(Date.tomorrow.noon)
  def have_performed_job(job = T.unsafe(nil)); end

  # Passes if a job has been performed inside block. May chain at_least, at_most or exactly to specify a number of times.
  #
  # @api public
  # @example
  #   expect {
  #   perform_jobs { HeavyLiftingJob.perform_later }
  #   }.to have_performed_job
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }
  #   }.to have_performed_job(HelloJob).exactly(:once)
  #
  #   expect {
  #   perform_jobs { 3.times { HelloJob.perform_later } }
  #   }.to have_performed_job(HelloJob).at_least(2).times
  #
  #   expect {
  #   perform_jobs { HelloJob.perform_later }
  #   }.to have_performed_job(HelloJob).at_most(:twice)
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.perform_later
  #   HeavyLiftingJob.perform_later
  #   }
  #   }.to have_performed_job(HelloJob).and have_performed_job(HeavyLiftingJob)
  #
  #   expect {
  #   perform_jobs {
  #   HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
  #   }
  #   }.to have_performed_job.with(42).on_queue("low").at(Date.tomorrow.noon)
  def perform_job(job = T.unsafe(nil)); end

  # Passes if the given inbound email would be routed to the subject inbox.
  #
  # @api public
  # @param message [Hash, Mail::Message] a mail message or hash of
  #   attributes used to build one
  def receive_inbound_email(message); end

  private

  # @private
  # @raise [StandardError]
  def check_action_cable_adapter; end

  # @private
  # @raise [StandardError]
  def check_active_job_adapter; end
end

# Namespace for various implementations of ActionCable features
#
# @api private
module RSpec::Rails::Matchers::ActionCable; end

# @private
class RSpec::Rails::Matchers::ActionCable::HaveBroadcastedTo < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @return [HaveBroadcastedTo] a new instance of HaveBroadcastedTo
  def initialize(target, channel:); end

  def at_least(count); end
  def at_most(count); end
  def exactly(count); end
  def failure_message; end
  def failure_message_when_negated; end
  def from_channel(channel); end

  # @raise [ArgumentError]
  # @return [Boolean]
  def matches?(proc); end

  def message_expectation_modifier; end
  def once; end

  # @return [Boolean]
  def supports_block_expectations?; end

  def thrice; end
  def times; end
  def twice; end
  def with(data = T.unsafe(nil), &block); end

  private

  def base_message; end
  def check(messages); end

  # @raise [ArgumentError]
  def check_channel_presence; end

  def data_description(data); end
  def pubsub_adapter; end
  def set_expected_number(relativity, count); end
  def stream; end
end

# Provides the implementation for `have_stream`, `have_stream_for`, and `have_stream_from`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Rails::Matchers::ActionCable::HaveStream < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Boolean]
  def does_not_match?(subscription); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @raise [ArgumentError]
  # @return [Boolean]
  def matches?(subscription); end

  private

  # @api private
  def base_message; end

  # @api private
  def match(subscription); end

  # @api private
  # @return [Boolean]
  def no_expected?; end
end

# Namespace for various implementations of ActionMailbox features
#
# @api private
module RSpec::Rails::Matchers::ActionMailbox; end

# @api private
# @private
class RSpec::Rails::Matchers::ActionMailbox::Base < ::RSpec::Rails::Matchers::BaseMatcher
  private

  # @api private
  def create_inbound_email(message); end
end

# @api private
# @private
class RSpec::Rails::Matchers::ActionMailbox::ReceiveInboundEmail < ::RSpec::Rails::Matchers::ActionMailbox::Base
  # @api private
  # @return [ReceiveInboundEmail] a new instance of ReceiveInboundEmail
  def initialize(message); end

  # @api private
  def failure_message; end

  # @api private
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(mailbox); end

  private

  # @api private
  def describe_inbound_email; end

  # @api private
  def inbound_email; end

  # @api private
  def mailbox; end

  # @api private
  def receiver; end
end

# Namespace for various implementations of ActiveJob features
#
# @api private
module RSpec::Rails::Matchers::ActiveJob; end

# @api private
# @private
class RSpec::Rails::Matchers::ActiveJob::Base < ::RSpec::Rails::Matchers::BaseMatcher
  # @api private
  # @return [Base] a new instance of Base
  def initialize; end

  # @api private
  def at(time_or_date); end

  # @api private
  def at_least(count); end

  # @api private
  def at_most(count); end

  # @api private
  def exactly(count); end

  # @api private
  def failure_message; end

  # @api private
  def failure_message_when_negated; end

  # @api private
  def message_expectation_modifier; end

  # @api private
  def on_queue(queue); end

  # @api private
  def once; end

  # @api private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  def thrice; end

  # @api private
  def times; end

  # @api private
  def twice; end

  # @api private
  def with(*args, &block); end

  private

  # @api private
  # @return [Boolean]
  def arguments_match?(job); end

  # @api private
  # @return [Boolean]
  def at_match?(job); end

  # @api private
  def base_job_message(job); end

  # @api private
  def base_message; end

  # @api private
  def check(jobs); end

  # @api private
  def check_for_inprecise_value(scheduled_at); end

  # @api private
  def deserialize_arguments(job); end

  # @api private
  # @return [Boolean]
  def job_match?(job); end

  # @api private
  def queue_adapter; end

  # @api private
  # @return [Boolean]
  def queue_match?(job); end

  # @api private
  def serialize_and_deserialize_arguments(args); end

  # @api private
  def set_expected_number(relativity, count); end
end

# @api private
# @private
class RSpec::Rails::Matchers::ActiveJob::HaveBeenEnqueued < ::RSpec::Rails::Matchers::ActiveJob::Base
  # @api private
  # @return [Boolean]
  def does_not_match?(proc); end

  # @api private
  # @return [Boolean]
  def matches?(job); end
end

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveBeenEnqueued::FAILURE_MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveBeenEnqueued::MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
# @private
class RSpec::Rails::Matchers::ActiveJob::HaveBeenPerformed < ::RSpec::Rails::Matchers::ActiveJob::Base
  # @api private
  # @return [Boolean]
  def matches?(job); end
end

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveBeenPerformed::FAILURE_MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveBeenPerformed::MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
# @private
class RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob < ::RSpec::Rails::Matchers::ActiveJob::Base
  # @api private
  # @return [HaveEnqueuedJob] a new instance of HaveEnqueuedJob
  def initialize(job); end

  # @api private
  # @return [Boolean]
  def does_not_match?(proc); end

  # @api private
  # @raise [ArgumentError]
  # @return [Boolean]
  def matches?(proc); end
end

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob::FAILURE_MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob::MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
# @private
class RSpec::Rails::Matchers::ActiveJob::HavePerformedJob < ::RSpec::Rails::Matchers::ActiveJob::Base
  # @api private
  # @return [HavePerformedJob] a new instance of HavePerformedJob
  def initialize(job); end

  # @api private
  # @raise [ArgumentError]
  # @return [Boolean]
  def matches?(proc); end
end

# @api private
RSpec::Rails::Matchers::ActiveJob::HavePerformedJob::FAILURE_MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# @api private
RSpec::Rails::Matchers::ActiveJob::HavePerformedJob::MESSAGE_EXPECTATION_ACTION = T.let(T.unsafe(nil), String)

# Base class to build matchers. Should not be instantiated directly.
#
# @api private
class RSpec::Rails::Matchers::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Rails::Matchers::BaseMatcher::HashFormatting
  include ::RSpec::Rails::Matchers::BaseMatcher::DefaultFailureMessages

  # @api private
  # @return [BaseMatcher] a new instance of BaseMatcher
  def initialize(expected = T.unsafe(nil)); end

  # @api private
  # @private
  def actual; end

  # @api private
  # @private
  def actual_formatted; end

  # Generates a description using {RSpec::Matchers::EnglishPhrasing}.
  #
  # @api private
  # @return [String]
  def description; end

  # Matchers are not diffable by default. Override this to make your
  # subclass diffable.
  #
  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @private
  def expected; end

  # @api private
  # @private
  def expected_formatted; end

  # @api private
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # Used to wrap a block of code that will indicate failure by
  # raising one of the named exceptions.
  #
  # This is used by rspec-rails for some of its matchers that
  # wrap rails' assertions.
  #
  # @api private
  def match_unless_raises(*exceptions); end

  # @api private
  # @private
  def matcher_name; end

  # @api private
  # @private
  def matcher_name=(_arg0); end

  # Indicates if the match is successful. Delegates to `match`, which
  # should be defined on a subclass. Takes care of consistently
  # initializing the `actual` attribute.
  #
  # @api private
  # @return [Boolean]
  def matches?(actual); end

  # @api private
  def present_ivars; end

  # @api private
  # @private
  def rescued_exception; end

  # Most matchers are value matchers (i.e. meant to work with `expect(value)`)
  # rather than block matchers (i.e. meant to work with `expect { }`), so
  # this defaults to false. Block matchers must override this to return true.
  #
  # @api private
  # @return [Boolean]
  def supports_block_expectations?; end

  private

  # @api private
  def assert_ivars(*expected_ivars); end

  class << self
    # @api private
    # @private
    def matcher_name; end

    private

    # Borrowed from ActiveSupport.
    #
    # @api private
    # @private
    def underscore(camel_cased_word); end
  end
end

# Provides default implementations of failure messages, based on the `description`.
#
# @api private
module RSpec::Rails::Matchers::BaseMatcher::DefaultFailureMessages
  # Provides a good generic failure message. Based on `description`.
  # When subclassing, if you are not satisfied with this failure message
  # you often only need to override `description`.
  #
  # @api private
  # @return [String]
  def failure_message; end

  # Provides a good generic negative failure message. Based on `description`.
  # When subclassing, if you are not satisfied with this failure message
  # you often only need to override `description`.
  #
  # @api private
  # @return [String]
  def failure_message_when_negated; end

  class << self
    # @api private
    # @private
    # @return [Boolean]
    def has_default_failure_messages?(matcher); end
  end
end

# @api private
# @private
module RSpec::Rails::Matchers::BaseMatcher::HashFormatting
  private

  # `{ :a => 5, :b => 2 }.inspect` produces:
  #
  #     {:a=>5, :b=>2}
  #
  # ...but it looks much better as:
  #
  #     {:a => 5, :b => 2}
  #
  # This is idempotent and safe to run on a string multiple times.
  #
  # @api private
  def improve_hash_formatting(inspect_string); end

  class << self
    # `{ :a => 5, :b => 2 }.inspect` produces:
    #
    #     {:a=>5, :b=>2}
    #
    # ...but it looks much better as:
    #
    #     {:a => 5, :b => 2}
    #
    # This is idempotent and safe to run on a string multiple times.
    #
    # @api private
    def improve_hash_formatting(inspect_string); end
  end
end

# Used to detect when no arg is passed to `initialize`.
# `nil` cannot be used because it's a valid value to pass.
#
# @api private
RSpec::Rails::Matchers::BaseMatcher::UNDEFINED = T.let(T.unsafe(nil), Object)

# Matcher class for `be_a_new`. Should not be instantiated directly.
#
# @api private
# @see RSpec::Rails::Matchers#be_a_new
class RSpec::Rails::Matchers::BeANew < ::RSpec::Rails::Matchers::BaseMatcher
  # @api private
  # @private
  # @return [BeANew] a new instance of BeANew
  def initialize(expected); end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(actual); end

  # @api public
  # @see RSpec::Rails::Matchers#be_a_new
  def with(expected_attributes); end

  private

  # @api private
  def attributes; end

  # @api private
  # @return [Boolean]
  def attributes_match?(actual); end

  # @api private
  def unmatched_attributes; end
end

# @private
class RSpec::Rails::Matchers::BeANewRecord < ::RSpec::Rails::Matchers::BaseMatcher
  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(actual); end
end

# @private
class RSpec::Rails::Matchers::BeValid < ::RSpec::Matchers::BuiltIn::Be
  # @return [BeValid] a new instance of BeValid
  def initialize(*args); end

  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(actual); end
end

# Matcher class for `have_enqueued_mail`. Should not be instantiated directly.
#
# @private
# @see RSpec::Rails::Matchers#have_enqueued_mail
class RSpec::Rails::Matchers::HaveEnqueuedMail < ::RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob
  include ::RSpec::Mocks::ArgumentMatchers

  # @return [HaveEnqueuedMail] a new instance of HaveEnqueuedMail
  def initialize(mailer_class, method_name); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end

  # @raise [ArgumentError]
  # @return [Boolean]
  def matches?(block); end

  def with(*args, &block); end

  private

  # @return [Boolean]
  def arguments_match?(job); end

  def base_mailer_args; end
  def base_message; end

  # @raise [StandardError]
  def check_active_job_adapter; end

  # Ruby 3.1 changed how params were serialized on Rails 6.1
  # so we override the active job implementation and customize it here.
  def deserialize_arguments(job); end

  def expected_count_message; end

  # @return [Boolean]
  def job_match?(job); end

  # @return [Boolean]
  def legacy_mail?(job); end

  def mail_job_message(job); end
  def mailer_class_name; end

  # @return [Boolean]
  def parameterized_mail?(job); end

  # @return [Boolean]
  def unified_mail?(job); end

  def unmatching_mail_jobs; end
  def unmatching_mail_jobs_message; end
  def yield_mail_args(block); end
end

RSpec::Rails::Matchers::HaveEnqueuedMail::MAILER_JOB_METHOD = T.let(T.unsafe(nil), String)

# Namespace for various implementations of `have_http_status`.
#
# @api private
module RSpec::Rails::Matchers::HaveHttpStatus
  # @api private
  # @return [String, nil] a formatted failure message if
  #   `@invalid_response` is present, `nil` otherwise
  def invalid_response_type_message; end

  private

  # Conversion function to coerce the provided object into an
  # `ActionDispatch::TestResponse`.
  #
  # @api private
  # @param obj [Object] object to convert to a response
  # @return [ActionDispatch::TestResponse]
  def as_test_response(obj); end

  class << self
    # Conversion function to coerce the provided object into an
    # `ActionDispatch::TestResponse`.
    #
    # @api private
    # @param obj [Object] object to convert to a response
    # @return [ActionDispatch::TestResponse]
    def as_test_response(obj); end

    # Instantiates an instance of the proper matcher based on the provided
    # `target`.
    #
    # @api private
    # @param target [Object] expected http status or code
    # @return response matcher instance
    def matcher_for_status(target); end
  end
end

# Provides an implementation for `have_http_status` matching against
# `ActionDispatch::TestResponse` http status category queries.
#
# Not intended to be instantiated directly.
#
# @api private
# @example
#   expect(response).to have_http_status(:success)
#   expect(response).to have_http_status(:error)
#   expect(response).to have_http_status(:missing)
#   expect(response).to have_http_status(:redirect)
# @see RSpec::Rails::Matchers#have_http_status
# @see https://github.com/rails/rails/blob/6-0-stable/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
class RSpec::Rails::Matchers::HaveHttpStatus::GenericStatus < ::RSpec::Rails::Matchers::BaseMatcher
  include ::RSpec::Rails::Matchers::HaveHttpStatus

  # @api private
  # @return [GenericStatus] a new instance of GenericStatus
  def initialize(type); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean] `true` if Rack's associated numeric HTTP code matched
  #   the `response` code or the named response status
  def matches?(response); end

  protected

  # @api private
  def check_expected_status(test_response, expected); end

  private

  # @api private
  # @return [String] formatting the associated code(s) for the various
  #   status code "groups"
  # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
  # @see https://github.com/rack/rack/blob/master/lib/rack/response.rb `Rack::Response`
  def type_codes; end

  # @api private
  # @return [String] formatting the expected status and associated code(s)
  def type_message; end

  class << self
    # @api private
    # @return [Array<Symbol>] of status codes which represent a HTTP status
    #   code "group"
    # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
    def valid_statuses; end
  end
end

# @api private
RSpec::Rails::Matchers::HaveHttpStatus::GenericStatus::RESPONSE_METHODS = T.let(T.unsafe(nil), Hash)

# Provides an implementation for `have_http_status` matching against
# numeric http status codes.
#
# Not intended to be instantiated directly.
#
# @api private
# @example
#   expect(response).to have_http_status(404)
# @see RSpec::Rails::Matchers#have_http_status
class RSpec::Rails::Matchers::HaveHttpStatus::NumericCode < ::RSpec::Rails::Matchers::BaseMatcher
  include ::RSpec::Rails::Matchers::HaveHttpStatus

  # @api private
  # @return [NumericCode] a new instance of NumericCode
  def initialize(code); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message_when_negated; end

  # @api private
  # @param response [Object] object providing an http code to match
  # @return [Boolean] `true` if the numeric code matched the `response` code
  def matches?(response); end
end

# Provides an implementation for `have_http_status` matching against
# Rack symbol http status codes.
#
# Not intended to be instantiated directly.
#
# @api private
# @example
#   expect(response).to have_http_status(:created)
# @see RSpec::Rails::Matchers#have_http_status
# @see https://github.com/rack/rack/blob/master/lib/rack/utils.rb `Rack::Utils::SYMBOL_TO_STATUS_CODE`
class RSpec::Rails::Matchers::HaveHttpStatus::SymbolicStatus < ::RSpec::Rails::Matchers::BaseMatcher
  include ::RSpec::Rails::Matchers::HaveHttpStatus

  # @api private
  # @return [SymbolicStatus] a new instance of SymbolicStatus
  def initialize(status); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message; end

  # @api private
  # @return [String] explaining why the match failed
  def failure_message_when_negated; end

  # @api private
  # @param response [Object] object providing an http code to match
  # @return [Boolean] `true` if Rack's associated numeric HTTP code matched
  #   the `response` code
  def matches?(response); end

  private

  # @api private
  # @return [Symbol] representing the actual http numeric code
  def actual_status; end

  # Reverse lookup of the Rack status code symbol based on the numeric
  # http code
  #
  # @api private
  # @param code [Fixnum] http status code to look up
  # @return [Symbol] representing the http numeric code
  def compute_status_from(code); end

  # The initialized expected status symbol
  #
  # @api private
  def expected_status; end

  # @api private
  # @return [String] pretty format the actual response status
  def pp_actual; end

  # @api private
  # @return [String] pretty format the expected status and associated code
  def pp_expected; end

  # @api private
  # @return [String] pretty format the actual response status
  def pp_status(status, code); end

  # Sets `expected` to the numeric http code based on the Rack
  # `expected_status` status
  #
  # @api private
  # @raise [ArgumentError] if an associated code could not be found
  # @see Rack::Utils::SYMBOL_TO_STATUS_CODE
  def set_expected_code!; end
end

# Matcher for redirects.
module RSpec::Rails::Matchers::RedirectTo
  # Delegates to `assert_redirected_to`.
  #
  # @example
  #   expect(response).to redirect_to(:action => "new")
  def redirect_to(target); end
end

# @private
class RSpec::Rails::Matchers::RedirectTo::RedirectTo < ::RSpec::Rails::Matchers::BaseMatcher
  # @return [RedirectTo] a new instance of RedirectTo
  def initialize(scope, expected); end

  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(_); end
end

# Matcher for template rendering.
module RSpec::Rails::Matchers::RenderTemplate
  # Delegates to `assert_template`.
  #
  # @example
  #   expect(response).to have_rendered("new")
  def have_rendered(options, message = T.unsafe(nil)); end

  # Delegates to `assert_template`.
  #
  # @example
  #   expect(response).to have_rendered("new")
  def render_template(options, message = T.unsafe(nil)); end
end

# @private
class RSpec::Rails::Matchers::RenderTemplate::RenderTemplateMatcher < ::RSpec::Rails::Matchers::BaseMatcher
  # @return [RenderTemplateMatcher] a new instance of RenderTemplateMatcher
  def initialize(scope, expected, message = T.unsafe(nil)); end

  # Uses normalize_argument_to_redirection to find and format
  # the redirect location. normalize_argument_to_redirection is private
  # in ActionDispatch::Assertions::ResponseAssertions so we call it
  # here using #send. This will keep the error message format consistent
  #
  # @api private
  def check_redirect; end

  # @api private
  def failure_message; end

  # @api private
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(*_arg0); end
end

# Matchers to help with specs for routing code.
module RSpec::Rails::Matchers::RoutingMatchers
  extend ::RSpec::Matchers::DSL

  # Passes if the route expression is recognized by the Rails router based on
  # the declarations in `config/routes.rb`. Delegates to
  # `RouteSet#recognize_path`.
  #
  # @example You can use route helpers provided by rspec-rails.
  #   expect(get:  "/a/path").to be_routable
  #   expect(post: "/another/path").to be_routable
  #   expect(put:  "/yet/another/path").to be_routable
  def be_routable; end

  # Delegates to `assert_recognizes`. Supports short-hand controller/action
  # declarations (e.g. `"controller#action"`).
  #
  # @example
  #
  #   expect(get: "/things/special").to route_to(
  #   controller: "things",
  #   action:     "special"
  #   )
  #
  #   expect(get: "/things/special").to route_to("things#special")
  # @see https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_recognizes
  def route_to(*expected); end
end

# @private
class RSpec::Rails::Matchers::RoutingMatchers::BeRoutableMatcher < ::RSpec::Rails::Matchers::BaseMatcher
  # @return [BeRoutableMatcher] a new instance of BeRoutableMatcher
  def initialize(scope); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(path); end
end

# Helpers for matching different route types.
module RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers
  # Shorthand method for matching this type of route.
  def delete(path); end

  # Shorthand method for matching this type of route.
  def get(path); end

  # Shorthand method for matching this type of route.
  def head(path); end

  # Shorthand method for matching this type of route.
  def options(path); end

  # Shorthand method for matching this type of route.
  def patch(path); end

  # Shorthand method for matching this type of route.
  def post(path); end

  # Shorthand method for matching this type of route.
  def put(path); end
end

# @private
class RSpec::Rails::Matchers::RoutingMatchers::RouteToMatcher < ::RSpec::Rails::Matchers::BaseMatcher
  # @return [RouteToMatcher] a new instance of RouteToMatcher
  def initialize(scope, *expected); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(verb_to_path_map); end
end

# @private
module RSpec::Rails::MinitestAssertionAdapter
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods

  def assertion_delegator; end
end

class RSpec::Rails::MinitestAssertionAdapter::AssertionDelegator
  include ::Minitest::Assertions
  include ::RSpec::Rails::MinitestCounters
end

# @private
module RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  # Returns the names of assertion methods that we want to expose to
  # examples without exposing non-assertion methods in Test::Unit or
  # Minitest.
  def assertion_method_names; end

  def define_assertion_delegators; end
end

# @private
module RSpec::Rails::MinitestCounters
  def assertions; end

  # Sets the attribute assertions
  #
  # @param value the value to set the attribute assertions to.
  def assertions=(_arg0); end
end

# Adapts example groups for `Minitest::Test::LifecycleHooks`
#
# @private
module RSpec::Rails::MinitestLifecycleAdapter
  extend ::ActiveSupport::Concern

  def after_setup; end
  def after_teardown; end
  def before_setup; end
  def before_teardown; end
end

# Container class for model spec functionality. Does not provide anything
# special over the common RailsExampleGroup currently.
#
# @api public
module RSpec::Rails::ModelExampleGroup
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Common rails example functionality.
#
# @api public
module RSpec::Rails::RailsExampleGroup
  include ::RSpec::Rails::TaggedLoggingAdapter
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Railtie to hook into Rails.
class RSpec::Rails::Railtie < ::Rails::Railtie
  private

  def config_default_preview_path(options); end

  # @return [Boolean]
  def config_preview_path?(options); end

  def setup_preview_path(app); end

  # @return [Boolean]
  def supports_action_mailer_previews?(config); end
end

# Container class for request spec functionality.
#
# @api public
module RSpec::Rails::RequestExampleGroup
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Integration::Runner
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::ActionController::TemplateAssertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionDispatch::IntegrationTest::Behavior

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::ActionDispatch::IntegrationTest::Behavior::ClassMethods

  # Delegates to `Rails.application`.
  #
  # @api public
  def app; end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# @private
module RSpec::Rails::RoutingAssertionDelegator
  def assert_generates(*args, &block); end
  def assert_recognizes(*args, &block); end
  def assert_routing(*args, &block); end
  def assertion_instance; end
  def build_assertion_instance; end
  def setup(*args, &block); end
  def with_routing(*args, &block); end
end

# Container module for routing spec functionality.
#
# @api public
module RSpec::Rails::RoutingExampleGroup
  include ::RSpec::Rails::Matchers::RoutingMatchers
  include ::RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers
  include ::RSpec::Rails::RoutingAssertionDelegator
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::RoutingExampleGroup::ClassMethods

  # @api public
  # @private
  def routes; end

  # @api public
  # @private
  def routes=(routes); end

  private

  # @api public
  def method_missing(m, *args, &block); end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# Class-level DSL for route specs.
#
# @api public
module RSpec::Rails::RoutingExampleGroup::ClassMethods
  # Specifies the routeset that will be used for the example group. This
  # is most useful when testing Rails engines.
  #
  # @api public
  # @example
  #   describe MyEngine::PostsController do
  #   routes { MyEngine::Engine.routes }
  #
  #   it "routes posts#index" do
  #   expect(:get => "/posts").to
  #   route_to(:controller => "my_engine/posts", :action => "index")
  #   end
  #   end
  def routes; end
end

# @private
module RSpec::Rails::SetupAndTeardownAdapter
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods

  def initialize(*args); end

  def method_name; end
end

module RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  # Wraps `setup` calls from within Rails' testing framework in `before`
  # hooks.
  def setup(*methods, &block); end

  # Wraps `teardown` calls from within Rails' testing framework in
  # `after` hooks.
  #
  # @api private
  def teardown(*methods, &block); end
end

# Container class for system tests
#
# @api public
module RSpec::Rails::SystemExampleGroup
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Integration::Runner
  include ::ActionController::TemplateAssertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  include ::RSpec::Rails::SystemExampleGroup::BlowAwayTeardownHooks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods

  # Delegates to `Rails.application`.
  #
  # @api public
  def app; end

  # @api public
  # @private
  def method_name; end

  # for the SystemTesting Screenshot situation
  #
  # @api public
  # @return [Boolean]
  def passed?; end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# @api public
# @private
module RSpec::Rails::SystemExampleGroup::BlowAwayTeardownHooks
  # @api public
  # @private
  def after_teardown; end

  # @api public
  # @private
  def before_teardown; end
end

# Special characters to translate into underscores for #method_name
#
# @api public
RSpec::Rails::SystemExampleGroup::CHARS_TO_TRANSLATE = T.let(T.unsafe(nil), Array)

# @private
module RSpec::Rails::TaggedLoggingAdapter
  private

  # Vendored from activesupport/lib/active_support/testing/tagged_logging.rb
  # This implements the tagged_logger method where it is expected, but
  # doesn't call `name` or set it up like Rails does.
  def tagged_logger; end
end

# Backwards compatibility. It's unlikely that anyone is using this
# constant, but we had forgotten to mark it as `@private` earlier
#
# @private
RSpec::Rails::TestUnitAssertionAdapter = RSpec::Rails::MinitestAssertionAdapter

# Helpers for making instance variables available to views.
module RSpec::Rails::ViewAssigns
  # Assigns a value to an instance variable in the scope of the
  # view being rendered.
  #
  # @example
  #
  #   assign(:widget, stub_model(Widget))
  def assign(key, value); end

  # Compat-shim for AbstractController::Rendering#view_assigns
  def view_assigns; end

  private

  def _encapsulated_assigns; end
end

# Container class for view spec functionality.
#
# @api public
module RSpec::Rails::ViewExampleGroup
  include ::RSpec::Rails::ViewAssigns
  include ::RSpec::Rails::Matchers::RenderTemplate
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::RSpec::Rails::SetupAndTeardownAdapter
  include ::RSpec::Rails::MinitestLifecycleAdapter
  include ::RSpec::Rails::MinitestAssertionAdapter
  include ::ActiveRecord::TestFixtures
  include ::RSpec::Rails::FixtureSupport::Fixtures
  include ::RSpec::Rails::FixtureSupport
  include ::RSpec::Rails::RailsExampleGroup
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::RSpec::Rails::ViewExampleGroup::ExampleMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::UrlHelper::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::SanitizeHelper::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionView::TestCase::Behavior::ClassMethods
  mixes_in_class_methods ::RSpec::Rails::ViewExampleGroup::ClassMethods

  module GeneratedClassMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# @api public
# @private
module RSpec::Rails::ViewExampleGroup::ClassMethods
  # @api public
  def _default_helper; end

  # @api public
  def _default_helpers; end
end

# DSL exposed to view specs.
#
# @api public
module RSpec::Rails::ViewExampleGroup::ExampleMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers

  mixes_in_class_methods GeneratedClassMethods

  # Provides access to the params hash that will be available within the
  # view.
  #
  #     params[:foo] = 'bar'
  #
  # @api public
  def params; end

  # Delegates to ActionView::Base#render, so see documentation on that
  # for more info.
  #
  # The only addition is that you can call render with no arguments, and
  # RSpec will pass the top level description to render:
  #
  #     describe "widgets/new.html.erb" do
  #       it "shows all the widgets" do
  #         render # => view.render(file: "widgets/new.html.erb")
  #         # ...
  #       end
  #     end
  #
  # @api public
  # @overload render
  # @overload render
  # @overload render
  # @overload render
  def render(options = T.unsafe(nil), local_assigns = T.unsafe(nil), &block); end

  # @api public
  # @deprecated Use `rendered` instead.
  def response; end

  # Simulates the presence of a template on the file system by adding a
  # Rails' FixtureResolver to the front of the view_paths list. Designed to
  # help isolate view examples from partials rendered by the view template
  # that is the subject of the example.
  #
  #     stub_template("widgets/_widget.html.erb" => "This content.")
  #
  # @api public
  def stub_template(hash); end

  # @api public
  # @deprecated Use `view` instead.
  def template; end

  # The instance of `ActionView::Base` that is used to render the template.
  # Use this to stub methods _before_ calling `render`.
  #
  #     describe "widgets/new.html.erb" do
  #       it "shows all the widgets" do
  #         view.stub(:foo) { "foo" }
  #         render
  #         # ...
  #       end
  #     end
  #
  # @api public
  def view; end

  private

  # @api public
  def _controller_path; end

  # @api public
  def _default_render_options; end

  # @api public
  def _include_controller_helpers; end

  # @api public
  def _inferred_action; end

  # @api public
  def _path_parts; end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

# @api public
# @private
module RSpec::Rails::ViewExampleGroup::StubResolverCache
  class << self
    # @api public
    def resolver_for(hash); end
  end
end

# Builds paths for view specs using a particular route set.
class RSpec::Rails::ViewPathBuilder
  # @return [ViewPathBuilder] a new instance of ViewPathBuilder
  def initialize(route_set); end

  # Given a hash of parameters, build a view path, if possible.
  # Returns nil if no path can be built from the given params.
  #
  # @example
  #   # path can be built because all required params are present in the hash
  #   view_path_builder = ViewPathBuilder.new(::Rails.application.routes)
  #   view_path_builder.path_for({ :controller => 'posts', :action => 'show', :id => '54' })
  #   # => "/post/54"
  # @example
  #   # path cannot be built because the params are missing a required element (:id)
  #   view_path_builder.path_for({ :controller => 'posts', :action => 'delete' })
  #   # => ActionController::UrlGenerationError: No route matches {:action=>"delete", :controller=>"posts"}
  def path_for(path_params); end
end

# Helpers for optionally rendering views in controller specs.
#
# @api public
module RSpec::Rails::ViewRendering
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RSpec::Rails::ViewRendering::ClassMethods

  # Returns the controller object instance under test.
  #
  # @api public
  def controller; end

  # @api private
  # @return [Boolean]
  def render_views?; end

  private

  # @api public
  # @private
  def controller=(_arg0); end
end

# DSL methods
#
# @api public
module RSpec::Rails::ViewRendering::ClassMethods
  # @api public
  # @see RSpec::Rails::ControllerExampleGroup
  def render_views(true_or_false = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def render_views?; end
end

# @api public
# @private
class RSpec::Rails::ViewRendering::EmptyTemplateHandler
  class << self
    # @api public
    def call(_template, _source = T.unsafe(nil)); end
  end
end

# @api public
# @private
class RSpec::Rails::ViewRendering::EmptyTemplateResolver
  class << self
    # @api public
    def build(path); end

    # @api public
    def nullify_template_rendering(templates); end

    # @api public
    def template_format(template); end
  end
end

# Delegates find_templates to the submitted path set and then returns
# templates with modified source
#
# @api public
# @private
class RSpec::Rails::ViewRendering::EmptyTemplateResolver::FileSystemResolver < ::ActionView::FileSystemResolver
  private

  # @api public
  def find_templates(*args); end
end

# Delegates all methods to the submitted resolver and for all methods
# that return a collection of `ActionView::Template` instances, return
# templates with modified source
#
# @api public
# @private
class RSpec::Rails::ViewRendering::EmptyTemplateResolver::ResolverDecorator < ::ActionView::Resolver
  # @api public
  # @return [ResolverDecorator] a new instance of ResolverDecorator
  def initialize(resolver); end

  # @api public
  def method_missing(name, *args, &block); end

  private

  # @api public
  def nullify_templates(collection); end
end

# Used to null out view rendering in controller specs.
#
# @api public
# @private
module RSpec::Rails::ViewRendering::EmptyTemplates
  # @api public
  def append_view_path(new_path); end

  # @api public
  def prepend_view_path(new_path); end

  private

  # @api public
  def _path_decorator(*paths); end
end

# @api public
# @private
RSpec::Rails::ViewRendering::RESOLVER_CACHE = T.let(T.unsafe(nil), Hash)

# Adds methods (generally to ActionView::TestCase::TestController).
# Intended for use in view specs.
module RSpec::Rails::ViewSpecMethods
  private

  # Adds methods `extra_params=` and `extra_params` to the indicated class.
  # When class is `::ActionView::TestCase::TestController`, these methods
  # are exposed in view specs on the `controller` object.
  def add_to(klass); end

  # Removes methods `extra_params=` and `extra_params` from the indicated class.
  def remove_from(klass); end

  class << self
    # Adds methods `extra_params=` and `extra_params` to the indicated class.
    # When class is `::ActionView::TestCase::TestController`, these methods
    # are exposed in view specs on the `controller` object.
    def add_to(klass); end

    # Removes methods `extra_params=` and `extra_params` from the indicated class.
    def remove_from(klass); end
  end
end
