# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `psych` gem.
# Please instead update this file by running `bin/tapioca gem psych`.


class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::MakeMakefile

  # call-seq: to_yaml(options = {})
  #
  # Convert an object to YAML.  See Psych.dump for more information on the
  # available +options+.
  def to_yaml(options = T.unsafe(nil)); end

  class << self
    def yaml_tag(url); end
  end
end

# = Overview
#
# Psych is a YAML parser and emitter.
# Psych leverages libyaml [Home page: https://pyyaml.org/wiki/LibYAML]
# or [git repo: https://github.com/yaml/libyaml] for its YAML parsing
# and emitting capabilities. In addition to wrapping libyaml, Psych also
# knows how to serialize and de-serialize most Ruby objects to and from
# the YAML format.
#
# = I NEED TO PARSE OR EMIT YAML RIGHT NOW!
#
#   # Parse some YAML
#   Psych.load("--- foo") # => "foo"
#
#   # Emit some YAML
#   Psych.dump("foo")     # => "--- foo\n...\n"
#   { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
#
# Got more time on your hands?  Keep on reading!
#
# == YAML Parsing
#
# Psych provides a range of interfaces for parsing a YAML document ranging from
# low level to high level, depending on your parsing needs.  At the lowest
# level, is an event based parser.  Mid level is access to the raw YAML AST,
# and at the highest level is the ability to unmarshal YAML to Ruby objects.
#
# == YAML Emitting
#
# Psych provides a range of interfaces ranging from low to high level for
# producing YAML documents.  Very similar to the YAML parsing interfaces, Psych
# provides at the lowest level, an event based system, mid-level is building
# a YAML AST, and the highest level is converting a Ruby object straight to
# a YAML document.
#
# == High-level API
#
# === Parsing
#
# The high level YAML parser provided by Psych simply takes YAML as input and
# returns a Ruby data structure.  For information on using the high level parser
# see Psych.load
#
# ==== Reading from a string
#
#   Psych.safe_load("--- a")             # => 'a'
#   Psych.safe_load("---\n - a\n - b")   # => ['a', 'b']
#   # From a trusted string:
#   Psych.load("--- !ruby/range\nbegin: 0\nend: 42\nexcl: false\n") # => 0..42
#
# ==== Reading from a file
#
#   Psych.safe_load_file("data.yml", permitted_classes: [Date])
#   Psych.load_file("trusted_database.yml")
#
# ==== Exception handling
#
#   begin
#     # The second argument changes only the exception contents
#     Psych.parse("--- `", "file.txt")
#   rescue Psych::SyntaxError => ex
#     ex.file    # => 'file.txt'
#     ex.message # => "(file.txt): found character that cannot start any token"
#   end
#
# === Emitting
#
# The high level emitter has the easiest interface.  Psych simply takes a Ruby
# data structure and converts it to a YAML document.  See Psych.dump for more
# information on dumping a Ruby data structure.
#
# ==== Writing to a string
#
#   # Dump an array, get back a YAML string
#   Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
#
#   # Dump an array to an IO object
#   Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
#
#   # Dump an array with indentation set
#   Psych.dump(['a', ['b']], :indentation => 3) # => "---\n- a\n-  - b\n"
#
#   # Dump an array to an IO with indentation set
#   Psych.dump(['a', ['b']], StringIO.new, :indentation => 3)
#
# ==== Writing to a file
#
# Currently there is no direct API for dumping Ruby structure to file:
#
#   File.open('database.yml', 'w') do |file|
#     file.write(Psych.dump(['a', 'b']))
#   end
#
# == Mid-level API
#
# === Parsing
#
# Psych provides access to an AST produced from parsing a YAML document.  This
# tree is built using the Psych::Parser and Psych::TreeBuilder.  The AST can
# be examined and manipulated freely.  Please see Psych::parse_stream,
# Psych::Nodes, and Psych::Nodes::Node for more information on dealing with
# YAML syntax trees.
#
# ==== Reading from a string
#
#   # Returns Psych::Nodes::Stream
#   Psych.parse_stream("---\n - a\n - b")
#
#   # Returns Psych::Nodes::Document
#   Psych.parse("---\n - a\n - b")
#
# ==== Reading from a file
#
#   # Returns Psych::Nodes::Stream
#   Psych.parse_stream(File.read('database.yml'))
#
#   # Returns Psych::Nodes::Document
#   Psych.parse_file('database.yml')
#
# ==== Exception handling
#
#   begin
#     # The second argument changes only the exception contents
#     Psych.parse("--- `", "file.txt")
#   rescue Psych::SyntaxError => ex
#     ex.file    # => 'file.txt'
#     ex.message # => "(file.txt): found character that cannot start any token"
#   end
#
# === Emitting
#
# At the mid level is building an AST.  This AST is exactly the same as the AST
# used when parsing a YAML document.  Users can build an AST by hand and the
# AST knows how to emit itself as a YAML document.  See Psych::Nodes,
# Psych::Nodes::Node, and Psych::TreeBuilder for more information on building
# a YAML AST.
#
# ==== Writing to a string
#
#   # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#   stream = Psych.parse_stream("---\n - a\n - b")
#
#   stream.to_yaml # => "---\n- a\n- b\n"
#
# ==== Writing to a file
#
#   # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#   stream = Psych.parse_stream(File.read('database.yml'))
#
#   File.open('database.yml', 'w') do |file|
#     file.write(stream.to_yaml)
#   end
#
# == Low-level API
#
# === Parsing
#
# The lowest level parser should be used when the YAML input is already known,
# and the developer does not want to pay the price of building an AST or
# automatic detection and conversion to Ruby objects.  See Psych::Parser for
# more information on using the event based parser.
#
# ==== Reading to Psych::Nodes::Stream structure
#
#   parser = Psych::Parser.new(TreeBuilder.new) # => #<Psych::Parser>
#   parser = Psych.parser                       # it's an alias for the above
#
#   parser.parse("---\n - a\n - b")             # => #<Psych::Parser>
#   parser.handler                              # => #<Psych::TreeBuilder>
#   parser.handler.root                         # => #<Psych::Nodes::Stream>
#
# ==== Receiving an events stream
#
#   recorder = Psych::Handlers::Recorder.new
#   parser = Psych::Parser.new(recorder)
#
#   parser.parse("---\n - a\n - b")
#   recorder.events # => [list of [event, args] lists]
#                   # event is one of: Psych::Handler::EVENTS
#                   # args are the arguments passed to the event
#
# === Emitting
#
# The lowest level emitter is an event based system.  Events are sent to a
# Psych::Emitter object.  That object knows how to convert the events to a YAML
# document.  This interface should be used when document format is known in
# advance or speed is a concern.  See Psych::Emitter for more information.
#
# ==== Writing to a Ruby structure
#
#   Psych.parser.parse("--- a")       # => #<Psych::Parser>
#
#   parser.handler.first              # => #<Psych::Nodes::Stream>
#   parser.handler.first.to_ruby      # => ["a"]
#
#   parser.handler.root.first         # => #<Psych::Nodes::Document>
#   parser.handler.root.first.to_ruby # => "a"
#
#   # You can instantiate an Emitter manually
#   Psych::Visitors::ToRuby.new.accept(parser.handler.root.first)
#   # => "a"
module Psych
  extend ::Bootsnap::CompileCache::YAML::Psych4::Patch

  class << self
    def add_builtin_type(type_tag, &block); end

    # :stopdoc:
    def add_domain_type(domain, type_tag, &block); end

    def add_tag(tag, klass); end
    def config; end
    def domain_types; end
    def domain_types=(value); end

    # call-seq:
    #   Psych.dump(o)               -> string of yaml
    #   Psych.dump(o, options)      -> string of yaml
    #   Psych.dump(o, io)           -> io object passed in
    #   Psych.dump(o, io, options)  -> io object passed in
    #
    # Dump Ruby object +o+ to a YAML string.  Optional +options+ may be passed in
    # to control the output format.  If an IO object is passed in, the YAML will
    # be dumped to that IO object.
    #
    # Currently supported options are:
    #
    # [<tt>:indentation</tt>]   Number of space characters used to indent.
    #                           Acceptable value should be in <tt>0..9</tt> range,
    #                           otherwise option is ignored.
    #
    #                           Default: <tt>2</tt>.
    # [<tt>:line_width</tt>]    Max character to wrap line at.
    #
    #                           Default: <tt>0</tt> (meaning "wrap at 81").
    # [<tt>:canonical</tt>]     Write "canonical" YAML form (very verbose, yet
    #                           strictly formal).
    #
    #                           Default: <tt>false</tt>.
    # [<tt>:header</tt>]        Write <tt>%YAML [version]</tt> at the beginning of document.
    #
    #                           Default: <tt>false</tt>.
    #
    # Example:
    #
    #   # Dump an array, get back a YAML string
    #   Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
    #
    #   # Dump an array to an IO object
    #   Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
    #
    #   # Dump an array with indentation set
    #   Psych.dump(['a', ['b']], indentation: 3) # => "---\n- a\n-  - b\n"
    #
    #   # Dump an array to an IO with indentation set
    #   Psych.dump(['a', ['b']], StringIO.new, indentation: 3)
    def dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end

    # Dump a list of objects as separate documents to a document stream.
    #
    # Example:
    #
    #   Psych.dump_stream("foo\n  ", {}) # => "--- ! \"foo\\n  \"\n--- {}\n"
    def dump_stream(*objects); end

    def dump_tags; end
    def dump_tags=(value); end

    # Load +yaml+ in to a Ruby data structure.  If multiple documents are
    # provided, the object contained in the first document will be returned.
    # +filename+ will be used in the exception message if any exception
    # is raised while parsing.  If +yaml+ is empty, it returns
    # the specified +fallback+ return value, which defaults to +false+.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.load("--- a")             # => 'a'
    #   Psych.load("---\n - a\n - b")   # => ['a', 'b']
    #
    #   begin
    #     Psych.load("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    #
    # Raises a TypeError when `yaml` parameter is NilClass.  This method is
    # similar to `safe_load` except that `Symbol` objects are allowed by default.
    def load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

    # Load multiple documents given in +yaml+.  Returns the parsed documents
    # as a list.  If a block is given, each document will be converted to Ruby
    # and passed to the block during parsing
    #
    # Example:
    #
    #   Psych.load_stream("--- foo\n...\n--- bar\n...") # => ['foo', 'bar']
    #
    #   list = []
    #   Psych.load_stream("--- foo\n...\n--- bar\n...") do |ruby|
    #     list << ruby
    #   end
    #   list # => ['foo', 'bar']
    def load_stream(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), **kwargs); end

    def load_tags; end
    def load_tags=(value); end

    # Parse a YAML string in +yaml+.  Returns the Psych::Nodes::Document.
    # +filename+ is used in the exception message if a Psych::SyntaxError is
    # raised.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.parse("---\n - a\n - b") # => #<Psych::Nodes::Document:0x00>
    #
    #   begin
    #     Psych.parse("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # See Psych::Nodes for more information about YAML AST.
    def parse(yaml, filename: T.unsafe(nil)); end

    # Parse a file at +filename+. Returns the Psych::Nodes::Document.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    def parse_file(filename, fallback: T.unsafe(nil)); end

    # Parse a YAML string in +yaml+.  Returns the Psych::Nodes::Stream.
    # This method can handle multiple YAML documents contained in +yaml+.
    # +filename+ is used in the exception message if a Psych::SyntaxError is
    # raised.
    #
    # If a block is given, a Psych::Nodes::Document node will be yielded to the
    # block as it's being parsed.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.parse_stream("---\n - a\n - b") # => #<Psych::Nodes::Stream:0x00>
    #
    #   Psych.parse_stream("--- a\n--- b") do |node|
    #     node # => #<Psych::Nodes::Document:0x00>
    #   end
    #
    #   begin
    #     Psych.parse_stream("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # Raises a TypeError when NilClass is passed.
    #
    # See Psych::Nodes for more information about YAML AST.
    def parse_stream(yaml, filename: T.unsafe(nil), &block); end

    # Returns a default parser
    def parser; end

    def remove_type(type_tag); end

    # call-seq:
    #   Psych.safe_dump(o)               -> string of yaml
    #   Psych.safe_dump(o, options)      -> string of yaml
    #   Psych.safe_dump(o, io)           -> io object passed in
    #   Psych.safe_dump(o, io, options)  -> io object passed in
    #
    # Safely dump Ruby object +o+ to a YAML string. Optional +options+ may be passed in
    # to control the output format.  If an IO object is passed in, the YAML will
    # be dumped to that IO object. By default, only the following
    # classes are allowed to be serialized:
    #
    # * TrueClass
    # * FalseClass
    # * NilClass
    # * Integer
    # * Float
    # * String
    # * Array
    # * Hash
    #
    # Arbitrary classes can be allowed by adding those classes to the +permitted_classes+
    # keyword argument.  They are additive.  For example, to allow Date serialization:
    #
    #   Psych.safe_dump(yaml, permitted_classes: [Date])
    #
    # Now the Date class can be dumped in addition to the classes listed above.
    #
    # A Psych::DisallowedClass exception will be raised if the object contains a
    # class that isn't in the +permitted_classes+ list.
    #
    # Currently supported options are:
    #
    # [<tt>:indentation</tt>]   Number of space characters used to indent.
    #                           Acceptable value should be in <tt>0..9</tt> range,
    #                           otherwise option is ignored.
    #
    #                           Default: <tt>2</tt>.
    # [<tt>:line_width</tt>]    Max character to wrap line at.
    #
    #                           Default: <tt>0</tt> (meaning "wrap at 81").
    # [<tt>:canonical</tt>]     Write "canonical" YAML form (very verbose, yet
    #                           strictly formal).
    #
    #                           Default: <tt>false</tt>.
    # [<tt>:header</tt>]        Write <tt>%YAML [version]</tt> at the beginning of document.
    #
    #                           Default: <tt>false</tt>.
    #
    # Example:
    #
    #   # Dump an array, get back a YAML string
    #   Psych.safe_dump(['a', 'b'])  # => "---\n- a\n- b\n"
    #
    #   # Dump an array to an IO object
    #   Psych.safe_dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
    #
    #   # Dump an array with indentation set
    #   Psych.safe_dump(['a', ['b']], indentation: 3) # => "---\n- a\n-  - b\n"
    #
    #   # Dump an array to an IO with indentation set
    #   Psych.safe_dump(['a', ['b']], StringIO.new, indentation: 3)
    def safe_dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end

    # Safely load the yaml string in +yaml+.  By default, only the following
    # classes are allowed to be deserialized:
    #
    # * TrueClass
    # * FalseClass
    # * NilClass
    # * Integer
    # * Float
    # * String
    # * Array
    # * Hash
    #
    # Recursive data structures are not allowed by default.  Arbitrary classes
    # can be allowed by adding those classes to the +permitted_classes+ keyword argument.  They are
    # additive.  For example, to allow Date deserialization:
    #
    #   Psych.safe_load(yaml, permitted_classes: [Date])
    #
    # Now the Date class can be loaded in addition to the classes listed above.
    #
    # Aliases can be explicitly allowed by changing the +aliases+ keyword argument.
    # For example:
    #
    #   x = []
    #   x << x
    #   yaml = Psych.dump x
    #   Psych.safe_load yaml               # => raises an exception
    #   Psych.safe_load yaml, aliases: true # => loads the aliases
    #
    # A Psych::DisallowedClass exception will be raised if the yaml contains a
    # class that isn't in the +permitted_classes+ list.
    #
    # A Psych::AliasesNotEnabled exception will be raised if the yaml contains aliases
    # but the +aliases+ keyword argument is set to false.
    #
    # +filename+ will be used in the exception message if any exception is raised
    # while parsing.
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.safe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.safe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    def safe_load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

    # Safely loads the document contained in +filename+.  Returns the yaml contained in
    # +filename+ as a Ruby object, or if the file is empty, it returns
    # the specified +fallback+ return value, which defaults to +false+.
    # See safe_load for options.
    def safe_load_file(filename, **kwargs); end

    # Dump Ruby +object+ to a JSON string.
    def to_json(object); end

    # Load +yaml+ in to a Ruby data structure.  If multiple documents are
    # provided, the object contained in the first document will be returned.
    # +filename+ will be used in the exception message if any exception
    # is raised while parsing.  If +yaml+ is empty, it returns
    # the specified +fallback+ return value, which defaults to +false+.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.unsafe_load("--- a")             # => 'a'
    #   Psych.unsafe_load("---\n - a\n - b")   # => ['a', 'b']
    #
    #   begin
    #     Psych.unsafe_load("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.unsafe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.unsafe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    #
    # Raises a TypeError when `yaml` parameter is NilClass
    #
    # NOTE: This method *should not* be used to parse untrusted documents, such as
    # YAML documents that are supplied via user input.  Instead, please use the
    # load method or the safe_load method.
    def unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
  end
end

# Subclasses `BadAlias` for backwards compatibility
class Psych::AliasesNotEnabled < ::Psych::BadAlias
  # @return [AliasesNotEnabled] a new instance of AliasesNotEnabled
  def initialize; end
end

# Subclasses `BadAlias` for backwards compatibility
class Psych::AnchorNotDefined < ::Psych::BadAlias
  # @return [AnchorNotDefined] a new instance of AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::ClassLoader
  # @return [ClassLoader] a new instance of ClassLoader
  def initialize; end

  def big_decimal; end
  def complex; end
  def date; end
  def date_time; end
  def exception; end
  def load(klassname); end
  def object; end
  def psych_omap; end
  def psych_set; end
  def range; end
  def rational; end
  def regexp; end
  def struct; end
  def symbol; end
  def symbolize(sym); end

  private

  def find(klassname); end
  def resolve(klassname); end
end

class Psych::ClassLoader::Restricted < ::Psych::ClassLoader
  # @return [Restricted] a new instance of Restricted
  def initialize(classes, symbols); end

  def symbolize(sym); end

  private

  def find(klassname); end
end

# If an object defines +encode_with+, then an instance of Psych::Coder will
# be passed to the method when the object is being serialized.  The Coder
# automatically assumes a Psych::Nodes::Mapping is being emitted.  Other
# objects like Sequence and Scalar may be emitted if +seq=+ or +scalar=+ are
# called, respectively.
class Psych::Coder
  # @return [Coder] a new instance of Coder
  def initialize(tag); end

  def [](k); end
  def []=(k, v); end
  def add(k, v); end

  # Returns the value of attribute implicit.
  def implicit; end

  # Sets the attribute implicit
  #
  # @param value the value to set the attribute implicit to.
  def implicit=(_arg0); end

  # Emit a map.  The coder will be yielded to the block.
  #
  # @yield [_self]
  # @yieldparam _self [Psych::Coder] the object that the method was called on
  def map(tag = T.unsafe(nil), style = T.unsafe(nil)); end

  # Emit a map with +value+
  def map=(map); end

  # Returns the value of attribute object.
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  def object=(_arg0); end

  # Emit a sequence with +map+ and +tag+
  def represent_map(tag, map); end

  # Emit an arbitrary object +obj+ and +tag+
  def represent_object(tag, obj); end

  # Emit a scalar with +value+ and +tag+
  def represent_scalar(tag, value); end

  # Emit a sequence with +list+ and +tag+
  def represent_seq(tag, list); end

  def scalar(*args); end

  # Emit a scalar with +value+
  def scalar=(value); end

  # Returns the value of attribute seq.
  def seq; end

  # Emit a sequence of +list+
  def seq=(list); end

  # Returns the value of attribute style.
  def style; end

  # Sets the attribute style
  #
  # @param value the value to set the attribute style to.
  def style=(_arg0); end

  # Returns the value of attribute tag.
  def tag; end

  # Sets the attribute tag
  #
  # @param value the value to set the attribute tag to.
  def tag=(_arg0); end

  # Returns the value of attribute type.
  def type; end
end

class Psych::DisallowedClass < ::Psych::Exception
  # @return [DisallowedClass] a new instance of DisallowedClass
  def initialize(action, klass_name); end
end

# Psych::Handler is an abstract base class that defines the events used
# when dealing with Psych::Parser.  Clients who want to use Psych::Parser
# should implement a class that inherits from Psych::Handler and define
# events that they can handle.
#
# Psych::Handler defines all events that Psych::Parser can possibly send to
# event handlers.
#
# See Psych::Parser for more details
class Psych::Handler
  # Called when an alias is found to +anchor+.  +anchor+ will be the name
  # of the anchor found.
  #
  # === Example
  #
  # Here we have an example of an array that references itself in YAML:
  #
  #   --- &ponies
  #   - first element
  #   - *ponies
  #
  # &ponies is the anchor, *ponies is the alias.  In this case, alias is
  # called with "ponies".
  def alias(anchor); end

  # Called when an empty event happens. (Which, as far as I can tell, is
  # never).
  def empty; end

  # Called with the document ends.  +implicit+ is a boolean value indicating
  # whether or not the document has an implicit ending.
  #
  # === Example
  #
  # Given the following YAML:
  #
  #   ---
  #     hello world
  #
  # +implicit+ will be true.  Given this YAML:
  #
  #   ---
  #     hello world
  #   ...
  #
  # +implicit+ will be false.
  def end_document(implicit); end

  # Called when a map ends
  def end_mapping; end

  # Called when a sequence ends.
  def end_sequence; end

  # Called when the YAML stream ends
  def end_stream; end

  # Called before each event with line/column information.
  def event_location(start_line, start_column, end_line, end_column); end

  # Called when a scalar +value+ is found.  The scalar may have an
  # +anchor+, a +tag+, be implicitly +plain+ or implicitly +quoted+
  #
  # +value+ is the string value of the scalar
  # +anchor+ is an associated anchor or nil
  # +tag+ is an associated tag or nil
  # +plain+ is a boolean value
  # +quoted+ is a boolean value
  # +style+ is an integer indicating the string style
  #
  # See the constants in Psych::Nodes::Scalar for the possible values of
  # +style+
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   - !str "foo"
  #   - &anchor fun
  #   - many
  #     lines
  #   - |
  #     many
  #     newlines
  #
  # The above YAML document contains a list with four strings.  Here are
  # the parameters sent to this method in the same order:
  #
  #   # value               anchor    tag     plain   quoted  style
  #   ["foo",               nil,      "!str", false,  false,  3    ]
  #   ["fun",               "anchor", nil,    true,   false,  1    ]
  #   ["many lines",        nil,      nil,    true,   false,  1    ]
  #   ["many\nnewlines\n",  nil,      nil,    false,  true,   4    ]
  def scalar(value, anchor, tag, plain, quoted, style); end

  # Called when the document starts with the declared +version+,
  # +tag_directives+, if the document is +implicit+.
  #
  # +version+ will be an array of integers indicating the YAML version being
  # dealt with, +tag_directives+ is a list of tuples indicating the prefix
  # and suffix of each tag, and +implicit+ is a boolean indicating whether
  # the document is started implicitly.
  #
  # === Example
  #
  # Given the following YAML:
  #
  #   %YAML 1.1
  #   %TAG ! tag:tenderlovemaking.com,2009:
  #   --- !squee
  #
  # The parameters for start_document must be this:
  #
  #   version         # => [1, 1]
  #   tag_directives  # => [["!", "tag:tenderlovemaking.com,2009:"]]
  #   implicit        # => false
  def start_document(version, tag_directives, implicit); end

  # Called when a map starts.
  #
  # +anchor+ is the anchor associated with the map or +nil+.
  # +tag+ is the tag associated with the map or +nil+.
  # +implicit+ is a boolean indicating whether or not the map was implicitly
  # started.
  # +style+ is an integer indicating the mapping style.
  #
  # See the constants in Psych::Nodes::Mapping for the possible values of
  # +style+.
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   k: !!map { hello: world }
  #   v: &pewpew
  #     hello: world
  #
  # The above YAML document consists of three maps, an outer map that contains
  # two inner maps.  Below is a matrix of the parameters sent in order to
  # represent these three maps:
  #
  #   # anchor    tag                       implicit  style
  #   [nil,       nil,                      true,     1     ]
  #   [nil,       "tag:yaml.org,2002:map",  false,    2     ]
  #   ["pewpew",  nil,                      true,     1     ]
  def start_mapping(anchor, tag, implicit, style); end

  # Called when a sequence is started.
  #
  # +anchor+ is the anchor associated with the sequence or nil.
  # +tag+ is the tag associated with the sequence or nil.
  # +implicit+ a boolean indicating whether or not the sequence was implicitly
  # started.
  # +style+ is an integer indicating the list style.
  #
  # See the constants in Psych::Nodes::Sequence for the possible values of
  # +style+.
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   - !!seq [
  #     a
  #   ]
  #   - &pewpew
  #     - b
  #
  # The above YAML document consists of three lists, an outer list that
  # contains two inner lists.  Here is a matrix of the parameters sent
  # to represent these lists:
  #
  #   # anchor    tag                       implicit  style
  #   [nil,       nil,                      true,     1     ]
  #   [nil,       "tag:yaml.org,2002:seq",  false,    2     ]
  #   ["pewpew",  nil,                      true,     1     ]
  def start_sequence(anchor, tag, implicit, style); end

  # Called with +encoding+ when the YAML stream starts.  This method is
  # called once per stream.  A stream may contain multiple documents.
  #
  # See the constants in Psych::Parser for the possible values of +encoding+.
  def start_stream(encoding); end

  # Is this handler a streaming handler?
  #
  # @return [Boolean]
  def streaming?; end
end

# Configuration options for dumping YAML.
class Psych::Handler::DumperOptions
  # @return [DumperOptions] a new instance of DumperOptions
  def initialize; end

  # Returns the value of attribute canonical.
  def canonical; end

  # Sets the attribute canonical
  #
  # @param value the value to set the attribute canonical to.
  def canonical=(_arg0); end

  # Returns the value of attribute indentation.
  def indentation; end

  # Sets the attribute indentation
  #
  # @param value the value to set the attribute indentation to.
  def indentation=(_arg0); end

  # Returns the value of attribute line_width.
  def line_width; end

  # Sets the attribute line_width
  #
  # @param value the value to set the attribute line_width to.
  def line_width=(_arg0); end
end

class Psych::JSON::Stream < ::Psych::Visitors::JSONTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

# YAML event parser class.  This class parses a YAML document and calls
# events on the handler that is passed to the constructor.  The events can
# be used for things such as constructing a YAML AST or deserializing YAML
# documents.  It can even be fed back to Psych::Emitter to emit the same
# document that was parsed.
#
# See Psych::Handler for documentation on the events that Psych::Parser emits.
#
# Here is an example that prints out ever scalar found in a YAML document:
#
#   # Handler for detecting scalar values
#   class ScalarHandler < Psych::Handler
#     def scalar value, anchor, tag, plain, quoted, style
#       puts value
#     end
#   end
#
#   parser = Psych::Parser.new(ScalarHandler.new)
#   parser.parse(yaml_document)
#
# Here is an example that feeds the parser back in to Psych::Emitter.  The
# YAML document is read from STDIN and written back out to STDERR:
#
#   parser = Psych::Parser.new(Psych::Emitter.new($stderr))
#   parser.parse($stdin)
#
# Psych uses Psych::Parser in combination with Psych::TreeBuilder to
# construct an AST of the parsed YAML document.
class Psych::Parser
  # Creates a new Psych::Parser instance with +handler+.  YAML events will
  # be called on +handler+.  See Psych::Parser for more details.
  #
  # @return [Parser] a new instance of Parser
  def initialize(handler = T.unsafe(nil)); end

  # Set the encoding for this parser to +encoding+
  def external_encoding=(_arg0); end

  # The handler on which events will be called
  def handler; end

  # The handler on which events will be called
  def handler=(_arg0); end

  # call-seq:
  #    parser.parse(yaml)
  #
  # Parse the YAML document contained in +yaml+.  Events will be called on
  # the handler set on the parser instance.
  #
  # See Psych::Parser and Psych::Parser#handler
  def parse(yaml, path = T.unsafe(nil)); end
end

# Scan scalars for built in types
class Psych::ScalarScanner
  # Create a new scanner
  #
  # @return [ScalarScanner] a new instance of ScalarScanner
  def initialize(class_loader, strict_integer: T.unsafe(nil)); end

  # Returns the value of attribute class_loader.
  def class_loader; end

  # Parse and return an int from +string+
  def parse_int(string); end

  # Parse and return a Time from +string+
  def parse_time(string); end

  # Tokenize +string+ returning the Ruby object
  def tokenize(string); end
end

# Same as above, but allows commas.
# Not to YML spec, but kept for backwards compatibility
Psych::ScalarScanner::INTEGER_LEGACY = T.let(T.unsafe(nil), Regexp)

# Taken from http://yaml.org/type/int.html
Psych::ScalarScanner::INTEGER_STRICT = T.let(T.unsafe(nil), Regexp)

# Psych::Stream is a streaming YAML emitter.  It will not buffer your YAML,
# but send it straight to an IO.
#
# Here is an example use:
#
#   stream = Psych::Stream.new($stdout)
#   stream.start
#   stream.push({:foo => 'bar'})
#   stream.finish
#
# YAML will be immediately emitted to $stdout with no buffering.
#
# Psych::Stream#start will take a block and ensure that Psych::Stream#finish
# is called, so you can do this form:
#
#   stream = Psych::Stream.new($stdout)
#   stream.start do |em|
#     em.push(:foo => 'bar')
#   end
class Psych::Stream < ::Psych::Visitors::YAMLTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

class Psych::Stream::Emitter < ::Psych::Emitter
  def end_document(implicit_end = T.unsafe(nil)); end

  # @return [Boolean]
  def streaming?; end
end

module Psych::Streaming
  # Start streaming using +encoding+
  def start(encoding = T.unsafe(nil)); end

  private

  def register(target, obj); end
end

module Psych::Streaming::ClassMethods
  # Create a new streaming emitter.  Emitter will print to +io+.  See
  # Psych::Stream for an example.
  def new(io); end
end

class Psych::SyntaxError < ::Psych::Exception
  # @return [SyntaxError] a new instance of SyntaxError
  def initialize(file, line, col, offset, problem, context); end

  # Returns the value of attribute column.
  def column; end

  # Returns the value of attribute context.
  def context; end

  # Returns the value of attribute file.
  def file; end

  # Returns the value of attribute line.
  def line; end

  # Returns the value of attribute offset.
  def offset; end

  # Returns the value of attribute problem.
  def problem; end
end

# This class works in conjunction with Psych::Parser to build an in-memory
# parse tree that represents a YAML document.
#
# == Example
#
#   parser = Psych::Parser.new Psych::TreeBuilder.new
#   parser.parse('--- foo')
#   tree = parser.handler.root
#
# See Psych::Handler for documentation on the event methods used in this
# class.
class Psych::TreeBuilder < ::Psych::Handler
  # Create a new TreeBuilder instance
  #
  # @return [TreeBuilder] a new instance of TreeBuilder
  def initialize; end

  def alias(anchor); end

  # Handles end_document events with +version+, +tag_directives+,
  # and +implicit+ styling.
  #
  # See Psych::Handler#start_document
  def end_document(implicit_end = T.unsafe(nil)); end

  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def event_location(start_line, start_column, end_line, end_column); end

  # Returns the root node for the built tree
  def root; end

  def scalar(value, anchor, tag, plain, quoted, style); end

  # Handles start_document events with +version+, +tag_directives+,
  # and +implicit+ styling.
  #
  # See Psych::Handler#start_document
  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
  def start_stream(encoding); end

  private

  def pop; end
  def push(value); end
  def set_end_location(node); end
  def set_location(node); end
  def set_start_location(node); end
end

# The version of Psych you are using
Psych::VERSION = T.let(T.unsafe(nil), String)

class Psych::Visitors::DepthFirst < ::Psych::Visitors::Visitor
  # @return [DepthFirst] a new instance of DepthFirst
  def initialize(block); end

  private

  def nary(o); end
  def terminal(o); end
  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::RestrictedYAMLTree < ::Psych::Visitors::YAMLTree
  # @return [RestrictedYAMLTree] a new instance of RestrictedYAMLTree
  def initialize(emitter, ss, options); end

  def accept(target); end
  def visit_Symbol(sym); end
end

Psych::Visitors::RestrictedYAMLTree::DEFAULT_PERMITTED_CLASSES = T.let(T.unsafe(nil), Hash)

# This class walks a YAML AST, converting each node to Ruby
class Psych::Visitors::ToRuby < ::Psych::Visitors::Visitor
  # @return [ToRuby] a new instance of ToRuby
  def initialize(ss, class_loader, symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end

  def accept(target); end

  # Returns the value of attribute class_loader.
  def class_loader; end

  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end

  private

  def deduplicate(key); end
  def deserialize(o); end
  def init_with(o, h, node); end
  def merge_key(hash, key, val); end
  def register(node, object); end
  def register_empty(object); end

  # Convert +klassname+ to a Class
  def resolve_class(klassname); end

  def revive(klass, node); end
  def revive_hash(hash, o, tagged = T.unsafe(nil)); end

  class << self
    def create(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
  end
end

class Psych::Visitors::Visitor
  def accept(target); end

  private

  def dispatch; end
  def visit(target); end

  class << self
    # @api private
    def dispatch_cache; end
  end
end

# YAMLTree builds a YAML ast given a Ruby object.  For example:
#
#   builder = Psych::Visitors::YAMLTree.new
#   builder << { :foo => 'bar' }
#   builder.tree # => #<Psych::Nodes::Stream .. }
class Psych::Visitors::YAMLTree < ::Psych::Visitors::Visitor
  # @return [YAMLTree] a new instance of YAMLTree
  def initialize(emitter, ss, options); end

  def <<(object); end
  def accept(target); end
  def finish; end

  # Returns the value of attribute finished.
  def finished; end

  # Returns the value of attribute finished.
  def finished?; end

  def push(object); end
  def start(encoding = T.unsafe(nil)); end

  # Returns the value of attribute started.
  def started; end

  # Returns the value of attribute started.
  def started?; end

  def tree; end
  def visit_Array(o); end
  def visit_BasicObject(o); end
  def visit_BigDecimal(o); end

  # @raise [TypeError]
  def visit_Class(o); end

  def visit_Complex(o); end
  def visit_Date(o); end
  def visit_DateTime(o); end
  def visit_Delegator(o); end
  def visit_Encoding(o); end
  def visit_Enumerator(o); end
  def visit_Exception(o); end
  def visit_FalseClass(o); end
  def visit_Float(o); end
  def visit_Hash(o); end
  def visit_Integer(o); end

  # @raise [TypeError]
  def visit_Module(o); end

  def visit_NameError(o); end
  def visit_NilClass(o); end
  def visit_Object(o); end
  def visit_Psych_Omap(o); end
  def visit_Psych_Set(o); end
  def visit_Range(o); end
  def visit_Rational(o); end
  def visit_Regexp(o); end
  def visit_String(o); end
  def visit_Struct(o); end
  def visit_Symbol(o); end
  def visit_Time(o); end
  def visit_TrueClass(o); end

  private

  # @return [Boolean]
  def binary?(string); end

  def dump_coder(o); end
  def dump_exception(o, msg); end
  def dump_ivars(target); end
  def dump_list(o); end
  def emit_coder(c, o); end
  def format_time(time, utc = T.unsafe(nil)); end
  def register(target, yaml_obj); end
  def visit_array_subclass(o); end
  def visit_hash_subclass(o); end

  class << self
    def create(options = T.unsafe(nil), emitter = T.unsafe(nil)); end
  end
end

class Psych::Visitors::YAMLTree::Registrar
  # @return [Registrar] a new instance of Registrar
  def initialize; end

  def id_for(target); end

  # @return [Boolean]
  def key?(target); end

  def node_for(target); end
  def register(target, node); end
end
