# typed: strict

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `scanf` gem.
# Please instead update this file by running `bin/tapioca gem scanf`.

# HighLine adds #getbyte alias to #getc when #getbyte is not available.
class IO
  include ::Enumerable
  include ::File::Constants

  # Scans the current string until the match is exhausted,
  # yielding each match as it is encountered in the string.
  # A block is not necessary though, as the results will simply
  # be aggregated into the final array.
  #
  #   "123 456".block_scanf("%d")
  #   # => [123, 456]
  #
  # If a block is given, the value from that is returned from
  # the yield is added to an output array.
  #
  #   "123 456".block_scanf("%d") do |digit,| # the ',' unpacks the Array
  #     digit + 100
  #   end
  #   # => [223, 556]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use IO#scanf.
  def scanf(str, &b); end

  private

  def block_scanf(str); end
  def soak_up_spaces; end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)

# Kernel extensions for minitest
module Kernel
  private

  # Scans STDIN for data matching +format+.  See IO#scanf for details.
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use Kernel#scanf.
  def scanf(format, &b); end
end

# ==Technical notes
#
# ===Rationale behind scanf for Ruby
#
# The impetus for a scanf implementation in Ruby comes chiefly from the fact
# that existing pattern matching operations, such as Regexp#match and
# String#scan, return all results as strings, which have to be converted to
# integers or floats explicitly in cases where what's ultimately wanted are
# integer or float values.
#
# ===Design of scanf for Ruby
#
# scanf for Ruby is essentially a <format string>-to-<regular
# expression> converter.
#
# When scanf is called, a FormatString object is generated from the
# format string ("%d%s...") argument. The FormatString object breaks the
# format string down into atoms ("%d", "%5f", "blah", etc.), and from
# each atom it creates a FormatSpecifier object, which it
# saves.
#
# Each FormatSpecifier has a regular expression fragment and a "handler"
# associated with it. For example, the regular expression fragment
# associated with the format "%d" is "([-+]?\d+)", and the handler
# associated with it is a wrapper around String#to_i. scanf itself calls
# FormatString#match, passing in the input string. FormatString#match
# iterates through its FormatSpecifiers; for each one, it matches the
# corresponding regular expression fragment against the string. If
# there's a match, it sends the matched string to the handler associated
# with the FormatSpecifier.
#
# Thus, to follow up the "%d" example: if "123" occurs in the input
# string when a FormatSpecifier consisting of "%d" is reached, the "123"
# will be matched against "([-+]?\d+)", and the matched string will be
# rendered into an integer by a call to to_i.
#
# The rendered match is then saved to an accumulator array, and the
# input string is reduced to the post-match substring. Thus the string
# is "eaten" from the left as the FormatSpecifiers are applied in
# sequence.  (This is done to a duplicate string; the original string is
# not altered.)
#
# As soon as a regular expression fragment fails to match the string, or
# when the FormatString object runs out of FormatSpecifiers, scanning
# stops and results accumulated so far are returned in an array.
class Scanf::FormatSpecifier
  # @return [FormatSpecifier] a new instance of FormatSpecifier
  def initialize(str); end

  # Returns the value of attribute conversion.
  def conversion; end

  # @return [Boolean]
  def count_space?; end

  def letter; end
  def match(str); end

  # Returns the value of attribute matched.
  def matched; end

  # Returns the value of attribute matched_string.
  def matched_string; end

  # @return [Boolean]
  def mid_match?; end

  # Returns the value of attribute re_string.
  def re_string; end

  def to_re; end
  def to_s; end
  def width; end

  private

  def extract_decimal(s); end
  def extract_float(s); end
  def extract_hex(s); end
  def extract_integer(s); end
  def extract_octal(s); end
  def extract_plain(s); end
  def nil_proc(s); end
  def skip; end
end

class Scanf::FormatString
  # @return [FormatString] a new instance of FormatString
  def initialize(str); end

  # Returns the value of attribute last_match_tried.
  def last_match_tried; end

  def last_spec; end

  # Returns the value of attribute last_spec_tried.
  def last_spec_tried; end

  def match(str); end

  # Returns the value of attribute matched_count.
  def matched_count; end

  def prune(n = T.unsafe(nil)); end

  # Returns the value of attribute space.
  def space; end

  def spec_count; end

  # Returns the value of attribute string_left.
  def string_left; end

  def to_s; end
end

Scanf::FormatString::REGEX = T.let(T.unsafe(nil), Regexp)
Scanf::FormatString::SPECIFIERS = T.let(T.unsafe(nil), String)

# Extensions to the core String class
class String
  include ::Comparable

  # Scans the current string until the match is exhausted
  # yielding each match as it is encountered in the string.
  # A block is not necessary as the results will simply
  # be aggregated into the final array.
  #
  #   "123 456".block_scanf("%d")
  #   # => [123, 456]
  #
  # If a block is given, the value from that is returned from
  # the yield is added to an output array.
  #
  #   "123 456".block_scanf("%d) do |digit,| # the ',' unpacks the Array
  #     digit + 100
  #   end
  #   # => [223, 556]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use String#block_scanf
  def block_scanf(fstr); end

  # Scans the current string. If a block is given, it
  # functions exactly like block_scanf.
  #
  #   arr = "123 456".scanf("%d%d")
  #   # => [123, 456]
  #
  #   require 'pp'
  #
  #   "this 123 read that 456 other".scanf("%s%d%s") {|m| pp m}
  #
  #   # ["this", 123, "read"]
  #   # ["that", 456, "other"]
  #   # => [["this", 123, "read"], ["that", 456, "other"]]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use String#scanf
  def scanf(fstr, &b); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
