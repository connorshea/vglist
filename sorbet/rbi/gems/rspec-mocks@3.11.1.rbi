# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-mocks` gem.
# Please instead update this file by running `bin/tapioca gem rspec-mocks`.

# Share the top-level RSpec namespace, because we are a core supported
# extension.
module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    # Used to ensure examples get reloaded between multiple runs in the same
    # process and ensures user configuration is persisted.
    #
    # Users must invoke this if they want to clear all examples but preserve
    # current configuration when they use the runner multiple times within the
    # same process.
    def clear_examples; end

    # Returns the global [Configuration](RSpec/Core/Configuration) object. While
    # you _can_ use this method to access the configuration, the more common
    # convention is to use [RSpec.configure](RSpec#configure-class_method).
    #
    # @example
    #   RSpec.configuration.drb_port = 1234
    # @see RSpec.configure
    # @see Core::Configuration
    def configuration; end

    # Setters for shared global objects
    #
    # @api private
    def configuration=(_arg0); end

    # Yields the global configuration to a block.
    #
    # @example
    #   RSpec.configure do |config|
    #   config.add_formatter 'documentation'
    #   end
    # @see Core::Configuration
    # @yield [Configuration] global configuration
    def configure; end

    # @private
    def const_missing(name); end

    def context(*args, &example_group_block); end

    # The example being executed.
    #
    # The primary audience for this method is library authors who need access
    # to the example currently being executed and also want to support all
    # versions of RSpec 2 and 3.
    #
    # @example
    #
    #   RSpec.configure do |c|
    #   # context.example is deprecated, but RSpec.current_example is not
    #   # available until RSpec 3.0.
    #   fetch_current_example = RSpec.respond_to?(:current_example) ?
    #   proc { RSpec.current_example } : proc { |context| context.example }
    #
    #   c.before(:example) do
    #   example = fetch_current_example.call(self)
    #
    #   # ...
    #   end
    #   end
    def current_example; end

    # Set the current example being executed.
    #
    # @api private
    def current_example=(example); end

    # Get the current RSpec execution scope
    #
    # Returns (in order of lifecycle):
    #   * `:suite` as an initial value, this is outside of the test lifecycle.
    #   * `:before_suite_hook` during `before(:suite)` hooks.
    #   * `:before_context_hook` during `before(:context)` hooks.
    #   * `:before_example_hook` during `before(:example)` hooks and `around(:example)` before `example.run`.
    #   * `:example` within the example run.
    #   * `:after_example_hook` during `after(:example)` hooks and `around(:example)` after `example.run`.
    #   * `:after_context_hook` during `after(:context)` hooks.
    #   * `:after_suite_hook` during `after(:suite)` hooks.
    #   * `:suite` as a final value, again this is outside of the test lifecycle.
    #
    # Reminder, `:context` hooks have `:all` alias and `:example` hooks have `:each` alias.
    #
    # @return [Symbol]
    def current_scope; end

    # Set the current scope rspec is executing in
    #
    # @api private
    def current_scope=(scope); end

    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def feature(*args, &example_group_block); end
    def ffeature(*args, &example_group_block); end

    # Used to ensure examples get reloaded and user configuration gets reset to
    # defaults between multiple runs in the same process.
    #
    # Users must invoke this if they want to have the configuration reset when
    # they use the runner multiple times within the same process. Users must deal
    # themselves with re-configuration of RSpec before run.
    def reset; end

    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end

    # Internal container for global non-configuration data.
    #
    # @private
    def world; end

    # Setters for shared global objects
    #
    # @api private
    def world=(_arg0); end

    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
    def xfeature(*args, &example_group_block); end
  end
end

# @private
RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)

# Contains top-level utility methods. While this contains a few
# public methods, these are not generally meant to be called from
# a test or example. They exist primarily for integration with
# test frameworks (such as rspec-core).
module RSpec::Mocks; end

# ArgumentMatchers are placeholders that you can include in message
# expectations to match arguments against a broader check than simple
# equality.
#
# With the exception of `any_args` and `no_args`, they all match against
# the arg in same position in the argument list.
#
# @see ArgumentListMatcher
module RSpec::Mocks::ArgumentMatchers
  # Matches if `arg.kind_of?(klass)`
  #
  # @example
  #   expect(object).to receive(:message).with(kind_of(Thing))
  def a_kind_of(klass); end

  # Matches if `arg.instance_of?(klass)`
  #
  # @example
  #   expect(object).to receive(:message).with(instance_of(Thing))
  def an_instance_of(klass); end

  # Acts like an arg splat, matching any number of args at any point in an arg list.
  #
  # @example
  #   expect(object).to receive(:message).with(1, 2, any_args)
  #
  #   # matches any of these:
  #   object.message(1, 2)
  #   object.message(1, 2, 3)
  #   object.message(1, 2, 3, 4)
  def any_args; end

  # Matches any argument at all.
  #
  # @example
  #   expect(object).to receive(:message).with(anything)
  def anything; end

  # Matches an array that includes the specified items at least once.
  # Ignores duplicates and additional values
  #
  # @example
  #   expect(object).to receive(:message).with(array_including(1,2,3))
  #   expect(object).to receive(:message).with(array_including([1,2,3]))
  def array_including(*args); end

  # Matches a boolean value.
  #
  # @example
  #   expect(object).to receive(:message).with(boolean())
  def boolean; end

  # Matches if the actual argument responds to the specified messages.
  #
  # @example
  #   expect(object).to receive(:message).with(duck_type(:hello))
  #   expect(object).to receive(:message).with(duck_type(:hello, :goodbye))
  def duck_type(*args); end

  # Matches a hash that doesn't include the specified key(s) or key/value.
  #
  # @example
  #   expect(object).to receive(:message).with(hash_excluding(:key => val))
  #   expect(object).to receive(:message).with(hash_excluding(:key))
  #   expect(object).to receive(:message).with(hash_excluding(:key, :key2 => :val2))
  def hash_excluding(*args); end

  # Matches a hash that includes the specified key(s) or key/value pairs.
  # Ignores any additional keys.
  #
  # @example
  #   expect(object).to receive(:message).with(hash_including(:key => val))
  #   expect(object).to receive(:message).with(hash_including(:key))
  #   expect(object).to receive(:message).with(hash_including(:key, :key2 => val2))
  def hash_including(*args); end

  # Matches a hash that doesn't include the specified key(s) or key/value.
  #
  # @example
  #   expect(object).to receive(:message).with(hash_excluding(:key => val))
  #   expect(object).to receive(:message).with(hash_excluding(:key))
  #   expect(object).to receive(:message).with(hash_excluding(:key, :key2 => :val2))
  def hash_not_including(*args); end

  # Matches if `arg.instance_of?(klass)`
  #
  # @example
  #   expect(object).to receive(:message).with(instance_of(Thing))
  def instance_of(klass); end

  # Matches if `arg.kind_of?(klass)`
  #
  # @example
  #   expect(object).to receive(:message).with(kind_of(Thing))
  def kind_of(klass); end

  # Matches no arguments.
  #
  # @example
  #   expect(object).to receive(:message).with(no_args)
  def no_args; end

  class << self
    # @private
    def anythingize_lonely_keys(*args); end
  end
end

# @private
class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher < ::RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def ===(_other); end
  def description; end
end

RSpec::Mocks::ArgumentMatchers::AnyArgMatcher::INSTANCE = T.let(T.unsafe(nil), RSpec::Mocks::ArgumentMatchers::AnyArgMatcher)

# @private
class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher < ::RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def description; end
end

RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher::INSTANCE = T.let(T.unsafe(nil), RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher)

# @private
class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
  # @return [ArrayIncludingMatcher] a new instance of ArrayIncludingMatcher
  def initialize(expected); end

  def ===(actual); end
  def description; end

  private

  def formatted_expected_values; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  # @return [BaseHashMatcher] a new instance of BaseHashMatcher
  def initialize(expected); end

  def ===(predicate, actual); end
  def description(name); end

  private

  def formatted_expected_hash; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::BooleanMatcher < ::RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def ===(value); end
  def description; end
end

RSpec::Mocks::ArgumentMatchers::BooleanMatcher::INSTANCE = T.let(T.unsafe(nil), RSpec::Mocks::ArgumentMatchers::BooleanMatcher)

# @private
class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
  # @return [DuckTypeMatcher] a new instance of DuckTypeMatcher
  def initialize(*methods_to_respond_to); end

  def ===(value); end
  def description; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher < ::RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(actual); end
  def description; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher < ::RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(actual); end
  def description; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::InstanceOf
  # @return [InstanceOf] a new instance of InstanceOf
  def initialize(klass); end

  def ===(actual); end
  def description; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::KindOf
  # @return [KindOf] a new instance of KindOf
  def initialize(klass); end

  def ===(actual); end
  def description; end
end

# @private
class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher < ::RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def description; end
end

RSpec::Mocks::ArgumentMatchers::NoArgsMatcher::INSTANCE = T.let(T.unsafe(nil), RSpec::Mocks::ArgumentMatchers::NoArgsMatcher)

# Intended to be subclassed by stateless, immutable argument matchers.
# Provides a `<klass name>::INSTANCE` constant for accessing a global
# singleton instance of the matcher. There is no need to construct
# multiple instance since there is no state. It also facilities the
# special case logic we need for some of these matchers, by making it
# easy to do comparisons like: `[klass::INSTANCE] == args` rather than
# `args.count == 1 && klass === args.first`.
#
# @private
class RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  class << self
    # @private
    def inherited(subklass); end
  end
end

# @private
RSpec::SharedContext = RSpec::Core::SharedContext
