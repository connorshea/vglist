# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pg_search` gem.
# Please instead update this file by running `bin/tapioca gem pg_search`.

module PgSearch
  include ::PgSearch::Model

  mixes_in_class_methods ::PgSearch::Model::ClassMethods

  def multisearch_options; end
  def multisearch_options=(val); end
  def unaccent_function; end
  def unaccent_function=(val); end

  class << self
    def disable_multisearch; end

    # @private
    def included(base); end

    def multisearch(*args); end

    # @return [Boolean]
    def multisearch_enabled?; end

    def multisearch_options; end
    def multisearch_options=(val); end
    def unaccent_function; end
    def unaccent_function=(val); end
  end
end

class PgSearch::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize(options, model); end

  def associated_columns; end
  def associations; end
  def columns; end
  def feature_options; end
  def features; end
  def ignore; end

  # Returns the value of attribute model.
  def model; end

  def order_within_rank; end
  def query; end
  def ranking_sql; end
  def regular_columns; end

  private

  def assert_valid_options(options); end
  def default_options; end

  # Returns the value of attribute options.
  def options; end

  # @return [Boolean]
  def using_tsvector_column?(options); end

  class << self
    def alias(*strings); end
  end
end

class PgSearch::Configuration::Association
  # @return [Association] a new instance of Association
  def initialize(model, name, column_names); end

  # Returns the value of attribute columns.
  def columns; end

  def join(primary_key); end
  def subselect_alias; end
  def table_name; end

  private

  def relation(primary_key); end
  def selects; end
  def selects_for_multiple_association; end
  def selects_for_singular_association; end

  # @return [Boolean]
  def singular_association?; end
end

class PgSearch::Configuration::Column
  # @return [Column] a new instance of Column
  def initialize(column_name, weight, model); end

  def full_name; end

  # Returns the value of attribute name.
  def name; end

  def to_sql; end

  # Returns the value of attribute weight.
  def weight; end

  private

  def column_name; end
  def expression; end
  def table_name; end
end

class PgSearch::Configuration::ForeignColumn < ::PgSearch::Configuration::Column
  # @return [ForeignColumn] a new instance of ForeignColumn
  def initialize(column_name, weight, model, association); end

  def alias; end

  # Returns the value of attribute weight.
  def weight; end

  private

  def expression; end
  def table_name; end
end

PgSearch::Configuration::VALID_KEYS = T.let(T.unsafe(nil), Array)
PgSearch::Configuration::VALID_VALUES = T.let(T.unsafe(nil), Hash)

class PgSearch::Document < ::ActiveRecord::Base
  include ::PgSearch::Document::GeneratedAttributeMethods
  include ::PgSearch::Document::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  include ::PgSearch::Model
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  extend ::PgSearch::Model::ClassMethods

  def autosave_associated_records_for_searchable(*args); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def defined_enums; end

    # The logger might not have loaded yet.
    # https://github.com/Casecommons/pg_search/issues/26
    def logger; end

    def page(num = T.unsafe(nil)); end
    def search(*args); end
  end
end

module PgSearch::Document::GeneratedAssociationMethods
  def reload_searchable; end
  def searchable; end
  def searchable=(value); end
end

module PgSearch::Document::GeneratedAttributeMethods; end
module PgSearch::Features; end

class PgSearch::Features::DMetaphone
  # @return [DMetaphone] a new instance of DMetaphone
  def initialize(query, options, columns, model, normalizer); end

  def conditions(*_arg0, &_arg1); end
  def rank(*_arg0, &_arg1); end

  private

  # Returns the value of attribute tsearch.
  def tsearch; end
end

# Decorates a normalizer with dmetaphone processing.
class PgSearch::Features::DMetaphone::Normalizer
  # @return [Normalizer] a new instance of Normalizer
  def initialize(normalizer_to_wrap); end

  def add_normalization(original_sql); end

  private

  # Returns the value of attribute normalizer_to_wrap.
  def normalizer_to_wrap; end
end

class PgSearch::Features::Feature
  # @return [Feature] a new instance of Feature
  def initialize(query, options, all_columns, model, normalizer); end

  def connection(*_arg0, &_arg1); end
  def quoted_table_name(*_arg0, &_arg1); end

  private

  # Returns the value of attribute all_columns.
  def all_columns; end

  def columns; end
  def document; end

  # Returns the value of attribute model.
  def model; end

  def normalize(expression); end

  # Returns the value of attribute normalizer.
  def normalizer; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute query.
  def query; end

  class << self
    def valid_options; end
  end
end

class PgSearch::Features::TSearch < ::PgSearch::Features::Feature
  def conditions; end
  def highlight; end
  def rank; end

  private

  def arel_wrap(sql_string); end
  def column_to_tsvector(search_column); end
  def columns_to_use; end
  def deprecated_headline_options; end
  def dictionary; end
  def headline_options; end

  # From http://www.postgresql.org/docs/8.3/static/textsearch-controls.html
  #   0 (the default) ignores the document length
  #   1 divides the rank by 1 + the logarithm of the document length
  #   2 divides the rank by the document length
  #   4 divides the rank by the mean harmonic distance between extents (this is implemented only by ts_rank_cd)
  #   8 divides the rank by the number of unique words in document
  #   16 divides the rank by 1 + the logarithm of the number of unique words in document
  #   32 divides the rank by itself + 1
  # The integer option controls several behaviors, so it is a bit mask: you can specify one or more behaviors
  def normalization; end

  def ts_headline; end
  def ts_headline_option_value(value); end
  def ts_headline_options; end
  def tsdocument; end
  def tsearch_rank; end
  def tsquery; end

  # After this, the SQL expression evaluates to a string containing the term surrounded by single-quotes.
  # If :prefix is true, then the term will have :* appended to the end.
  # If :negated is true, then the term will have ! prepended to the front.
  def tsquery_expression(term_sql, negated:, prefix:); end

  def tsquery_for_term(unsanitized_term); end

  class << self
    def valid_options; end
  end
end

PgSearch::Features::TSearch::DISALLOWED_TSQUERY_CHARACTERS = T.let(T.unsafe(nil), Regexp)

class PgSearch::Features::Trigram < ::PgSearch::Features::Feature
  def conditions; end
  def rank; end

  private

  def infix_operator; end
  def normalized_document; end
  def normalized_query; end
  def similarity; end
  def similarity_function; end

  # @return [Boolean]
  def word_similarity?; end

  class << self
    def valid_options; end
  end
end

module PgSearch::Model
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::PgSearch::Model::ClassMethods

  def method_missing(symbol, *args); end

  private

  # @return [Boolean]
  def respond_to_missing?(symbol, *args); end
end

module PgSearch::Model::ClassMethods
  def multisearchable(options = T.unsafe(nil)); end
  def pg_search_scope(name, options); end
end

module PgSearch::Multisearch
  class << self
    def rebuild(model, deprecated_clean_up = T.unsafe(nil), clean_up: T.unsafe(nil), transactional: T.unsafe(nil)); end

    private

    def execute(model, clean_up); end
  end
end

class PgSearch::Multisearch::ModelNotMultisearchable < ::StandardError
  # @return [ModelNotMultisearchable] a new instance of ModelNotMultisearchable
  def initialize(model_class); end

  def message; end
end

class PgSearch::Multisearch::Rebuilder
  # @raise [ModelNotMultisearchable]
  # @return [Rebuilder] a new instance of Rebuilder
  def initialize(model, time_source = T.unsafe(nil)); end

  def rebuild; end

  private

  # @return [Boolean]
  def additional_attributes?; end

  def base_model_name; end
  def columns; end

  # @return [Boolean]
  def conditional?; end

  def connection; end
  def content_expressions; end
  def current_time; end
  def documents_table; end

  # @return [Boolean]
  def dynamic?; end

  # Returns the value of attribute model.
  def model; end

  def model_name; end
  def model_table; end
  def primary_key; end
  def rebuild_sql; end
  def rebuild_sql_template; end
  def replacements; end
  def sti_clause; end
end

module PgSearch::Multisearchable
  def create_or_update_pg_search_document; end
  def pg_search_document_attrs; end
  def searchable_text; end

  # @return [Boolean]
  def should_update_pg_search_document?; end

  def update_pg_search_document; end

  class << self
    # @private
    def included(mod); end
  end
end

class PgSearch::Normalizer
  # @return [Normalizer] a new instance of Normalizer
  def initialize(config); end

  def add_normalization(sql_expression); end

  private

  # Returns the value of attribute config.
  def config; end
end

class PgSearch::PgSearchHighlightNotSelected < ::StandardError
  def message; end
end

class PgSearch::PgSearchRankNotSelected < ::StandardError
  def message; end
end

class PgSearch::Railtie < ::Rails::Railtie; end

class PgSearch::ScopeOptions
  # @return [ScopeOptions] a new instance of ScopeOptions
  def initialize(config); end

  def apply(scope); end

  # Returns the value of attribute config.
  def config; end

  def connection(*_arg0, &_arg1); end

  # Returns the value of attribute feature_options.
  def feature_options; end

  # Returns the value of attribute model.
  def model; end

  def quoted_table_name(*_arg0, &_arg1); end

  private

  def conditions; end

  # @raise [ArgumentError]
  def feature_for(feature_name); end

  def include_table_aliasing_for_rank(scope); end
  def order_within_rank; end
  def primary_key; end
  def rank; end
  def rank_join(rank_table_alias); end
  def subquery; end
  def subquery_join; end
end

PgSearch::ScopeOptions::FEATURE_CLASSES = T.let(T.unsafe(nil), Hash)

module PgSearch::ScopeOptions::PgSearchRankTableAliasing
  def pg_search_rank_table_alias(include_counter: T.unsafe(nil)); end

  private

  def increment_counter; end
end

module PgSearch::ScopeOptions::WithPgSearchHighlight
  def highlight; end

  # @raise [TypeError]
  def tsearch; end

  def with_pg_search_highlight; end

  class << self
    def [](tsearch); end
  end
end

module PgSearch::ScopeOptions::WithPgSearchRank
  def with_pg_search_rank; end
end

PgSearch::VERSION = T.let(T.unsafe(nil), String)
