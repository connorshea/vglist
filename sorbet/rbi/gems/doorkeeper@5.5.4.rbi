# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `doorkeeper` gem.
# Please instead update this file by running `bin/tapioca gem doorkeeper`.

# Main Doorkeeper namespace.
module Doorkeeper
  class << self
    def authenticate(request, methods = T.unsafe(nil)); end

    # @return [Doorkeeper::Config] configuration instance
    def config; end

    # @return [Doorkeeper::Config] configuration instance
    def configuration; end

    def configure(&block); end
    def gem_version; end
    def setup_application_owner; end
    def setup_orm_adapter; end
    def setup_orm_models; end
  end
end

module Doorkeeper::AccessGrantMixin
  include ::Doorkeeper::OAuth::Helpers
  include ::Doorkeeper::Models::Expirable
  include ::Doorkeeper::Models::Revocable
  include ::Doorkeeper::Models::Accessible
  include ::Doorkeeper::Models::Scopes
  extend ::ActiveSupport::Concern
  include ::Doorkeeper::Models::Orderable
  include ::Doorkeeper::Models::SecretStorable
  include ::Doorkeeper::Models::ResourceOwnerable

  mixes_in_class_methods ::Doorkeeper::Models::Orderable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::Models::SecretStorable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::Models::ResourceOwnerable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::AccessGrantMixin::ClassMethods

  # Never uses PKCE if PKCE migrations were not generated
  #
  # @return [Boolean]
  def uses_pkce?; end
end

module Doorkeeper::AccessGrantMixin::ClassMethods
  # Searches for Doorkeeper::AccessGrant record with the
  # specific token value.
  #
  # @param token [#to_s] token value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessGrant, nil] AccessGrant object or nil if there is no record with such token
  def by_token(token); end

  # Determine the fallback storing strategy
  # Unless configured, there will be no fallback
  #
  # @return [Doorkeeper::SecretStoring::Base]
  def fallback_secret_strategy; end

  # suitable for PKCE validation
  #
  # @param code_verifier [#to_s] a one time use value (any object that responds to `#to_s`)
  # @return [#to_s] An encoded code challenge based on the provided verifier
  def generate_code_challenge(code_verifier); end

  # @return [Boolean]
  def pkce_supported?; end

  # Revokes AccessGrant records that have not been revoked and associated
  # with the specific Application and Resource Owner.
  #
  # @param application_id [Integer] ID of the Application
  # @param resource_owner [ActiveRecord::Base, Integer] instance of the Resource Owner model or it's ID
  def revoke_all_for(application_id, resource_owner, clock = T.unsafe(nil)); end

  # Determines the secret storing transformer
  # Unless configured otherwise, uses the plain secret strategy
  #
  # @return [Doorkeeper::SecretStoring::Base]
  def secret_strategy; end
end

module Doorkeeper::AccessTokenMixin
  include ::Doorkeeper::OAuth::Helpers
  include ::Doorkeeper::Models::Expirable
  include ::Doorkeeper::Models::Reusable
  include ::Doorkeeper::Models::Revocable
  include ::Doorkeeper::Models::Accessible
  include ::Doorkeeper::Models::Scopes
  extend ::ActiveSupport::Concern
  include ::Doorkeeper::Models::Orderable
  include ::Doorkeeper::Models::SecretStorable
  include ::Doorkeeper::Models::ResourceOwnerable

  mixes_in_class_methods ::Doorkeeper::Models::Orderable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::Models::SecretStorable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::Models::ResourceOwnerable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::AccessTokenMixin::ClassMethods

  # Indicates if token is acceptable for specific scopes.
  #
  # @param scopes [Array<String>] scopes
  # @return [Boolean] true if record is accessible and includes scopes or
  #   false in other cases
  def acceptable?(scopes); end

  # JSON representation of the Access Token instance.
  #
  # @return [Hash] hash with token data
  def as_json(_options = T.unsafe(nil)); end

  # We keep a volatile copy of the raw refresh token for initial communication
  # The stored refresh_token may be mapped and not available in cleartext.
  def plaintext_refresh_token; end

  # We keep a volatile copy of the raw token for initial communication
  # The stored refresh_token may be mapped and not available in cleartext.
  #
  # Some strategies allow restoring stored secrets (e.g. symmetric encryption)
  # while hashing strategies do not, so you cannot rely on this value
  # returning a present value for persisted tokens.
  def plaintext_token; end

  # Revokes token with `:refresh_token` equal to `:previous_refresh_token`
  # and clears `:previous_refresh_token` attribute.
  def revoke_previous_refresh_token!; end

  # Indicates whether the token instance have the same credential
  # as the other Access Token.
  #
  # @param access_token [Doorkeeper::AccessToken] other token
  # @return [Boolean] true if credentials are same of false in other cases
  def same_credential?(access_token); end

  # Indicates whether the token instance have the same credential
  # as the other Access Token.
  #
  # @param access_token [Doorkeeper::AccessToken] other token
  # @return [Boolean] true if credentials are same of false in other cases
  def same_resource_owner?(access_token); end

  # Access Token type: Bearer.
  #
  # @see https://datatracker.ietf.org/doc/html/rfc6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage
  def token_type; end

  # @return [Boolean]
  def use_refresh_token?; end

  private

  # Set of attributes that would be passed to token generator to
  # generate unique token based on them.
  #
  #  @return [Hash] set of attributes
  def attributes_for_token_generator; end

  # Generates refresh token with UniqueToken generator.
  #
  # @return [String] refresh token value
  def generate_refresh_token; end

  # Generates and sets the token value with the
  # configured Generator class (see Doorkeeper.config).
  #
  # @raise [Doorkeeper::Errors::UnableToGenerateToken] custom class doesn't implement .generate method
  # @raise [Doorkeeper::Errors::TokenGeneratorNotFound] custom class doesn't exist
  # @return [String] generated token value
  def generate_token; end

  # Searches for Access Token record with `:refresh_token` equal to
  # `:previous_refresh_token` value.
  #
  # @return [Doorkeeper::AccessToken, nil] Access Token record or nil if nothing found
  def old_refresh_token; end

  def token_generator; end
end

module Doorkeeper::AccessTokenMixin::ClassMethods
  # Looking for not revoked Access Token records that belongs to specific
  # Application and Resource Owner.
  #
  # @param application_id [Integer] ID of the Application model instance
  # @param resource_owner [ActiveRecord::Base, Integer] Resource Owner model instance or it's ID
  # @return [ActiveRecord::Relation] collection of matching AccessToken objects
  def authorized_tokens_for(application_id, resource_owner); end

  # Returns an instance of the Doorkeeper::AccessToken
  # found by previous refresh token. Keep in mind that value
  # of the previous_refresh_token isn't encrypted using
  # secrets strategy.
  #
  # @param previous_refresh_token [#to_s] previous refresh token value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessToken, nil] AccessToken object or nil
  #   if there is no record with such refresh token
  def by_previous_refresh_token(previous_refresh_token); end

  # Returns an instance of the Doorkeeper::AccessToken
  # with specific token value.
  #
  # @param refresh_token [#to_s] refresh token value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessToken, nil] AccessToken object or nil
  #   if there is no record with such refresh token
  def by_refresh_token(refresh_token); end

  # Returns an instance of the Doorkeeper::AccessToken with
  # specific plain text token value.
  #
  # @param token [#to_s] Plain text token value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessToken, nil] AccessToken object or nil
  #   if there is no record with such token
  def by_token(token); end

  # Creates a not expired AccessToken record with a matching set of
  # scopes that belongs to specific Application and Resource Owner.
  #
  # @option token_attributes
  # @option token_attributes
  # @param application [Doorkeeper::Application] Application instance
  # @param resource_owner [ActiveRecord::Base, Integer] Resource Owner model instance or it's ID
  # @param scopes [#to_s] set of scopes (any object that responds to `#to_s`)
  # @param token_attributes [Hash] Additional attributes to use when creating a token
  # @return [Doorkeeper::AccessToken] new access token
  def create_for(application:, resource_owner:, scopes:, **token_attributes); end

  # Determine the fallback storing strategy
  # Unless configured, there will be no fallback
  def fallback_secret_strategy; end

  # Interface to enumerate access token records in batches in order not
  # to bloat the memory. Could be overloaded in any ORM extension.
  def find_access_token_in_batches(relation, **args, &block); end

  # Enumerates AccessToken records in batches to find a matching token.
  # Batching is required in order not to pollute the memory if Application
  # has huge amount of associated records.
  #
  # ActiveRecord 5.x - 6.x ignores custom ordering so we can't perform a
  # database sort by created_at, so we need to load all the matching records,
  # sort them and find latest one. Probably it would be better to rewrite this
  # query using Time math if possible, but we n eed to consider ORM and
  # different databases support.
  #
  # @param relation [ActiveRecord::Relation] Access tokens relation
  # @param application [Doorkeeper::Application] Application instance
  # @param scopes [String, Doorkeeper::OAuth::Scopes] set of scopes
  # @return [Doorkeeper::AccessToken, nil] Access Token instance or
  #   nil if matching record was not found
  def find_matching_token(relation, application, scopes); end

  # Looking for not expired AccessToken record with a matching set of
  # scopes that belongs to specific Application and Resource Owner.
  # If it doesn't exists - then creates it.
  #
  # @option token_attributes
  # @option token_attributes
  # @param application [Doorkeeper::Application] Application instance
  # @param resource_owner [ActiveRecord::Base, Integer] Resource Owner model instance or it's ID
  # @param scopes [#to_s] set of scopes (any object that responds to `#to_s`)
  # @param token_attributes [Hash] Additional attributes to use when creating a token
  # @return [Doorkeeper::AccessToken] existing record or a new one
  def find_or_create_for(application:, resource_owner:, scopes:, **token_attributes); end

  # Convenience method for backwards-compatibility, return the last
  # matching token for the given Application and Resource Owner.
  #
  # @param application_id [Integer] ID of the Application model instance
  # @param resource_owner [ActiveRecord::Base, Integer] ID of the Resource Owner model instance
  # @return [Doorkeeper::AccessToken, nil] matching AccessToken object or
  #   nil if nothing was found
  def last_authorized_token_for(application_id, resource_owner); end

  # Looking for not revoked Access Token with a matching set of scopes
  # that belongs to specific Application and Resource Owner.
  #
  # @param application [Doorkeeper::Application] Application instance
  # @param resource_owner [ActiveRecord::Base, Integer] Resource Owner model instance or it's ID
  # @param scopes [String, Doorkeeper::OAuth::Scopes] set of scopes
  # @return [Doorkeeper::AccessToken, nil] Access Token instance or
  #   nil if matching record was not found
  def matching_token_for(application, resource_owner, scopes); end

  # Revokes AccessToken records that have not been revoked and associated
  # with the specific Application and Resource Owner.
  #
  # @param application_id [Integer] ID of the Application
  # @param resource_owner [ActiveRecord::Base, Integer] instance of the Resource Owner model or it's ID
  def revoke_all_for(application_id, resource_owner, clock = T.unsafe(nil)); end

  # Checks whether the token scopes match the scopes from the parameters
  #
  # @param token_scopes [#to_s] set of scopes (any object that responds to `#to_s`)
  # @param param_scopes [Doorkeeper::OAuth::Scopes] scopes from params
  # @param app_scopes [Doorkeeper::OAuth::Scopes] Application scopes
  # @return [Boolean] true if the param scopes match the token scopes,
  #   and all the param scopes are defined in the application (or in the
  #   server configuration if the application doesn't define any scopes),
  #   and false in other cases
  def scopes_match?(token_scopes, param_scopes, app_scopes); end

  # Determines the secret storing transformer
  # Unless configured otherwise, uses the plain secret strategy
  #
  # @return [Doorkeeper::SecretStoring::Base]
  def secret_strategy; end
end

module Doorkeeper::ApplicationMixin
  include ::Doorkeeper::OAuth::Helpers
  include ::Doorkeeper::Models::Scopes
  extend ::ActiveSupport::Concern
  include ::Doorkeeper::Models::Orderable
  include ::Doorkeeper::Models::SecretStorable

  mixes_in_class_methods ::Doorkeeper::Models::Orderable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::Models::SecretStorable::ClassMethods
  mixes_in_class_methods ::Doorkeeper::ApplicationMixin::ClassMethods

  # Set an application's valid redirect URIs.
  #
  # @param uris [String, Array<String>] Newline-separated string or array the URI(s)
  # @return [String] The redirect URI(s) separated by newlines.
  def redirect_uri=(uris); end

  # Check whether the given plain text secret matches our stored secret
  #
  # @param input [#to_s] Plain secret provided by user
  #   (any object that responds to `#to_s`)
  # @return [Boolean] Whether the given secret matches the stored secret
  #   of this application.
  def secret_matches?(input); end
end

# :nodoc
module Doorkeeper::ApplicationMixin::ClassMethods
  # Returns an instance of the Doorkeeper::Application with specific UID.
  #
  # @param uid [#to_s] UID (any object that responds to `#to_s`)
  # @return [Doorkeeper::Application, nil] Application instance or nil
  #   if there is no record with such UID
  def by_uid(uid); end

  # Returns an instance of the Doorkeeper::Application with
  # specific UID and secret.
  #
  # Public/Non-confidential applications will only find by uid if secret is
  # blank.
  #
  # @param uid [#to_s] UID (any object that responds to `#to_s`)
  # @param secret [#to_s] secret (any object that responds to `#to_s`)
  # @return [Doorkeeper::Application, nil] Application instance or nil if there is no record with such credentials
  def by_uid_and_secret(uid, secret); end

  # Determine the fallback storing strategy
  # Unless configured, there will be no fallback
  def fallback_secret_strategy; end

  # Determines the secret storing transformer
  # Unless configured otherwise, uses the plain secret strategy
  def secret_strategy; end
end

class Doorkeeper::Config
  include ::Doorkeeper::Config::Validations
  extend ::Doorkeeper::Config::Option

  def access_grant_class(*_args); end

  # Doorkeeper Access Grant model class.
  #
  # @return [ActiveRecord::Base, Mongoid::Document, Sequel::Model]
  def access_grant_model; end

  def access_token_class(*_args); end
  def access_token_expires_in(*_args); end
  def access_token_generator(*_args); end
  def access_token_methods; end

  # Doorkeeper Access Token model class.
  #
  # @return [ActiveRecord::Base, Mongoid::Document, Sequel::Model]
  def access_token_model; end

  def active_record_options(*_args); end
  def after_successful_authorization(*_args); end
  def after_successful_strategy_response(*_args); end
  def allow_blank_redirect_uri(*_args); end

  # @return [Boolean]
  def allow_blank_redirect_uri?(application = T.unsafe(nil)); end

  # Allows to customize OAuth grant flows that +each+ application support.
  # You can configure a custom block (or use a class respond to `#call`) that must
  # return `true` in case Application instance supports requested OAuth grant flow
  # during the authorization request to the server. This configuration +doesn't+
  # set flows per application, it only allows to check if application supports
  # specific grant flow.
  #
  # For example you can add an additional database column to `oauth_applications` table,
  # say `t.array :grant_flows, default: []`, and store allowed grant flows that can
  # be used with this application there. Then when authorization requested Doorkeeper
  # will call this block to check if specific Application (passed with client_id and/or
  # client_secret) is allowed to perform the request for the specific grant type
  # (authorization, password, client_credentials, etc).
  #
  # Example of the block:
  #
  #   ->(flow, client) { client.grant_flows.include?(flow) }
  #
  # In case this option invocation result is `false`, Doorkeeper server returns
  # :unauthorized_client error and stops the request.
  #
  # @param allow_grant_flow_for_client [Proc] Block or any object respond to #call
  # @return [Boolean] `true` if allow or `false` if forbid the request
  def allow_grant_flow_for_client(*_args); end

  # @return [Boolean]
  def allow_grant_flow_for_client?(grant_flow, client); end

  def allow_token_introspection(*_args); end
  def api_only; end
  def application_class(*_args); end

  # Doorkeeper Application model class.
  #
  # @return [ActiveRecord::Base, Mongoid::Document, Sequel::Model]
  def application_model; end

  # Returns the value of attribute application_secret_fallback_strategy.
  def application_secret_fallback_strategy; end

  # @return [Boolean]
  def application_secret_hashed?; end

  def application_secret_strategy; end
  def authenticate_admin(*_args); end
  def authenticate_resource_owner(*_args); end
  def authorization_code_expires_in(*_args); end
  def authorization_response_flows; end
  def authorization_response_types; end
  def authorize_resource_owner_for_client(*_args); end
  def base_controller(*_args); end
  def base_metal_controller(*_args); end
  def before_successful_authorization(*_args); end
  def before_successful_strategy_response(*_args); end
  def builder_class; end

  # [NOTE]: deprecated and will be removed soon
  def calculate_authorization_response_types; end

  # Calculates grant flows configured by the user in Doorkeeper
  # configuration considering registered aliases that is exposed
  # to single or multiple other flows.
  def calculate_grant_flows; end

  # [NOTE]: deprecated and will be removed soon
  def calculate_token_grant_types; end

  def client_credentials_methods; end

  # @return [Boolean]
  def confirm_application_owner?; end

  def custom_access_token_expires_in(*_args); end
  def custom_introspection_response(*_args); end
  def default_generator_method(*_args); end
  def default_scopes; end

  # [NOTE]: deprecated and will be removed soon
  def deprecated_authorization_flows; end

  # [NOTE]: deprecated and will be removed soon
  def deprecated_token_grant_types_resolver; end

  # @return [Boolean]
  def enable_application_owner?; end

  def enabled_grant_flows; end

  # @return [Boolean]
  def enforce_configured_scopes?; end

  def enforce_content_type; end
  def forbid_redirect_uri(*_args); end
  def force_ssl_in_redirect_uri(*_args); end
  def grant_flows(*_args); end
  def handle_auth_errors(*_args); end
  def native_redirect_uri(*_args); end

  # @return [Boolean]
  def option_defined?(name); end

  def optional_scopes; end
  def orm(*_args); end

  # @return [Boolean]
  def polymorphic_resource_owner?; end

  # @return [Boolean]
  def raise_on_errors?; end

  def realm(*_args); end

  # @return [Boolean]
  def refresh_token_enabled?; end

  def resolve_controller(name); end
  def resource_owner_from_credentials(*_args); end

  # Returns the value of attribute reuse_access_token.
  def reuse_access_token; end

  # @return [Boolean]
  def revoke_previous_client_credentials_token?; end

  def scopes; end
  def scopes_by_grant_type; end
  def skip_authorization(*_args); end
  def skip_client_authentication_for_password_grant(*_args); end
  def token_grant_flows; end
  def token_grant_types; end
  def token_lookup_batch_size(*_args); end
  def token_reuse_limit(*_args); end

  # Returns the value of attribute token_secret_fallback_strategy.
  def token_secret_fallback_strategy; end

  def token_secret_strategy; end

  private

  def calculate_token_grant_flows; end

  # Helper to read boolearized configuration option
  #
  # @return [Boolean]
  def option_set?(instance_key); end

  class << self
    def builder_class; end
  end
end

# Abstract base class for Doorkeeper and it's extensions configuration
# builder. Instantiates and validates gem configuration.
class Doorkeeper::Config::AbstractBuilder
  # @param config [Class] class
  # @return [AbstractBuilder] a new instance of AbstractBuilder
  def initialize(config = T.unsafe(nil), &block); end

  # Builds and validates configuration.
  #
  # @return [Doorkeeper::Config] config instance
  def build; end

  # Returns the value of attribute config.
  def config; end
end

# Default Doorkeeper configuration builder
class Doorkeeper::Config::Builder < ::Doorkeeper::Config::AbstractBuilder
  def access_grant_class(*args, &block); end
  def access_token_class(*args, &block); end
  def access_token_expires_in(*args, &block); end
  def access_token_generator(*args, &block); end

  # Change the way access token is authenticated from the request object.
  # By default it retrieves first from the `HTTP_AUTHORIZATION` header, then
  # falls back to the `:access_token` or `:bearer_token` params from the
  # `params` object.
  #
  # @param methods [Array] Define access token methods
  def access_token_methods(*methods); end

  def active_record_options(*args, &block); end
  def admin_authenticator(*args, &block); end
  def after_successful_authorization(*args, &block); end
  def after_successful_strategy_response(*args, &block); end
  def allow_blank_redirect_uri(*args, &block); end
  def allow_grant_flow_for_client(*args, &block); end
  def allow_token_introspection(*args, &block); end

  # Use an API mode for applications generated with --api argument
  # It will skip applications controller, disable forgery protection
  def api_only; end

  def application_class(*args, &block); end
  def authorization_code_expires_in(*args, &block); end
  def authorize_resource_owner_for_client(*args, &block); end
  def base_controller(*args, &block); end
  def base_metal_controller(*args, &block); end
  def before_successful_authorization(*args, &block); end
  def before_successful_strategy_response(*args, &block); end

  # Change the way client credentials are retrieved from the request object.
  # By default it retrieves first from the `HTTP_AUTHORIZATION` header, then
  # falls back to the `:client_id` and `:client_secret` params from the
  # `params` object.
  #
  # @param methods [Array] Define client credentials
  def client_credentials(*methods); end

  def confirm_application_owner; end
  def custom_access_token_expires_in(*args, &block); end
  def custom_introspection_response(*args, &block); end
  def default_generator_method(*args, &block); end

  # Define default access token scopes for your provider
  #
  # token scopes
  #
  # @param scopes [Array] Default set of access (OAuth::Scopes.new)
  def default_scopes(*scopes); end

  # Provide support for an owner to be assigned to each registered
  # application (disabled by default)
  # Optional parameter confirmation: true (default false) if you want
  # to enforce ownership of a registered application
  #
  # @option opts[Boolean]
  # @param opts [Hash] the options to confirm if an application owner
  #   is present
  # @param opts[Boolean] [Hash] a customizable set of options
  def enable_application_owner(opts = T.unsafe(nil)); end

  # Forbids creating/updating applications with arbitrary scopes that are
  # not in configuration, i.e. `default_scopes` or `optional_scopes`.
  # (disabled by default)
  def enforce_configured_scopes; end

  # Enforce request content type as the spec requires:
  # disabled by default for backward compatibility.
  def enforce_content_type; end

  def forbid_redirect_uri(*args, &block); end
  def force_ssl_in_redirect_uri(*args, &block); end
  def grant_flows(*args, &block); end
  def handle_auth_errors(*args, &block); end

  # Allow optional hashing of application secrets before persisting them.
  # Will be used for hashing of input token and grants.
  #
  # @param using Provide a different secret storage implementation for applications
  # @param fallback Provide a fallback secret storage implementation for applications
  #   or use :plain to fallback to plain application secrets
  def hash_application_secrets(using: T.unsafe(nil), fallback: T.unsafe(nil)); end

  # Allow optional hashing of input tokens before persisting them.
  # Will be used for hashing of input token and grants.
  #
  # @param using Provide a different secret storage implementation class for tokens
  # @param fallback Provide a fallback secret storage implementation class for tokens
  #   or use :plain to fallback to plain tokens
  def hash_token_secrets(using: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def native_redirect_uri(*args, &block); end

  # Define default access token scopes for your provider
  #
  # token scopes
  #
  # @param scopes [Array] Optional set of access (OAuth::Scopes.new)
  def optional_scopes(*scopes); end

  def orm(*args, &block); end
  def realm(*args, &block); end
  def resource_owner_authenticator(*args, &block); end
  def resource_owner_from_credentials(*args, &block); end

  # Reuse access token for the same resource owner within an application
  # (disabled by default)
  # Rationale: https://github.com/doorkeeper-gem/doorkeeper/issues/383
  def reuse_access_token; end

  # TODO: maybe make it more generic for other flows too?
  # Only allow one valid access token obtained via client credentials
  # per client. If a new access token is obtained before the old one
  # expired, the old one gets revoked (disabled by default)
  def revoke_previous_client_credentials_token; end

  # Define scopes_by_grant_type to limit certain scope to certain grant_type
  # Default set to {} i.e. no limitation on scopes usage
  #
  # @param with [Hash] grant_types as keys.
  def scopes_by_grant_type(hash = T.unsafe(nil)); end

  def skip_authorization(*args, &block); end
  def skip_client_authentication_for_password_grant(*args, &block); end
  def token_lookup_batch_size(*args, &block); end
  def token_reuse_limit(*args, &block); end

  # Enables polymorphic Resource Owner association for Access Grant and
  # Access Token models. Requires additional database columns to be setup.
  def use_polymorphic_resource_owner; end

  # Issue access tokens with refresh token (disabled if not set)
  def use_refresh_token(enabled = T.unsafe(nil), &block); end

  private

  # Configure the secret storing functionality
  #
  # @raise [ArgumentError]
  def configure_secrets_for(type, using:, fallback:); end
end

# Doorkeeper configuration option DSL
module Doorkeeper::Config::Option
  # Defines configuration option
  #
  # When you call option, it defines two methods. One method will take place
  # in the +Config+ class and the other method will take place in the
  # +Builder+ class.
  #
  # The +name+ parameter will set both builder method and config attribute.
  # If the +:as+ option is defined, the builder method will be the specified
  # option while the config attribute will be the +name+ parameter.
  #
  # If you want to introduce another level of config DSL you can
  # define +builder_class+ parameter.
  # Builder should take a block as the initializer parameter and respond to function +build+
  # that returns the value of the config attribute.
  #
  # ==== Options
  #
  # * [:+as+] Set the builder method that goes inside +configure+ block
  # * [+:default+] The default value in case no option was set
  # * [+:builder_class+] Configuration option builder class
  #
  # ==== Examples
  #
  #    option :name
  #    option :name, as: :set_name
  #    option :name, default: 'My Name'
  #    option :scopes builder_class: ScopesBuilder
  def option(name, options = T.unsafe(nil)); end

  class << self
    # @private
    # @raise [Doorkeeper::MissingConfigurationBuilderClass]
    def extended(base); end
  end
end

# Doorkeeper configuration validator.
module Doorkeeper::Config::Validations
  # Validates configuration options to be set properly.
  def validate!; end

  private

  # Determine whether +reuse_access_token+ and a non-restorable
  # +token_secret_strategy+ have both been activated.
  #
  # In that case, disable reuse_access_token value and warn the user.
  def validate_reuse_access_token_value; end

  # Validate that the provided strategies are valid for
  # tokens and applications
  def validate_secret_strategies; end

  def validate_token_reuse_limit; end
end

module Doorkeeper::DashboardHelper
  def doorkeeper_errors_for(object, method); end
  def doorkeeper_submit_path(application); end
end

class Doorkeeper::Engine < ::Rails::Engine; end
module Doorkeeper::Errors; end

class Doorkeeper::Errors::BaseResponseError < ::Doorkeeper::Errors::DoorkeeperError
  # @return [BaseResponseError] a new instance of BaseResponseError
  def initialize(response); end

  # Returns the value of attribute response.
  def response; end
end

class Doorkeeper::Errors::DoorkeeperError < ::StandardError
  def type; end
end

class Doorkeeper::Errors::InvalidGrantReuse < ::Doorkeeper::Errors::DoorkeeperError
  def type; end
end

class Doorkeeper::Errors::InvalidToken < ::Doorkeeper::Errors::BaseResponseError; end

class Doorkeeper::Errors::InvalidTokenStrategy < ::Doorkeeper::Errors::DoorkeeperError
  def type; end
end

class Doorkeeper::Errors::MissingRequiredParameter < ::Doorkeeper::Errors::DoorkeeperError
  # @return [MissingRequiredParameter] a new instance of MissingRequiredParameter
  def initialize(missing_param); end

  # Returns the value of attribute missing_param.
  def missing_param; end

  def type; end
end

class Doorkeeper::Errors::NoOrmCleaner < ::Doorkeeper::Errors::DoorkeeperError; end
class Doorkeeper::Errors::TokenExpired < ::Doorkeeper::Errors::InvalidToken; end
class Doorkeeper::Errors::TokenForbidden < ::Doorkeeper::Errors::InvalidToken; end
class Doorkeeper::Errors::TokenGeneratorNotFound < ::Doorkeeper::Errors::DoorkeeperError; end
class Doorkeeper::Errors::TokenRevoked < ::Doorkeeper::Errors::InvalidToken; end
class Doorkeeper::Errors::TokenUnknown < ::Doorkeeper::Errors::InvalidToken; end
class Doorkeeper::Errors::UnableToGenerateToken < ::Doorkeeper::Errors::DoorkeeperError; end

module Doorkeeper::GrantFlow
  extend ::Doorkeeper::GrantFlow::Registry
end

class Doorkeeper::GrantFlow::FallbackFlow < ::Doorkeeper::GrantFlow::Flow
  # @return [Boolean]
  def handles_grant_type?; end

  # @return [Boolean]
  def handles_response_type?; end
end

class Doorkeeper::GrantFlow::Flow
  # @return [Flow] a new instance of Flow
  def initialize(name, **options); end

  def default_response_mode; end

  # Returns the value of attribute grant_type_matches.
  def grant_type_matches; end

  # Returns the value of attribute grant_type_strategy.
  def grant_type_strategy; end

  # @return [Boolean]
  def handles_grant_type?; end

  # @return [Boolean]
  def handles_response_type?; end

  # @return [Boolean]
  def matches_grant_type?(value); end

  # @return [Boolean]
  def matches_response_mode?(value); end

  # @return [Boolean]
  def matches_response_type?(value); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute response_mode_matches.
  def response_mode_matches; end

  # Returns the value of attribute response_type_matches.
  def response_type_matches; end

  # Returns the value of attribute response_type_strategy.
  def response_type_strategy; end
end

module Doorkeeper::GrantFlow::Registry
  def aliases; end
  def aliases=(val); end
  def expand_alias(alias_name); end
  def flows; end
  def flows=(val); end

  # [NOTE]: make it to use #fetch after removing fallbacks
  def get(name); end

  # Allows to register custom OAuth grant flow so that Doorkeeper
  # could recognize and process it.
  def register(name_or_flow, **options); end

  # Allows to register aliases that could be used in `grant_flows`
  # configuration option. It is possible to have aliases like 1:1 or
  # 1:N, i.e. "implicit_oidc" => ['token', 'id_token', 'id_token token'].
  def register_alias(alias_name, **options); end

  class << self
    def aliases; end
    def aliases=(val); end
    def flows; end
    def flows=(val); end
  end
end

module Doorkeeper::Helpers; end

# Rails controller helpers.
module Doorkeeper::Helpers::Controller
  private

  def authenticate_admin!; end
  def authenticate_resource_owner!; end
  def config_methods; end
  def current_resource_owner; end
  def doorkeeper_token; end
  def enforce_content_type; end
  def get_error_response_from_exception(exception); end
  def handle_token_exception(exception); end
  def resource_owner_from_credentials; end
  def server; end

  # @return [Boolean]
  def skip_authorization?; end

  # @return [Boolean]
  def x_www_form_urlencoded?; end
end

# Defines a MissingConfiguration error for a missing Doorkeeper configuration
class Doorkeeper::MissingConfiguration < ::StandardError
  # @return [MissingConfiguration] a new instance of MissingConfiguration
  def initialize; end
end

# Doorkeeper option DSL could be reused in extensions to build their own
# configurations. To use the Option DSL gems need to define `builder_class` method
# that returns configuration Builder class. This exception raises when they don't
# define it.
class Doorkeeper::MissingConfigurationBuilderClass < ::StandardError; end

module Doorkeeper::Models; end

module Doorkeeper::Models::Accessible
  # Indicates whether the object is accessible (not expired and not revoked).
  #
  # @return [Boolean] true if object accessible or false in other case
  def accessible?; end
end

module Doorkeeper::Models::Expirable
  # Indicates whether the object is expired (`#expires_in` present and
  # expiration time has come).
  #
  # @return [Boolean] true if object expired and false in other case
  def expired?; end

  # Expiration time (date time of creation + TTL).
  #
  # @return [Time, nil] expiration time in UTC
  #   or nil if the object never expires.
  def expires_at; end

  # Calculates expiration time in seconds.
  #
  # @return [Integer, nil] number of seconds if object has expiration time
  #   or nil if object never expires.
  def expires_in_seconds; end
end

module Doorkeeper::Models::Orderable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Doorkeeper::Models::Orderable::ClassMethods
end

module Doorkeeper::Models::Orderable::ClassMethods
  def ordered_by(attribute, direction = T.unsafe(nil)); end
end

module Doorkeeper::Models::ResourceOwnerable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Doorkeeper::Models::ResourceOwnerable::ClassMethods
end

module Doorkeeper::Models::ResourceOwnerable::ClassMethods
  # Searches for record by Resource Owner considering Doorkeeper
  # configuration for resource owner association.
  #
  # @param resource_owner [ActiveRecord::Base, Integer] resource owner
  # @return [Doorkeeper::AccessGrant, Doorkeeper::AccessToken] collection of records
  def by_resource_owner(resource_owner); end

  protected

  # Backward compatible way to retrieve resource owner itself (if
  # polymorphic association enabled) or just it's ID.
  #
  # @param resource_owner [ActiveRecord::Base, Integer] resource owner
  # @return [ActiveRecord::Base, Integer] instance of Resource Owner or it's ID
  def resource_owner_id_for(resource_owner); end
end

module Doorkeeper::Models::Reusable
  # Indicates whether the object is reusable (i.e. It is not expired and
  # has not crossed reuse_limit).
  #
  # @return [Boolean] true if can be reused and false in other case
  def reusable?; end
end

module Doorkeeper::Models::Revocable
  # Revokes the object (updates `:revoked_at` attribute setting its value
  # to the specific time).
  #
  # @param clock [Time] time object
  def revoke(clock = T.unsafe(nil)); end

  # Indicates whether the object has been revoked.
  #
  # @return [Boolean] true if revoked, false in other case
  def revoked?; end
end

module Doorkeeper::Models::Scopes
  # @return [Boolean]
  def includes_scope?(*required_scopes); end

  def scopes; end
  def scopes=(value); end
  def scopes_string; end
end

# Storable finder to provide lookups for input plaintext values which are
# mapped to their stored versions (e.g., hashing, encryption) before lookup.
module Doorkeeper::Models::SecretStorable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Doorkeeper::Models::SecretStorable::ClassMethods

  def fallback_secret_strategy(*_arg0, &_arg1); end
  def secret_strategy(*_arg0, &_arg1); end
end

# :nodoc
module Doorkeeper::Models::SecretStorable::ClassMethods
  # Determine the fallback storing strategy
  # Unless configured, there will be no fallback
  def fallback_secret_strategy; end

  # Allow looking up previously plain tokens as a fallback
  # IFF a fallback strategy has been defined
  #
  # @param attr [Symbol] The token attribute we're looking with.
  # @param plain_secret [#to_s] plain secret value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessToken, nil] AccessToken object or nil
  #   if there is no record with such token
  def find_by_fallback_token(attr, plain_secret); end

  # Returns an instance of the Doorkeeper::AccessToken with
  # specific token value.
  #
  # @param attr [Symbol] The token attribute we're looking with.
  # @param token [#to_s] token value (any object that responds to `#to_s`)
  # @return [Doorkeeper::AccessToken, nil] AccessToken object or nil
  #   if there is no record with such token
  def find_by_plaintext_token(attr, token); end

  # Compare the given plaintext with the secret
  #
  # @param input [String] The plain input to compare.
  # @param secret [String] The secret value to compare with.
  # @return [Boolean] Whether input matches secret as per the secret strategy
  def secret_matches?(*_arg0, &_arg1); end

  # Determines the secret storing transformer
  # Unless configured otherwise, uses the plain secret strategy
  def secret_strategy; end

  # Allow implementations in ORMs to replace a plain
  # value falling back to to avoid it remaining as plain text.
  #
  # @param instance An instance of this model with a plain value token.
  # @param attr The secret attribute name to upgrade.
  # @param plain_secret The plain secret to upgrade.
  def upgrade_fallback_value(instance, attr, plain_secret); end
end

module Doorkeeper::OAuth; end
Doorkeeper::OAuth::AUTHORIZATION_CODE = T.let(T.unsafe(nil), String)
module Doorkeeper::OAuth::Authorization; end

class Doorkeeper::OAuth::Authorization::Code
  # @return [Code] a new instance of Code
  def initialize(pre_auth, resource_owner); end

  # @return [Boolean]
  def access_grant?; end

  def issue_token!; end
  def oob_redirect; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end

  # Returns the value of attribute token.
  def token; end

  private

  def access_grant_attributes; end
  def authorization_code_expires_in; end
  def pkce_attributes; end

  # Ensures firstly, if migration with additional PKCE columns was
  # generated and migrated
  #
  # @return [Boolean]
  def pkce_supported?; end
end

class Doorkeeper::OAuth::Authorization::Context
  # @return [Context] a new instance of Context
  def initialize(**attributes); end

  # Returns the value of attribute client.
  def client; end

  # Returns the value of attribute grant_type.
  def grant_type; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end

  # Returns the value of attribute scopes.
  def scopes; end
end

class Doorkeeper::OAuth::Authorization::Token
  # @return [Token] a new instance of Token
  def initialize(pre_auth, resource_owner); end

  # @return [Boolean]
  def access_token?; end

  def issue_token!; end
  def oob_redirect; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end

  # Returns the value of attribute token.
  def token; end

  private

  def controller; end

  class << self
    def access_token_expires_in(configuration, context); end
    def build_context(pre_auth_or_oauth_client, grant_type, scopes, resource_owner); end

    # @return [Boolean]
    def refresh_token_enabled?(server, context); end
  end
end

class Doorkeeper::OAuth::Authorization::URIBuilder
  class << self
    def uri_with_fragment(url, parameters = T.unsafe(nil)); end
    def uri_with_query(url, parameters = T.unsafe(nil)); end

    private

    def build_query(parameters = T.unsafe(nil)); end
  end
end

class Doorkeeper::OAuth::AuthorizationCodeRequest < ::Doorkeeper::OAuth::BaseRequest
  # @return [AuthorizationCodeRequest] a new instance of AuthorizationCodeRequest
  def initialize(server, grant, client, parameters = T.unsafe(nil)); end

  # Returns the value of attribute access_token.
  def access_token; end

  # Returns the value of attribute client.
  def client; end

  # Returns the value of attribute code_verifier.
  def code_verifier; end

  # Returns the value of attribute grant.
  def grant; end

  # Returns the value of attribute invalid_request_reason.
  def invalid_request_reason; end

  # Returns the value of attribute missing_param.
  def missing_param; end

  # Returns the value of attribute redirect_uri.
  def redirect_uri; end

  private

  def before_successful_response; end
  def generate_code_challenge(code_verifier); end

  # @return [Boolean]
  def pkce_supported?; end

  def resource_owner; end
  def validate_client; end

  # if either side (server or client) request PKCE, check the verifier
  # against the DB - if PKCE is supported
  def validate_code_verifier; end

  def validate_grant; end
  def validate_params; end
  def validate_redirect_uri; end
end

class Doorkeeper::OAuth::BaseRequest
  include ::Doorkeeper::Validations
  extend ::Doorkeeper::Validations::ClassMethods

  def after_successful_response; end
  def authorize; end
  def before_successful_response; end
  def default_scopes(*_arg0, &_arg1); end
  def find_or_create_access_token(client, resource_owner, scopes, server); end

  # Returns the value of attribute grant_type.
  def grant_type; end

  def scopes; end

  # Returns the value of attribute server.
  def server; end

  def server_config; end

  private

  def build_scopes; end
end

class Doorkeeper::OAuth::BaseResponse
  def body; end
  def description; end
  def headers; end
  def redirect_uri; end

  # @return [Boolean]
  def redirectable?; end

  def status; end
end

Doorkeeper::OAuth::CLIENT_CREDENTIALS = T.let(T.unsafe(nil), String)

class Doorkeeper::OAuth::Client
  # @return [Client] a new instance of Client
  def initialize(application); end

  # Returns the value of attribute application.
  def application; end

  def id(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def redirect_uri(*_arg0, &_arg1); end
  def scopes(*_arg0, &_arg1); end
  def uid(*_arg0, &_arg1); end

  class << self
    def authenticate(credentials, method = T.unsafe(nil)); end
    def find(uid, method = T.unsafe(nil)); end
  end
end

class Doorkeeper::OAuth::Client::Credentials < ::Struct
  def blank?(*_arg0, &_arg1); end

  # Returns the value of attribute secret
  #
  # @return [Object] the current value of secret
  def secret; end

  # Sets the attribute secret
  #
  # @param value [Object] the value to set the attribute secret to.
  # @return [Object] the newly set value
  def secret=(_); end

  # Returns the value of attribute uid
  #
  # @return [Object] the current value of uid
  def uid; end

  # Sets the attribute uid
  #
  # @param value [Object] the value to set the attribute uid to.
  # @return [Object] the newly set value
  def uid=(_); end

  class << self
    def [](*_arg0); end
    def from_basic(request); end
    def from_params(request); end
    def from_request(request, *credentials_methods); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Doorkeeper::OAuth::ClientCredentials; end

class Doorkeeper::OAuth::ClientCredentials::Creator
  def call(client, scopes, attributes = T.unsafe(nil)); end

  private

  def find_existing_token_for(client, scopes); end

  # @return [Boolean]
  def lookup_existing_token?; end

  def server_config; end
  def with_revocation(existing_token:); end
end

class Doorkeeper::OAuth::ClientCredentials::Issuer
  # @return [Issuer] a new instance of Issuer
  def initialize(server, validator); end

  def create(client, scopes, creator = T.unsafe(nil)); end

  # Returns the value of attribute error.
  def error; end

  # Returns the value of attribute token.
  def token; end

  # Returns the value of attribute validator.
  def validator; end

  private

  def create_token(client, scopes, creator); end
end

class Doorkeeper::OAuth::ClientCredentials::Validator
  include ::Doorkeeper::Validations
  include ::Doorkeeper::OAuth::Helpers
  extend ::Doorkeeper::Validations::ClassMethods

  # @return [Validator] a new instance of Validator
  def initialize(server, request); end

  private

  def validate_client; end
  def validate_client_supports_grant_flow; end
  def validate_scopes; end
end

class Doorkeeper::OAuth::ClientCredentialsRequest < ::Doorkeeper::OAuth::BaseRequest
  # @return [ClientCredentialsRequest] a new instance of ClientCredentialsRequest
  def initialize(server, client, parameters = T.unsafe(nil)); end

  def access_token; end

  # Returns the value of attribute client.
  def client; end

  def error(*_arg0, &_arg1); end

  # Returns the value of attribute response.
  def error_response; end

  def issuer; end

  # Returns the value of attribute original_scopes.
  def original_scopes; end

  # Returns the value of attribute response.
  def response; end

  private

  # @return [Boolean]
  def valid?; end
end

class Doorkeeper::OAuth::CodeRequest
  # @return [CodeRequest] a new instance of CodeRequest
  def initialize(pre_auth, resource_owner); end

  def authorize; end
  def deny; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end
end

class Doorkeeper::OAuth::CodeResponse < ::Doorkeeper::OAuth::BaseResponse
  include ::Doorkeeper::OAuth::Helpers

  # @return [CodeResponse] a new instance of CodeResponse
  def initialize(pre_auth, auth, options = T.unsafe(nil)); end

  # Returns the value of attribute auth.
  def auth; end

  def body; end
  def issued_token; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end

  def redirect_uri; end

  # @return [Boolean]
  def redirectable?; end

  # Returns the value of attribute response_on_fragment.
  def response_on_fragment; end
end

class Doorkeeper::OAuth::Error < ::Struct
  def description; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute state
  #
  # @return [Object] the current value of state
  def state; end

  # Sets the attribute state
  #
  # @param value [Object] the value to set the attribute state to.
  # @return [Object] the newly set value
  def state=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Doorkeeper::OAuth::ErrorResponse < ::Doorkeeper::OAuth::BaseResponse
  include ::Doorkeeper::OAuth::Helpers

  # @return [ErrorResponse] a new instance of ErrorResponse
  def initialize(attributes = T.unsafe(nil)); end

  def body; end
  def description(*_arg0, &_arg1); end
  def headers; end
  def name(*_arg0, &_arg1); end

  # @raise [exception_class.new(self)]
  def raise_exception!; end

  def redirect_uri; end

  # @return [Boolean]
  def redirectable?; end

  def state(*_arg0, &_arg1); end
  def status; end

  protected

  # @raise [NotImplementedError]
  def exception_class; end

  def realm; end

  private

  def authenticate_info; end

  class << self
    def from_request(request, attributes = T.unsafe(nil)); end
  end
end

Doorkeeper::OAuth::ErrorResponse::NON_REDIRECTABLE_STATES = T.let(T.unsafe(nil), Array)

class Doorkeeper::OAuth::ForbiddenTokenResponse < ::Doorkeeper::OAuth::ErrorResponse
  # @return [ForbiddenTokenResponse] a new instance of ForbiddenTokenResponse
  def initialize(attributes = T.unsafe(nil)); end

  def description; end
  def headers; end
  def status; end

  protected

  def exception_class; end

  class << self
    def from_scopes(scopes, attributes = T.unsafe(nil)); end
  end
end

Doorkeeper::OAuth::GRANT_TYPES = T.let(T.unsafe(nil), Array)
module Doorkeeper::OAuth::Helpers; end

module Doorkeeper::OAuth::Helpers::ScopeChecker
  class << self
    # @return [Boolean]
    def valid?(scope_str:, server_scopes:, app_scopes: T.unsafe(nil), grant_type: T.unsafe(nil)); end
  end
end

class Doorkeeper::OAuth::Helpers::ScopeChecker::Validator
  # @return [Validator] a new instance of Validator
  def initialize(scope_str, server_scopes, app_scopes, grant_type); end

  # Returns the value of attribute parsed_scopes.
  def parsed_scopes; end

  # Returns the value of attribute scope_str.
  def scope_str; end

  # @return [Boolean]
  def valid?; end

  private

  # @return [Boolean]
  def permitted_to_grant_type?; end

  def valid_scopes(server_scopes, app_scopes); end
end

module Doorkeeper::OAuth::Helpers::URIChecker
  class << self
    def as_uri(url); end

    # @return [Boolean]
    def hypertext_scheme?(uri); end

    # @return [Boolean]
    def iff_host?(uri); end

    # @return [Boolean]
    def loopback_uri?(uri); end

    # @return [Boolean]
    def matches?(url, client_url); end

    # @return [Boolean]
    def oob_uri?(uri); end

    # @return [Boolean]
    def query_matches?(query, client_query); end

    # @return [Boolean]
    def valid?(url); end

    # @return [Boolean]
    def valid_for_authorization?(url, client_url); end

    # @return [Boolean]
    def valid_scheme?(uri); end
  end
end

# Default Doorkeeper token generator. Follows OAuth RFC and
# could be customized using `default_generator_method` in
# configuration.
module Doorkeeper::OAuth::Helpers::UniqueToken
  class << self
    # Generator method for default generator class (SecureRandom)
    def default_generator_method; end

    def generate(options = T.unsafe(nil)); end
  end
end

module Doorkeeper::OAuth::Hooks; end

class Doorkeeper::OAuth::Hooks::Context
  # @return [Context] a new instance of Context
  def initialize(**attributes); end

  # Returns the value of attribute auth.
  def auth; end

  def issued_token; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end
end

Doorkeeper::OAuth::IMPLICIT = T.let(T.unsafe(nil), String)

class Doorkeeper::OAuth::InvalidRequestResponse < ::Doorkeeper::OAuth::ErrorResponse
  # @return [InvalidRequestResponse] a new instance of InvalidRequestResponse
  def initialize(attributes = T.unsafe(nil)); end

  def description; end

  # Returns the value of attribute reason.
  def reason; end

  # @return [Boolean]
  def redirectable?; end

  def status; end

  class << self
    def from_request(request, attributes = T.unsafe(nil)); end
  end
end

class Doorkeeper::OAuth::InvalidTokenResponse < ::Doorkeeper::OAuth::ErrorResponse
  # @return [InvalidTokenResponse] a new instance of InvalidTokenResponse
  def initialize(attributes = T.unsafe(nil)); end

  def description; end

  # Returns the value of attribute reason.
  def reason; end

  def status; end

  protected

  def exception_class; end

  private

  def errors_mapping; end

  class << self
    def from_access_token(access_token, attributes = T.unsafe(nil)); end
  end
end

class Doorkeeper::OAuth::NonStandard; end

# When you use this value, your application can then detect that the page has loaded, and can
# read the title of the HTML page to obtain the authorization code. It is then up to your
# application to close the browser window if you want to ensure that the user never sees the
# page that contains the authorization code. The mechanism for doing this varies from platform
# to platform.
#
# If your platform doesn't allow you to detect that the page has loaded or read the title of
# the page, you can have the user paste the code back to your application, as prompted by the
# text in the confirmation page that the OAuth 2.0 server generates.
Doorkeeper::OAuth::NonStandard::IETF_WG_OAUTH2_OOB = T.let(T.unsafe(nil), String)

# This is identical to urn:ietf:wg:oauth:2.0:oob, but the text in the confirmation page that
# the OAuth 2.0 server generates won't instruct the user to copy the authorization code, but
# instead will simply ask the user to close the window.
#
# This is useful when your application reads the title of the HTML page (by checking window
# titles on the desktop, for example) to obtain the authorization code, but can't close the
# page on its own.
Doorkeeper::OAuth::NonStandard::IETF_WG_OAUTH2_OOB_AUTO = T.let(T.unsafe(nil), String)

Doorkeeper::OAuth::NonStandard::IETF_WG_OAUTH2_OOB_METHODS = T.let(T.unsafe(nil), Array)
Doorkeeper::OAuth::PASSWORD = T.let(T.unsafe(nil), String)

class Doorkeeper::OAuth::PasswordAccessTokenRequest < ::Doorkeeper::OAuth::BaseRequest
  include ::Doorkeeper::OAuth::Helpers

  # @return [PasswordAccessTokenRequest] a new instance of PasswordAccessTokenRequest
  def initialize(server, client, credentials, resource_owner, parameters = T.unsafe(nil)); end

  # Returns the value of attribute access_token.
  def access_token; end

  # Returns the value of attribute client.
  def client; end

  # Returns the value of attribute credentials.
  def credentials; end

  # Returns the value of attribute parameters.
  def parameters; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end

  private

  def before_successful_response; end

  # Section 4.3.2. Access Token Request for Resource Owner Password Credentials Grant:
  #
  #   If the client type is confidential or the client was issued client credentials (or assigned
  #   other authentication requirements), the client MUST authenticate with the authorization
  #   server as described in Section 3.2.1.
  #
  #   The authorization server MUST:
  #
  #    o  require client authentication for confidential clients or for any  client that was
  #       issued client credentials (or with other authentication requirements)
  #
  #    o  authenticate the client if client authentication is included,
  #
  #   @see https://datatracker.ietf.org/doc/html/rfc6749#section-4.3
  def validate_client; end

  def validate_client_supports_grant_flow; end
  def validate_resource_owner; end
  def validate_scopes; end
end

class Doorkeeper::OAuth::PreAuthorization
  include ::Doorkeeper::Validations
  extend ::Doorkeeper::Validations::ClassMethods

  # @return [PreAuthorization] a new instance of PreAuthorization
  def initialize(server, parameters = T.unsafe(nil), resource_owner = T.unsafe(nil)); end

  def as_json(_options = T.unsafe(nil)); end

  # @return [Boolean]
  def authorizable?; end

  # Returns the value of attribute authorization_response_flow.
  def authorization_response_flow; end

  # Returns the value of attribute client.
  def client; end

  # Returns the value of attribute code_challenge.
  def code_challenge; end

  # Returns the value of attribute code_challenge_method.
  def code_challenge_method; end

  def error_response; end

  # @return [Boolean]
  def form_post_response?; end

  # Returns the value of attribute missing_param.
  def missing_param; end

  # Returns the value of attribute redirect_uri.
  def redirect_uri; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end

  # Returns the value of attribute response_mode.
  def response_mode; end

  # Returns the value of attribute response_type.
  def response_type; end

  def scope; end
  def scopes; end

  # Returns the value of attribute state.
  def state; end

  private

  def build_scopes; end

  # Returns the value of attribute client_id.
  def client_id; end

  def grant_type; end
  def pre_auth_hash; end

  # @return [Boolean]
  def response_on_fragment?; end

  # Returns the value of attribute server.
  def server; end

  def validate_client; end
  def validate_client_id; end
  def validate_client_supports_grant_flow; end
  def validate_code_challenge_method; end
  def validate_params; end
  def validate_redirect_uri; end
  def validate_resource_owner_authorize_for_client; end
  def validate_response_mode; end
  def validate_response_type; end
  def validate_scopes; end
end

Doorkeeper::OAuth::REFRESH_TOKEN = T.let(T.unsafe(nil), String)

class Doorkeeper::OAuth::RefreshTokenRequest < ::Doorkeeper::OAuth::BaseRequest
  include ::Doorkeeper::OAuth::Helpers

  # @return [RefreshTokenRequest] a new instance of RefreshTokenRequest
  def initialize(server, refresh_token, credentials, parameters = T.unsafe(nil)); end

  # Returns the value of attribute access_token.
  def access_token; end

  # Returns the value of attribute client.
  def client; end

  # Returns the value of attribute credentials.
  def credentials; end

  # Returns the value of attribute missing_param.
  def missing_param; end

  # Returns the value of attribute refresh_token.
  def refresh_token; end

  private

  def before_successful_response; end
  def create_access_token; end
  def default_scopes; end
  def load_client(credentials); end

  # @return [Boolean]
  def refresh_token_revoked_on_use?; end

  def validate_client; end

  # @see https://datatracker.ietf.org/doc/html/rfc6749#section-1.5
  def validate_client_match; end

  def validate_scope; end
  def validate_token; end
  def validate_token_presence; end
end

class Doorkeeper::OAuth::Scopes
  include ::Enumerable
  include ::Comparable

  # @return [Scopes] a new instance of Scopes
  def initialize; end

  def &(other); end
  def +(other); end
  def <=>(other); end
  def add(*scopes); end
  def all; end
  def each(*_arg0, &_arg1); end
  def empty?(*_arg0, &_arg1); end

  # @return [Boolean]
  def exists?(scope); end

  # @return [Boolean]
  def has_scopes?(scopes); end

  # @return [Boolean]
  def scopes?(scopes); end

  def to_s; end

  private

  def to_array(other); end

  class << self
    def from_array(array); end
    def from_string(string); end
  end
end

class Doorkeeper::OAuth::Token
  class << self
    def authenticate(request, *methods); end
    def from_access_token_param(request); end
    def from_basic_authorization(request); end
    def from_bearer_authorization(request); end
    def from_bearer_param(request); end
    def from_request(request, *methods); end

    private

    def decode_basic_credentials_token(encoded_header); end

    # @return [Boolean]
    def match?(header, pattern); end

    def token_from_basic_header(header, pattern); end
    def token_from_header(header, pattern); end
  end
end

# RFC7662 OAuth 2.0 Token Introspection
#
# @see https://datatracker.ietf.org/doc/html/rfc7662
class Doorkeeper::OAuth::TokenIntrospection
  # @return [TokenIntrospection] a new instance of TokenIntrospection
  def initialize(server, token); end

  # @return [Boolean]
  def authorized?; end

  def error_response; end
  def to_json(*_arg0); end

  private

  # Boolean indicator of whether or not the presented token
  # is currently active.  The specifics of a token's "active" state
  # will vary depending on the implementation of the authorization
  # server and the information it keeps about its tokens, but a "true"
  # value return for the "active" property will generally indicate
  # that a given token has been issued by this authorization server,
  # has not been revoked by the resource owner, and is within its
  # given time window of validity (e.g., after its issuance time and
  # before its expiration time).
  #
  # Any other error is considered an "inactive" token.
  #
  # * The token requested does not exist or is invalid
  # * The token expired
  # * The token was issued to a different client than is making this request
  #
  # Since resource servers using token introspection rely on the
  # authorization server to determine the state of a token, the
  # authorization server MUST perform all applicable checks against a
  # token's state.  For instance, these tests include the following:
  #
  #    o  If the token can expire, the authorization server MUST determine
  #       whether or not the token has expired.
  #    o  If the token can be issued before it is able to be used, the
  #       authorization server MUST determine whether or not a token's valid
  #       period has started yet.
  #    o  If the token can be revoked after it was issued, the authorization
  #       server MUST determine whether or not such a revocation has taken
  #       place.
  #    o  If the token has been signed, the authorization server MUST
  #       validate the signature.
  #    o  If the token can be used only at certain resource servers, the
  #       authorization server MUST determine whether or not the token can
  #       be used at the resource server making the introspection call.
  #
  # @return [Boolean]
  def active?; end

  # If the protected resource uses OAuth 2.0 client credentials to
  # authenticate to the introspection endpoint and its credentials are
  # invalid, the authorization server responds with an HTTP 401
  # (Unauthorized) as described in Section 5.2 of OAuth 2.0 [RFC6749].
  #
  # Endpoint must first validate the authentication.
  # If the authentication is invalid, the endpoint should respond with
  # an HTTP 401 status code and an invalid_client response.
  #
  # To prevent token scanning attacks, the endpoint MUST also require
  # some form of authorization to access this endpoint, such as client
  # authentication as described in OAuth 2.0 [RFC6749] or a separate
  # OAuth 2.0 access token such as the bearer token described in OAuth
  # 2.0 Bearer Token Usage [RFC6750].
  #
  # @see https://www.oauth.com/oauth2-servers/token-introspection-endpoint/
  def authorize!; end

  # Client Authentication
  def authorized_client; end

  # Bearer Token Authentication
  def authorized_token; end

  # RFC7662 Section 2.1
  #
  # @return [Boolean]
  def authorized_token_matches_introspected?; end

  # Allows to customize introspection response.
  # Provides context (controller) and token for generating developer-specific
  # response.
  #
  # @see https://datatracker.ietf.org/doc/html/rfc7662#section-2.2
  def customize_response(response); end

  # Returns the value of attribute error.
  def error; end

  # If the introspection call is properly authorized but the token is not
  # active, does not exist on this server, or the protected resource is
  # not allowed to introspect this particular token, then the
  # authorization server MUST return an introspection response with the
  # "active" field set to "false".  Note that to avoid disclosing too
  # much of the authorization server's state to a third party, the
  # authorization server SHOULD NOT include any additional information
  # about an inactive token, including why the token is inactive.
  #
  # @see https://datatracker.ietf.org/doc/html/rfc7662 2.2. Introspection Response
  def failure_response; end

  # Returns the value of attribute invalid_request_reason.
  def invalid_request_reason; end

  # Returns the value of attribute server.
  def server; end

  # 2.2. Introspection Response
  def success_response; end

  # Returns the value of attribute token.
  def token; end

  # Config constraints for introspection in Doorkeeper.config.allow_token_introspection
  #
  # @return [Boolean]
  def token_introspection_allowed?(auth_client: T.unsafe(nil), auth_token: T.unsafe(nil)); end

  # @return [Boolean]
  def valid_authorized_token?; end

  # Token can be valid only if it is not expired or revoked.
  #
  # @return [Boolean]
  def valid_token?; end
end

class Doorkeeper::OAuth::TokenRequest
  # @return [TokenRequest] a new instance of TokenRequest
  def initialize(pre_auth, resource_owner); end

  def authorize; end
  def deny; end

  # Returns the value of attribute pre_auth.
  def pre_auth; end

  # Returns the value of attribute resource_owner.
  def resource_owner; end
end

class Doorkeeper::OAuth::TokenResponse
  # @return [TokenResponse] a new instance of TokenResponse
  def initialize(token); end

  def body; end
  def headers; end
  def status; end

  # Returns the value of attribute token.
  def token; end
end

module Doorkeeper::Orm; end

# ActiveRecord ORM for Doorkeeper entity models.
# Consists of three main OAuth entities:
#   * Access Token
#   * Access Grant
#   * Application (client)
#
# Do a lazy loading of all the required and configured stuff.
module Doorkeeper::Orm::ActiveRecord
  class << self
    def initialize_application_owner!; end
    def initialize_models!; end
    def lazy_load(&block); end
    def models; end
  end
end

module Doorkeeper::Rails; end

# Abstract router module that implements base behavior
# for generating and mapping Rails routes.
#
# Could be reused in Doorkeeper extensions.
module Doorkeeper::Rails::AbstractRouter
  extend ::ActiveSupport::Concern

  def initialize(routes, mapper = T.unsafe(nil), &block); end

  # @raise [NotImplementedError]
  def generate_routes!(**_options); end

  # Returns the value of attribute routes.
  def routes; end

  private

  def map_route(name, method); end
end

module Doorkeeper::Rails::Helpers
  def doorkeeper_authorize!(*scopes); end
  def doorkeeper_forbidden_render_options(**_arg0); end
  def doorkeeper_unauthorized_render_options(**_arg0); end

  # @return [Boolean]
  def valid_doorkeeper_token?; end

  private

  def doorkeeper_error; end

  # @return [Boolean]
  def doorkeeper_invalid_token_response?; end

  def doorkeeper_render_error; end
  def doorkeeper_render_error_with(error); end
  def doorkeeper_render_options(error); end
  def doorkeeper_status_for_error(error, respond_not_found_when_forbidden); end
  def doorkeeper_token; end
end

class Doorkeeper::Rails::Routes
  include ::Doorkeeper::Rails::AbstractRouter
  extend ::Doorkeeper::Rails::Routes::Registry

  # @return [Routes] a new instance of Routes
  def initialize(routes, mapper = T.unsafe(nil), &block); end

  def generate_routes!(options); end
  def mapping; end

  private

  def application_routes(mapping); end
  def authorization_routes(mapping); end
  def authorized_applications_routes(mapping); end
  def introspect_routes(mapping); end
  def revoke_routes(mapping); end
  def token_info_routes(mapping); end
  def token_routes(mapping); end

  class << self
    def install!; end
    def mapping; end
  end
end

module Doorkeeper::Rails::Routes::Helper
  def use_doorkeeper(options = T.unsafe(nil), &block); end
end

class Doorkeeper::Rails::Routes::Mapper
  # @return [Mapper] a new instance of Mapper
  def initialize(mapping = T.unsafe(nil)); end

  def as(alias_names = T.unsafe(nil)); end
  def controllers(controller_names = T.unsafe(nil)); end
  def map(&block); end
  def skip_controllers(*controller_names); end
end

class Doorkeeper::Rails::Routes::Mapping
  # @return [Mapping] a new instance of Mapping
  def initialize; end

  def [](routes); end

  # Returns the value of attribute as.
  def as; end

  # Sets the attribute as
  #
  # @param value the value to set the attribute as to.
  def as=(_arg0); end

  # Returns the value of attribute controllers.
  def controllers; end

  # Sets the attribute controllers
  #
  # @param value the value to set the attribute controllers to.
  def controllers=(_arg0); end

  # @return [Boolean]
  def skipped?(controller); end

  # Returns the value of attribute skips.
  def skips; end

  # Sets the attribute skips
  #
  # @param value the value to set the attribute skips to.
  def skips=(_arg0); end
end

# Thread-safe registry of any Doorkeeper additional routes.
# Used to allow implementing of Doorkeeper extensions that must
# use their own routes.
module Doorkeeper::Rails::Routes::Registry
  # Registers additional routes in the Doorkeeper registry
  #
  # @param routes [Object] routes class
  def register(routes); end

  # Registers additional routes in the Doorkeeper registry
  #
  # @param routes [Object] routes class
  def register_routes(routes); end

  # Collection of additional registered routes for Doorkeeper.
  #
  # @return [Array<Object>] set of registered routes
  def registered_routes; end
end

class Doorkeeper::Rails::Routes::Registry::InvalidRouterClass < ::StandardError; end
Doorkeeper::Rails::Routes::Registry::ROUTES_ACCESS_LOCK = T.let(T.unsafe(nil), Thread::Mutex)
Doorkeeper::Rails::Routes::Registry::ROUTES_DEFINITION_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

module Doorkeeper::Rake
  class << self
    def load_tasks; end
  end
end

module Doorkeeper::Request
  class << self
    def authorization_strategy(response_type); end

    # @raise [Errors::MissingRequiredParameter]
    def token_strategy(grant_type); end

    private

    def authorization_flows; end

    # [NOTE]: this will be removed in a newer versions of Doorkeeper.
    # For retro-compatibility only
    def available; end

    def build_fallback_strategy_class(grant_or_request_type); end
    def token_flows; end
  end
end

class Doorkeeper::Request::AuthorizationCode < ::Doorkeeper::Request::Strategy
  def client(*_arg0, &_arg1); end
  def parameters(*_arg0, &_arg1); end
  def request; end

  private

  # @raise [Errors::MissingRequiredParameter]
  def grant; end
end

class Doorkeeper::Request::ClientCredentials < ::Doorkeeper::Request::Strategy
  def client(*_arg0, &_arg1); end
  def parameters(*_arg0, &_arg1); end
  def request; end
end

class Doorkeeper::Request::Code < ::Doorkeeper::Request::Strategy
  def current_resource_owner(*_arg0, &_arg1); end
  def pre_auth; end
  def request; end
end

class Doorkeeper::Request::Password < ::Doorkeeper::Request::Strategy
  def client(*_arg0, &_arg1); end
  def credentials(*_arg0, &_arg1); end
  def parameters(*_arg0, &_arg1); end
  def request; end
  def resource_owner(*_arg0, &_arg1); end
end

class Doorkeeper::Request::RefreshToken < ::Doorkeeper::Request::Strategy
  def credentials(*_arg0, &_arg1); end
  def parameters(*_arg0, &_arg1); end
  def refresh_token; end
  def request; end
end

class Doorkeeper::Request::Strategy
  # @return [Strategy] a new instance of Strategy
  def initialize(server); end

  def authorize(*_arg0, &_arg1); end

  # @raise [NotImplementedError]
  def request; end

  # Returns the value of attribute server.
  def server; end
end

class Doorkeeper::Request::Token < ::Doorkeeper::Request::Strategy
  def current_resource_owner(*_arg0, &_arg1); end
  def pre_auth; end
  def request; end
end

module Doorkeeper::SecretStoring; end

# Plain text secret storing, which is the default
# but also provides fallback lookup if
# other secret storing mechanisms are enabled.
class Doorkeeper::SecretStoring::BCrypt < ::Doorkeeper::SecretStoring::Base
  class << self
    # Determines whether this strategy supports restoring
    # secrets from the database. This allows detecting users
    # trying to use a non-restorable strategy with +reuse_access_tokens+.
    #
    # @return [Boolean]
    def allows_restoring_secrets?; end

    # Test if we can require the BCrypt gem
    #
    # @return [Boolean]
    def bcrypt_present?; end

    # Securely compare the given +input+ value with a +stored+ value
    # processed by +transform_secret+.
    #
    # @return [Boolean]
    def secret_matches?(input, stored); end

    # Return the value to be stored by the database
    #
    # @param plain_secret The plain secret input / generated
    def transform_secret(plain_secret); end

    # Determines what secrets this strategy is applicable for
    def validate_for(model); end
  end
end

# Base class for secret storing, including common helpers
class Doorkeeper::SecretStoring::Base
  class << self
    # Determines whether this strategy supports restoring
    # secrets from the database. This allows detecting users
    # trying to use a non-restorable strategy with +reuse_access_tokens+.
    #
    # @return [Boolean]
    def allows_restoring_secrets?; end

    # Return the restored value from the database
    # as retrieved from the database.
    #
    # @param resource The resource instance to act on
    # @param attribute The secret attribute to restore
    # @raise [NotImplementedError]
    def restore_secret(_resource, _attribute); end

    # Securely compare the given +input+ value with a +stored+ value
    # processed by +transform_secret+.
    #
    # @return [Boolean]
    def secret_matches?(input, stored); end

    # Transform and store the given secret attribute => value
    # pair used for safely storing the attribute
    #
    # @param resource The model instance being modified
    # @param attribute The secret attribute
    # @param plain_secret The plain secret input / generated
    def store_secret(resource, attribute, plain_secret); end

    # Return the value to be stored by the database
    # used for looking up a database value.
    #
    # @param plain_secret The plain secret input / generated
    # @raise [NotImplementedError]
    def transform_secret(_plain_secret); end

    # Determines what secrets this strategy is applicable for
    #
    # @raise [ArgumentError]
    def validate_for(model); end
  end
end

# Plain text secret storing, which is the default
# but also provides fallback lookup if
# other secret storing mechanisms are enabled.
class Doorkeeper::SecretStoring::Plain < ::Doorkeeper::SecretStoring::Base
  class << self
    # Plain values obviously allow restoring
    #
    # @return [Boolean]
    def allows_restoring_secrets?; end

    # Return the restored value from the database
    # as retrieved from the database.
    #
    # @param resource The resource instance to act on
    # @param attribute The secret attribute to restore
    def restore_secret(resource, attribute); end

    # Return the value to be stored by the database
    #
    # @param plain_secret The plain secret input / generated
    def transform_secret(plain_secret); end
  end
end

# Plain text secret storing, which is the default
# but also provides fallback lookup if
# other secret storing mechanisms are enabled.
class Doorkeeper::SecretStoring::Sha256Hash < ::Doorkeeper::SecretStoring::Base
  class << self
    # Determines whether this strategy supports restoring
    # secrets from the database. This allows detecting users
    # trying to use a non-restorable strategy with +reuse_access_tokens+.
    #
    # @return [Boolean]
    def allows_restoring_secrets?; end

    # Return the value to be stored by the database
    #
    # @param plain_secret The plain secret input / generated
    def transform_secret(plain_secret); end
  end
end

class Doorkeeper::Server
  # @return [Server] a new instance of Server
  def initialize(context); end

  def authorization_request(strategy); end
  def client; end

  # Returns the value of attribute context.
  def context; end

  def credentials; end
  def current_resource_owner; end

  # TODO: context should be the request
  def parameters; end

  # TODO: Use configuration and evaluate proper context on block
  def resource_owner; end

  def token_request(strategy); end
end

class Doorkeeper::StaleRecordsCleaner
  class << self
    def configured_orm; end
    def for(base_scope); end
    def new(base_scope); end
  end
end

Doorkeeper::StaleRecordsCleaner::CLEANER_CLASS = T.let(T.unsafe(nil), String)
module Doorkeeper::VERSION; end

# Semantic versioning
Doorkeeper::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

Doorkeeper::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# Full version number
Doorkeeper::VERSION::STRING = T.let(T.unsafe(nil), String)

Doorkeeper::VERSION::TINY = T.let(T.unsafe(nil), Integer)

module Doorkeeper::Validations
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Doorkeeper::Validations::ClassMethods

  # Returns the value of attribute error.
  def error; end

  # Sets the attribute error
  #
  # @param value the value to set the attribute error to.
  def error=(_arg0); end

  # @return [Boolean]
  def valid?; end

  def validate; end
end

module Doorkeeper::Validations::ClassMethods
  def validate(attribute, options = T.unsafe(nil)); end
  def validations; end
end
