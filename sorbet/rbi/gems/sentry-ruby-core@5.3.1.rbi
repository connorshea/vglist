# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sentry-ruby-core` gem.
# Please instead update this file by running `bin/tapioca gem sentry-ruby-core`.

# @api private
module Rake
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils

  class << self
    # Add files to the rakelib list
    def add_rakelib(*files); end

    # Current Rake Application
    def application; end

    # Set the current Rake application object.
    def application=(app); end

    # Yield each file or directory component.
    def each_dir_parent(dir); end

    # Convert Pathname and Pathname-like objects to strings;
    # leave everything else alone
    def from_pathname(path); end

    # Load a rakefile.
    def load_rakefile(path); end

    # Return the original directory where the Rake application was started.
    def original_dir; end

    def suggested_thread_count; end

    # Make +block_application+ the default rake application inside a block so
    # you can load rakefiles into a different application.
    #
    # This is useful when you want to run rake tasks inside a library without
    # running rake in a sub-shell.
    #
    # Example:
    #
    #   Dir.chdir 'other/directory'
    #
    #   other_rake = Rake.with_application do |rake|
    #     rake.load_rakefile
    #   end
    #
    #   puts other_rake.tasks
    def with_application(block_application = T.unsafe(nil)); end
  end
end

# Rake main application object.  When invoking +rake+ from the
# command line, a Rake::Application object is created and run.
#
# @api private
class Rake::Application
  include ::Sentry::Rake::Application

  # Initialize a Rake::Application object.
  #
  # @return [Application] a new instance of Application
  def initialize; end

  # Add a file to the list of files to be imported.
  def add_import(fn); end

  # Add a loader to handle imported files ending in the extension
  # +ext+.
  def add_loader(ext, loader); end

  # Collect the list of tasks on the command line.  If no tasks are
  # given, return a list containing only the default task.
  # Environmental assignments are processed at this time as well.
  #
  # `args` is the list of arguments to peruse to get the list of tasks.
  # It should be the command line that was given to rake, less any
  # recognised command-line options, which OptionParser.parse will
  # have taken care of already.
  def collect_command_line_tasks(args); end

  # Default task name ("default").
  # (May be overridden by subclasses)
  def default_task_name; end

  # Warn about deprecated usage.
  #
  # Example:
  #    Rake.application.deprecate("import", "Rake.import", caller.first)
  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  # Display the error message that caused the exception.
  def display_error_message(ex); end

  def display_exception_backtrace(ex); end
  def display_exception_details(ex); end
  def display_exception_details_seen; end
  def display_exception_message_details(ex); end

  # Display the tasks and prerequisites
  def display_prerequisites; end

  # Display the tasks and comments.
  def display_tasks_and_comments; end

  # Calculate the dynamic width of the
  def dynamic_width; end

  def dynamic_width_stty; end
  def dynamic_width_tput; end

  # Exit the program because of an unhandled exception.
  # (may be overridden by subclasses)
  def exit_because_of_exception(ex); end

  def find_rakefile_location; end

  # Read and handle the command line options.  Returns the command line
  # arguments that we didn't understand, which should (in theory) be just
  # task names and env vars.
  def handle_options(argv); end

  # @return [Boolean]
  def has_cause?(ex); end

  # True if one of the files in RAKEFILES is in the current directory.
  # If a match is found, it is copied into @rakefile.
  def have_rakefile; end

  # Initialize the command line parameters and app name.
  def init(app_name = T.unsafe(nil), argv = T.unsafe(nil)); end

  # Invokes a task with arguments that are extracted from +task_string+
  def invoke_task(task_string); end

  # Load the pending list of imported files.
  def load_imports; end

  # Find the rakefile and then load it and any pending imports.
  def load_rakefile; end

  # The name of the application (typically 'rake')
  def name; end

  # Application options from the command line
  def options; end

  # The original directory where rake was invoked.
  def original_dir; end

  def parse_task_string(string); end
  def print_rakefile_directory(location); end

  # Similar to the regular Ruby +require+ command, but will check
  # for *.rake files in addition to *.rb files.
  def rake_require(file_name, paths = T.unsafe(nil), loaded = T.unsafe(nil)); end

  # Name of the actual rakefile used.
  def rakefile; end

  def rakefile_location(backtrace = T.unsafe(nil)); end
  def raw_load_rakefile; end

  # Run the Rake application.  The run method performs the following
  # three steps:
  #
  # * Initialize the command line options (+init+).
  # * Define the tasks (+load_rakefile+).
  # * Run the top level tasks (+top_level+).
  #
  # If you wish to build a custom rake command, you should call
  # +init+ on your application.  Then define any tasks.  Finally,
  # call +top_level+ to run your top level tasks.
  def run(argv = T.unsafe(nil)); end

  # Run the given block with the thread startup and shutdown.
  def run_with_threads; end

  def set_default_options; end

  # Provide standard exception handling for the given block.
  def standard_exception_handling; end

  # A list of all the standard options used in rake, suitable for
  # passing to OptionParser.
  def standard_rake_options; end

  # The directory path containing the system wide rakefiles.
  def system_dir; end

  # Number of columns on the terminal
  def terminal_columns; end

  # Number of columns on the terminal
  def terminal_columns=(_arg0); end

  def terminal_width; end

  # Return the thread pool used for multithreaded processing.
  def thread_pool; end

  # Run the top level tasks of a Rake application.
  def top_level; end

  # List of the top level task names (task names from the command line).
  def top_level_tasks; end

  def trace(*strings); end
  def truncate(string, width); end

  # We will truncate output if we are outputting to a TTY or if we've been
  # given an explicit column width to honor
  #
  # @return [Boolean]
  def truncate_output?; end

  # Override the detected TTY output state (mostly for testing)
  def tty_output=(_arg0); end

  # True if we are outputting to TTY, false otherwise
  #
  # @return [Boolean]
  def tty_output?; end

  # @return [Boolean]
  def unix?; end

  # @return [Boolean]
  def windows?; end

  private

  def glob(path, &block); end

  # Does the exception have a task invocation chain?
  #
  # @return [Boolean]
  def has_chain?(exception); end

  def select_tasks_to_show(options, show_tasks, value); end
  def select_trace_output(options, trace_option, value); end
  def sort_options(options); end
  def standard_system_dir; end
end

Rake::Application::DEFAULT_RAKEFILES = T.let(T.unsafe(nil), Array)
Rake::EARLY = T.let(T.unsafe(nil), Rake::EarlyTime)
Rake::EMPTY_TASK_ARGS = T.let(T.unsafe(nil), Rake::TaskArguments)
Rake::LATE = T.let(T.unsafe(nil), Rake::LateTime)
Rake::RDocTask = RDoc::Task

# A Task is the basic unit of work in a Rakefile.  Tasks have associated
# actions (possibly more than one) and a list of prerequisites.  When
# invoked, a task will first ensure that all of its prerequisites have an
# opportunity to run and then it will execute its own actions.
#
# Tasks are not usually created directly using the new method, but rather
# use the +file+ and +task+ convenience methods.
#
# @api private
class Rake::Task
  include ::Sentry::Rake::Task

  # Create a task named +task_name+ with no actions or prerequisites. Use
  # +enhance+ to add actions and prerequisites.
  #
  # @return [Task] a new instance of Task
  def initialize(task_name, app); end

  # List of actions attached to a task.
  def actions; end

  # Add a description to the task.  The description can consist of an option
  # argument list (enclosed brackets) and an optional comment.
  def add_description(description); end

  # List of all unique prerequisite tasks including prerequisite tasks'
  # prerequisites.
  # Includes self when cyclic dependencies are found.
  def all_prerequisite_tasks; end

  # Has this task already been invoked?  Already invoked tasks
  # will be skipped unless you reenable them.
  def already_invoked; end

  # Application owning this task.
  def application; end

  # Application owning this task.
  def application=(_arg0); end

  # Argument description (nil if none).
  def arg_description; end

  # Name of arguments for this task.
  def arg_names; end

  # Clear the existing prerequisites, actions, comments, and arguments of a rake task.
  def clear; end

  # Clear the existing actions on a rake task.
  def clear_actions; end

  # Clear the existing arguments on a rake task.
  def clear_args; end

  # Clear the existing comments on a rake task.
  def clear_comments; end

  # Clear the existing prerequisites of a rake task.
  def clear_prerequisites; end

  # First line (or sentence) of all comments. Multiple comments are
  # separated by a "/".
  def comment; end

  def comment=(comment); end

  # Enhance a task with prerequisites or actions.  Returns self.
  def enhance(deps = T.unsafe(nil), &block); end

  # Execute the actions associated with this task.
  def execute(args = T.unsafe(nil)); end

  # Full collection of comments. Multiple comments are separated by
  # newlines.
  def full_comment; end

  def inspect; end

  # Return a string describing the internal state of a task.  Useful for
  # debugging.
  def investigation; end

  # Invoke the task if it is needed.  Prerequisites are invoked first.
  def invoke(*args); end

  # Invoke all the prerequisites of a task.
  def invoke_prerequisites(task_args, invocation_chain); end

  # Invoke all the prerequisites of a task in parallel.
  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  # File/Line locations of each of the task definitions for this
  # task (only valid if the task was defined with the detect
  # location option set).
  def locations; end

  # Name of the task, including any namespace qualifiers.
  def name; end

  # Name of task with argument list description.
  def name_with_args; end

  # Is this task needed?
  #
  # @return [Boolean]
  def needed?; end

  # List of order only prerequisites for a task.
  def order_only_prerequisites; end

  # List of prerequisites for a task.
  def prereqs; end

  # List of prerequisite tasks
  def prerequisite_tasks; end

  # List of prerequisites for a task.
  def prerequisites; end

  # Reenable the task, allowing its tasks to be executed if the task
  # is invoked again.
  def reenable; end

  # Array of nested namespaces names used for task lookup by this task.
  def scope; end

  # Set the names of the arguments for this task. +args+ should be
  # an array of symbols, one for each argument name.
  def set_arg_names(args); end

  # First source from a rule (nil if no sources)
  def source; end

  def sources; end

  # List of sources for task.
  def sources=(_arg0); end

  # Timestamp for this task.  Basic tasks return the current time for their
  # time stamp.  Other tasks can be more sophisticated.
  def timestamp; end

  # Return task name
  def to_s; end

  # Add order only dependencies.
  def |(deps); end

  protected

  def collect_prerequisites(seen); end

  # Same as invoke, but explicitly pass a call chain to detect
  # circular dependencies.
  #
  # If multiple tasks depend on this
  # one in parallel, they will all fail if the first execution of
  # this task fails.
  def invoke_with_call_chain(task_args, invocation_chain); end

  private

  def add_chain_to(exception, new_chain); end
  def add_comment(comment); end

  # Get the first sentence in a string. The sentence is terminated
  # by the first period, exclamation mark, or the end of the line.
  # Decimal points do not count as periods.
  def first_sentence(string); end

  # Format the trace flags for display.
  def format_trace_flags; end

  def lookup_prerequisite(prerequisite_name); end

  # Transform the list of comments as specified by the block and
  # join with the separator.
  def transform_comments(separator, &block); end

  class << self
    # Return a task with the given name.  If the task is not currently
    # known, try to synthesize one from the defined rules.  If no rules are
    # found, but an existing file matches the task name, assume it is a file
    # task with no dependencies or actions.
    def [](task_name); end

    # Clear the task list.  This cause rake to immediately forget all the
    # tasks that have been assigned.  (Normally used in the unit tests.)
    def clear; end

    # Define a rule for synthesizing tasks.
    def create_rule(*args, &block); end

    # Define a task given +args+ and an option block.  If a rule with the
    # given name already exists, the prerequisites and actions are added to
    # the existing task.  Returns the defined task.
    def define_task(*args, &block); end

    # Format dependencies parameter to pass to task.
    def format_deps(deps); end

    # Apply the scope to the task name according to the rules for
    # this kind of task.  Generic tasks will accept the scope as
    # part of the name.
    def scope_name(scope, task_name); end

    # TRUE if the task name is already defined.
    #
    # @return [Boolean]
    def task_defined?(task_name); end

    # List of all defined tasks.
    def tasks; end
  end
end

Rake::VERSION = T.let(T.unsafe(nil), String)

# Based on ActionDispatch::RemoteIp. All security-related precautions from that
# middleware have been removed, because the Event IP just needs to be accurate,
# and spoofing an IP here only makes data inaccurate, not insecure. Don't re-use
# this module if you have to *trust* the IP address.
module Sentry
  class << self
    # Takes an instance of Sentry::Breadcrumb and stores it to the current active scope.
    #
    # @return [Breadcrumb, nil]
    def add_breadcrumb(breadcrumb, **options); end

    def apply_patches(config); end

    # @return [BackgroundWorker]
    def background_worker; end

    # Sets the attribute background_worker
    #
    # @param value the value to set the attribute background_worker to.
    def background_worker=(_arg0); end

    # Takes an instance of Sentry::Event and dispatches it to the currently active hub.
    #
    # @return [Event, nil]
    def capture_event(event); end

    # Takes an exception and reports it to Sentry via the currently active hub.
    #
    # @return [Event, nil]
    # @yieldparam scope [Scope]
    def capture_exception(exception, **options, &block); end

    # Takes a message string and reports it to Sentry via the currently active hub.
    #
    # @return [Event, nil]
    # @yieldparam scope [Scope]
    def capture_message(message, **options, &block); end

    # Clones the main thread's active hub and stores it to the current thread.
    #
    # @return [void]
    def clone_hub_to_current_thread; end

    def configuration; end

    # Takes a block and yields the current active scope.
    #
    # @example
    #   Sentry.configure_scope do |scope|
    #   scope.set_tags(foo: "bar")
    #   end
    #
    #   Sentry.capture_message("test message") # this event will have tags { foo: "bar" }
    # @return [void]
    # @yieldparam scope [Scope]
    def configure_scope(&block); end

    # Returns an uri for security policy reporting that's generated from the given DSN
    # (To learn more about security policy reporting: https://docs.sentry.io/product/security-policy-reporting/)
    #
    # It returns nil if
    # - The SDK is not initialized yet.
    # - The DSN is not provided or is invalid.
    #
    # @return [String, nil]
    def csp_report_uri; end

    # Checks if the exception object has been captured by the SDK.
    #
    # @return [Boolean]
    def exception_captured?(exc); end

    def exception_locals_tp; end

    # Returns the current active client.
    #
    # @return [Client, nil]
    def get_current_client; end

    # Returns the current active hub.
    # If the current thread doesn't have an active hub, it will clone the main thread's active hub,
    # stores it in the current thread, and then returns it.
    #
    # @return [Hub]
    def get_current_hub; end

    # Returns the current active scope.
    #
    # @return [Scope, nil]
    def get_current_scope; end

    # Returns the main thread's active hub.
    #
    # @return [Hub]
    def get_main_hub; end

    # Initializes the SDK with given configuration.
    #
    # @return [void]
    # @yieldparam config [Configuration]
    def init(&block); end

    # Returns true if the SDK is initialized.
    #
    # @return [Boolean]
    def initialized?; end

    # Returns a hash that contains all the integrations that have been registered to the main SDK.
    #
    # @return [Hash{String=>Hash}]
    def integrations; end

    # Returns the id of the lastly reported Sentry::Event.
    #
    # @return [String, nil]
    def last_event_id; end

    def logger; end
    def railtie_helpers_paths; end
    def railtie_namespace; end
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # Registers the SDK integration with its name and version.
    #
    # @param name [String] name of the integration
    # @param version [String] version of the integration
    def register_integration(name, version); end

    def register_patch(&block); end
    def registered_patches; end
    def sdk_meta; end
    def send_event(*args); end

    # Returns the value of attribute session_flusher.
    def session_flusher; end

    def set_context(*args); end
    def set_extras(*args); end
    def set_tags(*args); end
    def set_user(*args); end

    # Takes or initializes a new Sentry::Transaction and makes a sampling decision for it.
    #
    # @return [Transaction, nil]
    def start_transaction(**options); end

    def sys_command(command); end
    def table_name_prefix; end
    def use_relative_model_naming?; end
    def utc_now; end

    # Records the block's execution as a child of the current span.
    # If the current scope doesn't have a span, the block would still be executed but the yield param will be nil.
    #
    # @example
    #   Sentry.with_child_span(op: "my operation") do |child_span|
    #   child_span.set_data(operation_data)
    #   child_span.set_description(operation_detail)
    #   # result will be returned
    #   end
    # @param attributes [Hash] attributes for the child span.
    # @return yield result
    # @yieldparam child_span [Span, nil]
    def with_child_span(**attributes, &block); end

    # Takes a block and yields a temporary scope.
    # The temporary scope will inherit all the attributes from the current active scope and replace it to be the active
    # scope inside the block.
    #
    # @example
    #   Sentry.configure_scope do |scope|
    #   scope.set_tags(foo: "bar")
    #   end
    #
    #   Sentry.capture_message("test message") # this event will have tags { foo: "bar" }
    #
    #   Sentry.with_scope do |temp_scope|
    #   temp_scope.set_tags(foo: "baz")
    #   Sentry.capture_message("test message 2") # this event will have tags { foo: "baz" }
    #   end
    #
    #   Sentry.capture_message("test message 3") # this event will have tags { foo: "bar" }
    # @return [void]
    # @yieldparam scope [Scope]
    def with_scope(&block); end

    # Wrap a given block with session tracking.
    # Aggregate sessions in minutely buckets will be recorded
    # around this block and flushed every minute.
    #
    # @example
    #   Sentry.with_session_tracking do
    #   a = 1 + 1 # new session recorded with :exited status
    #   end
    #
    #   Sentry.with_session_tracking do
    #   1 / 0
    #   rescue => e
    #   Sentry.capture_exception(e) # new session recorded with :errored status
    #   end
    # @return [void]
    def with_session_tracking(&block); end
  end
end

module Sentry::ArgumentCheckingHelper
  private

  def check_argument_type!(argument, expected_type); end
end

class Sentry::BackgroundWorker
  include ::Sentry::LoggingHelper

  # @return [BackgroundWorker] a new instance of BackgroundWorker
  def initialize(configuration); end

  # @deprecated Use Sentry.logger to retrieve the current logger instead.
  def logger; end

  # Returns the value of attribute max_queue.
  def max_queue; end

  # Returns the value of attribute number_of_threads.
  def number_of_threads; end

  # if you want to monkey-patch this method, please override `_perform` instead
  def perform(&block); end

  def shutdown; end

  # Returns the value of attribute shutdown_timeout.
  def shutdown_timeout; end

  # Sets the attribute shutdown_timeout
  #
  # @param value the value to set the attribute shutdown_timeout to.
  def shutdown_timeout=(_arg0); end

  private

  def _perform(&block); end
end

# @api private
class Sentry::Backtrace
  # @api private
  # @return [Backtrace] a new instance of Backtrace
  def initialize(lines); end

  # @api private
  def ==(other); end

  # @api private
  def inspect; end

  # holder for an Array of Backtrace::Line instances
  #
  # @api private
  def lines; end

  # @api private
  def to_s; end

  class << self
    # @api private
    def parse(backtrace, project_root, app_dirs_pattern, &backtrace_cleanup_callback); end
  end
end

# @api private
Sentry::Backtrace::APP_DIRS_PATTERN = T.let(T.unsafe(nil), Regexp)

# Handles backtrace parsing line by line
#
# @api private
class Sentry::Backtrace::Line
  # @api private
  # @return [Line] a new instance of Line
  def initialize(file, number, method, module_name, in_app_pattern); end

  # @api private
  def ==(other); end

  # The file portion of the line (such as app/models/user.rb)
  #
  # @api private
  def file; end

  # @api private
  def in_app; end

  # @api private
  def in_app_pattern; end

  # @api private
  def inspect; end

  # The method of the line (such as index)
  #
  # @api private
  def method; end

  # The module name (JRuby)
  #
  # @api private
  def module_name; end

  # The line number portion of the line
  #
  # @api private
  def number; end

  # Reconstructs the line in a readable fashion
  #
  # @api private
  def to_s; end

  class << self
    # Parses a single line of a given backtrace
    #
    # @api private
    # @param unparsed_line [String] The raw line from +caller+ or some backtrace
    # @return [Line] The parsed backtrace line
    def parse(unparsed_line, in_app_pattern); end
  end
end

# org.jruby.runtime.callsite.CachingCallSite.call(CachingCallSite.java:170)
#
# @api private
Sentry::Backtrace::Line::JAVA_INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)

# @api private
Sentry::Backtrace::Line::RB_EXTENSION = T.let(T.unsafe(nil), String)

# regexp (optional leading X: on windows, or JRuby9000 class-prefix)
#
# @api private
Sentry::Backtrace::Line::RUBY_INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)

class Sentry::Breadcrumb
  # @param category [String, nil]
  # @param data [Hash, nil]
  # @param message [String, nil]
  # @param timestamp [Time, Integer, nil]
  # @param level [String, nil]
  # @param type [String, nil]
  # @return [Breadcrumb] a new instance of Breadcrumb
  def initialize(category: T.unsafe(nil), data: T.unsafe(nil), message: T.unsafe(nil), timestamp: T.unsafe(nil), level: T.unsafe(nil), type: T.unsafe(nil)); end

  # @return [String, nil]
  def category; end

  # @return [String, nil]
  def category=(_arg0); end

  # @return [Hash, nil]
  def data; end

  # @return [Hash, nil]
  def data=(_arg0); end

  # @return [String, nil]
  def level; end

  # @return [String, nil]
  def level=(_arg0); end

  # @return [String, nil]
  def message; end

  # @param message [String]
  # @return [void]
  def message=(message); end

  # @return [Time, Integer, nil]
  def timestamp; end

  # @return [Time, Integer, nil]
  def timestamp=(_arg0); end

  # @return [Hash]
  def to_hash; end

  # @return [String, nil]
  def type; end

  # @return [String, nil]
  def type=(_arg0); end

  private

  def serialized_data; end
end

Sentry::Breadcrumb::DATA_SERIALIZATION_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

class Sentry::BreadcrumbBuffer
  include ::Enumerable

  # @param size [Integer, nil] If it's not provided, it'll fallback to DEFAULT_SIZE
  # @return [BreadcrumbBuffer] a new instance of BreadcrumbBuffer
  def initialize(size = T.unsafe(nil)); end

  # @return [Array]
  def buffer; end

  # @return [Array]
  def buffer=(_arg0); end

  # @return [BreadcrumbBuffer]
  def dup; end

  # Iterates through all breadcrumbs.
  #
  # @param block [Proc]
  # @return [Array]
  # @yieldparam crumb [Breadcrumb]
  def each(&block); end

  # @return [Boolean]
  def empty?; end

  # @return [Array]
  def members; end

  # Returns the last breadcrumb stored in the buffer. If the buffer it's empty, it returns nil.
  #
  # @return [Breadcrumb, nil]
  def peek; end

  # @param crumb [Breadcrumb]
  # @return [void]
  # @yield [crumb]
  def record(crumb); end

  # @return [Hash]
  def to_hash; end
end

Sentry::BreadcrumbBuffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
Sentry::CAPTURED_SIGNATURE = T.let(T.unsafe(nil), Symbol)

class Sentry::Client
  include ::Sentry::LoggingHelper

  # @param configuration [Configuration]
  # @return [Client] a new instance of Client
  def initialize(configuration); end

  # Applies the given scope's data to the event and sends it to Sentry.
  #
  # @param event [Event] the event to be sent.
  # @param scope [Scope] the scope with contextual data that'll be applied to the event before it's sent.
  # @param hint [Hash] the hint data that'll be passed to `before_send` callback and the scope's event processors.
  # @return [Event, nil]
  def capture_event(event, scope, hint = T.unsafe(nil)); end

  # Returns the value of attribute configuration.
  def configuration; end

  # Initializes an Event object with the given exception. Returns `nil` if the exception's class is excluded from reporting.
  #
  # @param exception [Exception] the exception to be reported.
  # @param hint [Hash] the hint data that'll be passed to `before_send` callback and the scope's event processors.
  # @return [Event, nil]
  def event_from_exception(exception, hint = T.unsafe(nil)); end

  # Initializes an Event object with the given message.
  #
  # @param message [String] the message to be reported.
  # @param hint [Hash] the hint data that'll be passed to `before_send` callback and the scope's event processors.
  # @return [Event]
  def event_from_message(message, hint = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Initializes an Event object with the given Transaction object.
  #
  # @param transaction [Transaction] the transaction to be recorded.
  # @return [TransactionEvent]
  def event_from_transaction(transaction); end

  # Generates a Sentry trace for distribted tracing from the given Span.
  # Returns `nil` if `config.propagate_traces` is `false`.
  #
  # @param span [Span] the span to generate trace from.
  # @return [String, nil]
  def generate_sentry_trace(span); end

  # @deprecated Use Sentry.logger to retrieve the current logger instead.
  def logger; end

  def send_event(event, hint = T.unsafe(nil)); end

  # The Transport object that'll send events for the client.
  #
  # @return [Transport]
  def transport; end

  private

  def dispatch_async_event(async_block, event, hint); end
  def dispatch_background_event(event, hint); end
end

class Sentry::Configuration
  include ::Sentry::CustomInspection
  include ::Sentry::LoggingHelper

  # @return [Configuration] a new instance of Configuration
  def initialize; end

  # Directories to be recognized as part of your app. e.g. if you
  # have an `engines` dir at the root of your project, you may want
  # to set this to something like /(app|config|engines|lib)/
  #
  # @return [Regexp, nil]
  def app_dirs_pattern; end

  # Directories to be recognized as part of your app. e.g. if you
  # have an `engines` dir at the root of your project, you may want
  # to set this to something like /(app|config|engines|lib)/
  #
  # @return [Regexp, nil]
  def app_dirs_pattern=(_arg0); end

  # Provide an object that responds to `call` to send events asynchronously.
  # E.g.: lambda { |event| Thread.new { Sentry.send_event(event) } }
  #
  # @deprecated It will be removed in the next major release. Please read https://github.com/getsentry/sentry-ruby/issues/1522 for more information
  # @return [Proc, nil]
  def async; end

  def async=(value); end

  # Track sessions in request/response cycles automatically
  #
  # @return [Boolean]
  def auto_session_tracking; end

  # Track sessions in request/response cycles automatically
  #
  # @return [Boolean]
  def auto_session_tracking=(_arg0); end

  # to send events in a non-blocking way, sentry-ruby has its own background worker
  # by default, the worker holds a thread pool that has [the number of processors] threads
  # but you can configure it with this configuration option
  # E.g.: config.background_worker_threads = 5
  #
  # if you want to send events synchronously, set the value to 0
  # E.g.: config.background_worker_threads = 0
  #
  # @return [Integer]
  def background_worker_threads; end

  # to send events in a non-blocking way, sentry-ruby has its own background worker
  # by default, the worker holds a thread pool that has [the number of processors] threads
  # but you can configure it with this configuration option
  # E.g.: config.background_worker_threads = 5
  #
  # if you want to send events synchronously, set the value to 0
  # E.g.: config.background_worker_threads = 0
  #
  # @return [Integer]
  def background_worker_threads=(_arg0); end

  # a proc/lambda that takes an array of stack traces
  # it'll be used to silence (reduce) backtrace of the exception
  #
  # @example
  #   config.backtrace_cleanup_callback = lambda do |backtrace|
  #   Rails.backtrace_cleaner.clean(backtrace)
  #   end
  # @return [Proc, nil]
  def backtrace_cleanup_callback; end

  # a proc/lambda that takes an array of stack traces
  # it'll be used to silence (reduce) backtrace of the exception
  #
  # @example
  #   config.backtrace_cleanup_callback = lambda do |backtrace|
  #   Rails.backtrace_cleaner.clean(backtrace)
  #   end
  # @return [Proc, nil]
  def backtrace_cleanup_callback=(_arg0); end

  # Optional Proc, called before adding the breadcrumb to the current scope
  #
  # @example
  #   config.before = lambda do |breadcrumb, hint|
  #   breadcrumb.message = 'a'
  #   breadcrumb
  #   end
  # @return [Proc]
  def before_breadcrumb; end

  def before_breadcrumb=(value); end

  # Optional Proc, called before sending an event to the server
  #
  # @example
  #   config.before_send = lambda do |event, hint|
  #   # skip ZeroDivisionError exceptions
  #   # note: hint[:exception] would be a String if you use async callback
  #   if hint[:exception].is_a?(ZeroDivisionError)
  #   nil
  #   else
  #   event
  #   end
  #   end
  # @return [Proc]
  def before_send; end

  def before_send=(value); end

  # An array of breadcrumbs loggers to be used. Available options are:
  # - :sentry_logger
  # - :http_logger
  # - :redis_logger
  #
  # And if you also use sentry-rails:
  # - :active_support_logger
  # - :monotonic_active_support_logger
  #
  # @return [Array<Symbol>]
  def breadcrumbs_logger; end

  def breadcrumbs_logger=(logger); end

  # Whether to capture local variables from the raised exception's frame. Default is false.
  #
  # @return [Boolean]
  def capture_exception_frame_locals; end

  # Whether to capture local variables from the raised exception's frame. Default is false.
  #
  # @return [Boolean]
  def capture_exception_frame_locals=(_arg0); end

  # Number of lines of code context to capture, or nil for none
  #
  # @return [Integer, nil]
  def context_lines; end

  # Number of lines of code context to capture, or nil for none
  #
  # @return [Integer, nil]
  def context_lines=(_arg0); end

  # @return [String, nil]
  def csp_report_uri; end

  # Whether the SDK should run in the debugging mode. Default is false.
  # If set to true, SDK errors will be logged with backtrace
  #
  # @return [Boolean]
  def debug; end

  # Whether the SDK should run in the debugging mode. Default is false.
  # If set to true, SDK errors will be logged with backtrace
  #
  # @return [Boolean]
  def debug=(_arg0); end

  # @api private
  def detect_release; end

  # the dsn value, whether it's set via `config.dsn=` or `ENV["SENTRY_DSN"]`
  #
  # @return [String]
  def dsn; end

  def dsn=(value); end

  # Whitelist of enabled_environments that will send notifications to Sentry. Array of Strings.
  #
  # @return [Array<String>]
  def enabled_environments; end

  # Whitelist of enabled_environments that will send notifications to Sentry. Array of Strings.
  #
  # @return [Array<String>]
  def enabled_environments=(_arg0); end

  # @return [Boolean]
  def enabled_in_current_env?; end

  # RACK_ENV by default.
  #
  # @return [String]
  def environment; end

  def environment=(environment); end

  # @api private
  def error_messages; end

  # these are not config options
  def errors; end

  # @return [Boolean]
  def exception_class_allowed?(exc); end

  # Logger 'progname's to exclude from breadcrumbs
  #
  # @return [Array<String>]
  def exclude_loggers; end

  # Logger 'progname's to exclude from breadcrumbs
  #
  # @return [Array<String>]
  def exclude_loggers=(_arg0); end

  # Array of exception classes that should never be sent. See IGNORE_DEFAULT.
  # You should probably append to this rather than overwrite it.
  #
  # @return [Array<String>]
  def excluded_exceptions; end

  # Array of exception classes that should never be sent. See IGNORE_DEFAULT.
  # You should probably append to this rather than overwrite it.
  #
  # @return [Array<String>]
  def excluded_exceptions=(_arg0); end

  # these are not config options
  def gem_specs; end

  # Boolean to check nested exceptions when deciding if to exclude. Defaults to true
  #
  # @return [Boolean]
  def inspect_exception_causes_for_exclusion; end

  # Boolean to check nested exceptions when deciding if to exclude. Defaults to true
  #
  # @return [Boolean]
  def inspect_exception_causes_for_exclusion=(_arg0); end

  # Boolean to check nested exceptions when deciding if to exclude. Defaults to true
  #
  # @return [Boolean]
  def inspect_exception_causes_for_exclusion?; end

  # You may provide your own LineCache for matching paths with source files.
  # This may be useful if you need to get source code from places other than the disk.
  #
  # @return [LineCache]
  # @see LineCache
  def linecache; end

  # You may provide your own LineCache for matching paths with source files.
  # This may be useful if you need to get source code from places other than the disk.
  #
  # @return [LineCache]
  # @see LineCache
  def linecache=(_arg0); end

  # Logger used by Sentry. In Rails, this is the Rails logger, otherwise
  # Sentry provides its own Sentry::Logger.
  #
  # @return [Logger]
  def logger; end

  # Logger used by Sentry. In Rails, this is the Rails logger, otherwise
  # Sentry provides its own Sentry::Logger.
  #
  # @return [Logger]
  def logger=(_arg0); end

  # Max number of breadcrumbs a breadcrumb buffer can hold
  #
  # @return [Integer]
  def max_breadcrumbs; end

  # Max number of breadcrumbs a breadcrumb buffer can hold
  #
  # @return [Integer]
  def max_breadcrumbs=(_arg0); end

  # Project directory root for in_app detection. Could be Rails root, etc.
  # Set automatically for Rails.
  #
  # @return [String]
  def project_root; end

  # Project directory root for in_app detection. Could be Rails root, etc.
  # Set automatically for Rails.
  #
  # @return [String]
  def project_root=(_arg0); end

  # Insert sentry-trace to outgoing requests' headers
  #
  # @return [Boolean]
  def propagate_traces; end

  # Insert sentry-trace to outgoing requests' headers
  #
  # @return [Boolean]
  def propagate_traces=(_arg0); end

  # Array of rack env parameters to be included in the event sent to sentry.
  #
  # @return [Array<String>]
  def rack_env_whitelist; end

  # Array of rack env parameters to be included in the event sent to sentry.
  #
  # @return [Array<String>]
  def rack_env_whitelist=(_arg0); end

  # Returns the value of attribute rails.
  def rails; end

  # Release tag to be passed with every event sent to Sentry.
  # We automatically try to set this to a git SHA or Capistrano release.
  #
  # @return [String]
  def release; end

  # Release tag to be passed with every event sent to Sentry.
  # We automatically try to set this to a git SHA or Capistrano release.
  #
  # @return [String]
  def release=(_arg0); end

  # @return [Boolean]
  def sample_allowed?; end

  # The sampling factor to apply to events. A value of 0.0 will not send
  # any events, and a value of 1.0 will send 100% of events.
  #
  # @return [Float]
  def sample_rate; end

  # The sampling factor to apply to events. A value of 0.0 will not send
  # any events, and a value of 1.0 will send 100% of events.
  #
  # @return [Float]
  def sample_rate=(_arg0); end

  # Send diagnostic client reports about dropped events, true by default
  # tries to attach to an existing envelope max once every 30s
  #
  # @return [Boolean]
  def send_client_reports; end

  # Send diagnostic client reports about dropped events, true by default
  # tries to attach to an existing envelope max once every 30s
  #
  # @return [Boolean]
  def send_client_reports=(_arg0); end

  # When send_default_pii's value is false (default), sensitive information like
  # - user ip
  # - user cookie
  # - request body
  # - query string
  # will not be sent to Sentry.
  #
  # @return [Boolean]
  def send_default_pii; end

  # When send_default_pii's value is false (default), sensitive information like
  # - user ip
  # - user cookie
  # - request body
  # - query string
  # will not be sent to Sentry.
  #
  # @return [Boolean]
  def send_default_pii=(_arg0); end

  # Include module versions in reports - boolean.
  #
  # @return [Boolean]
  def send_modules; end

  # Include module versions in reports - boolean.
  #
  # @return [Boolean]
  def send_modules=(_arg0); end

  # @return [Boolean]
  def sending_allowed?; end

  def server=(value); end

  # @return [String]
  def server_name; end

  # @return [String]
  def server_name=(_arg0); end

  # Allow to skip Sentry emails within rake tasks
  #
  # @return [Boolean]
  def skip_rake_integration; end

  # Allow to skip Sentry emails within rake tasks
  #
  # @return [Boolean]
  def skip_rake_integration=(_arg0); end

  # @api private
  def stacktrace_builder; end

  # Take a float between 0.0 and 1.0 as the sample rate for tracing events (transactions).
  #
  # @return [Float]
  def traces_sample_rate; end

  # Take a float between 0.0 and 1.0 as the sample rate for tracing events (transactions).
  #
  # @return [Float]
  def traces_sample_rate=(_arg0); end

  # Take a Proc that controls the sample rate for every tracing event, e.g.
  #
  # @example
  #   config.traces_sampler =  lambda do |tracing_context|
  #   # tracing_context[:transaction_context] contains the information about the transaction
  #   # tracing_context[:parent_sampled] contains the transaction's parent's sample decision
  #   true # return value can be a boolean or a float between 0.0 and 1.0
  #   end
  # @return [Proc]
  def traces_sampler; end

  # Take a Proc that controls the sample rate for every tracing event, e.g.
  #
  # @example
  #   config.traces_sampler =  lambda do |tracing_context|
  #   # tracing_context[:transaction_context] contains the information about the transaction
  #   # tracing_context[:parent_sampled] contains the transaction's parent's sample decision
  #   true # return value can be a boolean or a float between 0.0 and 1.0
  #   end
  # @return [Proc]
  def traces_sampler=(_arg0); end

  # @return [Boolean]
  def tracing_enabled?; end

  # Return a Transport::Configuration object for transport-related configurations.
  #
  # @return [Transport]
  def transport; end

  # IP ranges for trusted proxies that will be skipped when calculating IP address.
  def trusted_proxies; end

  # IP ranges for trusted proxies that will be skipped when calculating IP address.
  def trusted_proxies=(_arg0); end

  private

  # @return [Boolean]
  def capture_in_environment?; end

  def check_callable!(name, value); end
  def environment_from_env; end

  # @return [Boolean]
  def excluded_exception?(incoming_exception); end

  def excluded_exception_classes; end
  def get_exception_class(x); end
  def init_dsn(dsn_string); end

  # @return [Boolean]
  def matches_exception?(excluded_exception_class, incoming_exception); end

  def run_post_initialization_callbacks; end

  # @return [Boolean]
  def running_on_heroku?; end

  def safe_const_get(x); end
  def server_name_from_env; end

  # @return [Boolean]
  def valid?; end

  class << self
    # allow extensions to add their hooks to the Configuration class
    def add_post_initialization_callback(&block); end

    def post_initialization_callbacks; end
  end
end

Sentry::Configuration::HEROKU_DYNO_METADATA_MESSAGE = T.let(T.unsafe(nil), String)

# Most of these errors generate 4XX responses. In general, Sentry clients
# only automatically report 5xx responses.
Sentry::Configuration::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)

Sentry::Configuration::LOG_PREFIX = T.let(T.unsafe(nil), String)
Sentry::Configuration::MODULE_SEPARATOR = T.let(T.unsafe(nil), String)
Sentry::Configuration::RACK_ENV_WHITELIST_DEFAULT = T.let(T.unsafe(nil), Array)
Sentry::Configuration::SKIP_INSPECTION_ATTRIBUTES = T.let(T.unsafe(nil), Array)

module Sentry::CustomInspection
  def inspect; end
end

class Sentry::DSN
  # @return [DSN] a new instance of DSN
  def initialize(dsn_string); end

  def csp_report_uri; end
  def envelope_endpoint; end
  def host; end
  def path; end
  def port; end
  def project_id; end
  def public_key; end
  def scheme; end
  def secret_key; end
  def server; end
  def to_s; end

  # @return [Boolean]
  def valid?; end
end

Sentry::DSN::PORT_MAP = T.let(T.unsafe(nil), Hash)
Sentry::DSN::REQUIRED_ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Sentry::DummyTransport < ::Sentry::Transport
  # @return [DummyTransport] a new instance of DummyTransport
  def initialize(*_arg0); end

  # Returns the value of attribute envelopes.
  def envelopes; end

  # Sets the attribute envelopes
  #
  # @param value the value to set the attribute envelopes to.
  def envelopes=(_arg0); end

  # Returns the value of attribute events.
  def events; end

  # Sets the attribute events
  #
  # @param value the value to set the attribute events to.
  def events=(_arg0); end

  def send_envelope(envelope); end
  def send_event(event); end
end

# @api private
class Sentry::Envelope
  # @api private
  # @return [Envelope] a new instance of Envelope
  def initialize(headers = T.unsafe(nil)); end

  # @api private
  def add_item(headers, payload); end

  # @api private
  def event_id; end

  # @api private
  def headers; end

  # @api private
  def headers=(_arg0); end

  # @api private
  def item_types; end

  # @api private
  def items; end

  # @api private
  def items=(_arg0); end
end

# @api private
class Sentry::Envelope::Item
  # @api private
  # @return [Item] a new instance of Item
  def initialize(headers, payload); end

  # @api private
  def headers; end

  # @api private
  def headers=(_arg0); end

  # @api private
  def payload; end

  # @api private
  def payload=(_arg0); end

  # @api private
  def to_s; end

  # @api private
  def type; end
end

class Sentry::Error < ::StandardError; end

# ErrorEvent represents error or normal message events.
class Sentry::ErrorEvent < ::Sentry::Event
  def add_exception_interface(exception); end
  def add_threads_interface(backtrace: T.unsafe(nil), **options); end

  # @return [ExceptionInterface]
  def exception; end

  # @return [ThreadsInterface]
  def threads; end

  # @return [Hash]
  def to_hash; end
end

# This is an abstract class that defines the shared attributes of an event.
# Please don't use it directly. The user-facing classes are its child classes.
class Sentry::Event
  include ::Sentry::CustomInspection

  # @param configuration [Configuration]
  # @param integration_meta [Hash, nil]
  # @param message [String, nil]
  # @return [Event] a new instance of Event
  def initialize(configuration:, integration_meta: T.unsafe(nil), message: T.unsafe(nil)); end

  def breadcrumbs; end
  def breadcrumbs=(_arg0); end

  # @deprecated This method will be removed in v5.0.0. Please just use Sentry.configuration
  # @return [Configuration]
  def configuration; end

  def contexts; end
  def contexts=(_arg0); end
  def environment; end
  def environment=(_arg0); end
  def event_id; end
  def event_id=(_arg0); end
  def extra; end
  def extra=(_arg0); end
  def fingerprint; end
  def fingerprint=(_arg0); end
  def level; end

  # Sets the event's level.
  #
  # @param level [String, Symbol]
  # @return [void]
  def level=(level); end

  def message; end
  def message=(_arg0); end
  def modules; end
  def modules=(_arg0); end
  def platform; end
  def platform=(_arg0); end

  # Sets the event's request environment data with RequestInterface.
  #
  # @param env [Hash]
  # @return [void]
  # @see RequestInterface
  def rack_env=(env); end

  def release; end
  def release=(_arg0); end

  # @return [RequestInterface]
  def request; end

  def sdk; end
  def sdk=(_arg0); end
  def server_name; end
  def server_name=(_arg0); end
  def tags; end
  def tags=(_arg0); end
  def timestamp; end

  # Sets the event's timestamp.
  #
  # @param time [Time, Float]
  # @return [void]
  def timestamp=(time); end

  # @return [Hash]
  def to_hash; end

  # @return [Hash]
  def to_json_compatible; end

  def transaction; end
  def transaction=(_arg0); end
  def type; end
  def user; end
  def user=(_arg0); end

  private

  def add_request_interface(env); end

  # When behind a proxy (or if the user is using a proxy), we can't use
  # REMOTE_ADDR to determine the Event IP, and must use other headers instead.
  def calculate_real_ip_from_rack(env); end

  def serialize_attributes; end

  class << self
    def get_log_message(event_hash); end
    def get_message_from_exception(event_hash); end
  end
end

Sentry::Event::MAX_MESSAGE_SIZE_IN_BYTES = T.let(T.unsafe(nil), Integer)
Sentry::Event::MAX_SERIALIZED_PAYLOAD_SIZE = T.let(T.unsafe(nil), Integer)

# These are readable attributes.
Sentry::Event::SERIALIZEABLE_ATTRIBUTES = T.let(T.unsafe(nil), Array)

Sentry::Event::SKIP_INSPECTION_ATTRIBUTES = T.let(T.unsafe(nil), Array)
Sentry::Event::TYPE = T.let(T.unsafe(nil), String)

# These are writable attributes.
Sentry::Event::WRITER_ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Sentry::ExceptionInterface < ::Sentry::Interface
  # @param exceptions [Array<SingleExceptionInterface>]
  # @return [ExceptionInterface] a new instance of ExceptionInterface
  def initialize(exceptions:); end

  # @return [Hash]
  def to_hash; end

  class << self
    # Builds ExceptionInterface with given exception and stacktrace_builder.
    #
    # @param exception [Exception]
    # @param stacktrace_builder [StacktraceBuilder]
    # @return [ExceptionInterface]
    # @see SingleExceptionInterface#build_with_stacktrace
    # @see SingleExceptionInterface#initialize
    def build(exception:, stacktrace_builder:); end
  end
end

class Sentry::ExternalError < ::Sentry::Error; end

class Sentry::HTTPTransport < ::Sentry::Transport
  # @return [HTTPTransport] a new instance of HTTPTransport
  def initialize(*args); end

  def send_data(data); end

  private

  def conn; end
  def handle_rate_limited_response(headers); end

  # @return [Boolean]
  def has_rate_limited_header?(headers); end

  def normalize_proxy(proxy); end
  def parse_rate_limit_header(rate_limit_header); end

  # @return [Boolean]
  def should_compress?(data); end

  def ssl_configuration; end
end

Sentry::HTTPTransport::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Sentry::HTTPTransport::DEFAULT_DELAY = T.let(T.unsafe(nil), Integer)
Sentry::HTTPTransport::GZIP_ENCODING = T.let(T.unsafe(nil), String)
Sentry::HTTPTransport::GZIP_THRESHOLD = T.let(T.unsafe(nil), Integer)
Sentry::HTTPTransport::RATE_LIMIT_HEADER = T.let(T.unsafe(nil), String)
Sentry::HTTPTransport::RETRY_AFTER_HEADER = T.let(T.unsafe(nil), String)
Sentry::HTTPTransport::USER_AGENT = T.let(T.unsafe(nil), String)

class Sentry::Hub
  include ::Sentry::ArgumentCheckingHelper

  # @return [Hub] a new instance of Hub
  def initialize(client, scope); end

  def add_breadcrumb(breadcrumb, hint: T.unsafe(nil)); end
  def bind_client(client); end
  def capture_event(event, **options, &block); end
  def capture_exception(exception, **options, &block); end
  def capture_message(message, **options, &block); end
  def clone; end
  def configuration; end
  def configure_scope(&block); end
  def current_client; end
  def current_scope; end
  def end_session; end

  # Returns the value of attribute last_event_id.
  def last_event_id; end

  def new_from_top; end
  def pop_scope; end
  def push_scope; end
  def start_session; end
  def start_transaction(transaction: T.unsafe(nil), custom_sampling_context: T.unsafe(nil), **options); end

  # this doesn't do anything to the already initialized background worker
  # but it temporarily disables dispatching events to it
  def with_background_worker_disabled(&block); end

  def with_scope(&block); end
  def with_session_tracking(&block); end

  private

  def current_layer; end
end

class Sentry::Hub::Layer
  # @return [Layer] a new instance of Layer
  def initialize(client, scope); end

  # Returns the value of attribute client.
  def client; end

  # Sets the attribute client
  #
  # @param value the value to set the attribute client to.
  def client=(_arg0); end

  # Returns the value of attribute scope.
  def scope; end
end

module Sentry::Integrable
  def capture_exception(exception, **options, &block); end
  def capture_message(message, **options, &block); end
  def integration_name; end
  def register_integration(name:, version:); end
end

class Sentry::Interface
  # @return [Hash]
  def to_hash; end
end

Sentry::LOGGER_PROGNAME = T.let(T.unsafe(nil), String)

# @api private
class Sentry::LineCache
  # @api private
  # @return [LineCache] a new instance of LineCache
  def initialize; end

  # Any linecache you provide to Sentry must implement this method.
  # Returns an Array of Strings representing the lines in the source
  # file. The number of lines retrieved is (2 * context) + 1, the middle
  # line should be the line requested by lineno. See specs for more information.
  #
  # @api private
  def get_file_context(filename, lineno, context); end

  private

  # @api private
  def getline(path, n); end

  # @api private
  def getlines(path); end

  # @api private
  # @return [Boolean]
  def valid_path?(path); end
end

class Sentry::Logger < ::Logger
  # @return [Logger] a new instance of Logger
  def initialize(*_arg0); end
end

Sentry::Logger::LOG_PREFIX = T.let(T.unsafe(nil), String)
Sentry::Logger::PROGNAME = T.let(T.unsafe(nil), String)

module Sentry::LoggingHelper
  def log_debug(message); end
  def log_error(message, exception, debug: T.unsafe(nil)); end
  def log_info(message); end
  def log_warn(message); end
end

Sentry::META = T.let(T.unsafe(nil), Hash)

# @api private
module Sentry::Net; end

# @api private
module Sentry::Net::HTTP
  # To explain how the entire thing works, we need to know how the original Net::HTTP#request works
  # Here's part of its definition. As you can see, it usually calls itself inside a #start block
  #
  # ```
  # def request(req, body = nil, &block)
  #   unless started?
  #     start {
  #       req['connection'] ||= 'close'
  #       return request(req, body, &block) # <- request will be called for the second time from the first call
  #     }
  #   end
  #   # .....
  # end
  # ```
  #
  # So we're only instrumenting request when `Net::HTTP` is already started
  #
  # @api private
  def request(req, body = T.unsafe(nil), &block); end

  private

  # @api private
  def extract_request_info(req); end

  # @api private
  def finish_sentry_span(sentry_span); end

  # @api private
  # @return [Boolean]
  def from_sentry_sdk?; end

  # @api private
  def record_sentry_breadcrumb(req, res); end

  # @api private
  def record_sentry_span(req, res, sentry_span); end

  # @api private
  def set_sentry_trace_header(req, sentry_span); end

  # @api private
  def start_sentry_span; end
end

# @api private
Sentry::Net::HTTP::BREADCRUMB_CATEGORY = T.let(T.unsafe(nil), String)

# @api private
Sentry::Net::HTTP::OP_NAME = T.let(T.unsafe(nil), String)

module Sentry::Rack; end

class Sentry::Rack::CaptureExceptions
  # @return [CaptureExceptions] a new instance of CaptureExceptions
  def initialize(app); end

  def call(env); end

  private

  def capture_exception(exception); end
  def collect_exception(env); end
  def finish_transaction(transaction, status_code); end
  def start_transaction(env, scope); end
  def transaction_op; end
end

module Sentry::Rake; end

module Sentry::Rake::Application
  # @api private
  def display_error_message(ex); end
end

module Sentry::Rake::Task
  # @api private
  def execute(args = T.unsafe(nil)); end
end

# @api private
class Sentry::Redis
  # @api private
  # @return [Redis] a new instance of Redis
  def initialize(commands, host, port, db); end

  # @api private
  def instrument; end

  private

  # @api private
  def commands; end

  # @api private
  def commands_description; end

  # @api private
  def db; end

  # @api private
  def host; end

  # @api private
  def parsed_commands; end

  # @api private
  def port; end

  # @api private
  def record_breadcrumb; end

  # @api private
  def record_span; end

  # @api private
  def server_description; end
end

# @api private
module Sentry::Redis::Client
  # @api private
  def logging(commands, &block); end
end

# @api private
Sentry::Redis::LOGGER_NAME = T.let(T.unsafe(nil), Symbol)

# @api private
Sentry::Redis::OP_NAME = T.let(T.unsafe(nil), String)

# @api private
class Sentry::ReleaseDetector
  class << self
    # @api private
    def detect_release(project_root:, running_on_heroku:); end

    # @api private
    def detect_release_from_capistrano(project_root); end

    # @api private
    def detect_release_from_env; end

    # @api private
    def detect_release_from_git; end

    # @api private
    def detect_release_from_heroku(running_on_heroku); end
  end
end

class Sentry::RequestInterface < ::Sentry::Interface
  # @param env [Hash]
  # @param send_default_pii [Boolean]
  # @param rack_env_whitelist [Array]
  # @return [RequestInterface] a new instance of RequestInterface
  # @see Configuration#send_default_pii
  # @see Configuration#rack_env_whitelist
  def initialize(env:, send_default_pii:, rack_env_whitelist:); end

  # @return [String]
  def cookies; end

  # @return [String]
  def cookies=(_arg0); end

  # @return [Hash]
  def data; end

  # @return [Hash]
  def data=(_arg0); end

  # @return [Hash]
  def env; end

  # @return [Hash]
  def env=(_arg0); end

  # @return [Hash]
  def headers; end

  # @return [Hash]
  def headers=(_arg0); end

  # @return [String]
  def method; end

  # @return [String]
  def method=(_arg0); end

  # @return [String]
  def query_string; end

  # @return [String]
  def query_string=(_arg0); end

  # @return [String]
  def url; end

  # @return [String]
  def url=(_arg0); end

  private

  def encode_to_utf_8(value); end
  def filter_and_format_env(env, rack_env_whitelist); end
  def filter_and_format_headers(env, send_default_pii); end

  # Rack adds in an incorrect HTTP_VERSION key, which causes downstream
  # to think this is a Version header. Instead, this is mapped to
  # env['SERVER_PROTOCOL']. But we don't want to ignore a valid header
  # if the request has legitimately sent a Version header themselves.
  # See: https://github.com/rack/rack/blob/028438f/lib/rack/handler/cgi.rb#L29
  # NOTE: This will be removed in version 3.0+
  #
  # @return [Boolean]
  def is_server_protocol?(key, value, protocol_version); end

  # @return [Boolean]
  def is_skippable_header?(key); end

  def read_data_from(request); end
end

Sentry::RequestInterface::CONTENT_HEADERS = T.let(T.unsafe(nil), Array)
Sentry::RequestInterface::IP_HEADERS = T.let(T.unsafe(nil), Array)

# See Sentry server default limits at
# https://github.com/getsentry/sentry/blob/master/src/sentry/conf/server.py
Sentry::RequestInterface::MAX_BODY_LIMIT = T.let(T.unsafe(nil), Integer)

Sentry::RequestInterface::REQUEST_ID_HEADERS = T.let(T.unsafe(nil), Array)
Sentry::SENTRY_TRACE_HEADER_NAME = T.let(T.unsafe(nil), String)

class Sentry::Scope
  include ::Sentry::ArgumentCheckingHelper

  # @param max_breadcrumbs [Integer] the maximum number of breadcrumbs to be stored in the scope.
  # @return [Scope] a new instance of Scope
  def initialize(max_breadcrumbs: T.unsafe(nil)); end

  # Adds the breadcrumb to the scope's breadcrumbs buffer.
  #
  # @param breadcrumb [Breadcrumb]
  # @return [void]
  def add_breadcrumb(breadcrumb); end

  # Adds a new event processor [Proc] to the scope.
  #
  # @param block [Proc]
  # @return [void]
  def add_event_processor(&block); end

  # Applies stored attributes and event processors to the given event.
  #
  # @param event [Event]
  # @param hint [Hash] the hint data that'll be passed to event processors.
  # @return [Event]
  def apply_to_event(event, hint = T.unsafe(nil)); end

  def breadcrumbs; end

  # Resets the scope's attributes to defaults.
  #
  # @return [void]
  def clear; end

  # Clears the scope's breadcrumbs buffer
  #
  # @return [void]
  def clear_breadcrumbs; end

  def contexts; end

  # @return [Scope]
  def dup; end

  def event_processors; end
  def extra; end
  def fingerprint; end

  # Returns the associated Span object.
  #
  # @return [Span, nil]
  def get_span; end

  # Returns the associated Transaction object.
  #
  # @return [Transaction, nil]
  def get_transaction; end

  def level; end
  def rack_env; end
  def session; end
  def set_context(key, value); end

  # Updates the scope's contexts attribute by merging with the old value.
  #
  # @param contexts [Hash]
  # @return [Hash]
  def set_contexts(contexts_hash); end

  # Adds a new key-value pair to current extras.
  #
  # @param key [String, Symbol]
  # @param value [Object]
  # @return [Hash]
  def set_extra(key, value); end

  def set_extras(extras_hash); end

  # Sets the scope's fingerprint attribute.
  #
  # @param fingerprint [Array]
  # @return [Array]
  def set_fingerprint(fingerprint); end

  # Sets the scope's level attribute.
  #
  # @param level [String, Symbol]
  # @return [void]
  def set_level(level); end

  # Sets the scope's rack_env attribute.
  #
  # @param env [Hash]
  # @return [Hash]
  def set_rack_env(env); end

  # Sets the currently active session on the scope.
  #
  # @param session [Session, nil]
  # @return [void]
  def set_session(session); end

  # Sets the scope's span attribute.
  #
  # @param span [Span]
  # @return [Span]
  def set_span(span); end

  # Adds a new key-value pair to current tags.
  #
  # @param key [String, Symbol]
  # @param value [Object]
  # @return [Hash]
  def set_tag(key, value); end

  def set_tags(tags_hash); end

  # Appends a new transaction name to the scope.
  # The "transaction" here does not refer to `Transaction` objects.
  #
  # @param transaction_name [String]
  # @return [void]
  def set_transaction_name(transaction_name); end

  def set_user(user_hash); end
  def span; end
  def tags; end

  # Returns current transaction name.
  # The "transaction" here does not refer to `Transaction` objects.
  #
  # @return [String, nil]
  def transaction_name; end

  def transaction_names; end

  # Updates the scope's data from the given options.
  #
  # @param contexts [Hash]
  # @param extras [Hash]
  # @param tags [Hash]
  # @param user [Hash]
  # @param level [String, Symbol]
  # @param fingerprint [Array]
  # @return [void]
  def update_from_options(contexts: T.unsafe(nil), extra: T.unsafe(nil), tags: T.unsafe(nil), user: T.unsafe(nil), level: T.unsafe(nil), fingerprint: T.unsafe(nil)); end

  # Updates the scope's data from a given scope.
  #
  # @param scope [Scope]
  # @return [void]
  def update_from_scope(scope); end

  def user; end

  protected

  def breadcrumbs=(_arg0); end
  def contexts=(_arg0); end
  def event_processors=(_arg0); end
  def extra=(_arg0); end
  def fingerprint=(_arg0); end
  def level=(_arg0); end
  def rack_env=(_arg0); end
  def session=(_arg0); end
  def span=(_arg0); end
  def tags=(_arg0); end
  def transaction_names=(_arg0); end
  def user=(_arg0); end

  private

  def set_default_value; end
  def set_new_breadcrumb_buffer; end

  class << self
    # @return [Hash]
    def os_context; end

    # @return [Hash]
    def runtime_context; end
  end
end

Sentry::Scope::ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Sentry::Session
  # @return [Session] a new instance of Session
  def initialize; end

  # truncate seconds from the timestamp since we only care about
  # minute level granularity for aggregation
  def aggregation_key; end

  def close; end
  def deep_dup; end

  # Returns the value of attribute started.
  def started; end

  # Returns the value of attribute status.
  def status; end

  # TODO-neel add :crashed after adding handled mechanism
  def update_from_exception(_exception = T.unsafe(nil)); end
end

Sentry::Session::AGGREGATE_STATUSES = T.let(T.unsafe(nil), Array)

# TODO-neel add :crashed after adding handled mechanism
Sentry::Session::STATUSES = T.let(T.unsafe(nil), Array)

class Sentry::SessionFlusher
  include ::Sentry::LoggingHelper

  # @return [SessionFlusher] a new instance of SessionFlusher
  def initialize(configuration, client); end

  def add_session(session); end
  def flush; end
  def kill; end

  private

  def attrs; end
  def ensure_thread; end
  def init_aggregates(aggregation_key); end
  def pending_envelope; end
end

Sentry::SessionFlusher::FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

class Sentry::SingleExceptionInterface < ::Sentry::Interface
  include ::Sentry::CustomInspection

  # @return [SingleExceptionInterface] a new instance of SingleExceptionInterface
  def initialize(exception:, stacktrace: T.unsafe(nil)); end

  # Returns the value of attribute module.
  def module; end

  # Returns the value of attribute stacktrace.
  def stacktrace; end

  # Returns the value of attribute thread_id.
  def thread_id; end

  def to_hash; end

  # Returns the value of attribute type.
  def type; end

  # Returns the value of attribute value.
  def value; end

  class << self
    # patch this method if you want to change an exception's stacktrace frames
    # also see `StacktraceBuilder.build`.
    def build_with_stacktrace(exception:, stacktrace_builder:); end
  end
end

Sentry::SingleExceptionInterface::MAX_LOCAL_BYTES = T.let(T.unsafe(nil), Integer)
Sentry::SingleExceptionInterface::OMISSION_MARK = T.let(T.unsafe(nil), String)
Sentry::SingleExceptionInterface::PROBLEMATIC_LOCAL_VALUE_REPLACEMENT = T.let(T.unsafe(nil), String)
Sentry::SingleExceptionInterface::SKIP_INSPECTION_ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Sentry::Span
  # @return [Span] a new instance of Span
  def initialize(description: T.unsafe(nil), op: T.unsafe(nil), status: T.unsafe(nil), trace_id: T.unsafe(nil), parent_span_id: T.unsafe(nil), sampled: T.unsafe(nil), start_timestamp: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  # Span data
  #
  # @return [Hash]
  def data; end

  def deep_dup; end

  # Span description
  #
  # @return [String]
  def description; end

  # Finishes the span by adding a timestamp.
  #
  # @return [self]
  def finish; end

  # Returns the span's context that can be used to embed in an Event.
  #
  # @return [Hash]
  def get_trace_context; end

  # Span operation
  #
  # @return [String]
  def op; end

  # Span parent's span_id.
  #
  # @return [String]
  def parent_span_id; end

  # Sampling result of the span.
  #
  # @return [Boolean, nil]
  def sampled; end

  # Inserts a key-value pair to the span's data payload.
  #
  # @param key [String, Symbol]
  # @param value [Object]
  def set_data(key, value); end

  # Sets the span's description.
  #
  # @param description [String] description of the span.
  def set_description(description); end

  # Sets the span's status with given http status code.
  #
  # @param status_code [String] example: "500".
  def set_http_status(status_code); end

  # Sets the span's operation.
  #
  # @param op [String] operation of the span.
  def set_op(op); end

  # Sets the span's status.
  #
  # @param satus [String] status of the span.
  def set_status(status); end

  # Sets a tag to the span.
  #
  # @param key [String, Symbol]
  # @param value [String]
  def set_tag(key, value); end

  # Sets the span's finish timestamp.
  #
  # @param timestamp [Float] finished time in float format (most precise).
  def set_timestamp(timestamp); end

  # An uuid that can be used to identify the span.
  #
  # @return [String]
  def span_id; end

  # The SpanRecorder the current span belongs to.
  # SpanRecorder holds all spans under the same Transaction object (including the Transaction itself).
  #
  # @return [SpanRecorder]
  def span_recorder; end

  # The SpanRecorder the current span belongs to.
  # SpanRecorder holds all spans under the same Transaction object (including the Transaction itself).
  #
  # @return [SpanRecorder]
  def span_recorder=(_arg0); end

  # Starts a child span with given attributes.
  #
  # @param attributes [Hash] the attributes for the child span.
  def start_child(**attributes); end

  # Starting timestamp of the span.
  #
  # @return [Float]
  def start_timestamp; end

  # Span status
  #
  # @return [String]
  def status; end

  # Span tags
  #
  # @return [Hash]
  def tags; end

  # Finishing timestamp of the span.
  #
  # @return [Float]
  def timestamp; end

  # @return [Hash]
  def to_hash; end

  # Generates a trace string that can be used to connect other transactions.
  #
  # @return [String]
  def to_sentry_trace; end

  # An uuid that can be used to identify a trace.
  #
  # @return [String]
  def trace_id; end

  # The Transaction object the Span belongs to.
  # Every span needs to be attached to a Transaction and their child spans will also inherit the same transaction.
  #
  # @return [Transaction]
  def transaction; end

  # The Transaction object the Span belongs to.
  # Every span needs to be attached to a Transaction and their child spans will also inherit the same transaction.
  #
  # @return [Transaction]
  def transaction=(_arg0); end

  # Starts a child span, yield it to the given block, and then finish the span after the block is executed.
  #
  # @example
  #   span.with_child_span do |child_span|
  #   # things happen here will be recorded in a child span
  #   end
  # @param attributes [Hash] the attributes for the child span.
  # @param block [Proc] the action to be recorded in the child span.
  # @yieldparam child_span [Span]
  def with_child_span(**attributes, &block); end
end

Sentry::Span::STATUS_MAP = T.let(T.unsafe(nil), Hash)

class Sentry::StacktraceBuilder
  # @param project_root [String]
  # @param app_dirs_pattern [Regexp, nil]
  # @param linecache [LineCache]
  # @param context_lines [Integer, nil]
  # @param backtrace_cleanup_callback [Proc, nil]
  # @return [StacktraceBuilder] a new instance of StacktraceBuilder
  # @see Configuration#project_root
  # @see Configuration#app_dirs_pattern
  # @see Configuration#linecache
  # @see Configuration#context_lines
  # @see Configuration#backtrace_cleanup_callback
  def initialize(project_root:, app_dirs_pattern:, linecache:, context_lines:, backtrace_cleanup_callback: T.unsafe(nil)); end

  # @return [Regexp, nil]
  def app_dirs_pattern; end

  # @return [Proc, nil]
  def backtrace_cleanup_callback; end

  # Generates a StacktraceInterface with the given backtrace.
  # You can pass a block to customize/exclude frames:
  #
  # @example
  #   builder.build(backtrace) do |frame|
  #   if frame.module.match?(/a_gem/)
  #   nil
  #   else
  #   frame
  #   end
  #   end
  # @param backtrace [Array<String>]
  # @param frame_callback [Proc]
  # @return [StacktraceInterface]
  # @yieldparam frame [StacktraceInterface::Frame]
  def build(backtrace:, &frame_callback); end

  # @return [Integer, nil]
  def context_lines; end

  # @return [LineCache]
  def linecache; end

  # @return [String]
  def project_root; end

  private

  def convert_parsed_line_into_frame(line); end
  def parse_backtrace_lines(backtrace); end
end

class Sentry::StacktraceInterface
  # @param frames [<Array[Frame]>]
  # @return [StacktraceInterface] a new instance of StacktraceInterface
  def initialize(frames:); end

  # @return [<Array[Frame]>]
  def frames; end

  # @return [String]
  def inspect; end

  # @return [Hash]
  def to_hash; end
end

# Not actually an interface, but I want to use the same style
class Sentry::StacktraceInterface::Frame < ::Sentry::Interface
  # @return [Frame] a new instance of Frame
  def initialize(project_root, line); end

  # Returns the value of attribute abs_path.
  def abs_path; end

  # Sets the attribute abs_path
  #
  # @param value the value to set the attribute abs_path to.
  def abs_path=(_arg0); end

  def compute_filename; end

  # Returns the value of attribute context_line.
  def context_line; end

  # Sets the attribute context_line
  #
  # @param value the value to set the attribute context_line to.
  def context_line=(_arg0); end

  # Returns the value of attribute filename.
  def filename; end

  # Sets the attribute filename
  #
  # @param value the value to set the attribute filename to.
  def filename=(_arg0); end

  # Returns the value of attribute function.
  def function; end

  # Sets the attribute function
  #
  # @param value the value to set the attribute function to.
  def function=(_arg0); end

  # Returns the value of attribute in_app.
  def in_app; end

  # Sets the attribute in_app
  #
  # @param value the value to set the attribute in_app to.
  def in_app=(_arg0); end

  # Returns the value of attribute lineno.
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  def lineno=(_arg0); end

  # Returns the value of attribute module.
  def module; end

  # Sets the attribute module
  #
  # @param value the value to set the attribute module to.
  def module=(_arg0); end

  # Returns the value of attribute post_context.
  def post_context; end

  # Sets the attribute post_context
  #
  # @param value the value to set the attribute post_context to.
  def post_context=(_arg0); end

  # Returns the value of attribute pre_context.
  def pre_context; end

  # Sets the attribute pre_context
  #
  # @param value the value to set the attribute pre_context to.
  def pre_context=(_arg0); end

  def set_context(linecache, context_lines); end
  def to_hash(*args); end
  def to_s; end

  # Returns the value of attribute vars.
  def vars; end

  # Sets the attribute vars
  #
  # @param value the value to set the attribute vars to.
  def vars=(_arg0); end

  private

  def longest_load_path; end

  # @return [Boolean]
  def under_project_root?; end
end

Sentry::THREAD_LOCAL = T.let(T.unsafe(nil), Symbol)

class Sentry::ThreadsInterface
  # @param crashed [Boolean]
  # @param stacktrace [Array]
  # @return [ThreadsInterface] a new instance of ThreadsInterface
  def initialize(crashed: T.unsafe(nil), stacktrace: T.unsafe(nil)); end

  # @return [Hash]
  def to_hash; end

  class << self
    # Builds the ThreadsInterface with given backtrace and stacktrace_builder.
    # Patch this method if you want to change a threads interface's stacktrace frames.
    #
    # @param backtrace [Array]
    # @param stacktrace_builder [StacktraceBuilder]
    # @param crashed [Hash]
    # @return [ThreadsInterface]
    # @see StacktraceBuilder.build
    def build(backtrace:, stacktrace_builder:, **options); end
  end
end

class Sentry::Transaction < ::Sentry::Span
  include ::Sentry::LoggingHelper

  # @return [Transaction] a new instance of Transaction
  def initialize(hub:, name: T.unsafe(nil), parent_sampled: T.unsafe(nil), **options); end

  # @deprecated Use Sentry.configuration instead.
  def configuration; end

  # @return [Transaction]
  def deep_dup; end

  # Finishes the transaction's recording and send it to Sentry.
  #
  # @param hub [Hub] the hub that'll send this transaction. (Deprecated)
  # @return [TransactionEvent]
  def finish(hub: T.unsafe(nil)); end

  # @deprecated Use Sentry.get_current_hub instead.
  def hub; end

  # @deprecated Use Sentry.logger instead.
  def logger; end

  # The name of the transaction.
  #
  # @return [String]
  def name; end

  # The sampling decision of the parent transaction, which will be considered when making the current transaction's sampling decision.
  #
  # @return [String]
  def parent_sampled; end

  # Sets initial sampling decision of the transaction.
  #
  # @param sampling_context [Hash] a context Hash that'll be passed to `traces_sampler` (if provided).
  # @return [void]
  def set_initial_sample_decision(sampling_context:); end

  # @return [Hash]
  def to_hash; end

  protected

  def init_span_recorder(limit = T.unsafe(nil)); end

  private

  def generate_transaction_description; end

  class << self
    # Initalizes a Transaction instance with a Sentry trace string from another transaction (usually from an external request).
    #
    # The original transaction will become the parent of the new Transaction instance. And they will share the same `trace_id`.
    #
    # The child transaction will also store the parent's sampling decision in its `parent_sampled` attribute.
    #
    # @param sentry_trace [String] the trace string from the previous transaction.
    # @param hub [Hub] the hub that'll be responsible for sending this transaction when it's finished.
    # @param options [Hash] the options you want to use to initialize a Transaction instance.
    # @return [Transaction, nil]
    def from_sentry_trace(sentry_trace, hub: T.unsafe(nil), **options); end
  end
end

Sentry::Transaction::MESSAGE_PREFIX = T.let(T.unsafe(nil), String)
Sentry::Transaction::SENTRY_TRACE_REGEXP = T.let(T.unsafe(nil), Regexp)

class Sentry::Transaction::SpanRecorder
  # @return [SpanRecorder] a new instance of SpanRecorder
  def initialize(max_length); end

  def add(span); end

  # Returns the value of attribute max_length.
  def max_length; end

  # Returns the value of attribute spans.
  def spans; end
end

# whitespace
Sentry::Transaction::UNLABELD_NAME = T.let(T.unsafe(nil), String)

# TransactionEvent represents events that carry transaction data (type: "transaction").
class Sentry::TransactionEvent < ::Sentry::Event
  # @return [<Array[Span]>]
  def spans; end

  # @return [<Array[Span]>]
  def spans=(_arg0); end

  # @return [Float, nil]
  def start_timestamp; end

  # Sets the event's start_timestamp.
  #
  # @param time [Time, Float]
  # @return [void]
  def start_timestamp=(time); end

  # @return [Hash]
  def to_hash; end
end

Sentry::TransactionEvent::TYPE = T.let(T.unsafe(nil), String)

class Sentry::Transport
  include ::Sentry::LoggingHelper

  # @return [Transport] a new instance of Transport
  def initialize(configuration); end

  # Returns the value of attribute discarded_events.
  def discarded_events; end

  def envelope_from_event(event); end
  def generate_auth_header; end

  # @return [Boolean]
  def is_rate_limited?(item_type); end

  # Returns the value of attribute last_client_report_sent.
  def last_client_report_sent; end

  # @deprecated Use Sentry.logger to retrieve the current logger instead.
  def logger; end

  # Returns the value of attribute rate_limits.
  def rate_limits; end

  def record_lost_event(reason, item_type); end

  # @raise [NotImplementedError]
  def send_data(data, options = T.unsafe(nil)); end

  def send_envelope(envelope); end
  def send_event(event); end
  def serialize_envelope(envelope); end

  private

  def fetch_pending_client_report; end
  def reject_rate_limited_items(envelope); end
end

Sentry::Transport::CLIENT_REPORT_INTERVAL = T.let(T.unsafe(nil), Integer)

# https://develop.sentry.dev/sdk/client-reports/#envelope-item-payload
Sentry::Transport::CLIENT_REPORT_REASONS = T.let(T.unsafe(nil), Array)

class Sentry::Transport::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize; end

  # Returns the value of attribute encoding.
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value the value to set the attribute encoding to.
  def encoding=(_arg0); end

  # Returns the value of attribute open_timeout.
  def open_timeout; end

  # Sets the attribute open_timeout
  #
  # @param value the value to set the attribute open_timeout to.
  def open_timeout=(_arg0); end

  # Returns the value of attribute proxy.
  def proxy; end

  # Sets the attribute proxy
  #
  # @param value the value to set the attribute proxy to.
  def proxy=(_arg0); end

  # Returns the value of attribute ssl.
  def ssl; end

  # Sets the attribute ssl
  #
  # @param value the value to set the attribute ssl to.
  def ssl=(_arg0); end

  # Returns the value of attribute ssl_ca_file.
  def ssl_ca_file; end

  # Sets the attribute ssl_ca_file
  #
  # @param value the value to set the attribute ssl_ca_file to.
  def ssl_ca_file=(_arg0); end

  # Returns the value of attribute ssl_verification.
  def ssl_verification; end

  # Sets the attribute ssl_verification
  #
  # @param value the value to set the attribute ssl_verification to.
  def ssl_verification=(_arg0); end

  # Returns the value of attribute timeout.
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  def timeout=(_arg0); end

  # Returns the value of attribute transport_class.
  def transport_class; end

  def transport_class=(klass); end
end

Sentry::Transport::PROTOCOL_VERSION = T.let(T.unsafe(nil), String)
Sentry::Transport::USER_AGENT = T.let(T.unsafe(nil), String)
module Sentry::Utils; end

module Sentry::Utils::ExceptionCauseChain
  class << self
    def exception_to_array(exception); end
  end
end

class Sentry::Utils::RealIp
  # @return [RealIp] a new instance of RealIp
  def initialize(remote_addr: T.unsafe(nil), client_ip: T.unsafe(nil), real_ip: T.unsafe(nil), forwarded_for: T.unsafe(nil), trusted_proxies: T.unsafe(nil)); end

  def calculate_ip; end

  # Returns the value of attribute ip.
  def ip; end

  protected

  def filter_trusted_proxy_addresses(ips); end
  def ips_from(header); end
end

Sentry::Utils::RealIp::LOCAL_ADDRESSES = T.let(T.unsafe(nil), Array)

module Sentry::Utils::RequestId
  class << self
    # Request ID based on ActionDispatch::RequestId
    def read_from(env); end
  end
end

Sentry::Utils::RequestId::REQUEST_ID_HEADERS = T.let(T.unsafe(nil), Array)
Sentry::VERSION = T.let(T.unsafe(nil), String)
