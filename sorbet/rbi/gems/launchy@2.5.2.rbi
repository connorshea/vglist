# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `launchy` gem.
# Please instead update this file by running `bin/tapioca gem launchy`.

# The entry point into Launchy. This is the sole supported public API.
#
#   Launchy.open( uri, options = {} )
#
# The currently defined global options are:
#
#   :debug        Turn on debugging output
#   :application  Explicitly state what application class is going to be used.
#                 This must be a child class of Launchy::Application
#   :host_os      Explicitly state what host operating system to pretend to be
#   :ruby_engine  Explicitly state what ruby engine to pretend to be under
#   :dry_run      Do nothing and print the command that would be executed on $stdout
#
# Other options may be used, and those will be passed directly to the
# application class
module Launchy
  class << self
    def app_for_uri(uri); end
    def app_for_uri_string(s); end
    def application; end
    def application=(app); end
    def bug_report_message; end
    def debug=(d); end

    # we may do logging before a call to 'open', hence the need to check
    # LAUNCHY_DEBUG here
    #
    # @return [Boolean]
    def debug?; end

    def dry_run=(dry_run); end

    # @return [Boolean]
    def dry_run?; end

    def extract_global_options(options); end
    def host_os; end
    def host_os=(host_os); end
    def log(msg); end

    # Launch an application for the given uri string
    def open(uri_s, options = T.unsafe(nil), &error_block); end

    def path; end
    def path=(path); end
    def reset_global_options; end
    def ruby_engine; end
    def ruby_engine=(ruby_engine); end

    # @raise [Launchy::ArgumentError]
    def string_to_uri(s); end

    private

    def to_bool(arg); end
  end
end

# Application is the base class of all the application types that launchy may
# invoke. It essentially defines the public api of the launchy system.
#
# Every class that inherits from Application must define:
#
# 1. A constructor taking no parameters
# 2. An instance method 'open' taking a string or URI as the first parameter and a
#    hash as the second
# 3. A class method 'handles?' that takes a String and returns true if that
#    class can handle the input.
class Launchy::Application
  extend ::Launchy::DescendantTracker

  # @return [Application] a new instance of Application
  def initialize; end

  def find_executable(bin, *paths); end

  # Returns the value of attribute host_os_family.
  def host_os_family; end

  # Returns the value of attribute ruby_engine.
  def ruby_engine; end

  def run(cmd, *args); end

  # Returns the value of attribute runner.
  def runner; end

  class << self
    # Find the given executable in the available paths
    def find_executable(bin, *paths); end

    # Find the application that handles the given uri.
    #
    # returns the Class that can handle the uri
    #
    # @raise [ApplicationNotFoundError]
    def handling(uri); end
  end
end

# The class handling the browser application and all of its schemes
class Launchy::Application::Browser < ::Launchy::Application
  # use a call back mechanism to get the right app_list that is decided by the
  # host_os_family class.
  def app_list; end

  # Get the full commandline of what we are going to add the uri to
  #
  # @raise [Launchy::CommandNotFoundError]
  def browser_cmdline; end

  def browser_env; end
  def cmd_and_args(uri, options = T.unsafe(nil)); end
  def cygwin_app_list; end

  # hardcode this to open?
  def darwin_app_list; end

  def nix_app_list; end

  # final assembly of the command and do %s substitution
  # http://www.catb.org/~esr/BROWSER/index.html
  def open(uri, options = T.unsafe(nil)); end

  def windows_app_list; end

  class << self
    # @return [Boolean]
    def handles?(uri); end

    def schemes; end
  end
end

class Launchy::ApplicationNotFoundError < ::Launchy::Error; end
class Launchy::ArgumentError < ::Launchy::Error; end

class Launchy::Argv
  # @return [Argv] a new instance of Argv
  def initialize(*args); end

  def ==(other); end
  def [](idx); end

  # Returns the value of attribute argv.
  def argv; end

  # @return [Boolean]
  def blank?; end

  # @return [Boolean]
  def executable?; end

  def to_s; end
  def to_str; end

  # @return [Boolean]
  def valid?; end
end

# This class is deprecated and will be removed
class Launchy::Browser
  def visit(url); end

  private

  def _warn(msg = T.unsafe(nil)); end
  def find_caller_context(stack); end
  def report_caller_context(stack); end

  class << self
    def run(*args); end
  end
end

class Launchy::Cli
  # @return [Cli] a new instance of Cli
  def initialize; end

  def error_output(error); end
  def good_run(argv, env); end

  # Returns the value of attribute options.
  def options; end

  def parse(argv, env); end
  def parser; end
  def run(argv = T.unsafe(nil), env = T.unsafe(nil)); end
end

class Launchy::CommandNotFoundError < ::Launchy::Error; end

# Use by either
#
#   class Foo
#     extend DescendantTracker
#   end
#
# or
#
#   class Foo
#     class << self
#       include DescendantTracker
#     end
#   end
#
# It will track all the classes that inherit from the extended class and keep
# them in a Set that is available via the 'children' method.
module Launchy::DescendantTracker
  # The list of children that are registered
  def children; end

  # Find one of the child classes by calling the given method
  # and passing all the rest of the parameters to that method in
  # each child
  def find_child(method, *args); end

  def inherited(klass); end
end

module Launchy::Detect; end

class Launchy::Detect::HostOs
  # @return [HostOs] a new instance of HostOs
  def initialize(host_os = T.unsafe(nil)); end

  def default_host_os; end

  # Returns the value of attribute host_os.
  def host_os; end

  def override_host_os; end

  # Returns the value of attribute host_os.
  def to_s; end

  # Returns the value of attribute host_os.
  def to_str; end
end

# Detect the current host os family
#
# If the current host familiy cannot be detected then return
# HostOsFamily::Unknown
class Launchy::Detect::HostOsFamily
  extend ::Launchy::DescendantTracker

  # @return [HostOsFamily] a new instance of HostOsFamily
  def initialize(host_os = T.unsafe(nil)); end

  # @return [Boolean]
  def cygwin?; end

  # @return [Boolean]
  def darwin?; end

  # Returns the value of attribute host_os.
  def host_os; end

  # @return [Boolean]
  def nix?; end

  # @return [Boolean]
  def windows?; end

  class << self
    # @return [Boolean]
    def cygwin?; end

    # @return [Boolean]
    def darwin?; end

    # @raise [NotFoundError]
    def detect(host_os = T.unsafe(nil)); end

    # @return [Boolean]
    def matches?(host_os); end

    # @return [Boolean]
    def nix?; end

    # @return [Boolean]
    def windows?; end
  end
end

class Launchy::Detect::HostOsFamily::Cygwin < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

class Launchy::Detect::HostOsFamily::Darwin < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

class Launchy::Detect::HostOsFamily::Nix < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

class Launchy::Detect::HostOsFamily::NotFoundError < ::Launchy::Error; end

# ---------------------------
# All known host os families
# ---------------------------
class Launchy::Detect::HostOsFamily::Windows < ::Launchy::Detect::HostOsFamily
  def app_list(app); end

  class << self
    def matching_regex; end
  end
end

# Detect the current desktop environment for *nix machines
# Currently this is Linux centric. The detection is based upon the detection
# used by xdg-open from http://portland.freedesktop.org/
class Launchy::Detect::NixDesktopEnvironment
  extend ::Launchy::DescendantTracker

  class << self
    def browsers; end

    # Detect the current *nix desktop environment
    #
    # If the current dekstop environment be detected, the return
    # NixDekstopEnvironment::Unknown
    def detect; end

    def fallback_browsers; end
  end
end

class Launchy::Detect::NixDesktopEnvironment::Gnome < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

# ---------------------------------------
# The list of known desktop environments
# ---------------------------------------
class Launchy::Detect::NixDesktopEnvironment::Kde < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

# The one that is found when all else fails. And this must be declared last
class Launchy::Detect::NixDesktopEnvironment::NotFound < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

class Launchy::Detect::NixDesktopEnvironment::NotFoundError < ::Launchy::Error; end

# Fall back environment as the last case
class Launchy::Detect::NixDesktopEnvironment::Xdg < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

class Launchy::Detect::NixDesktopEnvironment::Xfce < ::Launchy::Detect::NixDesktopEnvironment
  class << self
    def browser; end

    # @return [Boolean]
    def is_current_desktop_environment?; end
  end
end

class Launchy::Detect::RubyEngine
  extend ::Launchy::DescendantTracker

  # @return [RubyEngine] a new instance of RubyEngine
  def initialize(ruby_engine = T.unsafe(nil)); end

  # Returns the value of attribute ruby_engine.
  def ruby_engine; end

  # Returns the value of attribute ruby_engine.
  def to_s; end

  class << self
    # Detect the current ruby engine.
    #
    # If the current ruby engine cannot be detected, the return
    # RubyEngine::Unknown
    #
    # @raise [NotFoundError]
    def detect(ruby_engine = T.unsafe(nil)); end

    # @return [Boolean]
    def is_current_engine?(ruby_engine); end

    # @return [Boolean]
    def jruby?; end

    # @return [Boolean]
    def macruby?; end

    # @return [Boolean]
    def mri?; end

    # @return [Boolean]
    def rbx?; end

    def ruby_engine_error_message(ruby_engine); end
  end
end

class Launchy::Detect::RubyEngine::Jruby < ::Launchy::Detect::RubyEngine
  class << self
    def engine_name; end
  end
end

class Launchy::Detect::RubyEngine::MacRuby < ::Launchy::Detect::RubyEngine
  class << self
    def engine_name; end
  end
end

# This is the ruby engine if the RUBY_ENGINE constant is not defined
class Launchy::Detect::RubyEngine::Mri < ::Launchy::Detect::RubyEngine
  class << self
    def engine_name; end

    # @return [Boolean]
    def is_current_engine?(ruby_engine); end
  end
end

class Launchy::Detect::RubyEngine::NotFoundError < ::Launchy::Error; end

class Launchy::Detect::RubyEngine::Rbx < ::Launchy::Detect::RubyEngine
  class << self
    def engine_name; end
  end
end

class Launchy::Detect::Runner
  extend ::Launchy::DescendantTracker

  def commandline_normalize(cmdline); end
  def dry_run(cmd, *args); end

  # @raise [Launchy::CommandNotFoundError]
  def run(cmd, *args); end

  # cut it down to just the shell commands that will be passed to exec or
  # posix_spawn. The cmd argument is split according to shell rules and the
  # args are not escaped because they whole set is passed to system as *args
  # and in that case system shell escaping rules are not done.
  def shell_commands(cmd, args); end

  class << self
    # Detect the current command runner
    #
    # This will return an instance of the Runner to be used to do the
    # application launching.
    #
    # If a runner cannot be detected then raise Runner::NotFoundError
    #
    # The runner rules are, in order:
    #
    # 1) If you are on windows, you use the Windows Runner no matter what
    # 2) If you are using the jruby engine, use the Jruby Runner. Unless rule
    #    (1) took effect
    # 3) Use Forkable (barring rules (1) and (2))
    def detect; end
  end
end

class Launchy::Detect::Runner::Forkable < ::Launchy::Detect::Runner
  # Returns the value of attribute child_pid.
  def child_pid; end

  def wet_run(cmd, *args); end

  private

  # attaching to a StringIO instead of reopening so we don't loose the
  # STDERR, needed for exec_or_raise.
  def close_file_descriptors; end

  def exec_or_raise(cmd, *args); end
end

class Launchy::Detect::Runner::Jruby < ::Launchy::Detect::Runner
  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner::NotFoundError < ::Launchy::Error; end

# ---------------------------------------
# The list of known runners
# ---------------------------------------
class Launchy::Detect::Runner::Windows < ::Launchy::Detect::Runner
  def all_args(cmd, *args); end
  def dry_run(cmd, *args); end

  # escape the reserved shell characters in windows command shell
  # http://technet.microsoft.com/en-us/library/cc723564.aspx
  #
  # Also make sure that the item after 'start' is guaranteed to be quoted.
  # https://github.com/copiousfreetime/launchy/issues/62
  def shell_commands(cmd, *args); end

  def wet_run(cmd, *args); end
end

class Launchy::Error < ::StandardError; end
Launchy::VERSION = T.let(T.unsafe(nil), String)

module Launchy::Version
  class << self
    def to_a; end
    def to_s; end
  end
end

Launchy::Version::MAJOR = T.let(T.unsafe(nil), Integer)
Launchy::Version::MINOR = T.let(T.unsafe(nil), Integer)
Launchy::Version::PATCH = T.let(T.unsafe(nil), Integer)
