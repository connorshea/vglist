# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mini_magick` gem.
# Please instead update this file by running `bin/tapioca gem mini_magick`.

module MiniMagick
  extend ::MiniMagick::Configuration

  class << self
    # Returns ImageMagick's/GraphicsMagick's version.
    #
    # @return [String]
    def cli_version; end

    # Checks whether the CLI used is GraphicsMagick.
    #
    # @return [Boolean]
    def graphicsmagick?; end

    # Checks whether the CLI used is ImageMagick 7.
    #
    # @return [Boolean]
    def imagemagick7?; end

    # Checks whether the CLI used is ImageMagick.
    #
    # @return [Boolean]
    def imagemagick?; end

    # @return [Gem::Version]
    def version; end

    # You might want to execute only certain blocks of processing with a
    # different CLI, because for example that CLI does that particular thing
    # faster. After the block CLI resets to its previous value.
    #
    # @example
    #   MiniMagick.with_cli :graphicsmagick do
    #   # operations that are better done with GraphicsMagick
    #   end
    def with_cli(cli); end
  end
end

module MiniMagick::Configuration
  # Get [ImageMagick](http://www.imagemagick.org) or
  # [GraphicsMagick](http://www.graphicsmagick.org).
  #
  # @return [Symbol] `:imagemagick` or `:graphicsmagick`
  def cli; end

  # Set whether you want to use [ImageMagick](http://www.imagemagick.org) or
  # [GraphicsMagick](http://www.graphicsmagick.org).
  def cli=(value); end

  # If you set the path of CLI tools, you can get the path of the
  # executables.
  #
  # @return [String]
  def cli_path; end

  # If you don't have the CLI tools in your PATH, you can set the path to the
  # executables.
  def cli_path=(_arg0); end

  # Adds a prefix to the CLI command.
  # For example, you could use `firejail` to run all commands in a sandbox.
  # Can be a string, or an array of strings.
  # e.g. 'firejail', or ['firejail', '--force']
  #
  # @return [String]
  # @return [Array<String>]
  def cli_prefix; end

  # Adds a prefix to the CLI command.
  # For example, you could use `firejail` to run all commands in a sandbox.
  # Can be a string, or an array of strings.
  # e.g. 'firejail', or ['firejail', '--force']
  #
  # @return [String]
  # @return [Array<String>]
  def cli_prefix=(_arg0); end

  # @example
  #   MiniMagick.configure do |config|
  #   config.cli = :graphicsmagick
  #   config.timeout = 5
  #   end
  # @yield [self]
  def configure; end

  # When get to `true`, it outputs each command to STDOUT in their shell
  # version.
  #
  # @return [Boolean]
  def debug; end

  # When set to `true`, it outputs each command to STDOUT in their shell
  # version.
  def debug=(value); end

  # Logger for {#debug}, default is `MiniMagick::Logger.new(STDOUT)`, but
  # you can override it, for example if you want the logs to be written to
  # a file.
  #
  # @return [Logger]
  def logger; end

  # Logger for {#debug}, default is `MiniMagick::Logger.new(STDOUT)`, but
  # you can override it, for example if you want the logs to be written to
  # a file.
  #
  # @return [Logger]
  def logger=(_arg0); end

  # @private (for backwards compatibility)
  def processor; end

  # @private (for backwards compatibility)
  def processor=(processor); end

  # @private (for backwards compatibility)
  def processor_path; end

  # @private (for backwards compatibility)
  def processor_path=(_arg0); end

  # Backwards compatibility
  def reload_tools; end

  # Instructs MiniMagick how to execute the shell commands. Available
  # APIs are "open3" (default) and "posix-spawn" (requires the "posix-spawn"
  # gem).
  #
  # @return [String]
  def shell_api; end

  # Instructs MiniMagick how to execute the shell commands. Available
  # APIs are "open3" (default) and "posix-spawn" (requires the "posix-spawn"
  # gem).
  #
  # @return [String]
  def shell_api=(_arg0); end

  # If you don't want commands to take too long, you can set a timeout (in
  # seconds).
  #
  # @return [Integer]
  def timeout; end

  # If you don't want commands to take too long, you can set a timeout (in
  # seconds).
  #
  # @return [Integer]
  def timeout=(_arg0); end

  # If set to `true`, it will `identify` every newly created image, and raise
  # `MiniMagick::Invalid` if the image is not valid. Useful for validating
  # user input, although it adds a bit of overhead. Defaults to `true`.
  #
  # @return [Boolean]
  def validate_on_create; end

  # If set to `true`, it will `identify` every newly created image, and raise
  # `MiniMagick::Invalid` if the image is not valid. Useful for validating
  # user input, although it adds a bit of overhead. Defaults to `true`.
  #
  # @return [Boolean]
  def validate_on_create=(_arg0); end

  # If set to `true`, it will `identify` every image that gets written (with
  # {MiniMagick::Image#write}), and raise `MiniMagick::Invalid` if the image
  # is not valid. Useful for validating that processing was sucessful,
  # although it adds a bit of overhead. Defaults to `true`.
  #
  # @return [Boolean]
  def validate_on_write; end

  # If set to `true`, it will `identify` every image that gets written (with
  # {MiniMagick::Image#write}), and raise `MiniMagick::Invalid` if the image
  # is not valid. Useful for validating that processing was sucessful,
  # although it adds a bit of overhead. Defaults to `true`.
  #
  # @return [Boolean]
  def validate_on_write=(_arg0); end

  # If set to `false`, it will not raise errors when ImageMagick returns
  # status code different than 0. Defaults to `true`.
  #
  # @return [Boolean]
  def whiny; end

  # If set to `false`, it will not raise errors when ImageMagick returns
  # status code different than 0. Defaults to `true`.
  #
  # @return [Boolean]
  def whiny=(_arg0); end

  class << self
    # @private
    def extended(base); end
  end
end

MiniMagick::Configuration::CLI_DETECTION = T.let(T.unsafe(nil), Hash)
class MiniMagick::Error < ::RuntimeError; end

class MiniMagick::Image
  # Create a new {MiniMagick::Image} object.
  #
  # _DANGER_: The file location passed in here is the *working copy*. That
  # is, it gets *modified*. You can either copy it yourself or use {.open}
  # which creates a temporary file for you and protects your original.
  #
  # @param input_path [String, Pathname] The location of an image file
  # @return [Image] a new instance of Image
  # @yield [MiniMagick::Tool::Mogrify] If block is given, {#combine_options}
  #   is called.
  def initialize(input_path, tempfile = T.unsafe(nil), &block); end

  def ==(other); end

  # Use this method if you want to access raw Identify's format API.
  #
  # @example
  #   image["%w %h"]       #=> "250 450"
  #   image["%r"]          #=> "DirectClass sRGB"
  # @param value [String]
  # @return [String]
  # @see http://www.imagemagick.org/script/escape.php
  def [](value); end

  # Collapse images with sequences to the first frame (i.e. animated gifs) and
  # preserve quality.
  #
  # @param frame [Integer] The frame to which to collapse to, defaults to `0`.
  # @return [self]
  def collapse!(frame = T.unsafe(nil)); end

  # @return [String]
  def colorspace(*args); end

  # You can use multiple commands together using this method. Very easy to
  # use!
  #
  # @example
  #   image.combine_options do |c|
  #   c.draw "image Over 0,0 10,10 '#{MINUS_IMAGE_PATH}'"
  #   c.thumbnail "300x500>"
  #   c.background "blue"
  #   end
  # @return [self]
  # @see http://www.imagemagick.org/script/mogrify.php
  # @yield [MiniMagick::Tool::Mogrify]
  def combine_options(&block); end

  # @example
  #   first_image = MiniMagick::Image.open "first.jpg"
  #   second_image = MiniMagick::Image.open "second.jpg"
  #   result = first_image.composite(second_image) do |c|
  #   c.compose "Over" # OverCompositeOp
  #   c.geometry "+20+20" # copy second_image onto first_image from (20, 20)
  #   end
  #   result.write "output.jpg"
  # @see http://www.imagemagick.org/script/composite.php
  def composite(other_image, output_extension = T.unsafe(nil), mask = T.unsafe(nil)); end

  # Returns the information from `identify -verbose` in a Hash format, for
  # ImageMagick.
  #
  # @return [Hash]
  def data(*args); end

  # Destroys the tempfile (created by {.open}) if it exists.
  def destroy!; end

  # Returns the information from `identify -verbose` in a Hash format, for
  # GraphicsMagick.
  #
  # @return [Hash]
  def details(*args); end

  # @return [Array<Integer>]
  def dimensions(*args); end

  def eql?(other); end

  # @return [Hash]
  def exif(*args); end

  # This is used to change the format of the image. That is, from "tiff to
  # jpg" or something like that. Once you run it, the instance is pointing to
  # a new file with a new extension!
  #
  # *DANGER*: This renames the file that the instance is pointing to. So, if
  # you manually opened the file with Image.new(file_path)... Then that file
  # is DELETED! If you used Image.open(file) then you are OK. The original
  # file will still be there. But, any changes to it might not be...
  #
  # Formatting an animation into a non-animated type will result in
  # ImageMagick creating multiple pages (starting with 0).  You can choose
  # which page you want to manipulate.  We default to the first page.
  #
  # If you would like to convert between animated formats, pass nil as your
  # page and ImageMagick will copy all of the pages.
  #
  # @param format [String] The target format... Like 'jpg', 'gif', 'tiff' etc.
  # @param page [Integer] If this is an animated gif, say which 'page' you
  #   want with an integer. Default 0 will convert only the first page; 'nil'
  #   will convert all pages.
  # @param read_opts [Hash] Any read options to be passed to ImageMagick
  #   for example: image.format('jpg', page, {density: '300'})
  # @return [self]
  # @yield [MiniMagick::Tool::Convert] It optionally yields the command,
  #   if you want to add something.
  def format(format, page = T.unsafe(nil), read_opts = T.unsafe(nil)); end

  # Returns layers of the image. For example, JPEGs are 1-layered, but
  # formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.
  #
  # @example
  #   image = MiniMagick::Image.new("document.pdf")
  #   image.pages.each_with_index do |page, idx|
  #   page.write("page#{idx}.pdf")
  #   end
  # @return [Array<MiniMagick::Image>]
  def frames; end

  # Returns a matrix of pixels from the image. The matrix is constructed as
  # an array (1) of arrays (2) of arrays (3) of unsigned integers:
  #
  # 1) one for each row of pixels
  # 2) one for each column of pixels
  # 3) three elements in the range 0-255, one for each of the RGB color channels
  #
  # It can also be called after applying transformations:
  #
  # In this example, all pixels in pix should now have equal R, G, and B values.
  #
  # @example
  #   img = MiniMagick::Image.open 'image.jpg'
  #   pixels = img.get_pixels
  #   pixels[3][2][1] # the green channel value from the 4th-row, 3rd-column pixel
  # @example
  #   img = MiniMagick::Image.open 'image.jpg'
  #   img.crop '20x30+10+5'
  #   img.colorspace 'Gray'
  #   pixels = img.get_pixels
  # @return [Array] Matrix of each color of each pixel
  def get_pixels; end

  def hash; end

  # @return [Integer]
  def height(*args); end

  # Returns the file size in a human readable format.
  #
  # @return [String]
  def human_size(*args); end

  # Runs `identify` on itself. Accepts an optional block for adding more
  # options to `identify`.
  #
  # @example
  #   image = MiniMagick::Image.open("image.jpg")
  #   image.identify do |b|
  #   b.verbose
  #   end # runs `identify -verbose image.jpg`
  # @return [String] Output from `identify`
  # @yield [MiniMagick::Tool::Identify]
  def identify; end

  # Use this method if you want to access raw Identify's format API.
  #
  # @example
  #   image["%w %h"]       #=> "250 450"
  #   image["%r"]          #=> "DirectClass sRGB"
  # @param value [String]
  # @return [String]
  # @see http://www.imagemagick.org/script/escape.php
  def info(value); end

  # Compares if image width
  # is greater than height
  # ============
  # |          |
  # |          |
  # ============
  #
  # @return [Boolean]
  def landscape?; end

  # @return [Boolean]
  def layer?; end

  # Returns layers of the image. For example, JPEGs are 1-layered, but
  # formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.
  #
  # @example
  #   image = MiniMagick::Image.new("document.pdf")
  #   image.pages.each_with_index do |page, idx|
  #   page.write("page#{idx}.pdf")
  #   end
  # @return [Array<MiniMagick::Image>]
  def layers; end

  # If an unknown method is called then it is sent through the mogrify
  # program.
  #
  # @return [self]
  # @see http://www.imagemagick.org/script/mogrify.php
  def method_missing(name, *args); end

  # @return [String]
  def mime_type(*args); end

  def mogrify(page = T.unsafe(nil)); end

  # Returns layers of the image. For example, JPEGs are 1-layered, but
  # formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.
  #
  # @example
  #   image = MiniMagick::Image.new("document.pdf")
  #   image.pages.each_with_index do |page, idx|
  #   page.write("page#{idx}.pdf")
  #   end
  # @return [Array<MiniMagick::Image>]
  def pages; end

  # @return [String] The location of the current working file
  def path; end

  # Compares if image height
  # is greater than width
  # ======
  # |    |
  # |    |
  # |    |
  # |    |
  # ======
  #
  # @return [Boolean]
  def portrait?; end

  # Returns the resolution of the photo. You can optionally specify the
  # units measurement.
  #
  # @example
  #   image.resolution("PixelsPerInch") #=> [250, 250]
  # @return [Array<Integer>]
  # @see http://www.imagemagick.org/script/command-line-options.php#units
  def resolution(*args); end

  # @private
  def run_command(tool_name, *args); end

  # Returns the message digest of this image as a SHA-256, hexidecimal
  # encoded string. This signature uniquely identifies the image and is
  # convenient for determining if an image has been modified or whether two
  # images are identical.
  #
  # @example
  #   image.signature #=> "60a7848c4ca6e36b8e2c5dea632ecdc29e9637791d2c59ebf7a54c0c6a74ef7e"
  # @return [String]
  # @see http://www.imagemagick.org/api/signature.php
  def signature(*args); end

  # Returns the file size of the image (in bytes).
  #
  # @return [Integer]
  def size(*args); end

  # @return [Tempfile] The underlying temporary file
  def tempfile; end

  # Returns raw image data.
  #
  # @return [String] Binary string
  def to_blob; end

  # Returns the image format (e.g. "JPEG", "GIF").
  #
  # @return [String]
  def type(*args); end

  # Checks to make sure that MiniMagick can read the file and understand it.
  #
  # This uses the 'identify' command line utility to check the file. If you
  # are having issues with this, then please work directly with the
  # 'identify' command and see if you can figure out what the issue is.
  #
  # @return [Boolean]
  def valid?; end

  # Runs `identify` on the current image, and raises an error if it doesn't
  # pass.
  #
  # @raise [MiniMagick::Invalid]
  def validate!; end

  # @return [Integer]
  def width(*args); end

  # Writes the temporary file out to either a file location (by passing in a
  # String) or by passing in a Stream that you can #write(chunk) to
  # repeatedly
  #
  # @param output_to [String, Pathname, #read] Some kind of stream object
  #   that needs to be read or a file path as a String
  def write(output_to); end

  private

  # @return [Boolean]
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # @private
    def attribute(name, key = T.unsafe(nil)); end

    # Used to create a new Image object data-copy. Not used to "paint" or
    # that kind of thing.
    #
    # Takes an extension in a block and can be used to build a new Image
    # object. Used by both {.open} and {.read} to create a new object. Ensures
    # we have a good tempfile.
    #
    # @param ext [String] Specify the extension you want to read it as
    # @param validate [Boolean] If false, skips validation of the created
    #   image. Defaults to true.
    # @return [MiniMagick::Image] The created image
    # @yield [Tempfile] You can #write bits to this object to create the new
    #   Image
    def create(ext = T.unsafe(nil), validate = T.unsafe(nil), &block); end

    # This is used to create image from pixels. This might be required if you
    # create pixels for some image processing reasons and you want to form
    # image from those pixels.
    #
    # *DANGER*: This operation can be very expensive. Please try to use with
    # caution.
    #
    # @example
    #   # It is given in readme.md file
    def get_image_from_pixels(pixels, dimension, map, depth, mime_type); end

    # Creates an image object from a binary string blob which contains raw
    # pixel data (i.e. no header data).
    #
    # Defaults to 'png'.
    #
    # @param blob [String] Binary string blob containing raw pixel data.
    # @param columns [Integer] Number of columns.
    # @param rows [Integer] Number of rows.
    # @param depth [Integer] Bit depth of the encoded pixel data.
    # @param map [String] A code for the mapping of the pixel data. Example:
    #   'gray' or 'rgb'.
    # @param format [String] The file extension of the image format to be
    #   used when creating the image object.
    # @return [MiniMagick::Image] The loaded image.
    def import_pixels(blob, columns, rows, depth, map, format = T.unsafe(nil)); end

    # Opens a specific image file either on the local file system or at a URI.
    # Use this if you don't want to overwrite the image file.
    #
    # Extension is either guessed from the path or you can specify it as a
    # second parameter.
    #
    # @param path_or_url [String] Either a local file path or a URL that
    #   open-uri can read
    # @param ext [String] Specify the extension you want to read it as
    # @param options [Hash] Specify options for the open method
    # @return [MiniMagick::Image] The loaded image
    def open(path_or_url, ext = T.unsafe(nil), options = T.unsafe(nil)); end

    # This is the primary loading method used by all of the other class
    # methods.
    #
    # Use this to pass in a stream object. Must respond to #read(size) or be a
    # binary string object (BLOB)
    #
    # Probably easier to use the {.open} method if you want to open a file or a
    # URL.
    #
    # @param stream [#read, String] Some kind of stream object that needs
    #   to be read or is a binary String blob
    # @param ext [String] A manual extension to use for reading the file. Not
    #   required, but if you are having issues, give this a try.
    # @return [MiniMagick::Image]
    def read(stream, ext = T.unsafe(nil)); end
  end
end

# @private
class MiniMagick::Image::Info
  # @return [Info] a new instance of Info
  def initialize(path); end

  def [](value, *args); end
  def cheap_info(value); end
  def clear; end
  def colorspace; end

  # @raise [Error]
  def data; end

  def details; end
  def exif; end
  def identify; end
  def mime_type; end

  # @raise [TypeError]
  def parse_warnings(raw_info); end

  def raw(value); end
  def raw_exif(value); end
  def resolution(unit = T.unsafe(nil)); end
  def signature; end

  private

  def decode_comma_separated_ascii_characters(encoded_value); end
  def path; end
end

MiniMagick::Image::Info::ASCII_ENCODED_EXIF_KEYS = T.let(T.unsafe(nil), Array)
class MiniMagick::Invalid < ::StandardError; end

# Sends commands to the shell (more precisely, it sends commands directly to
# the operating system).
#
# @private
class MiniMagick::Shell
  def execute(command, options = T.unsafe(nil)); end
  def run(command, options = T.unsafe(nil)); end

  private

  def execute_open3(command, options = T.unsafe(nil)); end
  def execute_posix_spawn(command, options = T.unsafe(nil)); end
  def log(command, &block); end
end

# Abstract class that wraps command-line tools. It shouldn't be used directly,
# but through one of its subclasses (e.g. {MiniMagick::Tool::Mogrify}). Use
# this class if you want to be closer to the metal and execute ImageMagick
# commands directly, but still with a nice Ruby interface.
#
# @example
#   MiniMagick::Tool::Mogrify.new do |builder|
#   builder.resize "500x500"
#   builder << "path/to/image.jpg"
#   end
class MiniMagick::Tool
  # @example
  #   MiniMagick::Tool::Identify.new(whiny: false) do |identify|
  #   identify.help # returns exit status 1, which would otherwise throw an error
  #   end
  # @option options
  # @param name [String]
  # @param options [Hash]
  # @return [Tool] a new instance of Tool
  def initialize(name, options = T.unsafe(nil)); end

  # Changes the last operator to its "plus" form.
  #
  # @example
  #   MiniMagick::Tool::Mogrify.new do |mogrify|
  #   mogrify.antialias.+
  #   mogrify.distort.+("Perspective", "0,0,4,5 89,0,45,46")
  #   end
  #   # executes `mogrify +antialias +distort Perspective '0,0,4,5 89,0,45,46'`
  # @return [self]
  def +(*values); end

  # Appends raw options, useful for appending image paths.
  #
  # @return [self]
  def <<(arg); end

  # @private
  def args; end

  # Executes the command that has been built up.
  #
  # @example
  #   mogrify = MiniMagick::Tool::Mogrify.new
  #   mogrify.resize("500x500")
  #   mogrify << "path/to/image.jpg"
  #   mogrify.call # executes `mogrify -resize 500x500 path/to/image.jpg`
  # @example
  #   mogrify = MiniMagick::Tool::Mogrify.new
  #   # build the command
  #   mogrify.call do |stdout, stderr, status|
  #   # ...
  #   end
  # @return [String] Returns the output of the command
  # @yield [Array] Optionally yields stdout, stderr, and exit status
  def call(*args); end

  def canvas(value = T.unsafe(nil)); end

  # This option is a valid ImageMagick option, but it's also a Ruby method,
  # so we need to override it so that it correctly acts as an option method.
  def clone(*args); end

  # The currently built-up command.
  #
  # @example
  #   mogrify = MiniMagick::Tool::Mogrify.new
  #   mogrify.resize "500x500"
  #   mogrify.contrast
  #   mogrify.command #=> ["mogrify", "-resize", "500x500", "-contrast"]
  # @return [Array<String>]
  def command; end

  # The executable used for this tool. Respects
  # {MiniMagick::Configuration#cli}, {MiniMagick::Configuration#cli_path},
  # and {MiniMagick::Configuration#cli_prefix}.
  #
  # @example
  #   MiniMagick.configure { |config| config.cli = :graphicsmagick }
  #   identify = MiniMagick::Tool::Identify.new
  #   identify.executable #=> ["gm", "identify"]
  # @example
  #   MiniMagick.configure do |config|
  #   config.cli = :graphicsmagick
  #   config.cli_prefix = ['firejail', '--force']
  #   end
  #   identify = MiniMagick::Tool::Identify.new
  #   identify.executable #=> ["firejail", "--force", "gm", "identify"]
  # @return [Array<String>]
  def executable; end

  def gradient(value = T.unsafe(nil)); end
  def logo(value = T.unsafe(nil)); end

  # Merges a list of raw options.
  #
  # @return [self]
  def merge!(new_args); end

  # Any undefined method will be transformed into a CLI option
  #
  # @example
  #   mogrify = MiniMagick::Tool.new("mogrify")
  #   mogrify.adaptive_blur("...")
  #   mogrify.foo_bar
  #   mogrify.command.join(" ") # => "mogrify -adaptive-blur ... -foo-bar"
  def method_missing(name, *args); end

  # @private
  def name; end

  def pango(value = T.unsafe(nil)); end
  def pattern(value = T.unsafe(nil)); end
  def plasma(value = T.unsafe(nil)); end
  def radial_gradient(value = T.unsafe(nil)); end
  def rose(value = T.unsafe(nil)); end

  # Create an ImageMagick stack in the command (surround.
  #
  # @example
  #   MiniMagick::Tool::Convert.new do |convert|
  #   convert << "wand.gif"
  #   convert.stack do |stack|
  #   stack << "wand.gif"
  #   stack.rotate(30)
  #   end
  #   convert.append.+
  #   convert << "images.gif"
  #   end
  #   # executes `convert wand.gif \( wizard.gif -rotate 30 \) +append images.gif`
  # @yield [_self]
  # @yieldparam _self [MiniMagick::Tool] the object that the method was called on
  def stack(*args); end

  # Adds ImageMagick's pseudo-filename `-` for standard input.
  #
  # @example
  #   identify = MiniMagick::Tool::Identify.new
  #   identify.stdin
  #   identify.call(stdin: image_content)
  #   # executes `identify -` with the given standard input
  def stdin; end

  # Adds ImageMagick's pseudo-filename `-` for standard output.
  #
  # @example
  #   content = MiniMagick::Tool::Convert.new do |convert|
  #   convert << "input.jpg"
  #   convert.auto_orient
  #   convert.stdout
  #   end
  #   # executes `convert input.jpg -auto-orient -` which returns file contents
  def stdout; end

  def text(value = T.unsafe(nil)); end
  def xc(value = T.unsafe(nil)); end

  class << self
    # Aside from classic instantiation, it also accepts a block, and then
    # executes the command in the end.
    #
    # @example
    #   version = MiniMagick::Tool::Identify.new { |b| b.version }
    #   puts version
    # @return [MiniMagick::Tool, String] If no block is given, returns an
    #   instance of the tool, if block is given, returns the output of the
    #   command.
    def new(*args); end

    def option_methods; end
  end
end

# @see http://www.imagemagick.org/script/animate.php
class MiniMagick::Tool::Animate < ::MiniMagick::Tool
  # @return [Animate] a new instance of Animate
  def initialize(*args); end
end

MiniMagick::Tool::CREATION_OPERATORS = T.let(T.unsafe(nil), Array)

# @see http://www.imagemagick.org/script/compare.php
class MiniMagick::Tool::Compare < ::MiniMagick::Tool
  # @return [Compare] a new instance of Compare
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/composite.php
class MiniMagick::Tool::Composite < ::MiniMagick::Tool
  # @return [Composite] a new instance of Composite
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/conjure.php
class MiniMagick::Tool::Conjure < ::MiniMagick::Tool
  # @return [Conjure] a new instance of Conjure
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/convert.php
class MiniMagick::Tool::Convert < ::MiniMagick::Tool
  # @return [Convert] a new instance of Convert
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/display.php
class MiniMagick::Tool::Display < ::MiniMagick::Tool
  # @return [Display] a new instance of Display
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/identify.php
class MiniMagick::Tool::Identify < ::MiniMagick::Tool
  # @return [Identify] a new instance of Identify
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/import.php
class MiniMagick::Tool::Import < ::MiniMagick::Tool
  # @return [Import] a new instance of Import
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/command-line-processing.php
class MiniMagick::Tool::Magick < ::MiniMagick::Tool
  # @return [Magick] a new instance of Magick
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/mogrify.php
class MiniMagick::Tool::Mogrify < ::MiniMagick::Tool
  # @return [Mogrify] a new instance of Mogrify
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/mogrify.php
class MiniMagick::Tool::MogrifyRestricted < ::MiniMagick::Tool::Mogrify
  def format(*args); end
end

# @see http://www.imagemagick.org/script/montage.php
class MiniMagick::Tool::Montage < ::MiniMagick::Tool
  # @return [Montage] a new instance of Montage
  def initialize(*args); end
end

# @see http://www.imagemagick.org/script/stream.php
class MiniMagick::Tool::Stream < ::MiniMagick::Tool
  # @return [Stream] a new instance of Stream
  def initialize(*args); end
end

# @private
module MiniMagick::Utilities
  private

  def tempfile(extension); end

  # Cross-platform way of finding an executable in the $PATH.
  #
  # @example
  #   MiniMagick::Utilities.which('ruby') #=> "/usr/bin/ruby"
  def which(cmd); end

  class << self
    def tempfile(extension); end

    # Cross-platform way of finding an executable in the $PATH.
    #
    # @example
    #   MiniMagick::Utilities.which('ruby') #=> "/usr/bin/ruby"
    def which(cmd); end
  end
end

module MiniMagick::VERSION; end
MiniMagick::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
MiniMagick::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
MiniMagick::VERSION::STRING = T.let(T.unsafe(nil), String)
MiniMagick::VERSION::TINY = T.let(T.unsafe(nil), Integer)
