# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_storage_validations` gem.
# Please instead update this file by running `bin/tapioca gem active_storage_validations`.

module ActiveStorageValidations; end

# :nodoc
class ActiveStorageValidations::AspectRatioValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def check_validity!; end

  # Rails 5
  def validate_each(record, attribute, _value); end

  private

  def ensure_aspect_ratio_validity; end
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  def is_valid?(record, attribute, file, metadata); end
end

ActiveStorageValidations::AspectRatioValidator::ASPECT_RATIO_REGEX = T.let(T.unsafe(nil), Regexp)
ActiveStorageValidations::AspectRatioValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::AspectRatioValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::AspectRatioValidator::NAMED_ASPECT_RATIOS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::AspectRatioValidator::PRECISION = T.let(T.unsafe(nil), Integer)

class ActiveStorageValidations::AttachedValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def check_validity!; end
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::AttachedValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

class ActiveStorageValidations::ContentTypeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def authorized_types(record); end
  def check_validity!; end
  def content_type(file); end
  def ensure_content_types_validity; end
  def ensure_exactly_one_validator_option; end

  # @return [Boolean]
  def invalid_content_type?(content_type); end

  def invalid_content_type_message(content_type); end

  # @return [Boolean]
  def is_valid?(file, types); end

  def types_to_human_format(types); end
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::ContentTypeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::ContentTypeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# :nodoc
class ActiveStorageValidations::DimensionValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def check_validity!; end

  # @return [Boolean]
  def is_valid?(record, attribute, file, metadata); end

  def process_options(record); end

  # Rails 5
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::DimensionValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::DimensionValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

class ActiveStorageValidations::Engine < ::Rails::Engine
  class << self
    def __callbacks; end
  end
end

module ActiveStorageValidations::Errorable
  extend ::ActiveSupport::Concern

  def add_error(record, attribute, error_type, **errors_options); end
  def initialize_error_options(options, file = T.unsafe(nil)); end

  private

  def get_filename(file); end
end

class ActiveStorageValidations::LimitValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def check_validity!; end
  def validate_each(record, attribute, _); end

  private

  # @raise [ArgumentError]
  def ensure_arguments_validity; end

  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  def files_count_valid?(count, flat_options); end

  # @return [Boolean]
  def min_higher_than_max?; end

  # @return [Boolean]
  def min_max_are_proc?; end

  # @return [Boolean]
  def min_or_max_defined_and_not_integer?; end

  # @return [Boolean]
  def min_or_max_is_proc_and_other_not_present?; end
end

ActiveStorageValidations::LimitValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::LimitValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

module ActiveStorageValidations::Matchers
  def validate_aspect_ratio_of(name, expected_aspect_ratio); end
  def validate_attached_of(name); end
  def validate_content_type_of(name); end
  def validate_dimensions_of(name); end
  def validate_size_of(name); end

  class << self
    def mock_metadata(attachment, width, height); end

    # Helper to stub a method with either RSpec or Minitest (whatever is available)
    def stub_method(object, method, result); end
  end
end

module ActiveStorageValidations::Matchers::ActiveStorageable
  extend ::ActiveSupport::Concern

  private

  # @return [Boolean]
  def is_a_valid_active_storage_attribute?; end
end

module ActiveStorageValidations::Matchers::AllowBlankable
  extend ::ActiveSupport::Concern

  def allow_blank; end
  def initialize_allow_blankable; end

  private

  # @return [Boolean]
  def is_allowing_blank?; end
end

class ActiveStorageValidations::Matchers::AspectRatioValidatorMatcher
  include ::ActiveStorageValidations::Matchers::ActiveStorageable
  include ::ActiveStorageValidations::Matchers::AllowBlankable
  include ::ActiveStorageValidations::Matchers::Contextable
  include ::ActiveStorageValidations::Matchers::Messageable
  include ::ActiveStorageValidations::Matchers::Rspecable
  include ::ActiveStorageValidations::Matchers::Validatable

  # @return [AspectRatioValidatorMatcher] a new instance of AspectRatioValidatorMatcher
  def initialize(attribute_name); end

  def allowing(*aspect_ratios); end
  def description; end
  def failure_message; end

  # @return [Boolean]
  def matches?(subject); end

  def rejecting(*aspect_ratios); end

  protected

  # @return [Boolean]
  def all_allowed_aspect_ratios_allowed?; end

  # @return [Boolean]
  def all_rejected_aspect_ratios_rejected?; end

  # @return [Boolean]
  def aspect_ratio_allowed?(aspect_ratio); end

  def attach_file; end
  def dummy_file; end

  # @return [Boolean]
  def is_custom_message_valid?; end

  def mock_dimensions_for(attachment, width, height); end
  def valid_width_and_height_for(aspect_ratio); end
end

class ActiveStorageValidations::Matchers::AttachedValidatorMatcher
  include ::ActiveStorageValidations::Matchers::ActiveStorageable
  include ::ActiveStorageValidations::Matchers::Contextable
  include ::ActiveStorageValidations::Matchers::Messageable
  include ::ActiveStorageValidations::Matchers::Rspecable
  include ::ActiveStorageValidations::Matchers::Validatable

  # @return [AttachedValidatorMatcher] a new instance of AttachedValidatorMatcher
  def initialize(attribute_name); end

  def description; end
  def failure_message; end

  # @return [Boolean]
  def matches?(subject); end

  private

  def attach_dummy_file; end
  def detach_file; end

  # @return [Boolean]
  def file_attached?; end

  # @return [Boolean]
  def is_custom_message_valid?; end

  # @return [Boolean]
  def is_invalid_when_file_not_attached?; end

  # @return [Boolean]
  def is_valid_when_file_attached?; end
end

class ActiveStorageValidations::Matchers::ContentTypeValidatorMatcher
  include ::ActiveStorageValidations::Matchers::ActiveStorageable
  include ::ActiveStorageValidations::Matchers::AllowBlankable
  include ::ActiveStorageValidations::Matchers::Contextable
  include ::ActiveStorageValidations::Matchers::Messageable
  include ::ActiveStorageValidations::Matchers::Rspecable
  include ::ActiveStorageValidations::Matchers::Validatable

  # @return [ContentTypeValidatorMatcher] a new instance of ContentTypeValidatorMatcher
  def initialize(attribute_name); end

  def allowing(*types); end
  def description; end
  def failure_message; end

  # @return [Boolean]
  def matches?(subject); end

  def rejecting(*types); end

  protected

  # @return [Boolean]
  def all_allowed_types_allowed?; end

  # @return [Boolean]
  def all_rejected_types_rejected?; end

  def attach_file_of_type(type); end
  def attach_invalid_content_type_file; end
  def attachment_for(type); end
  def build_failure_message(message); end

  # @return [Boolean]
  def is_custom_message_valid?; end

  def pluralize(types); end

  # @return [Boolean]
  def type_allowed?(type); end
end

module ActiveStorageValidations::Matchers::Contextable
  extend ::ActiveSupport::Concern

  def initialize_contextable; end
  def on(context); end

  private

  # @raise [ArgumentError]
  # @return [Boolean]
  def is_context_valid?; end
end

class ActiveStorageValidations::Matchers::DimensionValidatorMatcher
  include ::ActiveStorageValidations::Matchers::ActiveStorageable
  include ::ActiveStorageValidations::Matchers::AllowBlankable
  include ::ActiveStorageValidations::Matchers::Contextable
  include ::ActiveStorageValidations::Matchers::Messageable
  include ::ActiveStorageValidations::Matchers::Rspecable
  include ::ActiveStorageValidations::Matchers::Validatable

  # @return [DimensionValidatorMatcher] a new instance of DimensionValidatorMatcher
  def initialize(attribute_name); end

  def description; end
  def failure_message; end
  def height(height); end
  def height_between(range); end
  def height_max(height); end
  def height_min(height); end

  # @return [Boolean]
  def matches?(subject); end

  def width(width); end
  def width_between(range); end
  def width_max(width); end
  def width_min(width); end

  protected

  def add_failure_message_artefact(width, height); end
  def attach_file; end
  def build_failure_message(message); end
  def dummy_file; end

  # @return [Boolean]
  def height_equals?; end

  # @return [Boolean]
  def height_larger_than_min?; end

  # @return [Boolean]
  def height_not_larger_than_max?; end

  # @return [Boolean]
  def height_not_smaller_than_min?; end

  # @return [Boolean]
  def height_smaller_than_max?; end

  # @return [Boolean]
  def is_custom_message_valid?; end

  def mock_dimensions_for(attachment, width, height); end
  def passes_validation_with_dimensions(width, height); end
  def valid_height; end
  def valid_width; end

  # @return [Boolean]
  def width_equals?; end

  # @return [Boolean]
  def width_larger_than_min?; end

  # @return [Boolean]
  def width_not_larger_than_max?; end

  # @return [Boolean]
  def width_not_smaller_than_min?; end

  # @return [Boolean]
  def width_smaller_than_max?; end
end

module ActiveStorageValidations::Matchers::Messageable
  extend ::ActiveSupport::Concern

  def initialize_messageable; end
  def with_message(custom_message); end

  private

  # @return [Boolean]
  def has_an_error_message_which_is_custom_message?; end
end

module ActiveStorageValidations::Matchers::Rspecable
  extend ::ActiveSupport::Concern

  # @raise [NotImplementedError]
  def description; end

  # @raise [NotImplementedError]
  def failure_message; end

  def failure_message_when_negated; end
  def initialize_rspecable; end
end

class ActiveStorageValidations::Matchers::SizeValidatorMatcher
  include ::ActiveStorageValidations::Matchers::ActiveStorageable
  include ::ActiveStorageValidations::Matchers::AllowBlankable
  include ::ActiveStorageValidations::Matchers::Contextable
  include ::ActiveStorageValidations::Matchers::Messageable
  include ::ActiveStorageValidations::Matchers::Rspecable
  include ::ActiveStorageValidations::Matchers::Validatable

  # @return [SizeValidatorMatcher] a new instance of SizeValidatorMatcher
  def initialize(attribute_name); end

  def between(range); end
  def description; end
  def failure_message; end
  def greater_than(size); end
  def greater_than_or_equal_to(size); end
  def less_than(size); end
  def less_than_or_equal_to(size); end

  # @return [Boolean]
  def matches?(subject); end

  protected

  def add_failure_message_artefact(size); end
  def attach_file; end
  def build_failure_message(message); end
  def dummy_file; end

  # @return [Boolean]
  def higher_than_min?; end

  def io; end

  # @return [Boolean]
  def is_custom_message_valid?; end

  # @return [Boolean]
  def lower_than_max?; end

  def mock_size_for(io, size); end

  # @return [Boolean]
  def not_higher_than_max?; end

  # @return [Boolean]
  def not_lower_than_min?; end

  def passes_validation_with_size(size); end
end

module ActiveStorageValidations::Matchers::Validatable
  extend ::ActiveSupport::Concern

  private

  def attribute_validator; end
  def available_errors; end
  def error_from_custom_message; end

  # @return [Boolean]
  def is_valid?; end

  def validate; end
  def validator_class; end
  def validator_errors_for_attribute; end
end

class ActiveStorageValidations::Metadata
  # @return [Metadata] a new instance of Metadata
  def initialize(file); end

  # Returns the value of attribute file.
  def file; end

  def metadata; end

  # @return [Boolean]
  def valid?; end

  private

  def exception_class; end
  def image_processor; end
  def logger; end
  def new_image_from_path(path); end
  def read_file_path; end
  def read_image; end
  def require_image_processor; end

  # @return [Boolean]
  def rotated_image?(image); end

  # @return [Boolean]
  def valid_image?(image); end

  # @return [Boolean]
  def vips_image_processor?; end
end

ActiveStorageValidations::Metadata::DEFAULT_IMAGE_PROCESSOR = T.let(T.unsafe(nil), Symbol)
class ActiveStorageValidations::Metadata::InvalidImageError < ::StandardError; end

module ActiveStorageValidations::OptionProcUnfolding
  def unfold_procs(record, object, only_keys); end
end

# :nodoc
class ActiveStorageValidations::ProcessableImageValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # Rails 5
  def validate_each(record, attribute, _value); end
end

ActiveStorageValidations::ProcessableImageValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)
class ActiveStorageValidations::Railtie < ::Rails::Railtie; end

class ActiveStorageValidations::SizeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  def check_validity!; end
  def number_to_human_size(*_arg0, **_arg1, &_arg2); end
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  def is_valid?(file_size, flat_options); end

  def max_size(flat_options); end
  def min_size(flat_options); end
end

ActiveStorageValidations::SizeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)
ActiveStorageValidations::SizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

module ActiveStorageValidations::Symbolizable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveStorageValidations::Symbolizable::ClassMethods
end

module ActiveStorageValidations::Symbolizable::ClassMethods
  def to_sym; end
end
