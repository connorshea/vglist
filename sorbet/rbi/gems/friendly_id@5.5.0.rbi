# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `friendly_id` gem.
# Please instead update this file by running `bin/tapioca gem friendly_id`.

class Array
  include ::Enumerable
  include ::FriendlyId::UnfriendlyUtils
end

class FalseClass
  include ::FriendlyId::UnfriendlyUtils
end

# About FriendlyId
#
# FriendlyId is an add-on to Ruby's Active Record that allows you to replace ids
# in your URLs with strings:
#
#     # without FriendlyId
#     http://example.com/states/4323454
#
#     # with FriendlyId
#     http://example.com/states/washington
#
# It requires few changes to your application code and offers flexibility,
# performance and a well-documented codebase.
#
# Core Concepts
#
# Slugs
#
# The concept of *slugs* is at the heart of FriendlyId.
#
# A slug is the part of a URL which identifies a page using human-readable
# keywords, rather than an opaque identifier such as a numeric id. This can make
# your application more friendly both for users and search engines.
#
# Finders: Slugs Act Like Numeric IDs
#
# To the extent possible, FriendlyId lets you treat text-based identifiers like
# normal IDs. This means that you can perform finds with slugs just like you do
# with numeric ids:
#
#     Person.find(82542335)
#     Person.friendly.find("joe")
module FriendlyId
  class << self
    # Set global defaults for all models using FriendlyId.
    #
    # The default defaults are to use the `:reserved` module and nothing else.
    #
    # @example
    #   FriendlyId.defaults do |config|
    #   config.base :name
    #   config.use :slugged
    #   end
    def defaults(&block); end

    # FriendlyId takes advantage of `extended` to do basic model setup, primarily
    # extending {FriendlyId::Base} to add {FriendlyId::Base#friendly_id
    # friendly_id} as a class method.
    #
    # Previous versions of FriendlyId simply patched ActiveRecord::Base, but this
    # version tries to be less invasive.
    #
    # In addition to adding {FriendlyId::Base#friendly_id friendly_id}, the class
    # instance variable +@friendly_id_config+ is added. This variable is an
    # instance of an anonymous subclass of {FriendlyId::Configuration}. This
    # allows subsequently loaded modules like {FriendlyId::Slugged} and
    # {FriendlyId::Scoped} to add functionality to the configuration class only
    # for the current class, rather than monkey patching
    # {FriendlyId::Configuration} directly. This isolates other models from large
    # feature changes an addon to FriendlyId could potentially introduce.
    #
    # The upshot of this is, you can have two Active Record models that both have
    # a @friendly_id_config, but each config object can have different methods
    # and behaviors depending on what modules have been loaded, without
    # conflicts.  Keep this in mind if you're hacking on FriendlyId.
    #
    # For examples of this, see the source for {Scoped.included}.
    def extended(model_class); end

    # Allow developers to `include` FriendlyId or `extend` it.
    def included(model_class); end

    def mark_as_unfriendly(klass); end

    # Set the ActiveRecord table name prefix to friendly_id_
    #
    # This makes 'slugs' into 'friendly_id_slugs' and also respects any
    # 'global' table_name_prefix set on ActiveRecord::Base.
    def table_name_prefix; end
  end
end

# Setting Up FriendlyId in Your Model
#
# To use FriendlyId in your ActiveRecord models, you must first either extend or
# include the FriendlyId module (it makes no difference), then invoke the
# {FriendlyId::Base#friendly_id friendly_id} method to configure your desired
# options:
#
#     class Foo < ActiveRecord::Base
#       include FriendlyId
#       friendly_id :bar, :use => [:slugged, :simple_i18n]
#     end
#
# The most important option is `:use`, which you use to tell FriendlyId which
# addons it should use. See the documentation for {FriendlyId::Base#friendly_id} for a list of all
# available addons, or skim through the rest of the docs to get a high-level
# overview.
#
# *A note about single table inheritance (STI): you must extend FriendlyId in
# all classes that participate in STI, both your parent classes and their
# children.*
#
# The Default Setup: Simple Models
#
# The simplest way to use FriendlyId is with a model that has a uniquely indexed
# column with no spaces or special characters, and that is seldom or never
# updated. The most common example of this is a user name:
#
#     class User < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :login
#       validates_format_of :login, :with => /\A[a-z0-9]+\z/i
#     end
#
#     @user = User.friendly.find "joe"   # the old User.find(1) still works, too
#     @user.to_param                     # returns "joe"
#     redirect_to @user                  # the URL will be /users/joe
#
# In this case, FriendlyId assumes you want to use the column as-is; it will never
# modify the value of the column, and your application should ensure that the
# value is unique and admissible in a URL:
#
#     class City < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :name
#     end
#
#     @city.friendly.find "Viña del Mar"
#     redirect_to @city # the URL will be /cities/Viña%20del%20Mar
#
# Writing the code to process an arbitrary string into a good identifier for use
# in a URL can be repetitive and surprisingly tricky, so for this reason it's
# often better and easier to use {FriendlyId::Slugged slugs}.
module FriendlyId::Base
  # Returns a scope that includes the friendly finders.
  #
  # @see FriendlyId::FinderMethods
  def friendly; end

  # Configure FriendlyId's behavior in a model.
  #
  #     class Post < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id :title, :use => :slugged
  #     end
  #
  # When given the optional block, this method will yield the class's instance
  # of {FriendlyId::Configuration} to the block before evaluating other
  # arguments, so configuration values set in the block may be overwritten by
  # the arguments. This order was chosen to allow passing the same proc to
  # multiple models, while being able to override the values it sets. Here is
  # a contrived example:
  #
  #     $friendly_id_config_proc = Proc.new do |config|
  #       config.base = :name
  #       config.use :slugged
  #     end
  #
  #     class Foo < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id &$friendly_id_config_proc
  #     end
  #
  #     class Bar < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id :title, &$friendly_id_config_proc
  #     end
  #
  # However, it's usually better to use {FriendlyId.defaults} for this:
  #
  #     FriendlyId.defaults do |config|
  #       config.base = :name
  #       config.use :slugged
  #     end
  #
  #     class Foo < ActiveRecord::Base
  #       extend FriendlyId
  #     end
  #
  #     class Bar < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id :title
  #     end
  #
  # In general you should use the block syntax either because of your personal
  # aesthetic preference, or because you need to share some functionality
  # between multiple models that can't be well encapsulated by
  # {FriendlyId.defaults}.
  #
  # ### Order Method Calls in a Block vs Ordering Options
  #
  # When calling this method without a block, you may set the hash options in
  # any order.
  #
  # However, when using block-style invocation, be sure to call
  # FriendlyId::Configuration's {FriendlyId::Configuration#use use} method
  # *prior* to the associated configuration options, because it will include
  # modules into your class, and these modules in turn may add required
  # configuration options to the `@friendly_id_configuraton`'s class:
  #
  #     class Person < ActiveRecord::Base
  #       friendly_id do |config|
  #         # This will work
  #         config.use :slugged
  #         config.sequence_separator = ":"
  #       end
  #     end
  #
  #     class Person < ActiveRecord::Base
  #       friendly_id do |config|
  #         # This will fail
  #         config.sequence_separator = ":"
  #         config.use :slugged
  #       end
  #     end
  #
  # ### Including Your Own Modules
  #
  # Because :use can accept a name or a Module, {FriendlyId.defaults defaults}
  # can be a convenient place to set up behavior common to all classes using
  # FriendlyId. You can include any module, or more conveniently, define one
  # on-the-fly. For example, let's say you want to make
  # [Babosa](http://github.com/norman/babosa) the default slugging library in
  # place of Active Support, and transliterate all slugs from Russian Cyrillic
  # to ASCII:
  #
  #     require "babosa"
  #
  #     FriendlyId.defaults do |config|
  #       config.base = :name
  #       config.use :slugged
  #       config.use Module.new {
  #         def normalize_friendly_id(text)
  #           text.to_slug.normalize! :transliterations => [:russian, :latin]
  #         end
  #       }
  #     end
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @yield Provides access to the model class's friendly_id_config, which
  #   allows an alternate configuration syntax, and conditional configuration
  #   logic.
  # @yieldparam config The model class's {FriendlyId::Configuration friendly_id_config}.
  def friendly_id(base = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the model class's {FriendlyId::Configuration friendly_id_config}.
  #
  # @note In the case of Single Table Inheritance (STI), this method will
  #   duplicate the parent class's FriendlyId::Configuration and relation class
  #   on first access. If you're concerned about thread safety, then be sure
  #   to invoke {#friendly_id} in your class for each model.
  def friendly_id_config; end

  def primary_key_type; end
end

# This class provides the slug candidate functionality.
#
# @see FriendlyId::Slugged
class FriendlyId::Candidates
  include ::Enumerable

  # @return [Candidates] a new instance of Candidates
  def initialize(object, *array); end

  def each(*args, &block); end

  private

  def candidates; end
  def filter(candidates); end
  def normalize(candidates); end

  # @return [Boolean]
  def reserved?(slug); end

  def to_candidate_array(object, array); end

  # @return [Boolean]
  def wanted?(slug); end
end

# The configuration parameters passed to {Base#friendly_id} will be stored in
# this object.
class FriendlyId::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize(model_class, values = T.unsafe(nil)); end

  # The base column or method used by FriendlyId as the basis of a friendly id
  # or slug.
  #
  # For models that don't use {FriendlyId::Slugged}, this is the column that
  # is used to store the friendly id. For models using {FriendlyId::Slugged},
  # the base is a column or method whose value is used as the basis of the
  # slug.
  #
  # For example, if you have a model representing blog posts and that uses
  # slugs, you likely will want to use the "title" attribute as the base, and
  # FriendlyId will take care of transforming the human-readable title into
  # something suitable for use in a URL.
  #
  # If you pass an argument, it will be used as the base. Otherwise the current
  # value is returned.
  #
  # @param value A symbol referencing a column or method in the model. This
  #   value is usually set by passing it as the first argument to
  #   {FriendlyId::Base#friendly_id friendly_id}.
  def base(*value); end

  # Sets the attribute base
  #
  # @param value the value to set the attribute base to.
  def base=(_arg0); end

  # The default configuration options.
  def defaults; end

  # The value used for the slugged association's dependent option
  def dependent; end

  # The value used for the slugged association's dependent option
  def dependent=(_arg0); end

  # The module to use for finders
  def finder_methods; end

  # The module to use for finders
  def finder_methods=(_arg0); end

  # The model class that this configuration belongs to.
  #
  # @return ActiveRecord::Base
  def model_class; end

  # The model class that this configuration belongs to.
  #
  # @return ActiveRecord::Base
  def model_class=(_arg0); end

  # The modules in use
  def modules; end

  # The column that FriendlyId will use to find the record when querying by
  # friendly id.
  #
  # This method is generally only used internally by FriendlyId.
  #
  # @return String
  def query_field; end

  # Route generation preferences
  def routes; end

  # Route generation preferences
  def routes=(_arg0); end

  # Lets you specify the addon modules to use with FriendlyId.
  #
  # This method is invoked by {FriendlyId::Base#friendly_id friendly_id} when
  # passing the `:use` option, or when using {FriendlyId::Base#friendly_id
  # friendly_id} with a block.
  #
  # @example
  #   class Book < ActiveRecord::Base
  #   extend FriendlyId
  #   friendly_id :name, :use => :slugged
  #   end
  # @param modules [#to_s, Module] Arguments should be Modules, or symbols or
  #   strings that correspond with the name of an addon to use with FriendlyId.
  #   By default FriendlyId provides `:slugged`, `:finders`, `:history`,
  #   `:reserved`, `:simple_i18n`, and `:scoped`.
  def use(*modules); end

  # Returns whether the given module is in use.
  #
  # @return [Boolean]
  def uses?(mod); end

  private

  def get_module(object); end
  def set(values); end
end

module FriendlyId::FinderMethods
  # Returns true if a record with the given id exists.
  #
  # @return [Boolean]
  def exists?(conditions = T.unsafe(nil)); end

  # @return [Boolean]
  def exists_by_friendly_id?(id); end

  # Finds a record using the given id.
  #
  # If the id is "unfriendly", it will call the original find method.
  # If the id is a numeric string like '123' it will first look for a friendly
  # id matching '123' and then fall back to looking for a record with the
  # numeric id '123'.
  #
  # Use allow_nil: true if you'd like the finder to return nil instead of
  # raising ActivRecord::RecordNotFound
  #
  # ### Example
  #
  #     MyModel.friendly.find("bad-slug")
  #     #=> raise ActiveRecord::RecordNotFound
  #
  #     MyModel.friendly.find("bad-slug", allow_nil: true)
  #     #=> nil
  #
  # Since FriendlyId 5.0, if the id is a nonnumeric string like '123-foo' it
  # will *only* search by friendly id and not fall back to the regular find
  # method.
  #
  # If you want to search only by the friendly id, use {#find_by_friendly_id}.
  #
  # @param allow_nil [Boolean] (default: false)
  # @raise ActiveRecord::RecordNotFound
  def find(*args, allow_nil: T.unsafe(nil)); end

  # Finds exclusively by the friendly id, completely bypassing original
  # `find`.
  #
  # @raise ActiveRecord::RecordNotFound
  def find_by_friendly_id(id); end

  private

  def first_by_friendly_id(id); end

  # Parse the given value to make it suitable for use as a slug according to
  # your application's rules.
  #
  # This method is not intended to be invoked directly; FriendlyId uses it
  # internally to process a slug into string to use as a finder.
  #
  # However, if FriendlyId's default slug parsing doesn't suit your needs,
  # you can override this method in your model class to control exactly how
  # slugs are generated.
  #
  # ### Example
  #
  #     class Person < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id :name_and_location
  #
  #       def name_and_location
  #         "#{name} from #{location}"
  #       end
  #
  #       # Use default slug, but lower case
  #       # If `id` is "Jane-Doe" or "JANE-DOE", this finds data by "jane-doe"
  #       def parse_friendly_id(slug)
  #         super.downcase
  #       end
  #     end
  #
  # @param value [#to_s] The slug to be parsed.
  # @return The parsed slug, which is not modified by default.
  def parse_friendly_id(value); end

  # @return [Boolean]
  def potential_primary_key?(id); end

  def raise_not_found_exception(id); end
end

# ## Performing Finds with FriendlyId
#
# FriendlyId offers enhanced finders which will search for your record by
# friendly id, and fall back to the numeric id if necessary. This makes it easy
# to add FriendlyId to an existing application with minimal code modification.
#
# By default, these methods are available only on the `friendly` scope:
#
#     Restaurant.friendly.find('plaza-diner') #=> works
#     Restaurant.friendly.find(23)            #=> also works
#     Restaurant.find(23)                     #=> still works
#     Restaurant.find('plaza-diner')          #=> will not work
#
# Restoring FriendlyId 4.0-style finders
#
# Prior to version 5.0, FriendlyId overrode the default finder methods to perform
# friendly finds all the time. This required modifying parts of Rails that did
# not have a public API, which was harder to maintain and at times caused
# compatiblity problems. In 5.0 we decided to change the library's defaults and add
# the friendly finder methods only to the `friendly` scope in order to boost
# compatiblity. However, you can still opt-in to original functionality very
# easily by using the `:finders` addon:
#
#     class Restaurant < ActiveRecord::Base
#       extend FriendlyId
#
#       scope :active, -> {where(:active => true)}
#
#       friendly_id :name, :use => [:slugged, :finders]
#     end
#
#     Restaurant.friendly.find('plaza-diner') #=> works
#     Restaurant.find('plaza-diner')          #=> now also works
#     Restaurant.active.find('plaza-diner')   #=> now also works
#
# Updating your application to use FriendlyId's finders
#
# Unless you've chosen to use the `:finders` addon, be sure to modify the finders
# in your controllers to use the `friendly` scope. For example:
#
#     # before
#     def set_restaurant
#       @restaurant = Restaurant.find(params[:id])
#     end
#
#     # after
#     def set_restaurant
#       @restaurant = Restaurant.friendly.find(params[:id])
#     end
#
# Active Admin
#
# Unless you use the `:finders` addon, you should modify your admin controllers
# for models that use FriendlyId with something similar to the following:
#
#     controller do
#       def find_resource
#         scoped_collection.friendly.find(params[:id])
#       end
#     end
module FriendlyId::Finders
  class << self
    def setup(model_class); end
  end
end

module FriendlyId::Finders::ClassMethods; end

# History: Avoiding 404's When Slugs Change
#
# FriendlyId's {FriendlyId::History History} module adds the ability to store a
# log of a model's slugs, so that when its friendly id changes, it's still
# possible to perform finds by the old id.
#
# The primary use case for this is avoiding broken URLs.
#
# Setup
#
# In order to use this module, you must add a table to your database schema to
# store the slug records. FriendlyId provides a generator for this purpose:
#
#     rails generate friendly_id
#     rake db:migrate
#
# This will add a table named `friendly_id_slugs`, used by the {FriendlyId::Slug}
# model.
#
# Considerations
#
# Because recording slug history requires creating additional database records,
# this module has an impact on the performance of the associated model's `create`
# method.
#
# Example
#
#     class Post < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :title, :use => :history
#     end
#
#     class PostsController < ApplicationController
#
#       before_filter :find_post
#
#       ...
#
#       def find_post
#         @post = Post.friendly.find params[:id]
#
#         # If an old id or a numeric id was used to find the record, then
#         # the request slug will not match the current slug, and we should do
#         # a 301 redirect to the new path
#         if params[:id] != @post.slug
#           return redirect_to @post, :status => :moved_permanently
#         end
#       end
#     end
module FriendlyId::History
  private

  def create_slug; end

  # @return [Boolean]
  def history_is_up_to_date?; end

  # If we're updating, don't consider historic slugs for the same record
  # to be conflicts. This will allow a record to revert to a previously
  # used slug.
  def scope_for_slug_generator; end

  class << self
    # Configures the model instance to use the History add-on.
    def included(model_class); end

    def setup(model_class); end
  end
end

module FriendlyId::History::Configuration
  def dependent_value; end
end

module FriendlyId::History::FinderMethods
  include ::FriendlyId::FinderMethods

  # @return [Boolean]
  def exists_by_friendly_id?(id); end

  private

  def first_by_friendly_id(id); end
  def slug_history_clause(id); end
  def slug_table_record(id); end
end

# Instance methods that will be added to all classes using FriendlyId.
module FriendlyId::Model
  # Clears slug on duplicate records when calling `dup`.
  def dup; end

  # Get the instance's friendly_id.
  def friendly_id; end

  # Convenience method for accessing the class method of the same name.
  def friendly_id_config; end

  # Either the friendly_id, or the numeric id cast to a string.
  def to_param; end

  class << self
    # @private
    def included(model_class); end
  end
end

# Utility methods for determining whether any object is a friendly id.
#
# Monkey-patching Object is a somewhat extreme measure not to be taken lightly
# by libraries, but in this case I decided to do it because to me, it feels
# cleaner than adding a module method to {FriendlyId}. I've given the methods
# names that unambigously refer to the library of their origin, which should
# be sufficient to avoid conflicts with other libraries.
module FriendlyId::ObjectUtils
  # True if the id is definitely friendly, false if definitely unfriendly,
  # else nil.
  #
  # An object is considired "definitely unfriendly" if its class is or
  # inherits from ActiveRecord::Base, Array, Hash, NilClass, Numeric, or
  # Symbol.
  #
  # An object is considered "definitely friendly" if it responds to +to_i+,
  # and its value when cast to an integer and then back to a string is
  # different from its value when merely cast to a string:
  #
  #     123.friendly_id?                  #=> false
  #     :id.friendly_id?                  #=> false
  #     {:name => 'joe'}.friendly_id?     #=> false
  #     ['name = ?', 'joe'].friendly_id?  #=> false
  #     nil.friendly_id?                  #=> false
  #     "123".friendly_id?                #=> nil
  #     "abc123".friendly_id?             #=> true
  #
  # @return [Boolean]
  def friendly_id?; end

  # True if the id is definitely unfriendly, false if definitely friendly,
  # else nil.
  #
  # @return [Boolean]
  def unfriendly_id?; end
end

# Reserved Words
#
# The {FriendlyId::Reserved Reserved} module adds the ability to exclude a list of
# words from use as FriendlyId slugs.
#
# With Ruby on Rails, FriendlyId's generator generates an initializer that
# reserves some words such as "new" and "edit" using {FriendlyId.defaults
# FriendlyId.defaults}.
#
# Note that the error messages for fields will appear on the field
# `:friendly_id`. If you are using Rails's scaffolded form errors display, then
# it will have no field to highlight. If you'd like to change this so that
# scaffolding works as expected, one way to accomplish this is to move the error
# message to a different field. For example:
#
#     class Person < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :name, use: :slugged
#
#       after_validation :move_friendly_id_error_to_name
#
#       def move_friendly_id_error_to_name
#         errors.add :name, *errors.delete(:friendly_id) if errors[:friendly_id].present?
#       end
#     end
module FriendlyId::Reserved
  class << self
    # When included, this module adds configuration options to the model class's
    # friendly_id_config.
    def included(model_class); end
  end
end

# This module adds the `:reserved_words` configuration option to
# {FriendlyId::Configuration FriendlyId::Configuration}.
module FriendlyId::Reserved::Configuration
  # Returns the value of attribute reserved_words.
  def reserved_words; end

  # Sets the attribute reserved_words
  #
  # @param value the value to set the attribute reserved_words to.
  def reserved_words=(_arg0); end

  # Returns the value of attribute treat_reserved_as_conflict.
  def treat_reserved_as_conflict; end

  # Sets the attribute treat_reserved_as_conflict
  #
  # @param value the value to set the attribute treat_reserved_as_conflict to.
  def treat_reserved_as_conflict=(_arg0); end
end

# Unique Slugs by Scope
#
# The {FriendlyId::Scoped} module allows FriendlyId to generate unique slugs
# within a scope.
#
# This allows, for example, two restaurants in different cities to have the slug
# `joes-diner`:
#
#     class Restaurant < ActiveRecord::Base
#       extend FriendlyId
#       belongs_to :city
#       friendly_id :name, :use => :scoped, :scope => :city
#     end
#
#     class City < ActiveRecord::Base
#       extend FriendlyId
#       has_many :restaurants
#       friendly_id :name, :use => :slugged
#     end
#
#     City.friendly.find("seattle").restaurants.friendly.find("joes-diner")
#     City.friendly.find("chicago").restaurants.friendly.find("joes-diner")
#
# Without :scoped in this case, one of the restaurants would have the slug
# `joes-diner` and the other would have `joes-diner-f9f3789a-daec-4156-af1d-fab81aa16ee5`.
#
# The value for the `:scope` option can be the name of a `belongs_to` relation, or
# a column.
#
# Additionally, the `:scope` option can receive an array of scope values:
#
#     class Cuisine < ActiveRecord::Base
#       extend FriendlyId
#       has_many :restaurants
#       friendly_id :name, :use => :slugged
#     end
#
#     class City < ActiveRecord::Base
#       extend FriendlyId
#       has_many :restaurants
#       friendly_id :name, :use => :slugged
#     end
#
#     class Restaurant < ActiveRecord::Base
#       extend FriendlyId
#       belongs_to :city
#       friendly_id :name, :use => :scoped, :scope => [:city, :cuisine]
#     end
#
# All supplied values will be used to determine scope.
#
# Finding Records by Friendly ID
#
# If you are using scopes your friendly ids may not be unique, so a simple find
# like:
#
#     Restaurant.friendly.find("joes-diner")
#
# may return the wrong record. In these cases it's best to query through the
# relation:
#
#     @city.restaurants.friendly.find("joes-diner")
#
# Alternatively, you could pass the scope value as a query parameter:
#
#     Restaurant.where(:city_id => @city.id).friendly.find("joes-diner")
#
#
# Finding All Records That Match a Scoped ID
#
# Query the slug column directly:
#
#     Restaurant.where(:slug => "joes-diner")
#
# Routes for Scoped Models
#
# Recall that FriendlyId is a database-centric library, and does not set up any
# routes for scoped models. You must do this yourself in your application. Here's
# an example of one way to set this up:
#
#     # in routes.rb
#     resources :cities do
#       resources :restaurants
#     end
#
#     # in views
#     <%= link_to 'Show', [@city, @restaurant] %>
#
#     # in controllers
#     @city = City.friendly.find(params[:city_id])
#     @restaurant = @city.restaurants.friendly.find(params[:id])
#
#     # URLs:
#     http://example.org/cities/seattle/restaurants/joes-diner
#     http://example.org/cities/chicago/restaurants/joes-diner
module FriendlyId::Scoped
  def serialized_scope; end

  # @return [Boolean]
  def should_generate_new_friendly_id?; end

  private

  def scope_for_slug_generator; end
  def slug_generator; end

  class << self
    # Sets up behavior and configuration options for FriendlyId's scoped slugs
    # feature.
    def included(model_class); end

    # FriendlyId::Config.use will invoke this method when present, to allow
    # loading dependent modules prior to overriding them when necessary.
    def setup(model_class); end
  end
end

# This module adds the `:scope` configuration option to
# {FriendlyId::Configuration FriendlyId::Configuration}.
module FriendlyId::Scoped::Configuration
  # Gets the scope value.
  #
  # When setting this value, the argument should be a symbol referencing a
  # `belongs_to` relation, or a column.
  #
  # @return Symbol The scope value
  def scope; end

  # Gets the scope value.
  #
  # When setting this value, the argument should be a symbol referencing a
  # `belongs_to` relation, or a column.
  #
  # @return Symbol The scope value
  def scope=(_arg0); end

  # Gets the scope columns.
  #
  # Checks to see if the `:scope` option passed to
  # {FriendlyId::Base#friendly_id} refers to a relation, and if so, returns
  # the realtion's foreign key. Otherwise it assumes the option value was
  # the name of column and returns it cast to a String.
  #
  # @return String The scope column
  def scope_columns; end

  private

  def reflection_foreign_key(scope); end
end

module FriendlyId::SequentiallySlugged
  def resolve_friendly_id_conflict(candidate_slugs); end

  private

  def slug_base_class; end
  def slug_column; end

  class << self
    def setup(model_class); end
  end
end

class FriendlyId::SequentiallySlugged::Calculator
  # @return [Calculator] a new instance of Calculator
  def initialize(scope, slug, slug_column, sequence_separator, base_class); end

  def next_slug; end

  # Returns the value of attribute scope.
  def scope; end

  # Sets the attribute scope
  #
  # @param value the value to set the attribute scope to.
  def scope=(_arg0); end

  # Returns the value of attribute sequence_separator.
  def sequence_separator; end

  # Sets the attribute sequence_separator
  #
  # @param value the value to set the attribute sequence_separator to.
  def sequence_separator=(_arg0); end

  # Returns the value of attribute slug.
  def slug; end

  # Sets the attribute slug
  #
  # @param value the value to set the attribute slug to.
  def slug=(_arg0); end

  # Returns the value of attribute slug_column.
  def slug_column; end

  # Sets the attribute slug_column
  #
  # @param value the value to set the attribute slug_column to.
  def slug_column=(_arg0); end

  private

  def conflict_query; end
  def last_sequence_number; end
  def next_sequence_number; end

  # Return the unnumbered (shortest) slug first, followed by the numbered ones
  # in ascending order.
  def ordering_query; end

  def regexp; end
  def sequential_slug_matcher; end
  def slug_conflicts; end
  def sql_length; end
end

# Translating Slugs Using Simple I18n
#
# The {FriendlyId::SimpleI18n SimpleI18n} module adds very basic i18n support to
# FriendlyId.
#
# In order to use this module, your model must have a slug column for each locale.
# By default FriendlyId looks for columns named, for example, "slug_en",
# "slug_es", "slug_pt_br", etc. The first part of the name can be configured by
# passing the `:slug_column` option if you choose. Note that the column for the
# default locale must also include the locale in its name.
#
# This module is most suitable to applications that need to support few locales.
# If you need to support two or more locales, you may wish to use the
# friendly_id_globalize gem instead.
#
# Example migration
#
#     def self.up
#       create_table :posts do |t|
#         t.string :title
#         t.string :slug_en
#         t.string :slug_es
#         t.string :slug_pt_br
#         t.text   :body
#       end
#       add_index :posts, :slug_en
#       add_index :posts, :slug_es
#       add_index :posts, :slug_pt_br
#     end
#
# Finds
#
# Finds will take into consideration the current locale:
#
#     I18n.locale = :es
#     Post.friendly.find("la-guerra-de-las-galaxias")
#     I18n.locale = :en
#     Post.friendly.find("star-wars")
#     I18n.locale = :"pt-BR"
#     Post.friendly.find("guerra-das-estrelas")
#
# To find a slug by an explicit locale, perform the find inside a block
# passed to I18n's `with_locale` method:
#
#     I18n.with_locale(:es) do
#       Post.friendly.find("la-guerra-de-las-galaxias")
#     end
#
# Creating Records
#
# When new records are created, the slug is generated for the current locale only.
#
# Translating Slugs
#
# To translate an existing record's friendly_id, use
# {FriendlyId::SimpleI18n::Model#set_friendly_id}. This will ensure that the slug
# you add is properly escaped, transliterated and sequenced:
#
#     post = Post.create :name => "Star Wars"
#     post.set_friendly_id("La guerra de las galaxias", :es)
#
# If you don't pass in a locale argument, FriendlyId::SimpleI18n will just use the
# current locale:
#
#     I18n.with_locale(:es) do
#       post.set_friendly_id("La guerra de las galaxias")
#     end
module FriendlyId::SimpleI18n
  include ::FriendlyId::SimpleI18n::Model

  class << self
    # @private
    def included(model_class); end

    # FriendlyId::Config.use will invoke this method when present, to allow
    # loading dependent modules prior to overriding them when necessary.
    def setup(model_class); end
  end
end

module FriendlyId::SimpleI18n::Configuration
  def slug_column; end

  private

  def locale_suffix; end
end

module FriendlyId::SimpleI18n::Model
  def set_friendly_id(text, locale = T.unsafe(nil)); end
  def slug=(value); end
end

# A FriendlyId slug stored in an external table.
#
# @see FriendlyId::History
class FriendlyId::Slug < ::ActiveRecord::Base
  include ::FriendlyId::Slug::GeneratedAttributeMethods
  include ::FriendlyId::Slug::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  extend ::Kaminari::ConfigurationMethods::ClassMethods

  def autosave_associated_records_for_sluggable(*args); end
  def sluggable; end
  def to_param; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def defined_enums; end
    def page(num = T.unsafe(nil)); end
  end
end

module FriendlyId::Slug::GeneratedAssociationMethods
  def reload_sluggable; end
  def sluggable; end
  def sluggable=(value); end
  def sluggable_changed?; end
  def sluggable_previously_changed?; end
end

module FriendlyId::Slug::GeneratedAttributeMethods; end

# The default slug generator offers functionality to check slug candidates for
# availability.
class FriendlyId::SlugGenerator
  # @return [SlugGenerator] a new instance of SlugGenerator
  def initialize(scope, config); end

  # @return [Boolean]
  def available?(slug); end

  def generate(candidates); end
end

# Slugged Models
#
# FriendlyId can use a separate column to store slugs for models which require
# some text processing.
#
# For example, blog applications typically use a post title to provide the basis
# of a search engine friendly URL. Such identifiers typically lack uppercase
# characters, use ASCII to approximate UTF-8 characters, and strip out other
# characters which may make them aesthetically unappealing or error-prone when
# used in a URL.
#
#     class Post < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :title, :use => :slugged
#     end
#
#     @post = Post.create(:title => "This is the first post!")
#     @post.friendly_id   # returns "this-is-the-first-post"
#     redirect_to @post   # the URL will be /posts/this-is-the-first-post
#
# In general, use slugs by default unless you know for sure you don't need them.
# To activate the slugging functionality, use the {FriendlyId::Slugged} module.
#
# FriendlyId will generate slugs from a method or column that you specify, and
# store them in a field in your model. By default, this field must be named
# `:slug`, though you may change this using the
# {FriendlyId::Slugged::Configuration#slug_column slug_column} configuration
# option. You should add an index to this column, and in most cases, make it
# unique. You may also wish to constrain it to NOT NULL, but this depends on your
# app's behavior and requirements.
#
# Example Setup
#
#     # your model
#     class Post < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :title, :use => :slugged
#       validates_presence_of :title, :slug, :body
#     end
#
#     # a migration
#     class CreatePosts < ActiveRecord::Migration
#       def self.up
#         create_table :posts do |t|
#           t.string :title, :null => false
#           t.string :slug, :null => false
#           t.text :body
#         end
#
#         add_index :posts, :slug, :unique => true
#       end
#
#       def self.down
#         drop_table :posts
#       end
#     end
#
# Working With Slugs
#
# Formatting
#
# By default, FriendlyId uses Active Support's
# [parameterize](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-parameterize)
# method to create slugs. This method will intelligently replace spaces with
# dashes, and Unicode Latin characters with ASCII approximations:
#
#     movie = Movie.create! :title => "Der Preis fürs Überleben"
#     movie.slug #=> "der-preis-furs-uberleben"
#
# Column or Method?
#
# FriendlyId always uses a method as the basis of the slug text - not a column. At
# first glance, this may sound confusing, but remember that Active Record provides
# methods for each column in a model's associated table, and that's what
# FriendlyId uses.
#
# Here's an example of a class that uses a custom method to generate the slug:
#
#     class Person < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :name_and_location, use: :slugged
#
#       def name_and_location
#         "#{name} from #{location}"
#       end
#     end
#
#     bob = Person.create! :name => "Bob Smith", :location => "New York City"
#     bob.friendly_id #=> "bob-smith-from-new-york-city"
#
# FriendlyId refers to this internally as the "base" method.
#
# Uniqueness
#
# When you try to insert a record that would generate a duplicate friendly id,
# FriendlyId will append a UUID to the generated slug to ensure uniqueness:
#
#     car = Car.create :title => "Peugeot 206"
#     car2 = Car.create :title => "Peugeot 206"
#
#     car.friendly_id #=> "peugeot-206"
#     car2.friendly_id #=> "peugeot-206-f9f3789a-daec-4156-af1d-fab81aa16ee5"
#
# Previous versions of FriendlyId appended a numeric sequence to make slugs
# unique, but this was removed to simplify using FriendlyId in concurrent code.
#
# Candidates
#
# Since UUIDs are ugly, FriendlyId provides a "slug candidates" functionality to
# let you specify alternate slugs to use in the event the one you want to use is
# already taken. For example:
#
#     class Restaurant < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :slug_candidates, use: :slugged
#
#       # Try building a slug based on the following fields in
#       # increasing order of specificity.
#       def slug_candidates
#         [
#           :name,
#           [:name, :city],
#           [:name, :street, :city],
#           [:name, :street_number, :street, :city]
#         ]
#       end
#     end
#
#     r1 = Restaurant.create! name: 'Plaza Diner', city: 'New Paltz'
#     r2 = Restaurant.create! name: 'Plaza Diner', city: 'Kingston'
#
#     r1.friendly_id  #=> 'plaza-diner'
#     r2.friendly_id  #=> 'plaza-diner-kingston'
#
# To use candidates, make your FriendlyId base method return an array. The
# method need not be named `slug_candidates`; it can be anything you want. The
# array may contain any combination of symbols, strings, procs or lambdas and
# will be evaluated lazily and in order. If you include symbols, FriendlyId will
# invoke a method on your model class with the same name. Strings will be
# interpreted literally. Procs and lambdas will be called and their return values
# used as the basis of the friendly id. If none of the candidates can generate a
# unique slug, then FriendlyId will append a UUID to the first candidate as a
# last resort.
#
# Sequence Separator
#
# By default, FriendlyId uses a dash to separate the slug from a sequence.
#
# You can change this with the {FriendlyId::Slugged::Configuration#sequence_separator
# sequence_separator} configuration option.
#
# Providing Your Own Slug Processing Method
#
# You can override {FriendlyId::Slugged#normalize_friendly_id} in your model for
# total control over the slug format. It will be invoked for any generated slug,
# whether for a single slug or for slug candidates.
#
# Deciding When to Generate New Slugs
#
# As of FriendlyId 5.0, slugs are only generated when the `slug` field is nil. If
# you want a slug to be regenerated,set the slug field to nil:
#
#     restaurant.friendly_id # joes-diner
#     restaurant.name = "The Plaza Diner"
#     restaurant.save!
#     restaurant.friendly_id # joes-diner
#     restaurant.slug = nil
#     restaurant.save!
#     restaurant.friendly_id # the-plaza-diner
#
# You can also override the
# {FriendlyId::Slugged#should_generate_new_friendly_id?} method, which lets you
# control exactly when new friendly ids are set:
#
#     class Post < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :title, :use => :slugged
#
#       def should_generate_new_friendly_id?
#         title_changed?
#       end
#     end
#
# If you want to extend the default behavior but add your own conditions,
# don't forget to invoke `super` from your implementation:
#
#     class Category < ActiveRecord::Base
#       extend FriendlyId
#       friendly_id :name, :use => :slugged
#
#       def should_generate_new_friendly_id?
#         name_changed? || super
#       end
#     end
#
# Locale-specific Transliterations
#
# Active Support's `parameterize` uses
# [transliterate](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-transliterate),
# which in turn can use I18n's transliteration rules to consider the current
# locale when replacing Latin characters:
#
#     # config/locales/de.yml
#     de:
#       i18n:
#         transliterate:
#           rule:
#             ü: "ue"
#             ö: "oe"
#             etc...
#
#     movie = Movie.create! :title => "Der Preis fürs Überleben"
#     movie.slug #=> "der-preis-fuers-ueberleben"
#
# This functionality was in fact taken from earlier versions of FriendlyId.
#
# Gotchas: Common Problems
#
# FriendlyId uses a before_validation callback to generate and set the slug. This
# means that if you create two model instances before saving them, it's possible
# they will generate the same slug, and the second save will fail.
#
# This can happen in two fairly normal cases: the first, when a model using nested
# attributes creates more than one record for a model that uses friendly_id. The
# second, in concurrent code, either in threads or multiple processes.
#
# To solve the nested attributes issue, I recommend simply avoiding them when
# creating more than one nested record for a model that uses FriendlyId. See [this
# Github issue](https://github.com/norman/friendly_id/issues/185) for discussion.
module FriendlyId::Slugged
  # Process the given value to make it suitable for use as a slug.
  #
  # This method is not intended to be invoked directly; FriendlyId uses it
  # internally to process strings into slugs.
  #
  # However, if FriendlyId's default slug generation doesn't suit your needs,
  # you can override this method in your model class to control exactly how
  # slugs are generated.
  #
  # ### Example
  #
  #     class Person < ActiveRecord::Base
  #       extend FriendlyId
  #       friendly_id :name_and_location
  #
  #       def name_and_location
  #         "#{name} from #{location}"
  #       end
  #
  #       # Use default slug, but upper case and with underscores
  #       def normalize_friendly_id(string)
  #         super.upcase.gsub("-", "_")
  #       end
  #     end
  #
  #     bob = Person.create! :name => "Bob Smith", :location => "New York City"
  #     bob.friendly_id #=> "BOB_SMITH_FROM_NEW_YORK_CITY"
  #
  # ### More Resources
  #
  # You might want to look into Babosa[https://github.com/norman/babosa],
  # which is the slugging library used by FriendlyId prior to version 4, which
  # offers some specialized functionality missing from Active Support.
  #
  # @param value [#to_s] The value used as the basis of the slug.
  # @return The candidate slug text, without a sequence.
  def normalize_friendly_id(value); end

  # Public: Resolve conflicts.
  #
  # This method adds UUID to first candidate and truncates (if `slug_limit` is set).
  #
  # Examples:
  #
  #   resolve_friendly_id_conflict(['12345'])
  #   # => '12345-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
  #
  #   FriendlyId.defaults { |config| config.slug_limit = 40 }
  #   resolve_friendly_id_conflict(['12345'])
  #   # => '123-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
  #
  # candidates - the Array with candidates.
  #
  # Returns the String with new slug.
  def resolve_friendly_id_conflict(candidates); end

  # Whether to generate a new slug.
  #
  # You can override this method in your model if, for example, you only want
  # slugs to be generated once, and then never updated.
  #
  # @return [Boolean]
  def should_generate_new_friendly_id?; end

  private

  # Private: Apply slug limit to candidate.
  #
  # candidate - the String with candidate.
  # uuid      - the String with UUID.
  #
  # Return the String with truncated candidate.
  def apply_slug_limit(candidate, uuid); end

  # Private: Get max length of candidate.
  #
  # uuid - the String with UUID.
  #
  # Returns the Integer with max length.
  def candidate_limit(uuid); end

  def scope_for_slug_generator; end

  # Sets the slug.
  def set_slug(normalized_slug = T.unsafe(nil)); end

  def slug_generator; end
  def unset_slug_if_invalid; end

  class << self
    # Sets up behavior and configuration options for FriendlyId's slugging
    # feature.
    def included(model_class); end
  end
end

# This module adds the `:slug_column`, and `:slug_limit`, and `:sequence_separator`,
# and `:slug_generator_class` configuration options to
# {FriendlyId::Configuration FriendlyId::Configuration}.
module FriendlyId::Slugged::Configuration
  # Makes FriendlyId use the slug column for querying.
  #
  # @return String The slug column.
  def query_field; end

  # The string used to separate a slug base from a numeric sequence.
  #
  # You can change the default separator by setting the
  # {FriendlyId::Slugged::Configuration#sequence_separator
  # sequence_separator} configuration option.
  #
  # @return String The sequence separator string. Defaults to "`-`".
  def sequence_separator; end

  # Sets the attribute sequence_separator
  #
  # @param value the value to set the attribute sequence_separator to.
  def sequence_separator=(_arg0); end

  # The column that will be used to store the generated slug.
  def slug_column; end

  # Sets the attribute slug_column
  #
  # @param value the value to set the attribute slug_column to.
  def slug_column=(_arg0); end

  # Returns the value of attribute slug_generator_class.
  def slug_generator_class; end

  # Sets the attribute slug_generator_class
  #
  # @param value the value to set the attribute slug_generator_class to.
  def slug_generator_class=(_arg0); end

  # The limit that will be used for slug.
  def slug_limit; end

  # Sets the attribute slug_limit
  #
  # @param value the value to set the attribute slug_limit to.
  def slug_limit=(_arg0); end
end

# Instances of these classes will never be considered a friendly id.
#
# @see FriendlyId::ObjectUtils#friendly_id
FriendlyId::UNFRIENDLY_CLASSES = T.let(T.unsafe(nil), Array)

module FriendlyId::UnfriendlyUtils
  # @return [Boolean]
  def friendly_id?; end

  # @return [Boolean]
  def unfriendly_id?; end
end

class Hash
  include ::Enumerable
  include ::FriendlyId::UnfriendlyUtils
end

class NilClass
  include ::FriendlyId::UnfriendlyUtils
  include ::FriendlyId::Reserved::Configuration
  include ::FriendlyId::Scoped::Configuration
  include ::FriendlyId::SimpleI18n::Configuration
  include ::FriendlyId::Slugged::Configuration
end

class Numeric
  include ::Comparable
  include ::FriendlyId::UnfriendlyUtils
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::FriendlyId::ObjectUtils
  include ::MakeMakefile
end

class Symbol
  include ::Comparable
  include ::FriendlyId::UnfriendlyUtils
end

class TrueClass
  include ::FriendlyId::UnfriendlyUtils
end
