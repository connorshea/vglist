# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `drb` gem.
# Please instead update this file by running `bin/tapioca gem drb`.


# for ruby-1.8.0
module DRb
  private

  # Get the configuration of the current server.
  #
  # If there is no current server, this returns the default configuration.
  # See #current_server and DRbServer::make_config.
  def config; end

  # Get the 'current' server.
  #
  # In the context of execution taking place within the main
  # thread of a dRuby server (typically, as a result of a remote
  # call on the server or one of its objects), the current
  # server is that server.  Otherwise, the current server is
  # the primary server.
  #
  # If the above rule fails to find a server, a DRbServerNotFound
  # error is raised.
  #
  # @raise [DRbServerNotFound]
  def current_server; end

  # Retrieves the server with the given +uri+.
  #
  # See also regist_server and remove_server.
  def fetch_server(uri); end

  # Get the front object of the current server.
  #
  # This raises a DRbServerNotFound error if there is no current server.
  # See #current_server.
  def front; end

  # Is +uri+ the URI for the current local server?
  #
  # @return [Boolean]
  def here?(uri); end

  # Set the default ACL to +acl+.
  #
  # See DRb::DRbServer.default_acl.
  def install_acl(acl); end

  # Set the default id conversion object.
  #
  # This is expected to be an instance such as DRb::DRbIdConv that responds to
  # #to_id and #to_obj that can convert objects to and from DRb references.
  #
  # See DRbServer#default_id_conv.
  def install_id_conv(idconv); end

  def mutex; end

  # The primary local dRuby server.
  #
  # This is the server created by the #start_service call.
  def primary_server; end

  # The primary local dRuby server.
  #
  # This is the server created by the #start_service call.
  def primary_server=(_arg0); end

  # Registers +server+ with DRb.
  #
  # This is called when a new DRb::DRbServer is created.
  #
  # If there is no primary server then +server+ becomes the primary server.
  #
  # Example:
  #
  #  require 'drb'
  #
  #  s = DRb::DRbServer.new # automatically calls regist_server
  #  DRb.fetch_server s.uri #=> #<DRb::DRbServer:0x...>
  def regist_server(server); end

  # Removes +server+ from the list of registered servers.
  def remove_server(server); end

  # Start a dRuby server locally.
  #
  # The new dRuby server will become the primary server, even
  # if another server is currently the primary server.
  #
  # +uri+ is the URI for the server to bind to.  If nil,
  # the server will bind to random port on the default local host
  # name and use the default dRuby protocol.
  #
  # +front+ is the server's front object.  This may be nil.
  #
  # +config+ is the configuration for the new server.  This may
  # be nil.
  #
  # See DRbServer::new.
  def start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end

  # Stop the local dRuby server.
  #
  # This operates on the primary server.  If there is no primary
  # server currently running, it is a noop.
  def stop_service; end

  # Get the thread of the primary server.
  #
  # This returns nil if there is no primary server.  See #primary_server.
  def thread; end

  # Get a reference id for an object using the current server.
  #
  # This raises a DRbServerNotFound error if there is no current server.
  # See #current_server.
  def to_id(obj); end

  # Convert a reference into an object using the current server.
  #
  # This raises a DRbServerNotFound error if there is no current server.
  # See #current_server.
  def to_obj(ref); end

  # Get the URI defining the local dRuby space.
  #
  # This is the URI of the current server.  See #current_server.
  def uri; end

  class << self
    # Get the configuration of the current server.
    #
    # If there is no current server, this returns the default configuration.
    # See #current_server and DRbServer::make_config.
    def config; end

    # Get the 'current' server.
    #
    # In the context of execution taking place within the main
    # thread of a dRuby server (typically, as a result of a remote
    # call on the server or one of its objects), the current
    # server is that server.  Otherwise, the current server is
    # the primary server.
    #
    # If the above rule fails to find a server, a DRbServerNotFound
    # error is raised.
    #
    # @raise [DRbServerNotFound]
    def current_server; end

    # Retrieves the server with the given +uri+.
    #
    # See also regist_server and remove_server.
    def fetch_server(uri); end

    # Get the front object of the current server.
    #
    # This raises a DRbServerNotFound error if there is no current server.
    # See #current_server.
    def front; end

    # Is +uri+ the URI for the current local server?
    #
    # @return [Boolean]
    def here?(uri); end

    # Set the default ACL to +acl+.
    #
    # See DRb::DRbServer.default_acl.
    def install_acl(acl); end

    # Set the default id conversion object.
    #
    # This is expected to be an instance such as DRb::DRbIdConv that responds to
    # #to_id and #to_obj that can convert objects to and from DRb references.
    #
    # See DRbServer#default_id_conv.
    def install_id_conv(idconv); end

    def mutex; end

    # The primary local dRuby server.
    #
    # This is the server created by the #start_service call.
    def primary_server; end

    # The primary local dRuby server.
    #
    # This is the server created by the #start_service call.
    def primary_server=(_arg0); end

    # Registers +server+ with DRb.
    #
    # This is called when a new DRb::DRbServer is created.
    #
    # If there is no primary server then +server+ becomes the primary server.
    #
    # Example:
    #
    #  require 'drb'
    #
    #  s = DRb::DRbServer.new # automatically calls regist_server
    #  DRb.fetch_server s.uri #=> #<DRb::DRbServer:0x...>
    def regist_server(server); end

    # Removes +server+ from the list of registered servers.
    def remove_server(server); end

    # Start a dRuby server locally.
    #
    # The new dRuby server will become the primary server, even
    # if another server is currently the primary server.
    #
    # +uri+ is the URI for the server to bind to.  If nil,
    # the server will bind to random port on the default local host
    # name and use the default dRuby protocol.
    #
    # +front+ is the server's front object.  This may be nil.
    #
    # +config+ is the configuration for the new server.  This may
    # be nil.
    #
    # See DRbServer::new.
    def start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end

    # Stop the local dRuby server.
    #
    # This operates on the primary server.  If there is no primary
    # server currently running, it is a noop.
    def stop_service; end

    # Get the thread of the primary server.
    #
    # This returns nil if there is no primary server.  See #primary_server.
    def thread; end

    # Get a reference id for an object using the current server.
    #
    # This raises a DRbServerNotFound error if there is no current server.
    # See #current_server.
    def to_id(obj); end

    # Convert a reference into an object using the current server.
    #
    # This raises a DRbServerNotFound error if there is no current server.
    # See #current_server.
    def to_obj(ref); end

    # Get the URI defining the local dRuby space.
    #
    # This is the URI of the current server.  See #current_server.
    def uri; end
  end
end

# An Array wrapper that can be sent to another server via DRb.
#
# All entries in the array will be dumped or be references that point to
# the local server.
class DRb::DRbArray
  # Creates a new DRbArray that either dumps or wraps all the items in the
  # Array +ary+ so they can be loaded by a remote DRb server.
  #
  # @return [DRbArray] a new instance of DRbArray
  def initialize(ary); end

  def _dump(lv); end

  class << self
    def _load(s); end
  end
end

# Class handling the connection between a DRbObject and the
# server the real object lives on.
#
# This class maintains a pool of connections, to reduce the
# overhead of starting and closing down connections for each
# method call.
#
# This class is used internally by DRbObject.  The user does
# not normally need to deal with it directly.
class DRb::DRbConn
  # @return [DRbConn] a new instance of DRbConn
  def initialize(remote_uri); end

  # @return [Boolean]
  def alive?; end

  def close; end
  def send_message(ref, msg_id, arg, block); end
  def uri; end

  class << self
    def make_pool; end
    def open(remote_uri); end
    def stop_pool; end
  end
end

# Class responsible for converting between an object and its id.
#
# This, the default implementation, uses an object's local ObjectSpace
# __id__ as its id.  This means that an object's identification over
# drb remains valid only while that object instance remains alive
# within the server runtime.
#
# For alternative mechanisms, see DRb::TimerIdConv in drb/timeridconv.rb
# and DRbNameIdConv in sample/name.rb in the full drb distribution.
class DRb::DRbIdConv
  # Convert an object into a reference id.
  #
  # This implementation returns the object's __id__ in the local
  # object space.
  def to_id(obj); end

  # Convert an object reference id to an object.
  #
  # This implementation looks up the reference id in the local object
  # space and returns the object it refers to.
  def to_obj(ref); end
end

# Handler for sending and receiving drb messages.
#
# This takes care of the low-level marshalling and unmarshalling
# of drb requests and responses sent over the wire between server
# and client.  This relieves the implementor of a new drb
# protocol layer with having to deal with these details.
#
# The user does not have to directly deal with this object in
# normal use.
class DRb::DRbMessage
  # @return [DRbMessage] a new instance of DRbMessage
  def initialize(config); end

  def dump(obj, error = T.unsafe(nil)); end

  # @raise [DRbConnError]
  def load(soc); end

  def recv_reply(stream); end

  # @raise [DRbConnError]
  def recv_request(stream); end

  def send_reply(stream, succ, result); end
  def send_request(stream, ref, msg_id, arg, b); end

  private

  def make_proxy(obj, error = T.unsafe(nil)); end
end

class DRb::DRbObject
  # Create a new remote object stub.
  #
  # +obj+ is the (local) object we want to create a stub for.  Normally
  # this is +nil+.  +uri+ is the URI of the remote object that this
  # will be a stub for.
  #
  # @return [DRbObject] a new instance of DRbObject
  def initialize(obj, uri = T.unsafe(nil)); end

  def ==(other); end

  # Get the reference of the object, if local.
  def __drbref; end

  # Get the URI of the remote object.
  def __drburi; end

  # Marshall this object.
  #
  # The URI and ref of the object are marshalled.
  def _dump(lv); end

  def eql?(other); end
  def hash; end
  def method_missing(msg_id, *a, **_arg2, &b); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end

  # Routes respond_to? to the referenced remote object.
  #
  # @return [Boolean]
  def respond_to?(msg_id, priv = T.unsafe(nil)); end

  class << self
    # Unmarshall a marshalled DRbObject.
    #
    # If the referenced object is located within the local server, then
    # the object itself is returned.  Otherwise, a new DRbObject is
    # created to act as a stub for the remote referenced object.
    def _load(s); end

    # Creates a DRb::DRbObject given the reference information to the remote
    # host +uri+ and object +ref+.
    def new_with(uri, ref); end

    # Create a new DRbObject from a URI alone.
    def new_with_uri(uri); end

    # Returns a modified backtrace from +result+ with the +uri+ where each call
    # in the backtrace came from.
    def prepare_backtrace(uri, result); end

    # Given the +uri+ of another host executes the block provided.
    def with_friend(uri); end
  end
end

# Module managing the underlying network protocol(s) used by drb.
#
# By default, drb uses the DRbTCPSocket protocol.  Other protocols
# can be defined.  A protocol must define the following class methods:
#
#   [open(uri, config)] Open a client connection to the server at +uri+,
#                       using configuration +config+.  Return a protocol
#                       instance for this connection.
#   [open_server(uri, config)] Open a server listening at +uri+,
#                              using configuration +config+.  Return a
#                              protocol instance for this listener.
#   [uri_option(uri, config)] Take a URI, possibly containing an option
#                             component (e.g. a trailing '?param=val'),
#                             and return a [uri, option] tuple.
#
# All of these methods should raise a DRbBadScheme error if the URI
# does not identify the protocol they support (e.g. "druby:" for
# the standard Ruby protocol).  This is how the DRbProtocol module,
# given a URI, determines which protocol implementation serves that
# protocol.
#
# The protocol instance returned by #open_server must have the
# following methods:
#
# [accept] Accept a new connection to the server.  Returns a protocol
#          instance capable of communicating with the client.
# [close] Close the server connection.
# [uri] Get the URI for this server.
#
# The protocol instance returned by #open must have the following methods:
#
# [send_request (ref, msg_id, arg, b)]
#      Send a request to +ref+ with the given message id and arguments.
#      This is most easily implemented by calling DRbMessage.send_request,
#      providing a stream that sits on top of the current protocol.
# [recv_reply]
#      Receive a reply from the server and return it as a [success-boolean,
#      reply-value] pair.  This is most easily implemented by calling
#      DRb.recv_reply, providing a stream that sits on top of the
#      current protocol.
# [alive?]
#      Is this connection still alive?
# [close]
#      Close this connection.
#
# The protocol instance returned by #open_server().accept() must have
# the following methods:
#
# [recv_request]
#     Receive a request from the client and return a [object, message,
#     args, block] tuple.  This is most easily implemented by calling
#     DRbMessage.recv_request, providing a stream that sits on top of
#     the current protocol.
# [send_reply(succ, result)]
#     Send a reply to the client.  This is most easily implemented
#     by calling DRbMessage.send_reply, providing a stream that sits
#     on top of the current protocol.
# [close]
#     Close this connection.
#
# A new protocol is registered with the DRbProtocol module using
# the add_protocol method.
#
# For examples of other protocols, see DRbUNIXSocket in drb/unix.rb,
# and HTTP0 in sample/http0.rb and sample/http0serv.rb in the full
# drb distribution.
module DRb::DRbProtocol
  private

  # Add a new protocol to the DRbProtocol module.
  def add_protocol(prot); end

  def auto_load(uri); end

  # Open a client connection to +uri+ with the configuration +config+.
  #
  # The DRbProtocol module asks each registered protocol in turn to
  # try to open the URI.  Each protocol signals that it does not handle that
  # URI by raising a DRbBadScheme error.  If no protocol recognises the
  # URI, then a DRbBadURI error is raised.  If a protocol accepts the
  # URI, but an error occurs in opening it, a DRbConnError is raised.
  #
  # @raise [DRbBadURI]
  def open(uri, config, first = T.unsafe(nil)); end

  # Open a server listening for connections at +uri+ with
  # configuration +config+.
  #
  # The DRbProtocol module asks each registered protocol in turn to
  # try to open a server at the URI.  Each protocol signals that it does
  # not handle that URI by raising a DRbBadScheme error.  If no protocol
  # recognises the URI, then a DRbBadURI error is raised.  If a protocol
  # accepts the URI, but an error occurs in opening it, the underlying
  # error is passed on to the caller.
  #
  # @raise [DRbBadURI]
  def open_server(uri, config, first = T.unsafe(nil)); end

  # Parse +uri+ into a [uri, option] pair.
  #
  # The DRbProtocol module asks each registered protocol in turn to
  # try to parse the URI.  Each protocol signals that it does not handle that
  # URI by raising a DRbBadScheme error.  If no protocol recognises the
  # URI, then a DRbBadURI error is raised.
  #
  # @raise [DRbBadURI]
  def uri_option(uri, config, first = T.unsafe(nil)); end

  class << self
    # Add a new protocol to the DRbProtocol module.
    def add_protocol(prot); end

    def auto_load(uri); end

    # Open a client connection to +uri+ with the configuration +config+.
    #
    # The DRbProtocol module asks each registered protocol in turn to
    # try to open the URI.  Each protocol signals that it does not handle that
    # URI by raising a DRbBadScheme error.  If no protocol recognises the
    # URI, then a DRbBadURI error is raised.  If a protocol accepts the
    # URI, but an error occurs in opening it, a DRbConnError is raised.
    #
    # @raise [DRbBadURI]
    def open(uri, config, first = T.unsafe(nil)); end

    # Open a server listening for connections at +uri+ with
    # configuration +config+.
    #
    # The DRbProtocol module asks each registered protocol in turn to
    # try to open a server at the URI.  Each protocol signals that it does
    # not handle that URI by raising a DRbBadScheme error.  If no protocol
    # recognises the URI, then a DRbBadURI error is raised.  If a protocol
    # accepts the URI, but an error occurs in opening it, the underlying
    # error is passed on to the caller.
    #
    # @raise [DRbBadURI]
    def open_server(uri, config, first = T.unsafe(nil)); end

    # Parse +uri+ into a [uri, option] pair.
    #
    # The DRbProtocol module asks each registered protocol in turn to
    # try to parse the URI.  Each protocol signals that it does not handle that
    # URI by raising a DRbBadScheme error.  If no protocol recognises the
    # URI, then a DRbBadURI error is raised.
    #
    # @raise [DRbBadURI]
    def uri_option(uri, config, first = T.unsafe(nil)); end
  end
end

# An exception wrapping an error object
class DRb::DRbRemoteError < ::DRb::DRbError
  # Creates a new remote error that wraps the Exception +error+
  #
  # @return [DRbRemoteError] a new instance of DRbRemoteError
  def initialize(error); end

  # the class of the error, as a string.
  def reason; end
end

class DRb::DRbServer
  # Create a new DRbServer instance.
  #
  # +uri+ is the URI to bind to.  This is normally of the form
  # 'druby://<hostname>:<port>' where <hostname> is a hostname of
  # the local machine.  If nil, then the system's default hostname
  # will be bound to, on a port selected by the system; these value
  # can be retrieved from the +uri+ attribute.  'druby:' specifies
  # the default dRuby transport protocol: another protocol, such
  # as 'drbunix:', can be specified instead.
  #
  # +front+ is the front object for the server, that is, the object
  # to which remote method calls on the server will be passed.  If
  # nil, then the server will not accept remote method calls.
  #
  # If +config_or_acl+ is a hash, it is the configuration to
  # use for this server.  The following options are recognised:
  #
  # :idconv :: an id-to-object conversion object.  This defaults
  #            to an instance of the class DRb::DRbIdConv.
  # :verbose :: if true, all unsuccessful remote calls on objects
  #             in the server will be logged to $stdout. false
  #             by default.
  # :tcp_acl :: the access control list for this server.  See
  #             the ACL class from the main dRuby distribution.
  # :load_limit :: the maximum message size in bytes accepted by
  #                the server.  Defaults to 25 MB (26214400).
  # :argc_limit :: the maximum number of arguments to a remote
  #                method accepted by the server.  Defaults to
  #                256.
  # The default values of these options can be modified on
  # a class-wide basis by the class methods #default_argc_limit,
  # #default_load_limit, #default_acl, #default_id_conv,
  # and #verbose=
  #
  # If +config_or_acl+ is not a hash, but is not nil, it is
  # assumed to be the access control list for this server.
  # See the :tcp_acl option for more details.
  #
  # If no other server is currently set as the primary server,
  # this will become the primary server.
  #
  # The server will immediately start running in its own thread.
  #
  # @return [DRbServer] a new instance of DRbServer
  def initialize(uri = T.unsafe(nil), front = T.unsafe(nil), config_or_acl = T.unsafe(nil)); end

  # Is this server alive?
  #
  # @return [Boolean]
  def alive?; end

  # Check that a method is callable via dRuby.
  #
  # +obj+ is the object we want to invoke the method on. +msg_id+ is the
  # method name, as a Symbol.
  #
  # If the method is an insecure method (see #insecure_method?) a
  # SecurityError is thrown.  If the method is private or undefined,
  # a NameError is thrown.
  #
  # @raise [ArgumentError]
  def check_insecure_method(obj, msg_id); end

  # The configuration of this DRbServer
  def config; end

  # The front object of the DRbServer.
  #
  # This object receives remote method calls made on the server's
  # URI alone, with an object id.
  def front; end

  # Is +uri+ the URI for this server?
  #
  # @return [Boolean]
  def here?(uri); end

  # Stop this server.
  def stop_service; end

  # The main thread of this DRbServer.
  #
  # This is the thread that listens for and accepts connections
  # from clients, not that handles each client's request-response
  # session.
  def thread; end

  # Convert a local object to a dRuby reference.
  def to_id(obj); end

  # Convert a dRuby reference to the local object it refers to.
  def to_obj(ref); end

  # The URI of this DRbServer.
  def uri; end

  # Get whether the server is in verbose mode.
  #
  # In verbose mode, failed calls are logged to stdout.
  def verbose; end

  # Set whether to operate in verbose mode.
  #
  # In verbose mode, failed calls are logged to stdout.
  def verbose=(v); end

  private

  # Coerce an object to a string, providing our own representation if
  # to_s is not defined for the object.
  def any_to_s(obj); end

  def error_print(exception); end

  # Has a method been included in the list of insecure methods?
  #
  # @return [Boolean]
  def insecure_method?(msg_id); end

  # The main loop performed by a DRbServer's internal thread.
  #
  # Accepts a connection from a client, and starts up its own
  # thread to handle it.  This thread loops, receiving requests
  # from the client, invoking them on a local object, and
  # returning responses, until the client closes the connection
  # or a local method call fails.
  def main_loop; end

  # Starts the DRb main loop in a new thread.
  def run; end

  def shutdown; end

  class << self
    # Set the default access control list to +acl+.  The default ACL is +nil+.
    #
    # See also DRb::ACL and #new()
    def default_acl(acl); end

    # Set the default value for the :argc_limit option.
    #
    # See #new().  The initial default value is 256.
    def default_argc_limit(argc); end

    # Set the default value for the :id_conv option.
    #
    # See #new().  The initial default value is a DRbIdConv instance.
    def default_id_conv(idconv); end

    # Set the default value for the :load_limit option.
    #
    # See #new().  The initial default value is 25 MB.
    def default_load_limit(sz); end

    def make_config(hash = T.unsafe(nil)); end

    # Get the default value of the :verbose option.
    def verbose; end

    # Set the default value of the :verbose option.
    #
    # See #new().  The initial default value is false.
    def verbose=(on); end
  end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin

  # @return [InvokeMethod] a new instance of InvokeMethod
  def initialize(drb_server, client); end

  def perform; end

  private

  def check_insecure_method; end
  def init_with_client; end
  def perform_without_block; end
  def setup_message; end
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end
  def perform_with_block; end
end

# The default drb protocol which communicates over a TCP socket.
#
# The DRb TCP protocol URI looks like:
# <code>druby://<host>:<port>?<option></code>.  The option is optional.
class DRb::DRbTCPSocket
  # Create a new DRbTCPSocket instance.
  #
  # +uri+ is the URI we are connected to.
  # +soc+ is the tcp socket we are bound to.  +config+ is our
  # configuration.
  #
  # @return [DRbTCPSocket] a new instance of DRbTCPSocket
  def initialize(uri, soc, config = T.unsafe(nil)); end

  # On the server side, for an instance returned by #open_server,
  # accept a client connection and return a new instance to handle
  # the server's side of this client-server session.
  def accept; end

  # Check to see if this connection is alive.
  #
  # @return [Boolean]
  def alive?; end

  # Close the connection.
  #
  # If this is an instance returned by #open_server, then this stops
  # listening for new connections altogether.  If this is an instance
  # returned by #open or by #accept, then it closes this particular
  # client-server session.
  def close; end

  # Get the address of our TCP peer (the other end of the socket
  # we are bound to.
  def peeraddr; end

  # On the client side, receive a reply from the server.
  def recv_reply; end

  # On the server side, receive a request from the client.
  def recv_request; end

  # On the server side, send a reply to the client.
  def send_reply(succ, result); end

  # On the client side, send a request to the server.
  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  # Graceful shutdown
  def shutdown; end

  # Get the socket.
  def stream; end

  # Get the URI that we are connected to.
  def uri; end

  private

  def accept_or_shutdown; end
  def close_shutdown_pipe; end

  class << self
    # Returns the hostname of this server
    def getservername; end

    # Open a client connection to +uri+ (DRb URI string) using configuration
    # +config+.
    #
    # This can raise DRb::DRbBadScheme or DRb::DRbBadURI if +uri+ is not for a
    # recognized protocol.  See DRb::DRbServer.new for information on built-in
    # URI protocols.
    def open(uri, config); end

    # Open a server listening for connections at +uri+ using
    # configuration +config+.
    def open_server(uri, config); end

    # For the families available for +host+, returns a TCPServer on +port+.
    # If +port+ is 0 the first available port is used.  IPv4 servers are
    # preferred over IPv6 servers.
    def open_server_inaddr_any(host, port); end

    def parse_uri(uri); end

    # Parse +uri+ into a [uri, option] pair.
    def uri_option(uri, config); end
  end
end

# Implements DRb over a UNIX socket
#
# DRb UNIX socket URIs look like <code>drbunix:<path>?<option></code>.  The
# option is optional.
class DRb::DRbUNIXSocket < ::DRb::DRbTCPSocket
  # @return [DRbUNIXSocket] a new instance of DRbUNIXSocket
  def initialize(uri, soc, config = T.unsafe(nil), server_mode = T.unsafe(nil)); end

  def accept; end
  def close; end
  def set_sockopt(soc); end

  class << self
    def open(uri, config); end
    def open_server(uri, config); end

    # :stopdoc:
    def parse_uri(uri); end

    def temp_server; end
    def uri_option(uri, config); end
  end
end

# import from tempfile.rb
DRb::DRbUNIXSocket::Max_try = T.let(T.unsafe(nil), Integer)

class DRb::DRbURIOption
  # @return [DRbURIOption] a new instance of DRbURIOption
  def initialize(option); end

  def ==(other); end
  def eql?(other); end
  def hash; end

  # Returns the value of attribute option.
  def option; end

  def to_s; end
end

# Mixin module making an object undumpable or unmarshallable.
#
# If an object which includes this module is returned by method
# called over drb, then the object remains in the server space
# and a reference to the object is returned, rather than the
# object being marshalled and moved into the client space.
module DRb::DRbUndumped
  # @raise [TypeError]
  def _dump(dummy); end
end

# Class wrapping a marshalled object whose type is unknown locally.
#
# If an object is returned by a method invoked over drb, but the
# class of the object is unknown in the client namespace, or
# the object is a constant unknown in the client namespace, then
# the still-marshalled object is returned wrapped in a DRbUnknown instance.
#
# If this object is passed as an argument to a method invoked over
# drb, then the wrapped object is passed instead.
#
# The class or constant name of the object can be read from the
# +name+ attribute.  The marshalled object is held in the +buf+
# attribute.
class DRb::DRbUnknown
  # Create a new DRbUnknown object.
  #
  # +buf+ is a string containing a marshalled object that could not
  # be unmarshalled.  +err+ is the error message that was raised
  # when the unmarshalling failed.  It is used to determine the
  # name of the unmarshalled object.
  #
  # @return [DRbUnknown] a new instance of DRbUnknown
  def initialize(err, buf); end

  def _dump(lv); end

  # Buffer contained the marshalled, unknown object.
  def buf; end

  # Create a DRbUnknownError exception containing this object.
  def exception; end

  # The name of the unknown thing.
  #
  # Class name for unknown objects; variable name for unknown
  # constants.
  def name; end

  # Attempt to load the wrapped marshalled object again.
  #
  # If the class of the object is now known locally, the object
  # will be unmarshalled and returned.  Otherwise, a new
  # but identical DRbUnknown object will be returned.
  def reload; end

  class << self
    def _load(s); end
  end
end

# An exception wrapping a DRb::DRbUnknown object
class DRb::DRbUnknownError < ::DRb::DRbError
  # Create a new DRbUnknownError for the DRb::DRbUnknown object +unknown+
  #
  # @return [DRbUnknownError] a new instance of DRbUnknownError
  def initialize(unknown); end

  def _dump(lv); end

  # Get the wrapped DRb::DRbUnknown object.
  def unknown; end

  class << self
    def _load(s); end
  end
end

class DRb::ThreadObject
  include ::MonitorMixin

  # @return [ThreadObject] a new instance of ThreadObject
  def initialize(&blk); end

  def _execute; end

  # @return [Boolean]
  def alive?; end

  def kill; end
  def method_missing(msg, *arg, &blk); end
end

DRb::VERSION = T.let(T.unsafe(nil), String)
DRbIdConv = DRb::DRbIdConv

# :stopdoc:
DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped
