# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `devise` gem.
# Please instead update this file by running `bin/tapioca gem devise`.

module ActionDispatch::Routing; end

class ActionDispatch::Routing::Mapper
  def initialize(set); end

  # Sets the devise scope to be used in the controller. If you have custom routes,
  # you are required to call this method (also aliased as :as) in order to specify
  # to which controller it is targeted.
  #
  #   as :user do
  #     get "sign_in", to: "devise/sessions#new"
  #   end
  #
  # Notice you cannot have two scopes mapping to the same URL. And remember, if
  # you try to access a devise controller without specifying a scope, it will
  # raise ActionNotFound error.
  #
  # Also be aware of that 'devise_scope' and 'as' use the singular form of the
  # noun where other devise route commands expect the plural form. This would be a
  # good and working example.
  #
  #  devise_scope :user do
  #    get "/some/route" => "some_devise_controller"
  #  end
  #  devise_for :users
  #
  # Notice and be aware of the differences above between :user and :users
  def as(scope); end

  # Allow you to add authentication request from the router.
  # Takes an optional scope and block to provide constraints
  # on the model instance itself.
  #
  #   authenticate do
  #     resources :post
  #   end
  #
  #   authenticate(:admin) do
  #     resources :users
  #   end
  #
  #   authenticate :user, lambda {|u| u.role == "admin"} do
  #     root to: "admin/dashboard#show", as: :user_root
  #   end
  def authenticate(scope = T.unsafe(nil), block = T.unsafe(nil)); end

  # Allow you to route based on whether a scope is authenticated. You
  # can optionally specify which scope and a block. The block accepts
  # a model and allows extra constraints to be done on the instance.
  #
  #   authenticated :admin do
  #     root to: 'admin/dashboard#show', as: :admin_root
  #   end
  #
  #   authenticated do
  #     root to: 'dashboard#show', as: :authenticated_root
  #   end
  #
  #   authenticated :user, lambda {|u| u.role == "admin"} do
  #     root to: "admin/dashboard#show", as: :user_root
  #   end
  #
  #   root to: 'landing#show'
  def authenticated(scope = T.unsafe(nil), block = T.unsafe(nil)); end

  # Includes devise_for method for routes. This method is responsible to
  # generate all needed routes for devise, based on what modules you have
  # defined in your model.
  #
  # ==== Examples
  #
  # Let's say you have an User model configured to use authenticatable,
  # confirmable and recoverable modules. After creating this inside your routes:
  #
  #   devise_for :users
  #
  # This method is going to look inside your User model and create the
  # needed routes:
  #
  #  # Session routes for Authenticatable (default)
  #       new_user_session GET    /users/sign_in                    {controller:"devise/sessions", action:"new"}
  #           user_session POST   /users/sign_in                    {controller:"devise/sessions", action:"create"}
  #   destroy_user_session DELETE /users/sign_out                   {controller:"devise/sessions", action:"destroy"}
  #
  #  # Password routes for Recoverable, if User model has :recoverable configured
  #      new_user_password GET    /users/password/new(.:format)     {controller:"devise/passwords", action:"new"}
  #     edit_user_password GET    /users/password/edit(.:format)    {controller:"devise/passwords", action:"edit"}
  #          user_password PUT    /users/password(.:format)         {controller:"devise/passwords", action:"update"}
  #                        POST   /users/password(.:format)         {controller:"devise/passwords", action:"create"}
  #
  #  # Confirmation routes for Confirmable, if User model has :confirmable configured
  #  new_user_confirmation GET    /users/confirmation/new(.:format) {controller:"devise/confirmations", action:"new"}
  #      user_confirmation GET    /users/confirmation(.:format)     {controller:"devise/confirmations", action:"show"}
  #                        POST   /users/confirmation(.:format)     {controller:"devise/confirmations", action:"create"}
  #
  # ==== Routes integration
  #
  # +devise_for+ is meant to play nicely with other routes methods. For example,
  # by calling +devise_for+ inside a namespace, it automatically nests your devise
  # controllers:
  #
  #     namespace :publisher do
  #       devise_for :account
  #     end
  #
  # The snippet above will use publisher/sessions controller instead of devise/sessions
  # controller. You can revert this change or configure it directly by passing the :module
  # option described below to +devise_for+.
  #
  # Also note that when you use a namespace it will affect all the helpers and methods
  # for controllers and views. For example, using the above setup you'll end with
  # following methods: current_publisher_account, authenticate_publisher_account!,
  # publisher_account_signed_in, etc.
  #
  # The only aspect not affect by the router configuration is the model name. The
  # model name can be explicitly set via the :class_name option.
  #
  # ==== Options
  #
  # You can configure your routes with some options:
  #
  #  * class_name: set up a different class to be looked up by devise, if it cannot be
  #    properly found by the route name.
  #
  #      devise_for :users, class_name: 'Account'
  #
  #  * path: allows you to set up path name that will be used, as rails routes does.
  #    The following route configuration would set up your route as /accounts instead of /users:
  #
  #      devise_for :users, path: 'accounts'
  #
  #  * singular: set up the singular name for the given resource. This is used as the helper methods
  #    names in controller ("authenticate_#{singular}!", "#{singular}_signed_in?", "current_#{singular}"
  #    and "#{singular}_session"), as the scope name in routes and as the scope given to warden.
  #
  #      devise_for :admins, singular: :manager
  #
  #      devise_scope :manager do
  #        ...
  #      end
  #
  #      class ManagerController < ApplicationController
  #        before_action authenticate_manager!
  #
  #        def show
  #          @manager = current_manager
  #          ...
  #        end
  #      end
  #
  #  * path_names: configure different path names to overwrite defaults :sign_in, :sign_out, :sign_up,
  #    :password, :confirmation, :unlock.
  #
  #      devise_for :users, path_names: {
  #        sign_in: 'login', sign_out: 'logout',
  #        password: 'secret', confirmation: 'verification',
  #        registration: 'register', edit: 'edit/profile'
  #      }
  #
  #  * controllers: the controller which should be used. All routes by default points to Devise controllers.
  #    However, if you want them to point to custom controller, you should do:
  #
  #      devise_for :users, controllers: { sessions: "users/sessions" }
  #
  #  * failure_app: a rack app which is invoked whenever there is a failure. Strings representing a given
  #    are also allowed as parameter.
  #
  #  * sign_out_via: the HTTP method(s) accepted for the :sign_out action (default: :delete),
  #    if you wish to restrict this to accept only :post or :delete requests you should do:
  #
  #      devise_for :users, sign_out_via: [:get, :post]
  #
  #    You need to make sure that your sign_out controls trigger a request with a matching HTTP method.
  #
  #  * module: the namespace to find controllers (default: "devise", thus
  #    accessing devise/sessions, devise/registrations, and so on). If you want
  #    to namespace all at once, use module:
  #
  #      devise_for :users, module: "users"
  #
  #  * skip: tell which controller you want to skip routes from being created.
  #    It accepts :all as an option, meaning it will not generate any route at all:
  #
  #      devise_for :users, skip: :sessions
  #
  #  * only: the opposite of :skip, tell which controllers only to generate routes to:
  #
  #      devise_for :users, only: :sessions
  #
  #  * skip_helpers: skip generating Devise url helpers like new_session_path(@user).
  #    This is useful to avoid conflicts with previous routes and is false by default.
  #    It accepts true as option, meaning it will skip all the helpers for the controllers
  #    given in :skip but it also accepts specific helpers to be skipped:
  #
  #      devise_for :users, skip: [:registrations, :confirmations], skip_helpers: true
  #      devise_for :users, skip_helpers: [:registrations, :confirmations]
  #
  #  * format: include "(.:format)" in the generated routes? true by default, set to false to disable:
  #
  #      devise_for :users, format: false
  #
  #  * constraints: works the same as Rails' constraints
  #
  #  * defaults: works the same as Rails' defaults
  #
  #  * router_name: allows application level router name to be overwritten for the current scope
  #
  # ==== Scoping
  #
  # Following Rails 3 routes DSL, you can nest devise_for calls inside a scope:
  #
  #   scope "/my" do
  #     devise_for :users
  #   end
  #
  # However, since Devise uses the request path to retrieve the current user,
  # this has one caveat: If you are using a dynamic segment, like so ...
  #
  #   scope ":locale" do
  #     devise_for :users
  #   end
  #
  # you are required to configure default_url_options in your
  # ApplicationController class, so Devise can pick it:
  #
  #   class ApplicationController < ActionController::Base
  #     def self.default_url_options
  #       { locale: I18n.locale }
  #     end
  #   end
  #
  # ==== Adding custom actions to override controllers
  #
  # You can pass a block to devise_for that will add any routes defined in the block to Devise's
  # list of known actions.  This is important if you add a custom action to a controller that
  # overrides an out of the box Devise controller.
  # For example:
  #
  #    class RegistrationsController < Devise::RegistrationsController
  #      def update
  #         # do something different here
  #      end
  #
  #      def deactivate
  #        # not a standard action
  #        # deactivate code here
  #      end
  #    end
  #
  # In order to get Devise to recognize the deactivate action, your devise_scope entry should look like this:
  #
  #     devise_scope :owner do
  #       post "deactivate", to: "registrations#deactivate", as: "deactivate_registration"
  #     end
  def devise_for(*resources); end

  # Sets the devise scope to be used in the controller. If you have custom routes,
  # you are required to call this method (also aliased as :as) in order to specify
  # to which controller it is targeted.
  #
  #   as :user do
  #     get "sign_in", to: "devise/sessions#new"
  #   end
  #
  # Notice you cannot have two scopes mapping to the same URL. And remember, if
  # you try to access a devise controller without specifying a scope, it will
  # raise ActionNotFound error.
  #
  # Also be aware of that 'devise_scope' and 'as' use the singular form of the
  # noun where other devise route commands expect the plural form. This would be a
  # good and working example.
  #
  #  devise_scope :user do
  #    get "/some/route" => "some_devise_controller"
  #  end
  #  devise_for :users
  #
  # Notice and be aware of the differences above between :user and :users
  def devise_scope(scope); end

  # Allow you to route based on whether a scope is *not* authenticated.
  # You can optionally specify which scope.
  #
  #   unauthenticated do
  #     as :user do
  #       root to: 'devise/registrations#new'
  #     end
  #   end
  #
  #   root to: 'dashboard#show'
  def unauthenticated(scope = T.unsafe(nil)); end

  protected

  def constraints_for(method_to_apply, scope = T.unsafe(nil), block = T.unsafe(nil)); end
  def devise_confirmation(mapping, controllers); end
  def devise_omniauth_callback(mapping, controllers); end
  def devise_password(mapping, controllers); end
  def devise_registration(mapping, controllers); end
  def devise_session(mapping, controllers); end
  def devise_unlock(mapping, controllers); end
  def raise_no_devise_method_error!(klass); end
  def raise_no_secret_key; end
  def set_omniauth_path_prefix!(path_prefix); end
  def with_devise_exclusive_scope(new_path, new_as, options); end

  class << self
    def normalize_name(name); end
    def normalize_path(path); end
  end
end

class ActionDispatch::Routing::RouteSet
  include ::Devise::RouteSet

  def initialize(config = T.unsafe(nil)); end

  def add_polymorphic_mapping(klass, options, &block); end
  def add_route(mapping, name); end
  def add_url_helper(name, options, &block); end
  def api_only?; end
  def append(&block); end
  def call(env); end
  def clear!; end
  def default_scope; end
  def default_scope=(_arg0); end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def define_mounted_helper(name, script_namer = T.unsafe(nil)); end
  def disable_clear_and_finalize; end
  def disable_clear_and_finalize=(_arg0); end
  def draw(&block); end
  def draw_paths; end
  def draw_paths=(_arg0); end
  def eager_load!; end
  def empty?; end
  def env_key; end
  def extra_keys(options, recall = T.unsafe(nil)); end
  def finalize!; end
  def find_relative_url_root(options); end
  def find_script_name(options); end
  def formatter; end
  def formatter=(_arg0); end
  def generate_extras(options, recall = T.unsafe(nil)); end
  def generate_url_helpers(supports_path); end
  def inspect; end
  def mounted_helpers; end
  def named_routes; end
  def named_routes=(_arg0); end
  def optimize_routes_generation?; end
  def path_for(options, route_name = T.unsafe(nil), reserved = T.unsafe(nil)); end
  def polymorphic_mappings; end
  def prepend(&block); end
  def recognize_path(path, environment = T.unsafe(nil)); end
  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end
  def relative_url_root; end
  def request_class; end
  def resources_path_names; end
  def resources_path_names=(_arg0); end
  def router; end
  def router=(_arg0); end
  def routes; end
  def set; end
  def set=(_arg0); end
  def url_for(options, route_name = T.unsafe(nil), url_strategy = T.unsafe(nil), method_name = T.unsafe(nil), reserved = T.unsafe(nil)); end
  def url_helpers(supports_path = T.unsafe(nil)); end

  private

  def eval_block(block); end
  def generate(route_name, options, recall = T.unsafe(nil), method_name = T.unsafe(nil)); end
  def make_request(env); end

  class << self
    def default_resources_path_names; end
    def new_with_config(config); end
  end
end

class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  extend ::Devise::Models
end

module Devise
  def allow_unconfirmed_access_for; end
  def allow_unconfirmed_access_for=(val); end
  def authentication_keys; end
  def authentication_keys=(val); end
  def case_insensitive_keys; end
  def case_insensitive_keys=(val); end
  def clean_up_csrf_token_on_authentication; end
  def clean_up_csrf_token_on_authentication=(val); end
  def confirm_within; end
  def confirm_within=(val); end
  def confirmation_keys; end
  def confirmation_keys=(val); end
  def default_scope; end
  def default_scope=(val); end
  def email_regexp; end
  def email_regexp=(val); end
  def expire_all_remember_me_on_sign_out; end
  def expire_all_remember_me_on_sign_out=(val); end
  def extend_remember_period; end
  def extend_remember_period=(val); end
  def helpers; end
  def http_authenticatable; end
  def http_authenticatable=(val); end
  def http_authenticatable_on_xhr; end
  def http_authenticatable_on_xhr=(val); end
  def http_authentication_key; end
  def http_authentication_key=(val); end
  def http_authentication_realm; end
  def http_authentication_realm=(val); end
  def last_attempt_warning; end
  def last_attempt_warning=(val); end
  def lock_strategy; end
  def lock_strategy=(val); end
  def mailer_sender; end
  def mailer_sender=(val); end
  def mappings; end
  def maximum_attempts; end
  def maximum_attempts=(val); end
  def navigational_formats; end
  def navigational_formats=(val); end
  def omniauth_configs; end
  def omniauth_path_prefix; end
  def omniauth_path_prefix=(val); end
  def params_authenticatable; end
  def params_authenticatable=(val); end
  def paranoid; end
  def paranoid=(val); end
  def parent_controller; end
  def parent_controller=(val); end
  def parent_mailer; end
  def parent_mailer=(val); end
  def password_length; end
  def password_length=(val); end
  def pepper; end
  def pepper=(val); end
  def reconfirmable; end
  def reconfirmable=(val); end
  def reload_routes; end
  def reload_routes=(val); end
  def remember_for; end
  def remember_for=(val); end
  def rememberable_options; end
  def rememberable_options=(val); end
  def request_keys; end
  def request_keys=(val); end
  def reset_password_keys; end
  def reset_password_keys=(val); end
  def reset_password_within; end
  def reset_password_within=(val); end
  def responder; end
  def responder=(val); end
  def router_name; end
  def router_name=(val); end
  def scoped_views; end
  def scoped_views=(val); end
  def secret_key; end
  def secret_key=(val); end
  def send_email_changed_notification; end
  def send_email_changed_notification=(val); end
  def send_password_change_notification; end
  def send_password_change_notification=(val); end
  def sign_in_after_change_password; end
  def sign_in_after_change_password=(val); end
  def sign_in_after_reset_password; end
  def sign_in_after_reset_password=(val); end
  def sign_out_all_scopes; end
  def sign_out_all_scopes=(val); end
  def sign_out_via; end
  def sign_out_via=(val); end
  def skip_session_storage; end
  def skip_session_storage=(val); end
  def stretches; end
  def stretches=(val); end
  def strip_whitespace_keys; end
  def strip_whitespace_keys=(val); end
  def timeout_in; end
  def timeout_in=(val); end
  def token_generator; end
  def token_generator=(val); end
  def unlock_in; end
  def unlock_in=(val); end
  def unlock_keys; end
  def unlock_keys=(val); end
  def unlock_strategy; end
  def unlock_strategy=(val); end
  def warden_config; end
  def warden_config=(val); end

  class << self
    # @return [Boolean]
    def activerecord51?; end

    # Small method that adds a mapping to Devise.
    def add_mapping(resource, options); end

    # Register available devise modules. For the standard modules that Devise provides, this method is
    # called from lib/devise/modules.rb. Third-party modules need to be added explicitly using this method.
    #
    # Note that adding a module using this method does not cause it to be used in the authentication
    # process. That requires that the module be listed in the arguments passed to the 'devise' method
    # in the model class definition.
    #
    # == Options:
    #
    #   +model+      - String representing the load path to a custom *model* for this module (to autoload.)
    #   +controller+ - Symbol representing the name of an existing or custom *controller* for this module.
    #   +route+      - Symbol representing the named *route* helper for this module.
    #   +strategy+   - Symbol representing if this module got a custom *strategy*.
    #   +insert_at+  - Integer representing the order in which this module's model will be included
    #
    # All values, except :model, accept also a boolean and will have the same name as the given module
    # name.
    #
    # == Examples:
    #
    #   Devise.add_module(:party_module)
    #   Devise.add_module(:party_module, strategy: true, controller: :sessions)
    #   Devise.add_module(:party_module, model: 'party_module/model')
    #   Devise.add_module(:party_module, insert_at: 0)
    def add_module(module_name, options = T.unsafe(nil)); end

    def allow_unconfirmed_access_for; end
    def allow_unconfirmed_access_for=(val); end
    def authentication_keys; end
    def authentication_keys=(val); end
    def available_router_name; end
    def case_insensitive_keys; end
    def case_insensitive_keys=(val); end
    def clean_up_csrf_token_on_authentication; end
    def clean_up_csrf_token_on_authentication=(val); end

    # A method used internally to complete the setup of warden manager after routes are loaded.
    # See lib/devise/rails/routes.rb - ActionDispatch::Routing::RouteSet#finalize_with_devise!
    def configure_warden!; end

    def confirm_within; end
    def confirm_within=(val); end
    def confirmation_keys; end
    def confirmation_keys=(val); end
    def default_scope; end
    def default_scope=(val); end
    def email_regexp; end
    def email_regexp=(val); end
    def expire_all_remember_me_on_sign_out; end
    def expire_all_remember_me_on_sign_out=(val); end
    def extend_remember_period; end
    def extend_remember_period=(val); end

    # Generate a friendly string randomly to be used as token.
    # By default, length is 20 characters.
    def friendly_token(length = T.unsafe(nil)); end

    def helpers; end
    def http_authenticatable; end
    def http_authenticatable=(val); end
    def http_authenticatable_on_xhr; end
    def http_authenticatable_on_xhr=(val); end
    def http_authentication_key; end
    def http_authentication_key=(val); end
    def http_authentication_realm; end
    def http_authentication_realm=(val); end

    # Include helpers in the given scope to AC and AV.
    def include_helpers(scope); end

    def last_attempt_warning; end
    def last_attempt_warning=(val); end
    def lock_strategy; end
    def lock_strategy=(val); end

    # Get the mailer class from the mailer reference object.
    def mailer; end

    # Set the mailer reference object to access the mailer.
    def mailer=(class_name); end

    def mailer_sender; end
    def mailer_sender=(val); end
    def mappings; end
    def maximum_attempts; end
    def maximum_attempts=(val); end
    def navigational_formats; end
    def navigational_formats=(val); end

    # Specify an OmniAuth provider.
    #
    #   config.omniauth :github, APP_ID, APP_SECRET
    def omniauth(provider, *args); end

    def omniauth_configs; end
    def omniauth_path_prefix; end
    def omniauth_path_prefix=(val); end
    def omniauth_providers; end
    def params_authenticatable; end
    def params_authenticatable=(val); end
    def paranoid; end
    def paranoid=(val); end
    def parent_controller; end
    def parent_controller=(val); end
    def parent_mailer; end
    def parent_mailer=(val); end
    def password_length; end
    def password_length=(val); end
    def pepper; end
    def pepper=(val); end
    def reconfirmable; end
    def reconfirmable=(val); end
    def ref(arg); end

    # Regenerates url helpers considering Devise.mapping
    def regenerate_helpers!; end

    def reload_routes; end
    def reload_routes=(val); end
    def remember_for; end
    def remember_for=(val); end
    def rememberable_options; end
    def rememberable_options=(val); end
    def request_keys; end
    def request_keys=(val); end
    def reset_password_keys; end
    def reset_password_keys=(val); end
    def reset_password_within; end
    def reset_password_within=(val); end
    def responder; end
    def responder=(val); end
    def router_name; end
    def router_name=(val); end
    def scoped_views; end
    def scoped_views=(val); end
    def secret_key; end
    def secret_key=(val); end

    # constant-time comparison algorithm to prevent timing attacks
    def secure_compare(a, b); end

    def send_email_changed_notification; end
    def send_email_changed_notification=(val); end
    def send_password_change_notification; end
    def send_password_change_notification=(val); end

    # Default way to set up Devise. Run rails generate devise_install to create
    # a fresh initializer with all configuration values.
    #
    # @yield [_self]
    # @yieldparam _self [Devise] the object that the method was called on
    def setup; end

    def sign_in_after_change_password; end
    def sign_in_after_change_password=(val); end
    def sign_in_after_reset_password; end
    def sign_in_after_reset_password=(val); end
    def sign_out_all_scopes; end
    def sign_out_all_scopes=(val); end
    def sign_out_via; end
    def sign_out_via=(val); end
    def skip_session_storage; end
    def skip_session_storage=(val); end
    def stretches; end
    def stretches=(val); end
    def strip_whitespace_keys; end
    def strip_whitespace_keys=(val); end
    def timeout_in; end
    def timeout_in=(val); end
    def token_generator; end
    def token_generator=(val); end
    def unlock_in; end
    def unlock_in=(val); end
    def unlock_keys; end
    def unlock_keys=(val); end
    def unlock_strategy; end
    def unlock_strategy=(val); end

    # Sets warden configuration using a block that will be invoked on warden
    # initialization.
    #
    #  Devise.setup do |config|
    #    config.allow_unconfirmed_access_for = 2.days
    #
    #    config.warden do |manager|
    #      # Configure warden to use other strategies, like oauth.
    #      manager.oauth(:twitter)
    #    end
    #  end
    def warden(&block); end

    def warden_config; end
    def warden_config=(val); end
  end
end

# Constants which holds devise configuration for extensions. Those should
# not be modified by the "end user" (this is why they are constants).
Devise::ALL = T.let(T.unsafe(nil), Array)

Devise::CONTROLLERS = T.let(T.unsafe(nil), Hash)
module Devise::Controllers; end

# Those helpers are convenience methods added to ApplicationController.
module Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Controllers::Helpers::ClassMethods

  # The default url to be used after signing in. This is used by all Devise
  # controllers and you can overwrite it in your ApplicationController to
  # provide a custom hook for a custom resource.
  #
  # By default, it first tries to find a valid resource_return_to key in the
  # session, then it fallbacks to resource_root_path, otherwise it uses the
  # root path. For a user scope, you can define the default url in
  # the following way:
  #
  #   get '/users' => 'users#index', as: :user_root # creates user_root_path
  #
  #   namespace :user do
  #     root 'users#index' # creates user_root_path
  #   end
  #
  # If the resource root path is not defined, root_path is used. However,
  # if this default is not enough, you can customize it, for example:
  #
  #   def after_sign_in_path_for(resource)
  #     stored_location_for(resource) ||
  #       if resource.is_a?(User) && resource.can_publish?
  #         publisher_url
  #       else
  #         super
  #       end
  #   end
  def after_sign_in_path_for(resource_or_scope); end

  # Method used by sessions controller to sign out a user. You can overwrite
  # it in your ApplicationController to provide a custom hook for a custom
  # scope. Notice that differently from +after_sign_in_path_for+ this method
  # receives a symbol with the scope, and not the resource.
  #
  # By default it is the root_path.
  def after_sign_out_path_for(resource_or_scope); end

  # Tell warden that params authentication is allowed for that specific page.
  def allow_params_authentication!; end

  # Return true if it's a devise_controller. false to all controllers unless
  # the controllers defined inside devise. Useful if you want to apply a before
  # filter to all controllers, except the ones in devise:
  #
  #   before_action :my_filter, unless: :devise_controller?
  #
  # @return [Boolean]
  def devise_controller?; end

  # Set up a param sanitizer to filter parameters using strong_parameters. See
  # lib/devise/parameter_sanitizer.rb for more info. Override this
  # method in your application controller to use your own parameter sanitizer.
  def devise_parameter_sanitizer; end

  # Overwrite Rails' handle unverified request to sign out all scopes,
  # clear run strategies and remove cached variables.
  def handle_unverified_request; end

  # Check if flash messages should be emitted. Default is to do it on
  # navigational formats
  #
  # @return [Boolean]
  def is_flashing_format?; end

  # @return [Boolean]
  def is_navigational_format?; end

  def request_format; end

  # Sign in a user and tries to redirect first to the stored location and
  # then to the url specified by after_sign_in_path_for. It accepts the same
  # parameters as the sign_in method.
  def sign_in_and_redirect(resource_or_scope, *args); end

  # Sign out a user and tries to redirect to the url specified by
  # after_sign_out_path_for.
  def sign_out_and_redirect(resource_or_scope); end

  # The scope root url to be used when they're signed in. By default, it first
  # tries to find a resource_root_path, otherwise it uses the root_path.
  def signed_in_root_path(resource_or_scope); end

  # The main accessor for the warden proxy instance
  def warden; end

  private

  def expire_data_after_sign_out!; end

  class << self
    # Define authentication filters and accessor helpers based on mappings.
    # These filters should be used inside the controllers as before_actions,
    # so you can control the scope of the user who should be signed in to
    # access that specific controller/action.
    # Example:
    #
    #   Roles:
    #     User
    #     Admin
    #
    #   Generated methods:
    #     authenticate_user!  # Signs user in or redirect
    #     authenticate_admin! # Signs admin in or redirect
    #     user_signed_in?     # Checks whether there is a user signed in or not
    #     admin_signed_in?    # Checks whether there is an admin signed in or not
    #     current_user        # Current signed in user
    #     current_admin       # Current signed in admin
    #     user_session        # Session data available only to the user scope
    #     admin_session       # Session data available only to the admin scope
    #
    #   Use:
    #     before_action :authenticate_user!  # Tell devise to use :user map
    #     before_action :authenticate_admin! # Tell devise to use :admin map
    def define_helpers(mapping); end
  end
end

module Devise::Controllers::Helpers::ClassMethods
  # Define authentication filters and accessor helpers for a group of mappings.
  # These methods are useful when you are working with multiple mappings that
  # share some functionality. They are pretty much the same as the ones
  # defined for normal mappings.
  #
  # Example:
  #
  #   inside BlogsController (or any other controller, it doesn't matter which):
  #     devise_group :blogger, contains: [:user, :admin]
  #
  #   Generated methods:
  #     authenticate_blogger!  # Redirects unless user or admin are signed in
  #     blogger_signed_in?     # Checks whether there is either a user or an admin signed in
  #     current_blogger        # Currently signed in user or admin
  #     current_bloggers       # Currently signed in user and admin
  #
  #   Use:
  #     before_action :authenticate_blogger!              # Redirects unless either a user or an admin are authenticated
  #     before_action ->{ authenticate_blogger! :admin }  # Redirects to the admin login page
  #     current_blogger :user                             # Preferably returns a User if one is signed in
  def devise_group(group_name, opts = T.unsafe(nil)); end

  def log_process_action(payload); end
end

# A module that may be optionally included in a controller in order
# to provide remember me behavior. Useful when signing in is done
# through a callback, like in OmniAuth.
module Devise::Controllers::Rememberable
  # Forgets the given resource by deleting a cookie
  def forget_me(resource); end

  # Remembers the given resource by setting up a cookie
  def remember_me(resource); end

  # @return [Boolean]
  def remember_me_is_active?(resource); end

  protected

  def forget_cookie_values(resource); end
  def remember_cookie_values(resource); end
  def remember_key(resource, scope); end

  class << self
    # Return default cookie values retrieved from session options.
    def cookie_values; end
  end
end

# Custom Responder to configure default statuses that only apply to Devise,
# and allow to integrate more easily with Hotwire/Turbo.
class Devise::Controllers::Responder < ::ActionController::Responder
  class << self
    # TODO: remove this support for older Rails versions, which aren't supported by Turbo
    # and/or responders. It won't allow configuring a custom response, but it allows Devise
    # to use these methods and defaults across the implementation more easily.
    def error_status; end

    def redirect_status; end
  end
end

module Devise::Controllers::ScopedViews
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Controllers::ScopedViews::ClassMethods
end

module Devise::Controllers::ScopedViews::ClassMethods
  def scoped_views=(value); end

  # @return [Boolean]
  def scoped_views?; end
end

# Provide sign in and sign out functionality.
# Included by default in all controllers.
module Devise::Controllers::SignInOut
  # Sign in a user bypassing the warden callbacks and stores the user
  # straight in session. This option is useful in cases the user is already
  # signed in, but we want to refresh the credentials in session.
  #
  # Examples:
  #
  #   bypass_sign_in @user, scope: :user
  #   bypass_sign_in @user
  def bypass_sign_in(resource, scope: T.unsafe(nil)); end

  # Sign in a user that already was authenticated. This helper is useful for logging
  # users in after sign up. All options given to sign_in is passed forward
  # to the set_user method in warden.
  # If you are using a custom warden strategy and the timeoutable module, you have to
  # set `env["devise.skip_timeout"] = true` in the request to use this method, like we do
  # in the sessions controller: https://github.com/heartcombo/devise/blob/main/app/controllers/devise/sessions_controller.rb#L7
  #
  # Examples:
  #
  #   sign_in :user, @user                      # sign_in(scope, resource)
  #   sign_in @user                             # sign_in(resource)
  #   sign_in @user, event: :authentication     # sign_in(resource, options)
  #   sign_in @user, store: false               # sign_in(resource, options)
  def sign_in(resource_or_scope, *args); end

  # Sign out a given user or scope. This helper is useful for signing out a user
  # after deleting accounts. Returns true if there was a logout and false if there
  # is no user logged in on the referred scope
  #
  # Examples:
  #
  #   sign_out :user     # sign_out(scope)
  #   sign_out @user     # sign_out(resource)
  def sign_out(resource_or_scope = T.unsafe(nil)); end

  # Sign out all active users or scopes. This helper is useful for signing out all roles
  # in one click. This signs out ALL scopes in warden. Returns true if there was at least one logout
  # and false if there was no user logged in on all scopes.
  def sign_out_all_scopes(lock = T.unsafe(nil)); end

  # Return true if the given scope is signed in session. If no scope given, return
  # true if any scope is signed in. This will run authentication hooks, which may
  # cause exceptions to be thrown from this method; if you simply want to check
  # if a scope has already previously been authenticated without running
  # authentication hooks, you can directly call `warden.authenticated?(scope: scope)`
  #
  # @return [Boolean]
  def signed_in?(scope = T.unsafe(nil)); end

  private

  def expire_data_after_sign_in!; end
  def expire_data_after_sign_out!; end
end

# Provide the ability to store a location.
# Used to redirect back to a desired path after sign in.
# Included by default in all controllers.
module Devise::Controllers::StoreLocation
  # Stores the provided location to redirect the user after signing in.
  # Useful in combination with the `stored_location_for` helper.
  #
  # Example:
  #
  #   store_location_for(:user, dashboard_path)
  #   redirect_to user_facebook_omniauth_authorize_path
  def store_location_for(resource_or_scope, location); end

  # Returns and delete (if it's navigational format) the url stored in the session for
  # the given scope. Useful for giving redirect backs after sign up:
  #
  # Example:
  #
  #   redirect_to stored_location_for(:user) || root_path
  def stored_location_for(resource_or_scope); end

  private

  def add_fragment_back_to_path(uri, path); end
  def extract_path_from_location(location); end
  def parse_uri(location); end
  def remove_domain_from_uri(uri); end
  def stored_location_key_for(resource_or_scope); end
end

# Create url helpers to be used with resource/scope configuration. Acts as
# proxies to the generated routes created by devise.
# Resource param can be a string or symbol, a class, or an instance object.
# Example using a :user resource:
#
#   new_session_path(:user)      => new_user_session_path
#   session_path(:user)          => user_session_path
#   destroy_session_path(:user)  => destroy_user_session_path
#
#   new_password_path(:user)     => new_user_password_path
#   password_path(:user)         => user_password_path
#   edit_password_path(:user)    => edit_user_password_path
#
#   new_confirmation_path(:user) => new_user_confirmation_path
#   confirmation_path(:user)     => user_confirmation_path
#
# Those helpers are included by default to ActionController::Base.
#
# In case you want to add such helpers to another class, you can do
# that as long as this new class includes both url_helpers and
# mounted_helpers. Example:
#
#     include Rails.application.routes.url_helpers
#     include Rails.application.routes.mounted_helpers
module Devise::Controllers::UrlHelpers
  def cancel_registration_path(resource_or_scope, *args); end
  def cancel_registration_url(resource_or_scope, *args); end
  def confirmation_path(resource_or_scope, *args); end
  def confirmation_url(resource_or_scope, *args); end
  def destroy_session_path(resource_or_scope, *args); end
  def destroy_session_url(resource_or_scope, *args); end
  def edit_password_path(resource_or_scope, *args); end
  def edit_password_url(resource_or_scope, *args); end
  def edit_registration_path(resource_or_scope, *args); end
  def edit_registration_url(resource_or_scope, *args); end
  def new_confirmation_path(resource_or_scope, *args); end
  def new_confirmation_url(resource_or_scope, *args); end
  def new_password_path(resource_or_scope, *args); end
  def new_password_url(resource_or_scope, *args); end
  def new_registration_path(resource_or_scope, *args); end
  def new_registration_url(resource_or_scope, *args); end
  def new_session_path(resource_or_scope, *args); end
  def new_session_url(resource_or_scope, *args); end
  def new_unlock_path(resource_or_scope, *args); end
  def new_unlock_url(resource_or_scope, *args); end
  def password_path(resource_or_scope, *args); end
  def password_url(resource_or_scope, *args); end
  def registration_path(resource_or_scope, *args); end
  def registration_url(resource_or_scope, *args); end
  def session_path(resource_or_scope, *args); end
  def session_url(resource_or_scope, *args); end
  def unlock_path(resource_or_scope, *args); end
  def unlock_url(resource_or_scope, *args); end

  private

  def _devise_route_context; end

  class << self
    def generate_helpers!(routes = T.unsafe(nil)); end
    def remove_helpers!; end
  end
end

# Checks the scope in the given environment and returns the associated failure app.
class Devise::Delegator
  def call(env); end
  def failure_app(env); end
end

Devise::DeprecatedConstantAccessor = ActiveSupport::Deprecation::DeprecatedConstantAccessor

module Devise::Encryptor
  class << self
    def compare(klass, hashed_password, password); end
    def digest(klass, password); end
  end
end

class Devise::Engine < ::Rails::Engine
  class << self
    def __callbacks; end
  end
end

# Failure application that will be called every time :warden is thrown from
# any strategy or hook. It is responsible for redirecting the user to the sign
# in page based on current scope and mapping. If no scope is given, it
# redirects to the default_url.
class Devise::FailureApp < ::ActionController::Metal
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Devise::Controllers::StoreLocation
  extend ::AbstractController::UrlFor::ClassMethods

  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def flash(*_arg0, **_arg1, &_arg2); end
  def http_auth; end
  def logger; end
  def logger=(value); end
  def raise_on_open_redirects; end
  def raise_on_open_redirects=(val); end
  def recall; end
  def redirect; end
  def respond; end

  protected

  def attempted_path; end

  # Choose whether we should respond in an HTTP authentication fashion,
  # including 401 and optional headers.
  #
  # This method allows the user to explicitly disable HTTP authentication
  # on AJAX requests in case they want to redirect on failures instead of
  # handling the errors on their own. This is useful in case your AJAX API
  # is the same as your public API and uses a format like JSON (so you
  # cannot mark JSON as a navigational format).
  #
  # @return [Boolean]
  def http_auth?; end

  def http_auth_body; end

  # It doesn't make sense to send authenticate headers in AJAX requests
  # or if the user disabled them.
  #
  # @return [Boolean]
  def http_auth_header?; end

  def i18n_message(default = T.unsafe(nil)); end
  def i18n_options(options); end

  # Check if flash messages should be emitted. Default is to do it on
  # navigational formats
  #
  # @return [Boolean]
  def is_flashing_format?; end

  # @return [Boolean]
  def is_navigational_format?; end

  def recall_app(app); end
  def redirect_url; end
  def relative_url_root; end

  # @return [Boolean]
  def relative_url_root?; end

  def request_format; end
  def route(scope); end
  def scope; end
  def scope_class; end
  def scope_url; end

  # @return [Boolean]
  def skip_format?; end

  # Stores requested URI to redirect the user after signing in. We can't use
  # the scoped session provided by warden here, since the user is not
  # authenticated yet, but we still need to store the URI based on scope, so
  # different scopes would never use the same URI to redirect.
  def store_location!; end

  def warden; end
  def warden_message; end
  def warden_options; end

  private

  # @return [Boolean]
  def rails_51_and_up?; end

  # @return [Boolean]
  def root_path_defined?(context); end

  class << self
    def _routes; end
    def call(env); end

    # Try retrieving the URL options from the parent controller (usually
    # ApplicationController). Instance methods are not supported at the moment,
    # so only the class-level attribute is used.
    def default_url_options(*args); end

    def default_url_options=(value); end
    def default_url_options?; end
    def logger; end
    def logger=(value); end
    def middleware_stack; end
    def raise_on_open_redirects; end
    def raise_on_open_redirects=(val); end
  end
end

class Devise::Getter
  # @return [Getter] a new instance of Getter
  def initialize(name); end

  def get; end
end

module Devise::Hooks; end

# A small warden proxy so we can remember, forget and
# sign out users from hooks.
class Devise::Hooks::Proxy
  include ::Devise::Controllers::Rememberable
  include ::Devise::Controllers::SignInOut

  # @return [Proxy] a new instance of Proxy
  def initialize(warden); end

  def cookies(*_arg0, **_arg1, &_arg2); end
  def request(*_arg0, **_arg1, &_arg2); end
  def session; end

  # Returns the value of attribute warden.
  def warden; end
end

class Devise::Mailer < ::ActionMailer::Base
  include ::Devise::Mailers::Helpers
  include ::Devise::Controllers::ScopedViews
  extend ::Devise::Controllers::ScopedViews::ClassMethods

  def confirmation_instructions(record, token, opts = T.unsafe(nil)); end
  def email_changed(record, opts = T.unsafe(nil)); end
  def password_change(record, opts = T.unsafe(nil)); end
  def reset_password_instructions(record, token, opts = T.unsafe(nil)); end
  def unlock_instructions(record, token, opts = T.unsafe(nil)); end

  private

  def _layout(lookup_context, formats); end
end

module Devise::Mailers; end

module Devise::Mailers::Helpers
  extend ::ActiveSupport::Concern
  include ::Devise::Controllers::ScopedViews

  mixes_in_class_methods ::Devise::Controllers::ScopedViews::ClassMethods

  protected

  # Configure default email options
  def devise_mail(record, action, opts = T.unsafe(nil), &block); end

  def devise_mapping; end
  def headers_for(action, opts); end
  def initialize_from_record(record); end
  def mailer_from(mapping); end
  def mailer_reply_to(mapping); end
  def mailer_sender(mapping, sender = T.unsafe(nil)); end

  # Returns the value of attribute resource.
  def resource; end

  # Returns the value of attribute scope_name.
  def scope_name; end

  # Set up a subject doing an I18n lookup. At first, it attempts to set a subject
  # based on the current mapping:
  #
  #   en:
  #     devise:
  #       mailer:
  #         confirmation_instructions:
  #           user_subject: '...'
  #
  # If one does not exist, it fallbacks to ActionMailer default:
  #
  #   en:
  #     devise:
  #       mailer:
  #         confirmation_instructions:
  #           subject: '...'
  def subject_for(key); end

  def template_paths; end
end

# Responsible for handling devise mappings and routes configuration. Each
# resource configured by devise_for in routes is actually creating a mapping
# object. You can refer to devise_for in routes for usage options.
#
# The required value in devise_for is actually not used internally, but it's
# inflected to find all other values.
#
#   map.devise_for :users
#   mapping = Devise.mappings[:user]
#
#   mapping.name #=> :user
#   # is the scope used in controllers and warden, given in the route as :singular.
#
#   mapping.as   #=> "users"
#   # how the mapping should be search in the path, given in the route as :as.
#
#   mapping.to   #=> User
#   # is the class to be loaded from routes, given in the route as :class_name.
#
#   mapping.modules  #=> [:authenticatable]
#   # is the modules included in the class
class Devise::Mapping
  # @return [Mapping] a new instance of Mapping
  def initialize(name, options); end

  # @return [Boolean]
  def authenticatable?; end

  def class_name; end
  def confirmable?; end
  def controllers; end
  def database_authenticatable?; end
  def failure_app; end
  def format; end
  def fullpath; end
  def lockable?; end

  # Return modules for the mapping.
  def modules; end

  def name; end
  def no_input_strategies; end
  def omniauthable?; end
  def path; end
  def path_names; end
  def recoverable?; end
  def registerable?; end
  def rememberable?; end
  def router_name; end
  def routes; end
  def scoped_path; end
  def sign_out_via; end
  def singular; end
  def strategies; end
  def timeoutable?; end

  # Gives the class the mapping points to.
  def to; end

  def trackable?; end
  def used_helpers; end
  def used_routes; end
  def validatable?; end

  private

  def default_constraints(options); end
  def default_controllers(options); end
  def default_defaults(options); end
  def default_failure_app(options); end
  def default_path_names(options); end
  def default_used_helpers(options); end
  def default_used_route(options); end

  class << self
    # Create magic predicates for verifying what module is activated by this map.
    # Example:
    #
    #   def confirmable?
    #     self.modules.include?(:confirmable)
    #   end
    def add_module(m); end

    def find_by_path!(path, path_type = T.unsafe(nil)); end

    # Receives an object and find a scope for it. If a scope cannot be found,
    # raises an error. If a symbol is given, it's considered to be the scope.
    def find_scope!(obj); end
  end
end

class Devise::MissingWarden < ::StandardError
  # @return [MissingWarden] a new instance of MissingWarden
  def initialize; end
end

module Devise::Models
  # Include the chosen devise modules in your model:
  #
  #   devise :database_authenticatable, :confirmable, :recoverable
  #
  # You can also give any of the devise configuration values in form of a hash,
  # with specific values for this model. Please check your Devise initializer
  # for a complete description on those values.
  def devise(*modules); end

  # The hook which is called inside devise.
  # So your ORM can include devise compatibility stuff.
  def devise_modules_hook!; end

  class << self
    def check_fields!(klass); end

    # Creates configuration values for Devise and for the given module.
    #
    #   Devise::Models.config(Devise::Models::DatabaseAuthenticatable, :stretches)
    #
    # The line above creates:
    #
    #   1) An accessor called Devise.stretches, which value is used by default;
    #
    #   2) Some class methods for your model Model.stretches and Model.stretches=
    #      which have higher priority than Devise.stretches;
    #
    #   3) And an instance method stretches.
    #
    # To add the class methods you need to have a module ClassMethods defined
    # inside the given class.
    def config(mod, *accessors); end
  end
end

# Authenticatable module. Holds common settings for authentication.
#
# == Options
#
# Authenticatable adds the following options to +devise+:
#
#   * +authentication_keys+: parameters used for authentication. By default [:email].
#
#   * +http_authentication_key+: map the username passed via HTTP Auth to this parameter. Defaults to
#     the first element in +authentication_keys+.
#
#   * +request_keys+: parameters from the request object used for authentication.
#     By specifying a symbol (which should be a request method), it will automatically be
#     passed to find_for_authentication method and considered in your model lookup.
#
#     For instance, if you set :request_keys to [:subdomain], :subdomain will be considered
#     as key on authentication. This can also be a hash where the value is a boolean specifying
#     if the value is required or not.
#
#   * +http_authenticatable+: if this model allows http authentication. By default false.
#     It also accepts an array specifying the strategies that should allow http.
#
#   * +params_authenticatable+: if this model allows authentication through request params. By default true.
#     It also accepts an array specifying the strategies that should allow params authentication.
#
#   * +skip_session_storage+: By default Devise will store the user in session.
#     By default is set to skip_session_storage: [:http_auth].
#
# == active_for_authentication?
#
# After authenticating a user and in each request, Devise checks if your model is active by
# calling model.active_for_authentication?. This method is overwritten by other devise modules. For instance,
# :confirmable overwrites .active_for_authentication? to only return true if your model was confirmed.
#
# You can overwrite this method yourself, but if you do, don't forget to call super:
#
#   def active_for_authentication?
#     super && special_condition_is_valid?
#   end
#
# Whenever active_for_authentication? returns false, Devise asks the reason why your model is inactive using
# the inactive_message method. You can overwrite it as well:
#
#   def inactive_message
#     special_condition_is_valid? ? super : :special_condition_is_not_valid
#   end
module Devise::Models::Authenticatable
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Devise::Models::Authenticatable::ClassMethods

  # @return [Boolean]
  def active_for_authentication?; end

  def authenticatable_salt; end
  def inactive_message; end

  # Redefine inspect using serializable_hash, to ensure we don't accidentally
  # leak passwords into exceptions.
  def inspect; end

  # Redefine serializable_hash in models for more secure defaults.
  # By default, it removes from the serializable model all attributes that
  # are *not* accessible. You can remove this default by using :force_except
  # and passing a new list of attributes you want to exempt. All attributes
  # given to :except will simply add names to exempt to Devise internal list.
  def serializable_hash(options = T.unsafe(nil)); end

  def unauthenticated_message; end

  # Check if the current object is valid for authentication. This method and
  # find_for_authentication are the methods used in a Warden::Strategy to check
  # if a model should be signed in or not.
  #
  # However, you should not overwrite this method, you should overwrite active_for_authentication?
  # and inactive_message instead.
  #
  # @return [Boolean]
  def valid_for_authentication?; end

  protected

  def apply_to_attribute_or_variable(attr, method); end
  def devise_mailer; end
  def downcase_keys; end

  # This is an internal method called every time Devise needs
  # to send a notification/mail. This can be overridden if you
  # need to customize the e-mail delivery logic. For instance,
  # if you are using a queue to deliver e-mails (active job, delayed
  # job, sidekiq, resque, etc), you must add the delivery to the queue
  # just after the transaction was committed. To achieve this,
  # you can override send_devise_notification to store the
  # deliveries until the after_commit callback is triggered.
  #
  # The following example uses Active Job's `deliver_later` :
  #
  #     class User
  #       devise :database_authenticatable, :confirmable
  #
  #       after_commit :send_pending_devise_notifications
  #
  #       protected
  #
  #       def send_devise_notification(notification, *args)
  #         # If the record is new or changed then delay the
  #         # delivery until the after_commit callback otherwise
  #         # send now because after_commit will not be called.
  #         # For Rails < 6 use `changed?` instead of `saved_changes?`.
  #         if new_record? || saved_changes?
  #           pending_devise_notifications << [notification, args]
  #         else
  #           render_and_send_devise_message(notification, *args)
  #         end
  #       end
  #
  #       private
  #
  #       def send_pending_devise_notifications
  #         pending_devise_notifications.each do |notification, args|
  #           render_and_send_devise_message(notification, *args)
  #         end
  #
  #         # Empty the pending notifications array because the
  #         # after_commit hook can be called multiple times which
  #         # could cause multiple emails to be sent.
  #         pending_devise_notifications.clear
  #       end
  #
  #       def pending_devise_notifications
  #         @pending_devise_notifications ||= []
  #       end
  #
  #       def render_and_send_devise_message(notification, *args)
  #         message = devise_mailer.send(notification, self, *args)
  #
  #         # Deliver later with Active Job's `deliver_later`
  #         if message.respond_to?(:deliver_later)
  #           message.deliver_later
  #         # Remove once we move to Rails 4.2+ only, as `deliver` is deprecated.
  #         elsif message.respond_to?(:deliver_now)
  #           message.deliver_now
  #         else
  #           message.deliver
  #         end
  #       end
  #
  #     end
  def send_devise_notification(notification, *args); end

  def strip_whitespace; end

  class << self
    def required_fields(klass); end
  end

  module GeneratedClassMethods
    def devise_modules; end
    def devise_modules=(value); end
    def devise_modules?; end
  end

  module GeneratedInstanceMethods
    def devise_modules; end
    def devise_modules?; end
  end
end

module Devise::Models::Authenticatable::ClassMethods
  def authentication_keys; end
  def authentication_keys=(value); end
  def case_insensitive_keys; end
  def case_insensitive_keys=(value); end
  def find_first_by_auth_conditions(tainted_conditions, opts = T.unsafe(nil)); end

  # Find first record based on conditions given (ie by the sign in form).
  # This method is always called during an authentication process but
  # it may be wrapped as well. For instance, database authenticatable
  # provides a `find_for_database_authentication` that wraps a call to
  # this method. This allows you to customize both database authenticatable
  # or the whole authenticate stack by customize `find_for_authentication.`
  #
  # Overwrite to add customized conditions, create a join, or maybe use a
  # namedscope to filter records while authenticating.
  # Example:
  #
  #   def self.find_for_authentication(tainted_conditions)
  #     find_first_by_auth_conditions(tainted_conditions, active: true)
  #   end
  #
  # Finally, notice that Devise also queries for users in other scenarios
  # besides authentication, for example when retrieving a user to send
  # an e-mail for password reset. In such cases, find_for_authentication
  # is not called.
  def find_for_authentication(tainted_conditions); end

  # Find or initialize a record setting an error if it can't be found.
  def find_or_initialize_with_error_by(attribute, value, error = T.unsafe(nil)); end

  # Find or initialize a record with group of attributes based on a list of required attributes.
  def find_or_initialize_with_errors(required_attributes, attributes, error = T.unsafe(nil)); end

  def http_authenticatable; end
  def http_authenticatable=(value); end

  # @return [Boolean]
  def http_authenticatable?(strategy); end

  def http_authentication_key; end
  def http_authentication_key=(value); end
  def params_authenticatable; end
  def params_authenticatable=(value); end

  # @return [Boolean]
  def params_authenticatable?(strategy); end

  def request_keys; end
  def request_keys=(value); end
  def serialize_from_session(key, salt); end
  def serialize_into_session(record); end
  def skip_session_storage; end
  def skip_session_storage=(value); end
  def strip_whitespace_keys; end
  def strip_whitespace_keys=(value); end

  protected

  def devise_parameter_filter; end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

Devise::Models::Authenticatable::UNSAFE_ATTRIBUTES_FOR_SERIALIZATION = T.let(T.unsafe(nil), Array)

# Confirmable is responsible to verify if an account is already confirmed to
# sign in, and to send emails with confirmation instructions.
# Confirmation instructions are sent to the user email after creating a
# record and when manually requested by a new confirmation instruction request.
#
# Confirmable tracks the following columns:
#
# * confirmation_token   - A unique random token
# * confirmed_at         - A timestamp when the user clicked the confirmation link
# * confirmation_sent_at - A timestamp when the confirmation_token was generated (not sent)
# * unconfirmed_email    - An email address copied from the email attr. After confirmation
#                          this value is copied to the email attr then cleared
#
# == Options
#
# Confirmable adds the following options to +devise+:
#
#   * +allow_unconfirmed_access_for+: the time you want to allow the user to access their account
#     before confirming it. After this period, the user access is denied. You can
#     use this to let your user access some features of your application without
#     confirming the account, but blocking it after a certain period (ie 7 days).
#     By default allow_unconfirmed_access_for is zero, it means users always have to confirm to sign in.
#   * +reconfirmable+: requires any email changes to be confirmed (exactly the same way as
#     initial account confirmation) to be applied. Requires additional unconfirmed_email
#     db field to be set up (t.reconfirmable in migrations). Until confirmed, new email is
#     stored in unconfirmed email column, and copied to email column on successful
#     confirmation. Also, when used in conjunction with `send_email_changed_notification`,
#     the notification is sent to the original email when the change is requested,
#     not when the unconfirmed email is confirmed.
#   * +confirm_within+: the time before a sent confirmation token becomes invalid.
#     You can use this to force the user to confirm within a set period of time.
#     Confirmable will not generate a new token if a repeat confirmation is requested
#     during this time frame, unless the user's email changed too.
#
# == Examples
#
#   User.find(1).confirm       # returns true unless it's already confirmed
#   User.find(1).confirmed?    # true/false
#   User.find(1).send_confirmation_instructions # manually send instructions
module Devise::Models::Confirmable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Confirmable::ClassMethods

  def initialize(*args, &block); end

  # Overwrites active_for_authentication? for confirmation
  # by verifying whether a user is active to sign in or not. If the user
  # is already confirmed, it should never be blocked. Otherwise we need to
  # calculate if the confirm time has not expired for this user.
  #
  # @return [Boolean]
  def active_for_authentication?; end

  # Confirm a user by setting it's confirmed_at to actual time. If the user
  # is already confirmed, add an error to email field. If the user is invalid
  # add errors
  def confirm(args = T.unsafe(nil)); end

  # Verifies whether a user is confirmed or not
  #
  # @return [Boolean]
  def confirmed?; end

  # The message to be shown if the account is inactive.
  def inactive_message; end

  # @return [Boolean]
  def pending_reconfirmation?; end

  # Resend confirmation token.
  # Regenerates the token if the period is expired.
  def resend_confirmation_instructions; end

  # Send confirmation instructions by email
  def send_confirmation_instructions; end

  def send_reconfirmation_instructions; end

  # If you don't want confirmation to be sent on create, neither a code
  # to be generated, call skip_confirmation!
  def skip_confirmation!; end

  # Skips sending the confirmation/reconfirmation notification email after_create/after_update. Unlike
  # #skip_confirmation!, record still requires confirmation.
  def skip_confirmation_notification!; end

  # If you don't want reconfirmation to be sent, neither a code
  # to be generated, call skip_reconfirmation!
  def skip_reconfirmation!; end

  protected

  # A callback initiated after successfully confirming. This can be
  # used to insert your own logic that is only run after the user successfully
  # confirms.
  #
  # Example:
  #
  #   def after_confirmation
  #     self.update_attribute(:invite_code, nil)
  #   end
  def after_confirmation; end

  # Checks if the user confirmation happens before the token becomes invalid
  # Examples:
  #
  #   # confirm_within = 3.days and confirmation_sent_at = 2.days.ago
  #   confirmation_period_expired?  # returns false
  #
  #   # confirm_within = 3.days and confirmation_sent_at = 4.days.ago
  #   confirmation_period_expired?  # returns true
  #
  #   # confirm_within = nil
  #   confirmation_period_expired?  # will always return false
  #
  # @return [Boolean]
  def confirmation_period_expired?; end

  # Checks if the confirmation for the user is within the limit time.
  # We do this by calculating if the difference between today and the
  # confirmation sent date does not exceed the confirm in time configured.
  # allow_unconfirmed_access_for is a model configuration, must always be an integer value.
  #
  # Example:
  #
  #   # allow_unconfirmed_access_for = 1.day and confirmation_sent_at = today
  #   confirmation_period_valid?   # returns true
  #
  #   # allow_unconfirmed_access_for = 5.days and confirmation_sent_at = 4.days.ago
  #   confirmation_period_valid?   # returns true
  #
  #   # allow_unconfirmed_access_for = 5.days and confirmation_sent_at = 5.days.ago
  #   confirmation_period_valid?   # returns false
  #
  #   # allow_unconfirmed_access_for = 0.days
  #   confirmation_period_valid?   # will always return false
  #
  #   # allow_unconfirmed_access_for = nil
  #   confirmation_period_valid?   # will always return true
  #
  # @return [Boolean]
  def confirmation_period_valid?; end

  # Callback to overwrite if confirmation is required or not.
  #
  # @return [Boolean]
  def confirmation_required?; end

  # Generates a new random token for confirmation, and stores
  # the time this token is being generated in confirmation_sent_at
  def generate_confirmation_token; end

  def generate_confirmation_token!; end

  # Checks whether the record requires any confirmation.
  def pending_any_confirmation; end

  # @return [Boolean]
  def postpone_email_change?; end

  def postpone_email_change_until_confirmation_and_regenerate_confirmation_token; end

  # @return [Boolean]
  def reconfirmation_required?; end

  # @return [Boolean]
  def send_confirmation_notification?; end

  # With reconfirmable, notify the original email when the user first
  # requests the email change, instead of when the change is confirmed.
  #
  # @return [Boolean]
  def send_email_changed_notification?; end

  # A callback method used to deliver confirmation
  # instructions on creation. This can be overridden
  # in models to map to a nice sign up e-mail.
  def send_on_create_confirmation_instructions; end

  # To not require reconfirmation after creating with #save called in a
  # callback call skip_create_confirmation!
  def skip_reconfirmation_in_callback!; end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Confirmable::ClassMethods
  def allow_unconfirmed_access_for; end
  def allow_unconfirmed_access_for=(value); end

  # Find a user by its confirmation token and try to confirm it.
  # If no user is found, returns a new user with an error.
  # If the user is already confirmed, create an error for the user
  # Options must have the confirmation_token
  def confirm_by_token(confirmation_token); end

  def confirm_within; end
  def confirm_within=(value); end
  def confirmation_keys; end
  def confirmation_keys=(value); end

  # Find a record for confirmation by unconfirmed email field
  def find_by_unconfirmed_email_with_errors(attributes = T.unsafe(nil)); end

  def reconfirmable; end
  def reconfirmable=(value); end

  # Attempt to find a user by its email. If a record is found, send new
  # confirmation instructions to it. If not, try searching for a user by unconfirmed_email
  # field. If no user is found, returns a new user with an email not found error.
  # Options must contain the user email
  def send_confirmation_instructions(attributes = T.unsafe(nil)); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Authenticatable Module, responsible for hashing the password and
# validating the authenticity of a user while signing in.
#
# This module defines a `password=` method. This method will hash the argument
# and store it in the `encrypted_password` column, bypassing any pre-existing
# `password` column if it exists.
#
# == Options
#
# DatabaseAuthenticatable adds the following options to +devise+:
#
#   * +pepper+: a random string used to provide a more secure hash. Use
#     `rails secret` to generate new keys.
#
#   * +stretches+: the cost given to bcrypt.
#
#   * +send_email_changed_notification+: notify original email when it changes.
#
#   * +send_password_change_notification+: notify email when password changes.
#
# == Examples
#
#    User.find(1).valid_password?('password123')         # returns true/false
module Devise::Models::DatabaseAuthenticatable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::DatabaseAuthenticatable::ClassMethods

  def initialize(*args, &block); end

  # A callback initiated after successfully authenticating. This can be
  # used to insert your own logic that is only run after the user successfully
  # authenticates.
  #
  # Example:
  #
  #   def after_database_authentication
  #     self.update_attribute(:invite_code, nil)
  #   end
  def after_database_authentication; end

  # A reliable way to expose the salt regardless of the implementation.
  def authenticatable_salt; end

  # Set password and password confirmation to nil
  def clean_up_passwords; end

  # Destroy record when :current_password matches, otherwise returns
  # error on :current_password. It also automatically rejects
  # :current_password if it is blank.
  def destroy_with_password(current_password); end

  # Generates a hashed password based on the given value.
  # For legacy reasons, we use `encrypted_password` to store
  # the hashed password.
  def password=(new_password); end

  # Send notification to user when email changes.
  def send_email_changed_notification; end

  # Send notification to user when password changes.
  def send_password_change_notification; end

  # Skips sending the email changed notification after_update
  def skip_email_changed_notification!; end

  # Skips sending the password change notification after_update
  def skip_password_change_notification!; end

  # Update record attributes when :current_password matches, otherwise
  # returns error on :current_password.
  #
  # This method also rejects the password field if it is blank (allowing
  # users to change relevant information like the e-mail without changing
  # their password). In case the password field is rejected, the confirmation
  # is also rejected as long as it is also blank.
  def update_with_password(params, *options); end

  # Updates record attributes without asking for the current password.
  # Never allows a change to the current password. If you are using this
  # method, you should probably override this method to protect other
  # attributes you would not like to be updated without a password.
  #
  # Example:
  #
  #   def update_without_password(params, *options)
  #     params.delete(:email)
  #     super(params)
  #   end
  def update_without_password(params, *options); end

  # Verifies whether a password (ie from sign in) is the user password.
  #
  # @return [Boolean]
  def valid_password?(password); end

  protected

  # Hashes the password using bcrypt. Custom hash functions should override
  # this method to apply their own algorithm.
  #
  # See https://github.com/heartcombo/devise-encryptable for examples
  # of other hashing engines.
  def password_digest(password); end

  # @return [Boolean]
  def send_email_changed_notification?; end

  # @return [Boolean]
  def send_password_change_notification?; end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  # We assume this method already gets the sanitized values from the
  # DatabaseAuthenticatable strategy. If you are using this method on
  # your own, be sure to sanitize the conditions hash to only include
  # the proper fields.
  def find_for_database_authentication(conditions); end

  def pepper; end
  def pepper=(value); end
  def send_email_changed_notification; end
  def send_email_changed_notification=(value); end
  def send_password_change_notification; end
  def send_password_change_notification=(value); end
  def stretches; end
  def stretches=(value); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Handles blocking a user access after a certain number of attempts.
# Lockable accepts two different strategies to unlock a user after it's
# blocked: email and time. The former will send an email to the user when
# the lock happens, containing a link to unlock its account. The second
# will unlock the user automatically after some configured time (ie 2.hours).
# It's also possible to set up lockable to use both email and time strategies.
#
# == Options
#
# Lockable adds the following options to +devise+:
#
#   * +maximum_attempts+: how many attempts should be accepted before blocking the user.
#   * +lock_strategy+: lock the user account by :failed_attempts or :none.
#   * +unlock_strategy+: unlock the user account by :time, :email, :both or :none.
#   * +unlock_in+: the time you want to unlock the user after lock happens. Only available when unlock_strategy is :time or :both.
#   * +unlock_keys+: the keys you want to use when locking and unlocking an account
module Devise::Models::Lockable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Lockable::ClassMethods

  # Verifies whether a user is locked or not.
  #
  # @return [Boolean]
  def access_locked?; end

  # Overwrites active_for_authentication? from Devise::Models::Activatable for locking purposes
  # by verifying whether a user is active to sign in or not based on locked?
  #
  # @return [Boolean]
  def active_for_authentication?; end

  # Overwrites invalid_message from Devise::Models::Authenticatable to define
  # the correct reason for blocking the sign in.
  def inactive_message; end

  def increment_failed_attempts; end

  # Lock a user setting its locked_at to actual time.
  # * +opts+: Hash options if you don't want to send email
  #   when you lock access, you could pass the next hash
  #   `{ send_instructions: false } as option`.
  def lock_access!(opts = T.unsafe(nil)); end

  def lock_strategy_enabled?(*_arg0, **_arg1, &_arg2); end

  # Resend the unlock instructions if the user is locked.
  def resend_unlock_instructions; end

  # Resets failed attempts counter to 0.
  def reset_failed_attempts!; end

  # Send unlock instructions by email
  def send_unlock_instructions; end

  def unauthenticated_message; end

  # Unlock a user by cleaning locked_at and failed_attempts.
  def unlock_access!; end

  def unlock_strategy_enabled?(*_arg0, **_arg1, &_arg2); end

  # Overwrites valid_for_authentication? from Devise::Models::Authenticatable
  # for verifying whether a user is allowed to sign in or not. If the user
  # is locked, it should never be allowed.
  #
  # @return [Boolean]
  def valid_for_authentication?; end

  protected

  # @return [Boolean]
  def attempts_exceeded?; end

  # Checks whether the record is locked or not, yielding to the block
  # if it's locked, otherwise adds an error to email.
  def if_access_locked; end

  # @return [Boolean]
  def last_attempt?; end

  # Tells if the lock is expired if :time unlock strategy is active
  #
  # @return [Boolean]
  def lock_expired?; end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Lockable::ClassMethods
  def last_attempt_warning; end
  def last_attempt_warning=(value); end
  def lock_strategy; end
  def lock_strategy=(value); end

  # Is the lock enabled for the given lock strategy?
  #
  # @return [Boolean]
  def lock_strategy_enabled?(strategy); end

  def maximum_attempts; end
  def maximum_attempts=(value); end

  # Attempt to find a user by its unlock keys. If a record is found, send new
  # unlock instructions to it. If not user is found, returns a new user
  # with an email not found error.
  # Options must contain the user's unlock keys
  def send_unlock_instructions(attributes = T.unsafe(nil)); end

  # Find a user by its unlock token and try to unlock it.
  # If no user is found, returns a new user with an error.
  # If the user is not locked, creates an error for the user
  # Options must have the unlock_token
  def unlock_access_by_token(unlock_token); end

  def unlock_in; end
  def unlock_in=(value); end
  def unlock_keys; end
  def unlock_keys=(value); end
  def unlock_strategy; end
  def unlock_strategy=(value); end

  # Is the unlock enabled for the given unlock strategy?
  #
  # @return [Boolean]
  def unlock_strategy_enabled?(strategy); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# List of strategies that are enabled/supported if :both is used.
Devise::Models::Lockable::ClassMethods::BOTH_STRATEGIES = T.let(T.unsafe(nil), Array)

class Devise::Models::MissingAttribute < ::StandardError
  # @return [MissingAttribute] a new instance of MissingAttribute
  def initialize(attributes); end

  def message; end
end

# Recoverable takes care of resetting the user password and send reset instructions.
#
# ==Options
#
# Recoverable adds the following options to +devise+:
#
#   * +reset_password_keys+: the keys you want to use when recovering the password for an account
#   * +reset_password_within+: the time period within which the password must be reset or the token expires.
#   * +sign_in_after_reset_password+: whether or not to sign in the user automatically after a password reset.
#
# == Examples
#
#   # resets the user password and save the record, true if valid passwords are given, otherwise false
#   User.find(1).reset_password('password123', 'password123')
#
#   # creates a new token and send it with instructions about how to reset the password
#   User.find(1).send_reset_password_instructions
module Devise::Models::Recoverable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Recoverable::ClassMethods

  # Update password saving the record and clearing token. Returns true if
  # the passwords are valid and the record was saved, false otherwise.
  def reset_password(new_password, new_password_confirmation); end

  # Checks if the reset password token sent is within the limit time.
  # We do this by calculating if the difference between today and the
  # sending date does not exceed the confirm in time configured.
  # Returns true if the resource is not responding to reset_password_sent_at at all.
  # reset_password_within is a model configuration, must always be an integer value.
  #
  # Example:
  #
  #   # reset_password_within = 1.day and reset_password_sent_at = today
  #   reset_password_period_valid?   # returns true
  #
  #   # reset_password_within = 5.days and reset_password_sent_at = 4.days.ago
  #   reset_password_period_valid?   # returns true
  #
  #   # reset_password_within = 5.days and reset_password_sent_at = 5.days.ago
  #   reset_password_period_valid?   # returns false
  #
  #   # reset_password_within = 0.days
  #   reset_password_period_valid?   # will always return false
  #
  # @return [Boolean]
  def reset_password_period_valid?; end

  # Resets reset password token and send reset password instructions by email.
  # Returns the token sent in the e-mail.
  def send_reset_password_instructions; end

  protected

  # Removes reset_password token
  def clear_reset_password_token; end

  # @return [Boolean]
  def clear_reset_password_token?; end

  def send_reset_password_instructions_notification(token); end
  def set_reset_password_token; end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Recoverable::ClassMethods
  # Attempt to find a user by its reset_password_token to reset its
  # password. If a user is found and token is still valid, reset its password and automatically
  # try saving the record. If not user is found, returns a new user
  # containing an error in reset_password_token attribute.
  # Attributes must contain reset_password_token, password and confirmation
  def reset_password_by_token(attributes = T.unsafe(nil)); end

  def reset_password_keys; end
  def reset_password_keys=(value); end
  def reset_password_within; end
  def reset_password_within=(value); end

  # Attempt to find a user by its email. If a record is found, send new
  # password instructions to it. If user is not found, returns a new user
  # with an email not found error.
  # Attributes must contain the user's email
  def send_reset_password_instructions(attributes = T.unsafe(nil)); end

  def sign_in_after_reset_password; end
  def sign_in_after_reset_password=(value); end

  # Attempt to find a user by password reset token. If a user is found, return it
  # If a user is not found, return nil
  def with_reset_password_token(token); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Registerable is responsible for everything related to registering a new
# resource (ie user sign up).
module Devise::Models::Registerable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Registerable::ClassMethods

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Registerable::ClassMethods
  # A convenience method that receives both parameters and session to
  # initialize a user. This can be used by OAuth, for example, to send
  # in the user token and be stored on initialization.
  #
  # By default discards all information sent by the session by calling
  # new with params.
  def new_with_session(params, session); end

  def sign_in_after_change_password; end
  def sign_in_after_change_password=(value); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Rememberable manages generating and clearing token for remembering the user
# from a saved cookie. Rememberable also has utility methods for dealing
# with serializing the user into the cookie and back from the cookie, trying
# to lookup the record based on the saved information.
# You probably wouldn't use rememberable methods directly, they are used
# mostly internally for handling the remember token.
#
# == Options
#
# Rememberable adds the following options to +devise+:
#
#   * +remember_for+: the time you want the user will be remembered without
#     asking for credentials. After this time the user will be blocked and
#     will have to enter their credentials again. This configuration is also
#     used to calculate the expires time for the cookie created to remember
#     the user. By default remember_for is 2.weeks.
#
#   * +extend_remember_period+: if true, extends the user's remember period
#     when remembered via cookie. False by default.
#
#   * +rememberable_options+: configuration options passed to the created cookie.
#
# == Examples
#
#   User.find(1).remember_me!  # regenerating the token
#   User.find(1).forget_me!    # clearing the token
#
#   # generating info to put into cookies
#   User.serialize_into_cookie(user)
#
#   # lookup the user based on the incoming cookie information
#   User.serialize_from_cookie(cookie_string)
module Devise::Models::Rememberable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Rememberable::ClassMethods

  # A callback initiated after successfully being remembered. This can be
  # used to insert your own logic that is only run after the user is
  # remembered.
  #
  # Example:
  #
  #   def after_remembered
  #     self.update_attribute(:invite_code, nil)
  #   end
  def after_remembered; end

  def extend_remember_period; end

  # If the record is persisted, remove the remember token (but only if
  # it exists), and save the record without validations.
  def forget_me!; end

  def remember_expires_at; end

  # Returns the value of attribute remember_me.
  def remember_me; end

  def remember_me!; end

  # Sets the attribute remember_me
  #
  # @param value the value to set the attribute remember_me to.
  def remember_me=(_arg0); end

  # @return [Boolean]
  def remember_me?(token, generated_at); end

  def rememberable_options; end
  def rememberable_value; end

  private

  def time_from_json(value); end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Rememberable::ClassMethods
  def expire_all_remember_me_on_sign_out; end
  def expire_all_remember_me_on_sign_out=(value); end
  def extend_remember_period; end
  def extend_remember_period=(value); end
  def remember_for; end
  def remember_for=(value); end

  # Generate a token checking if one does not already exist in the database.
  def remember_token; end

  def rememberable_options; end
  def rememberable_options=(value); end

  # Recreate the user based on the stored cookie
  def serialize_from_cookie(*args); end

  # Create the cookie key using the record id and remember_token
  def serialize_into_cookie(record); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Timeoutable takes care of verifying whether a user session has already
# expired or not. When a session expires after the configured time, the user
# will be asked for credentials again, it means, they will be redirected
# to the sign in page.
#
# == Options
#
# Timeoutable adds the following options to +devise+:
#
#   * +timeout_in+: the interval to timeout the user session without activity.
#
# == Examples
#
#   user.timedout?(30.minutes.ago)
module Devise::Models::Timeoutable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Devise::Models::Timeoutable::ClassMethods

  # Checks whether the user session has expired based on configured time.
  #
  # @return [Boolean]
  def timedout?(last_access); end

  def timeout_in; end

  class << self
    def required_fields(klass); end
  end
end

module Devise::Models::Timeoutable::ClassMethods
  def timeout_in; end
  def timeout_in=(value); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# Track information about your user sign in. It tracks the following columns:
#
# * sign_in_count      - Increased every time a sign in is made (by form, openid, oauth)
# * current_sign_in_at - A timestamp updated when the user signs in
# * last_sign_in_at    - Holds the timestamp of the previous sign in
# * current_sign_in_ip - The remote ip updated when the user sign in
# * last_sign_in_ip    - Holds the remote ip of the previous sign in
module Devise::Models::Trackable
  def update_tracked_fields(request); end
  def update_tracked_fields!(request); end

  protected

  def extract_ip_from(request); end

  class << self
    def required_fields(klass); end
  end
end

# Validatable creates all needed validations for a user email and password.
# It's optional, given you may want to create the validations by yourself.
# Automatically validate if the email is present, unique and its format is
# valid. Also tests presence of password, confirmation and length.
#
# == Options
#
# Validatable adds the following options to +devise+:
#
#   * +email_regexp+: the regular expression used to validate e-mails;
#   * +password_length+: a range expressing password length. Defaults to 6..128.
module Devise::Models::Validatable
  protected

  # @return [Boolean]
  def email_required?; end

  # Checks whether a password is needed or not. For validations only.
  # Passwords are always required if it's a new record, or if the password
  # or confirmation are being set somewhere.
  #
  # @return [Boolean]
  def password_required?; end

  class << self
    def assert_validations_api!(base); end

    # @private
    def included(base); end

    def required_fields(klass); end
  end
end

module Devise::Models::Validatable::ClassMethods
  def email_regexp; end
  def email_regexp=(value); end
  def password_length; end
  def password_length=(value); end

  class << self
    def available_configs; end
    def available_configs=(_arg0); end
  end
end

# All validations used by this module.
Devise::Models::Validatable::VALIDATIONS = T.let(T.unsafe(nil), Array)

# Strategies that do not require user input.
Devise::NO_INPUT = T.let(T.unsafe(nil), Array)

module Devise::Orm
  include ::Devise::Orm::DirtyTrackingOldMethods

  class << self
    # @return [Boolean]
    def active_record?(model); end

    # @return [Boolean]
    def active_record_51?(model); end

    # @private
    def included(model); end
  end
end

module Devise::Orm::DirtyTrackingNewMethods
  def devise_email_before_last_save; end
  def devise_email_in_database; end

  # @return [Boolean]
  def devise_respond_to_and_will_save_change_to_attribute?(attribute); end

  # @return [Boolean]
  def devise_saved_change_to_email?; end

  # @return [Boolean]
  def devise_saved_change_to_encrypted_password?; end

  # @return [Boolean]
  def devise_will_save_change_to_email?; end
end

module Devise::Orm::DirtyTrackingOldMethods
  def devise_email_before_last_save; end
  def devise_email_in_database; end

  # @return [Boolean]
  def devise_respond_to_and_will_save_change_to_attribute?(attribute); end

  # @return [Boolean]
  def devise_saved_change_to_email?; end

  # @return [Boolean]
  def devise_saved_change_to_encrypted_password?; end

  # @return [Boolean]
  def devise_will_save_change_to_email?; end
end

class Devise::ParameterFilter
  # @return [ParameterFilter] a new instance of ParameterFilter
  def initialize(case_insensitive_keys, strip_whitespace_keys); end

  def filter(conditions); end
  def filtered_hash_by_method_for_given_keys(conditions, method, condition_keys); end

  # Force keys to be string to avoid injection on mongoid related database.
  def stringify_params(conditions); end

  private

  # @return [Boolean]
  def param_requires_string_conversion?(value); end
end

# The +ParameterSanitizer+ deals with permitting specific parameters values
# for each +Devise+ scope in the application.
#
# The sanitizer knows about Devise default parameters (like +password+ and
# +password_confirmation+ for the `RegistrationsController`), and you can
# extend or change the permitted parameters list on your controllers.
#
# === Permitting new parameters
#
# You can add new parameters to the permitted list using the +permit+ method
# in a +before_action+ method, for instance.
#
#    class ApplicationController < ActionController::Base
#      before_action :configure_permitted_parameters, if: :devise_controller?
#
#      protected
#
#      def configure_permitted_parameters
#        # Permit the `subscribe_newsletter` parameter along with the other
#        # sign up parameters.
#        devise_parameter_sanitizer.permit(:sign_up, keys: [:subscribe_newsletter])
#      end
#    end
#
# Using a block yields an +ActionController::Parameters+ object so you can
# permit nested parameters and have more control over how the parameters are
# permitted in your controller.
#
#    def configure_permitted_parameters
#      devise_parameter_sanitizer.permit(:sign_up) do |user|
#        user.permit(newsletter_preferences: [])
#      end
#    end
class Devise::ParameterSanitizer
  # @return [ParameterSanitizer] a new instance of ParameterSanitizer
  def initialize(resource_class, resource_name, params); end

  # Add or remove new parameters to the permitted list of an +action+.
  #
  # === Arguments
  #
  # * +action+ - A +Symbol+ with the action that the controller is
  #   performing, like +sign_up+, +sign_in+, etc.
  # * +keys:+     - An +Array+ of keys that also should be permitted.
  # * +except:+   - An +Array+ of keys that shouldn't be permitted.
  # * +block+     - A block that should be used to permit the action
  #   parameters instead of the +Array+ based approach. The block will be
  #   called with an +ActionController::Parameters+ instance.
  #
  # === Examples
  #
  #   # Adding new parameters to be permitted in the `sign_up` action.
  #   devise_parameter_sanitizer.permit(:sign_up, keys: [:subscribe_newsletter])
  #
  #   # Removing the `password` parameter from the `account_update` action.
  #   devise_parameter_sanitizer.permit(:account_update, except: [:password])
  #
  #   # Using the block form to completely override how we permit the
  #   # parameters for the `sign_up` action.
  #   devise_parameter_sanitizer.permit(:sign_up) do |user|
  #     user.permit(:email, :password, :password_confirmation)
  #   end
  #
  #
  # Returns nothing.
  def permit(action, keys: T.unsafe(nil), except: T.unsafe(nil), &block); end

  # Sanitize the parameters for a specific +action+.
  #
  # === Arguments
  #
  # * +action+ - A +Symbol+ with the action that the controller is
  #   performing, like +sign_up+, +sign_in+, etc.
  #
  # === Examples
  #
  #    # Inside the `RegistrationsController#create` action.
  #    resource = build_resource(devise_parameter_sanitizer.sanitize(:sign_up))
  #    resource.save
  #
  # Returns an +ActiveSupport::HashWithIndifferentAccess+ with the permitted
  # attributes.
  def sanitize(action); end

  private

  # Cast a sanitized +ActionController::Parameters+ to a +HashWithIndifferentAccess+
  # that can be used elsewhere.
  #
  # Returns an +ActiveSupport::HashWithIndifferentAccess+.
  def cast_to_hash(params); end

  def default_params; end
  def empty_params; end
  def extract_auth_keys(klass); end

  # @return [Boolean]
  def hashable_resource_params?; end

  def permit_keys(parameters, keys); end

  # @raise [NotImplementedError]
  def unknown_action!(action); end
end

Devise::ParameterSanitizer::DEFAULT_PERMITTED_ATTRIBUTES = T.let(T.unsafe(nil), Hash)
Devise::ROUTES = T.let(T.unsafe(nil), Hash)

module Devise::RouteSet
  def finalize!; end
end

Devise::STRATEGIES = T.let(T.unsafe(nil), Hash)

class Devise::SecretKeyFinder
  # @return [SecretKeyFinder] a new instance of SecretKeyFinder
  def initialize(application); end

  def find; end

  private

  # @return [Boolean]
  def key_exists?(object); end
end

module Devise::Strategies; end

# This strategy should be used as basis for authentication strategies. It retrieves
# parameters both from params or from http authorization headers. See database_authenticatable
# for an example.
class Devise::Strategies::Authenticatable < ::Devise::Strategies::Base
  # Returns the value of attribute authentication_hash.
  def authentication_hash; end

  # Sets the attribute authentication_hash
  #
  # @param value the value to set the attribute authentication_hash to.
  def authentication_hash=(_arg0); end

  # Returns the value of attribute authentication_type.
  def authentication_type; end

  # Sets the attribute authentication_type
  #
  # @param value the value to set the attribute authentication_type to.
  def authentication_type=(_arg0); end

  # Override and set to false for things like OmniAuth that technically
  # run through Authentication (user_set) very often, which would normally
  # reset CSRF data in the session
  #
  # @return [Boolean]
  def clean_up_csrf?; end

  # Returns the value of attribute password.
  def password; end

  # Sets the attribute password
  #
  # @param value the value to set the attribute password to.
  def password=(_arg0); end

  # @return [Boolean]
  def store?; end

  # @return [Boolean]
  def valid?; end

  private

  # Holds the authenticatable name for this class. Devise::Strategies::DatabaseAuthenticatable
  # becomes simply :database.
  def authenticatable_name; end

  def authentication_keys; end

  # Helper to decode credentials from HTTP.
  def decode_credentials; end

  # Extract a hash with attributes:values from the http params.
  def http_auth_hash; end

  # Check if the model accepts this strategy as http authenticatable.
  #
  # @return [Boolean]
  def http_authenticatable?; end

  def http_authentication_key; end

  # Extract the appropriate subhash for authentication from params.
  def params_auth_hash; end

  # Check if the model accepts this strategy as params authenticatable.
  #
  # @return [Boolean]
  def params_authenticatable?; end

  def parse_authentication_key_values(hash, keys); end

  # Get values from params and set in the resource.
  def remember_me(resource); end

  # Should this resource be marked to be remembered?
  #
  # @return [Boolean]
  def remember_me?; end

  def request_keys; end
  def request_values; end

  # Check if this is a valid strategy for http authentication by:
  #
  #   * Validating if the model allows http authentication;
  #   * If any of the authorization headers were sent;
  #   * If all authentication keys are present;
  #
  # @return [Boolean]
  def valid_for_http_auth?; end

  # Check if this is a valid strategy for params authentication by:
  #
  #   * Validating if the model allows params authentication;
  #   * If the request hits the sessions controller through POST;
  #   * If the params[scope] returns a hash with credentials;
  #   * If all authentication keys are present;
  #
  # @return [Boolean]
  def valid_for_params_auth?; end

  # If the request is valid, finally check if params_auth_hash returns a hash.
  #
  # @return [Boolean]
  def valid_params?; end

  # By default, a request is valid if the controller set the proper env variable.
  #
  # @return [Boolean]
  def valid_params_request?; end

  # Note: unlike `Model.valid_password?`, this method does not actually
  # ensure that the password in the params matches the password stored in
  # the database. It only checks if the password is *present*. Do not rely
  # on this method for validating that a given password is correct.
  #
  # @return [Boolean]
  def valid_password?; end

  # Receives a resource and check if it is valid by calling valid_for_authentication?
  # A block that will be triggered while validating can be optionally
  # given as parameter. Check Devise::Models::Authenticatable.valid_for_authentication?
  # for more information.
  #
  # In case the resource can't be validated, it will fail with the given
  # unauthenticated_message.
  def validate(resource, &block); end

  # Sets the authentication hash and the password from params_auth_hash or http_auth_hash.
  def with_authentication_hash(auth_type, auth_values); end
end

# Base strategy for Devise. Responsible for verifying correct scope and mapping.
class Devise::Strategies::Base < ::Warden::Strategies::Base
  # Checks if a valid scope was given for devise and find mapping based on this scope.
  def mapping; end

  # Whenever CSRF cannot be verified, we turn off any kind of storage
  #
  # @return [Boolean]
  def store?; end
end

# Default strategy for signing in a user, based on their email and password in the database.
class Devise::Strategies::DatabaseAuthenticatable < ::Devise::Strategies::Authenticatable
  def authenticate!; end
end

# Remember the user through the remember token. This strategy is responsible
# to verify whether there is a cookie with the remember token, and to
# recreate the user from this cookie if it exists. Must be called *before*
# authenticatable.
class Devise::Strategies::Rememberable < ::Devise::Strategies::Authenticatable
  # To authenticate a user we deserialize the cookie and attempt finding
  # the record in the database. If the attempt fails, we pass to another
  # strategy handle the authentication.
  def authenticate!; end

  # No need to clean up the CSRF when using rememberable.
  # In fact, cleaning it up here would be a bug because
  # rememberable is triggered on GET requests which means
  # we would render a page on first access with all csrf
  # tokens expired.
  #
  # @return [Boolean]
  def clean_up_csrf?; end

  # A valid strategy for rememberable needs a remember token in the cookies.
  #
  # @return [Boolean]
  def valid?; end

  private

  # @return [Boolean]
  def extend_remember_me?(resource); end

  def remember_cookie; end
  def remember_key; end

  # @return [Boolean]
  def remember_me?; end
end

# True values used to check params
Devise::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# Devise::Test::IntegrationHelpers is a helper module for facilitating
# authentication on Rails integration tests to bypass the required steps for
# signin in or signin out a record.
#
# Examples
#
#  class PostsTest < ActionDispatch::IntegrationTest
#    include Devise::Test::IntegrationHelpers
#
#    test 'authenticated users can see posts' do
#      sign_in users(:bob)
#
#      get '/posts'
#      assert_response :success
#    end
#  end
module Devise::Test; end

# `Devise::Test::ControllerHelpers` provides a facility to test controllers
# in isolation when using `ActionController::TestCase` allowing you to
# quickly sign_in or sign_out a user. Do not use
# `Devise::Test::ControllerHelpers` in integration tests.
#
# Examples
#
#  class PostsTest < ActionController::TestCase
#    include Devise::Test::ControllerHelpers
#
#    test 'authenticated users can GET index' do
#      sign_in users(:bob)
#
#      get :index
#      assert_response :success
#    end
#  end
#
# Important: you should not test Warden specific behavior (like callbacks)
# using `Devise::Test::ControllerHelpers` since it is a stub of the actual
# behavior. Such callbacks should be tested in your integration suite instead.
module Devise::Test::ControllerHelpers
  extend ::ActiveSupport::Concern

  # Override process to consider warden.
  def process(*_arg0, **_arg1); end

  # We need to set up the environment variables and the response in the controller.
  def setup_controller_for_warden; end

  # sign_in a given resource by storing its keys in the session.
  # This method bypass any warden authentication callback.
  #
  # * +resource+ - The resource that should be authenticated
  # * +scope+    - An optional +Symbol+ with the scope where the resource
  #                should be signed in with.
  # Examples:
  #
  # sign_in users(:alice)
  # sign_in users(:alice), scope: :admin
  def sign_in(resource, deprecated = T.unsafe(nil), scope: T.unsafe(nil)); end

  # Sign out a given resource or scope by calling logout on Warden.
  # This method bypass any warden logout callback.
  #
  # Examples:
  #
  #   sign_out :user     # sign_out(scope)
  #   sign_out @user     # sign_out(resource)
  def sign_out(resource_or_scope); end

  # Quick access to Warden::Proxy.
  def warden; end

  protected

  # Catch warden continuations and handle like the middleware would.
  # Returns nil when interrupted, otherwise the normal result of the block.
  def _catch_warden(&block); end

  def _process_unauthenticated(env, options = T.unsafe(nil)); end
end

module Devise::Test::IntegrationHelpers
  include ::Warden::Test::Helpers

  # Signs in a specific resource, mimicking a successful sign in
  # operation through +Devise::SessionsController#create+.
  #
  # * +resource+ - The resource that should be authenticated
  # * +scope+    - An optional +Symbol+ with the scope where the resource
  #                should be signed in with.
  def sign_in(resource, scope: T.unsafe(nil)); end

  # Signs out a specific scope from the session.
  #
  # * +resource_or_scope+ - The resource or scope that should be signed out.
  def sign_out(resource_or_scope); end

  protected

  def setup_integration_for_devise; end
  def teardown_integration_for_devise; end

  class << self
    # @private
    def included(base); end
  end
end

module Devise::TestHelpers
  include ::Devise::Test::ControllerHelpers

  class << self
    # @private
    def included(base); end
  end
end

class Devise::TimeInflector
  include ::ActionView::Helpers::DateHelper

  class << self
    # Returns the value of attribute instance.
    def instance; end

    def time_ago_in_words(*_arg0, **_arg1, &_arg2); end
  end
end

class Devise::TokenGenerator
  # @return [TokenGenerator] a new instance of TokenGenerator
  def initialize(key_generator, digest = T.unsafe(nil)); end

  def digest(klass, column, value); end
  def generate(klass, column); end

  private

  def key_for(column); end
end

Devise::URL_HELPERS = T.let(T.unsafe(nil), Hash)

module DeviseHelper
  def devise_error_messages!; end
end

module Warden::Mixins; end

module Warden::Mixins::Common
  def cookies; end
  def params; end
  def raw_session; end
  def request; end
  def reset_session!; end
  def session; end
  def warden_cookies; end
end
