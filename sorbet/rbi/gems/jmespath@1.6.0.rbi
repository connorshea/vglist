# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `jmespath` gem.
# Please instead update this file by running `bin/tapioca gem jmespath`.

module JMESPath
  class << self
    def load_json(path); end
    def search(expression, data, runtime_options = T.unsafe(nil)); end
  end
end

class JMESPath::CachingParser
  def initialize(options = T.unsafe(nil)); end

  def parse(expression); end

  private

  def cache_expression(expression); end
end

module JMESPath::Errors; end
class JMESPath::Errors::Error < ::StandardError; end
class JMESPath::Errors::InvalidArityError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::InvalidTypeError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::InvalidValueError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::RuntimeError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::SyntaxError < ::JMESPath::Errors::Error; end
class JMESPath::Errors::UnknownFunctionError < ::JMESPath::Errors::Error; end

class JMESPath::Lexer
  def tokenize(expression); end

  private

  def inside(chars, delim, type); end
  def match_or(chars, current, expected, type, or_type); end
  def parse_json(token, quoted = T.unsafe(nil)); end

  class << self
    def requires_wrapping?; end
  end
end

class JMESPath::Lexer::CharacterStream
  def initialize(chars); end

  def current; end
  def next; end
  def position; end
end

JMESPath::Lexer::NUMBERS = T.let(T.unsafe(nil), Set)
JMESPath::Lexer::SIMPLE_TOKENS = T.let(T.unsafe(nil), Hash)
JMESPath::Lexer::STATE_AND = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_EQ = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_GT = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_IDENTIFIER = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_JSON_LITERAL = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_LBRACKET = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_LT = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_NOT = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_NUMBER = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_PIPE = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_QUOTED_STRING = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_SINGLE_CHAR = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_STRING_LITERAL = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::STATE_WHITESPACE = T.let(T.unsafe(nil), Integer)
JMESPath::Lexer::TRANSLATION_TABLE = T.let(T.unsafe(nil), Hash)
JMESPath::Lexer::T_AND = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_COLON = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_COMMA = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_COMPARATOR = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_CURRENT = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_DOT = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_EOF = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_EXPREF = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_FILTER = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_FLATTEN = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_IDENTIFIER = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_LBRACE = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_LBRACKET = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_LITERAL = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_LPAREN = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_NOT = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_NUMBER = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_OR = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_PIPE = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_QUOTED_IDENTIFIER = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_RBRACE = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_RBRACKET = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_RPAREN = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_STAR = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::T_UNKNOWN = T.let(T.unsafe(nil), Symbol)
JMESPath::Lexer::VALID_IDENTIFIERS = T.let(T.unsafe(nil), Set)
module JMESPath::Nodes; end

class JMESPath::Nodes::AbsFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::And < ::JMESPath::Nodes::Node
  def initialize(left, right); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::ArrayProjection < ::JMESPath::Nodes::Projection
  def extract_targets(target); end
  def fast_instance; end
end

class JMESPath::Nodes::AvgFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::CeilFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::Chain
  def initialize(children); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::ChainedField < ::JMESPath::Nodes::Field
  def initialize(keys); end

  def chain(other); end
  def visit(obj); end

  private

  def keys; end
end

class JMESPath::Nodes::Comparator < ::JMESPath::Nodes::Node
  def initialize(left, right); end

  def left; end
  def optimize; end
  def right; end
  def visit(value); end

  private

  def check(left_value, right_value); end
  def comparable?(left_value, right_value); end

  class << self
    def create(relation, left, right); end
  end
end

JMESPath::Nodes::Comparator::COMPARABLE_TYPES = T.let(T.unsafe(nil), Array)

class JMESPath::Nodes::ComparatorCondition < ::JMESPath::Nodes::Node
  def initialize(left, right, child); end

  def visit(value); end

  private

  def comparable?(left_value, right_value); end
end

JMESPath::Nodes::ComparatorCondition::COMPARABLE_TYPES = T.let(T.unsafe(nil), Array)
JMESPath::Nodes::ComparatorCondition::COMPARATOR_TO_CONDITION = T.let(T.unsafe(nil), Hash)
module JMESPath::Nodes::Comparators; end

class JMESPath::Nodes::Comparators::Eq < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

class JMESPath::Nodes::Comparators::Gt < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

class JMESPath::Nodes::Comparators::Gte < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

class JMESPath::Nodes::Comparators::Lt < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

class JMESPath::Nodes::Comparators::Lte < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

class JMESPath::Nodes::Comparators::Neq < ::JMESPath::Nodes::Comparator
  def check(left_value, right_value); end
end

module JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker

  def compare_by(mode, *args); end
end

class JMESPath::Nodes::Condition < ::JMESPath::Nodes::Node
  def initialize(test, child); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::ContainsFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::Current < ::JMESPath::Nodes::Node
  def visit(value); end
end

class JMESPath::Nodes::EndsWithFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::EqCondition < ::JMESPath::Nodes::ComparatorCondition
  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::Expression < ::JMESPath::Nodes::Node
  def initialize(expression); end

  def eval(value); end
  def expression; end
  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::FastArrayProjection < ::JMESPath::Nodes::ArrayProjection
  include ::JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::FastObjectProjection < ::JMESPath::Nodes::ObjectProjection
  include ::JMESPath::Nodes::FastProjector
end

module JMESPath::Nodes::FastProjector
  def visit(value); end
end

class JMESPath::Nodes::Field < ::JMESPath::Nodes::Node
  def initialize(key); end

  def chain(other); end
  def chains_with?(other); end
  def visit(value); end

  protected

  def keys; end
end

class JMESPath::Nodes::Flatten < ::JMESPath::Nodes::Node
  def initialize(child); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::FloorFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::Function < ::JMESPath::Nodes::Node
  def initialize(children, options = T.unsafe(nil)); end

  def optimize; end
  def visit(value); end

  private

  def call(args); end
  def maybe_raise(error_type, message); end

  class << self
    def create(name, children, options = T.unsafe(nil)); end
  end
end

JMESPath::Nodes::Function::FUNCTIONS = T.let(T.unsafe(nil), Hash)

class JMESPath::Nodes::Function::FunctionName
  def initialize(name); end

  def name; end
end

class JMESPath::Nodes::GtCondition < ::JMESPath::Nodes::ComparatorCondition
  def visit(value); end
end

class JMESPath::Nodes::GteCondition < ::JMESPath::Nodes::ComparatorCondition
  def visit(value); end
end

JMESPath::Nodes::Index = JMESPath::Nodes::Field

class JMESPath::Nodes::JoinFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::KeysFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::LengthFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::Literal < ::JMESPath::Nodes::Node
  def initialize(value); end

  def value; end
  def visit(value); end
end

class JMESPath::Nodes::LiteralRightEqCondition < ::JMESPath::Nodes::EqCondition
  def initialize(left, right, child); end

  def visit(value); end
end

class JMESPath::Nodes::LiteralRightNeqCondition < ::JMESPath::Nodes::NeqCondition
  def initialize(left, right, child); end

  def visit(value); end
end

class JMESPath::Nodes::LtCondition < ::JMESPath::Nodes::ComparatorCondition
  def visit(value); end
end

class JMESPath::Nodes::LteCondition < ::JMESPath::Nodes::ComparatorCondition
  def visit(value); end
end

class JMESPath::Nodes::Map < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::MaxByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker
  include ::JMESPath::Nodes::CompareBy

  def call(args); end
end

class JMESPath::Nodes::MaxFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::MergeFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::MinByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker
  include ::JMESPath::Nodes::CompareBy

  def call(args); end
end

class JMESPath::Nodes::MinFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::MultiSelectHash < ::JMESPath::Nodes::Node
  def initialize(kv_pairs); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::MultiSelectHash::KeyValuePair
  def initialize(key, value); end

  def key; end
  def optimize; end
  def value; end
end

class JMESPath::Nodes::MultiSelectList < ::JMESPath::Nodes::Node
  def initialize(children); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::NeqCondition < ::JMESPath::Nodes::ComparatorCondition
  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::Node
  def chains_with?(other); end
  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::Not < ::JMESPath::Nodes::Node
  def initialize(expression); end

  def optimize; end
  def visit(value); end
end

class JMESPath::Nodes::NotNullFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::ObjectProjection < ::JMESPath::Nodes::Projection
  def extract_targets(target); end
  def fast_instance; end
end

class JMESPath::Nodes::Or < ::JMESPath::Nodes::Node
  def initialize(left, right); end

  def optimize; end
  def visit(value); end
end

JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

class JMESPath::Nodes::Projection < ::JMESPath::Nodes::Node
  def initialize(target, projection); end

  def optimize; end
  def visit(value); end

  private

  def extract_targets(left_value); end
end

class JMESPath::Nodes::ReverseFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::SimpleSlice < ::JMESPath::Nodes::Slice
  def initialize(start, stop); end

  def visit(value); end
end

class JMESPath::Nodes::Slice < ::JMESPath::Nodes::Node
  def initialize(start, stop, step); end

  def optimize; end
  def visit(value); end

  private

  def adjust_endpoint(length, endpoint, step); end
  def adjust_slice(length, start, stop, step); end
end

class JMESPath::Nodes::SortByFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::SortFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::StartsWithFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::Subexpression < ::JMESPath::Nodes::Node
  def initialize(left, right); end

  def optimize; end
  def visit(value); end

  protected

  def flatten; end
  def left; end
  def right; end
end

class JMESPath::Nodes::SumFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::ToArrayFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::ToNumberFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Nodes::ToStringFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

module JMESPath::Nodes::TypeChecker
  def get_type(value); end
end

JMESPath::Nodes::TypeChecker::ARRAY_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::BOOLEAN_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::EXPRESSION_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::NULL_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::NUMBER_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::OBJECT_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::STRING_TYPE = T.let(T.unsafe(nil), Integer)
JMESPath::Nodes::TypeChecker::TYPE_NAMES = T.let(T.unsafe(nil), Hash)

class JMESPath::Nodes::TypeFunction < ::JMESPath::Nodes::Function
  include ::JMESPath::Nodes::TypeChecker

  def call(args); end
end

class JMESPath::Nodes::ValuesFunction < ::JMESPath::Nodes::Function
  def call(args); end
end

class JMESPath::Parser
  def initialize(options = T.unsafe(nil)); end

  def method_missing(method_name, *args); end
  def parse(expression); end

  private

  def expr(stream, rbp = T.unsafe(nil)); end
  def led_and(stream, left); end
  def led_comparator(stream, left); end
  def led_dot(stream, left); end
  def led_filter(stream, left); end
  def led_flatten(stream, left); end
  def led_lbracket(stream, left); end
  def led_lparen(stream, left); end
  def led_or(stream, left); end
  def led_pipe(stream, left); end
  def nud_current(stream); end
  def nud_expref(stream); end
  def nud_filter(stream); end
  def nud_flatten(stream); end
  def nud_identifier(stream); end
  def nud_lbrace(stream); end
  def nud_lbracket(stream); end
  def nud_literal(stream); end
  def nud_lparen(stream); end
  def nud_not(stream); end
  def nud_quoted_identifier(stream); end
  def nud_star(stream); end
  def nud_unknown(stream); end
  def parse_array_index_expression(stream); end
  def parse_dot(stream, binding_power); end
  def parse_key_value_pair(stream); end
  def parse_multi_select_list(stream); end
  def parse_projection(stream, binding_power); end
  def parse_wildcard_array(stream, left = T.unsafe(nil)); end
  def parse_wildcard_object(stream, left = T.unsafe(nil)); end
end

JMESPath::Parser::AFTER_DOT = T.let(T.unsafe(nil), Set)
JMESPath::Parser::COLON_RBRACKET = T.let(T.unsafe(nil), Set)
JMESPath::Parser::CURRENT_NODE = T.let(T.unsafe(nil), JMESPath::Nodes::Current)
JMESPath::Parser::NUM_COLON_RBRACKET = T.let(T.unsafe(nil), Set)

class JMESPath::Runtime
  def initialize(options = T.unsafe(nil)); end

  def parser; end
  def search(expression, data); end

  private

  def default_parser(options); end
end

JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

class JMESPath::Token < ::Struct
  def initialize(type, value, position); end
end

JMESPath::Token::BINDING_POWER = T.let(T.unsafe(nil), Hash)
JMESPath::Token::NULL_TOKEN = T.let(T.unsafe(nil), JMESPath::Token)

class JMESPath::TokenStream
  def initialize(expression, tokens); end

  def expression; end
  def inspect; end
  def lookahead(count); end
  def next(options = T.unsafe(nil)); end
  def position; end
  def token; end

  private

  def _next; end
  def validate_match(token, match); end
end

module JMESPath::Util
  class << self
    def as_json(value); end
    def falsey?(value); end
  end
end

JMESPath::VERSION = T.let(T.unsafe(nil), String)
