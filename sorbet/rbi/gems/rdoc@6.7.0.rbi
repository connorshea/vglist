# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rdoc` gem.
# Please instead update this file by running `bin/tapioca gem rdoc`.


module ERB::Escape
  private

  def html_escape(_arg0); end

  class << self
    def html_escape(_arg0); end
  end
end

# RDoc produces documentation for Ruby source files by parsing the source and
# extracting the definition for classes, modules, methods, includes and
# requires.  It associates these with optional documentation contained in an
# immediately preceding comment block then renders the result using an output
# formatter.
#
# For a simple introduction to writing or generating documentation using RDoc
# see the README.
#
# == Roadmap
#
# If you think you found a bug in RDoc see CONTRIBUTING@Bugs
#
# If you want to use RDoc to create documentation for your Ruby source files,
# see RDoc::Markup and refer to <tt>rdoc --help</tt> for command line usage.
#
# If you want to set the default markup format see
# RDoc::Markup@Supported+Formats
#
# If you want to store rdoc configuration in your gem (such as the default
# markup format) see RDoc::Options@Saved+Options
#
# If you want to write documentation for Ruby files see RDoc::Parser::Ruby
#
# If you want to write documentation for extensions written in C see
# RDoc::Parser::C
#
# If you want to generate documentation using <tt>rake</tt> see RDoc::Task.
#
# If you want to drive RDoc programmatically, see RDoc::RDoc.
#
# If you want to use the library to format text blocks into HTML or other
# formats, look at RDoc::Markup.
#
# If you want to make an RDoc plugin such as a generator or directive handler
# see RDoc::RDoc.
#
# If you want to write your own output generator see RDoc::Generator.
#
# If you want an overview of how RDoc works see CONTRIBUTING
#
# == Credits
#
# RDoc is currently being maintained by Eric Hodel <drbrain@segment7.net>.
#
# Dave Thomas <dave@pragmaticprogrammer.com> is the original author of RDoc.
#
# * The Ruby parser in rdoc/parse.rb is based heavily on the outstanding
#   work of Keiju ISHITSUKA of Nippon Rational Inc, who produced the Ruby
#   parser for irb and the rtags package.
module RDoc
  class << self
    # Searches and returns the directory for settings.
    #
    # 1. <tt>$HOME/.rdoc</tt> directory, if it exists.
    # 2. The +rdoc+ directory under the path specified by the
    #    +XDG_DATA_HOME+ environment variable, if it is set.
    # 3. <tt>$HOME/.local/share/rdoc</tt> directory.
    #
    # Other than the home directory, the containing directory will be
    # created automatically.
    def home; end

    # Loads the best available YAML library.
    def load_yaml; end
  end
end

# Represent an alias, which is an old_name/new_name pair associated with a
# particular context
# --
# TODO implement Alias as a proxy to a method/attribute, inheriting from
#      MethodAttr
class RDoc::Alias < ::RDoc::CodeObject
  # Creates a new Alias with a token stream of +text+ that aliases +old_name+
  # to +new_name+, has +comment+ and is a +singleton+ context.
  #
  # @return [Alias] a new instance of Alias
  def initialize(text, old_name, new_name, comment, singleton = T.unsafe(nil)); end

  # Order by #singleton then #new_name
  def <=>(other); end

  # HTML fragment reference for this alias
  def aref; end

  # Full old name including namespace
  def full_old_name; end

  # HTML id-friendly version of +#new_name+.
  def html_name; end

  def inspect; end

  # Aliased method's name
  def name; end

  # '::' for the alias of a singleton method/attribute, '#' for instance-level.
  def name_prefix; end

  # Aliased method's name
  def new_name; end

  # Aliasee method's name
  def old_name; end

  # New name with prefix '::' or '#'.
  def pretty_name; end

  # New name with prefix '::' or '#'.
  def pretty_new_name; end

  # Old name with prefix '::' or '#'.
  def pretty_old_name; end

  # Is this an alias declared in a singleton context?
  def singleton; end

  # Is this an alias declared in a singleton context?
  def singleton=(_arg0); end

  # Source file token stream
  def text; end

  def to_s; end
end

# AnyMethod is the base class for objects representing methods
class RDoc::AnyMethod < ::RDoc::MethodAttr
  include ::RDoc::TokenStream

  # Creates a new AnyMethod with a token stream +text+ and +name+
  #
  # @return [AnyMethod] a new instance of AnyMethod
  def initialize(text, name); end

  # Adds +an_alias+ as an alias for this method in +context+.
  def add_alias(an_alias, context = T.unsafe(nil)); end

  # Prefix for +aref+ is 'method'.
  def aref_prefix; end

  # The call_seq or the param_seq with method name, if there is no call_seq.
  #
  # Use this for displaying a method's argument lists.
  def arglists; end

  # The C function that implements this method (if it was defined in a C file)
  def c_function; end

  # The C function that implements this method (if it was defined in a C file)
  def c_function=(_arg0); end

  # Different ways to call this method
  def call_seq; end

  # Sets the different ways you can call this method.  If an empty +call_seq+
  # is given nil is assumed.
  #
  # See also #param_seq
  def call_seq=(call_seq); end

  # If true this method uses +super+ to call a superclass version
  def calls_super; end

  # If true this method uses +super+ to call a superclass version
  def calls_super=(_arg0); end

  # Don't rename \#initialize to \::new
  def dont_rename_initialize; end

  # Don't rename \#initialize to \::new
  def dont_rename_initialize=(_arg0); end

  # Whether the method has a call-seq.
  #
  # @return [Boolean]
  def has_call_seq?; end

  # Loads is_alias_for from the internal name.  Returns nil if the alias
  # cannot be found.
  def is_alias_for; end

  # Dumps this AnyMethod for use by ri.  See also #marshal_load
  def marshal_dump; end

  # Loads this AnyMethod from +array+.  For a loaded AnyMethod the following
  # methods will return cached values:
  #
  # * #full_name
  # * #parent_name
  def marshal_load(array); end

  # Method name
  #
  # If the method has no assigned name, it extracts it from #call_seq.
  def name; end

  # A list of this method's method and yield parameters.  +call-seq+ params
  # are preferred over parsed method and block params.
  def param_list; end

  # Pretty parameter list for this method.  If the method's parameters were
  # given by +call-seq+ it is preferred over the parsed values.
  def param_seq; end

  # Parameters for this method
  def params; end

  # Parameters for this method
  def params=(_arg0); end

  # The section title of the method (if defined in a C file via +:category:+)
  def section_title; end

  # The section title of the method (if defined in a C file via +:category:+)
  def section_title=(_arg0); end

  # Whether to skip the method description, true for methods that have
  # aliases with a call-seq that doesn't include the method name.
  #
  # @return [Boolean]
  def skip_description?; end

  # Sets the store for this method and its referenced code objects.
  def store=(store); end

  # For methods that +super+, find the superclass method that would be called.
  def superclass_method; end

  protected

  # call_seq without deduplication and alias lookup.
  def _call_seq; end

  private

  # call_seq with alias examples information removed, if this
  # method is an alias method.
  def deduplicate_call_seq(call_seq); end
end

# An attribute created by \#attr, \#attr_reader, \#attr_writer or
# \#attr_accessor
class RDoc::Attr < ::RDoc::MethodAttr
  # Creates a new Attr with body +text+, +name+, read/write status +rw+ and
  # +comment+.  +singleton+ marks this as a class attribute.
  #
  # @return [Attr] a new instance of Attr
  def initialize(text, name, rw, comment, singleton = T.unsafe(nil)); end

  # Attributes are equal when their names, singleton and rw are identical
  def ==(other); end

  # Add +an_alias+ as an attribute in +context+.
  def add_alias(an_alias, context); end

  # The #aref prefix for attributes
  def aref_prefix; end

  # Attributes never call super.  See RDoc::AnyMethod#calls_super
  #
  # An RDoc::Attr can show up in the method list in some situations (see
  # Gem::ConfigFile)
  def calls_super; end

  # Returns attr_reader, attr_writer or attr_accessor as appropriate.
  def definition; end

  def inspect; end

  # Dumps this Attr for use by ri.  See also #marshal_load
  def marshal_dump; end

  # Loads this Attr from +array+.  For a loaded Attr the following
  # methods will return cached values:
  #
  # * #full_name
  # * #parent_name
  def marshal_load(array); end

  def pretty_print(q); end

  # Is the attribute readable ('R'), writable ('W') or both ('RW')?
  def rw; end

  # Is the attribute readable ('R'), writable ('W') or both ('RW')?
  def rw=(_arg0); end

  def to_s; end

  # Attributes do not have token streams.
  #
  # An RDoc::Attr can show up in the method list in some situations (see
  # Gem::ConfigFile)
  def token_stream; end
end

# ClassModule is the base class for objects representing either a class or a
# module.
class RDoc::ClassModule < ::RDoc::Context
  # Creates a new ClassModule with +name+ with optional +superclass+
  #
  # This is a constructor for subclasses, and must never be called directly.
  #
  # @return [ClassModule] a new instance of ClassModule
  def initialize(name, superclass = T.unsafe(nil)); end

  # Adds +comment+ to this ClassModule's list of comments at +location+.  This
  # method is preferred over #comment= since it allows ri data to be updated
  # across multiple runs.
  def add_comment(comment, location); end

  def add_things(my_things, other_things); end

  # Ancestors list for this ClassModule: the list of included modules
  # (classes will add their superclass if any).
  #
  # Returns the included classes or modules, not the includes
  # themselves. The returned values are either String or
  # RDoc::NormalModule instances (see RDoc::Include#module).
  #
  # The values are returned in reverse order of their inclusion,
  # which is the order suitable for searching methods/attributes
  # in the ancestors. The superclass, if any, comes last.
  def ancestors; end

  # HTML fragment reference for this module or class.  See
  # RDoc::NormalClass#aref and RDoc::NormalModule#aref
  def aref; end

  # @raise [NotImplementedError]
  def aref_prefix; end

  # Clears the comment. Used by the Ruby parser.
  def clear_comment; end

  # This method is deprecated, use #add_comment instead.
  #
  # Appends +comment+ to the current comment, but separated by a rule.  Works
  # more like <tt>+=</tt>.
  def comment=(comment); end

  # Comment and the location it came from.  Use #add_comment to add comments
  def comment_location; end

  # Comment and the location it came from.  Use #add_comment to add comments
  def comment_location=(_arg0); end

  # Prepares this ClassModule for use by a generator.
  #
  # See RDoc::Store#complete
  def complete(min_visibility); end

  # Constants that are aliases for this class or module
  def constant_aliases; end

  # Constants that are aliases for this class or module
  def constant_aliases=(_arg0); end

  # Handy wrapper for marking up this class or module's comment
  def description; end

  def diagram; end
  def diagram=(_arg0); end

  # Ancestors list for this ClassModule: the list of included modules
  # (classes will add their superclass if any).
  #
  # Returns the included classes or modules, not the includes
  # themselves. The returned values are either String or
  # RDoc::NormalModule instances (see RDoc::Include#module).
  #
  # The values are returned in reverse order of their inclusion,
  # which is the order suitable for searching methods/attributes
  # in the ancestors. The superclass, if any, comes last.
  #
  # Ancestors of this class or module only
  def direct_ancestors; end

  # Does this ClassModule or any of its methods have document_self set?
  def document_self_or_methods; end

  # Does this class or module have a comment with content or is
  # #received_nodoc true?
  #
  # @return [Boolean]
  def documented?; end

  # Iterates the ancestors of this class or module for which an
  # RDoc::ClassModule exists.
  def each_ancestor; end

  # Looks for a symbol in the #ancestors. See Context#find_local_symbol.
  def find_ancestor_local_symbol(symbol); end

  # Finds a class or module with +name+ in this namespace or its descendants
  def find_class_named(name); end

  # Return the fully qualified name of this class or module
  def full_name; end

  # Class or module this constant is an alias for
  def is_alias_for; end

  # Class or module this constant is an alias for
  def is_alias_for=(_arg0); end

  # TODO: filter included items by #display?
  def marshal_dump; end

  def marshal_load(array); end

  # Merges +class_module+ into this ClassModule.
  #
  # The data in +class_module+ is preferred over the receiver.
  def merge(class_module); end

  # Merges collection +mine+ with +other+ preferring other.  +other_files+ is
  # used to help determine which items should be deleted.
  #
  # Yields whether the item should be added or removed (true or false) and the
  # item to be added or removed.
  #
  #   merge_collections things, other.things, other.in_files do |add, thing|
  #     if add then
  #       # add the thing
  #     else
  #       # remove the thing
  #     end
  #   end
  def merge_collections(mine, other, other_files, &block); end

  # Merges the comments in this ClassModule with the comments in the other
  # ClassModule +cm+.
  def merge_sections(cm); end

  # Does this object represent a module?
  #
  # @return [Boolean]
  def module?; end

  # Allows overriding the initial name.
  #
  # Used for modules and classes that are constant aliases.
  def name=(new_name); end

  # Name to use to generate the url:
  # modules and classes that are aliases for another
  # module or class return the name of the latter.
  def name_for_path; end

  # Returns the classes and modules that are not constants
  # aliasing another class or module. For use by formatters
  # only (caches its result).
  def non_aliases; end

  # Parses +comment_location+ into an RDoc::Markup::Document composed of
  # multiple RDoc::Markup::Documents with their file set.
  def parse(comment_location); end

  # Path to this class or module for use with HTML generator output.
  def path; end

  # Updates the child modules or classes of class/module +parent+ by
  # deleting the ones that have been removed from the documentation.
  #
  # +parent_hash+ is either <tt>parent.modules_hash</tt> or
  # <tt>parent.classes_hash</tt> and +all_hash+ is ::all_modules_hash or
  # ::all_classes_hash.
  def remove_nodoc_children; end

  def remove_things(my_things, other_files); end

  # Search record used by RDoc::Generator::JsonIndex
  def search_record; end

  # Sets the store for this class or module and its contained code objects.
  def store=(store); end

  # Get the superclass of this class.  Attempts to retrieve the superclass
  # object, returns the name if it is not known.
  def superclass; end

  # Set the superclass of this class to +superclass+
  #
  # @raise [NoMethodError]
  def superclass=(superclass); end

  def to_s; end

  # 'module' or 'class'
  def type; end

  # Updates the child modules & classes by replacing the ones that are
  # aliases through a constant.
  #
  # The aliased module/class is replaced in the children and in
  # RDoc::Store#modules_hash or RDoc::Store#classes_hash
  # by a copy that has <tt>RDoc::ClassModule#is_alias_for</tt> set to
  # the aliased module/class, and this copy is added to <tt>#aliases</tt>
  # of the aliased module/class.
  #
  # Formatters can use the #non_aliases method to retrieve children that
  # are not aliases, for instance to list the namespace content, since
  # the aliased modules are included in the constants of the class/module,
  # that are listed separately.
  def update_aliases; end

  # Deletes from #extends those whose module has been removed from the
  # documentation.
  # --
  # FIXME: like update_includes, extends are not reliably removed
  def update_extends; end

  # Deletes from #includes those whose module has been removed from the
  # documentation.
  # --
  # FIXME: includes are not reliably removed, see _possible_bug test case
  def update_includes; end

  class << self
    # Return a RDoc::ClassModule of class +class_type+ that is a copy
    # of module +module+. Used to promote modules to classes.
    # --
    # TODO move to RDoc::NormalClass (I think)
    def from_module(class_type, mod); end
  end
end

# Base class for the RDoc code tree.
#
# We contain the common stuff for contexts (which are containers) and other
# elements (methods, attributes and so on)
#
# Here's the tree of the CodeObject subclasses:
#
# * RDoc::Context
#   * RDoc::TopLevel
#   * RDoc::ClassModule
#     * RDoc::AnonClass (never used so far)
#     * RDoc::NormalClass
#     * RDoc::NormalModule
#     * RDoc::SingleClass
# * RDoc::MethodAttr
#   * RDoc::Attr
#   * RDoc::AnyMethod
#     * RDoc::GhostMethod
#     * RDoc::MetaMethod
# * RDoc::Alias
# * RDoc::Constant
# * RDoc::Mixin
#   * RDoc::Require
#   * RDoc::Include
class RDoc::CodeObject
  include ::RDoc::Text
  include ::RDoc::Generator::Markup

  # Creates a new CodeObject that will document itself and its children
  #
  # @return [CodeObject] a new instance of CodeObject
  def initialize; end

  # Our comment
  def comment; end

  # Replaces our comment with +comment+, unless it is empty.
  def comment=(comment); end

  # Should this CodeObject be displayed in output?
  #
  # A code object should be displayed if:
  #
  # * The item didn't have a nodoc or wasn't in a container that had nodoc
  # * The item wasn't ignored
  # * The item has documentation and was not suppressed
  #
  # @return [Boolean]
  def display?; end

  # Do we document our children?
  def document_children; end

  # Enables or disables documentation of this CodeObject's children unless it
  # has been turned off by :enddoc:
  def document_children=(document_children); end

  # Do we document ourselves?
  def document_self; end

  # Enables or disables documentation of this CodeObject unless it has been
  # turned off by :enddoc:.  If the argument is +nil+ it means the
  def document_self=(document_self); end

  # Does this object have a comment with content or is #received_nodoc true?
  #
  # @return [Boolean]
  def documented?; end

  # Are we done documenting (ie, did we come across a :enddoc:)?
  def done_documenting; end

  # Turns documentation on/off, and turns on/off #document_self
  # and #document_children.
  #
  # Once documentation has been turned off (by +:enddoc:+),
  # the object will refuse to turn #document_self or
  # will have no effect in the current file.
  def done_documenting=(value); end

  # Yields each parent of this CodeObject.  See also
  # RDoc::ClassModule#each_ancestor
  def each_parent; end

  # Which file this code object was defined in
  def file; end

  # File name where this CodeObject was found.
  #
  # See also RDoc::Context#in_files
  def file_name; end

  # Force documentation of this CodeObject
  def force_documentation; end

  # Force the documentation of this object unless documentation
  # has been turned off by :enddoc:
  # --
  # HACK untested, was assigning to an ivar
  def force_documentation=(value); end

  # Sets the full_name overriding any computed full name.
  #
  # Set to +nil+ to clear RDoc's cached value
  def full_name=(full_name); end

  # Use this to ignore a CodeObject and all its children until found again
  # (#record_location is called).  An ignored item will not be displayed in
  # documentation.
  #
  # See github issue #55
  #
  # The ignored status is temporary in order to allow implementation details
  # to be hidden.  At the end of processing a file RDoc allows all classes
  # and modules to add new documentation to previously created classes.
  #
  # If a class was ignored (via stopdoc) then reopened later with additional
  # documentation it should be displayed.  If a class was ignored and never
  # reopened it should not be displayed.  The ignore flag allows this to
  # occur.
  def ignore; end

  # Has this class been ignored?
  #
  # See also #ignore
  #
  # @return [Boolean]
  def ignored?; end

  # Initializes state for visibility of this CodeObject and its children.
  def initialize_visibility; end

  # Line in #file where this CodeObject was defined
  def line; end

  # Line in #file where this CodeObject was defined
  def line=(_arg0); end

  # Hash of arbitrary metadata for this CodeObject
  def metadata; end

  # The options instance from the store this CodeObject is attached to, or a
  # default options instance if the CodeObject is not attached.
  #
  # This is used by Text#snippet
  def options; end

  # Our parent CodeObject.  The parent may be missing for classes loaded from
  # legacy RI data stores.
  def parent; end

  # Sets the parent CodeObject
  def parent=(_arg0); end

  # File name of our parent
  def parent_file_name; end

  # Name of our parent
  def parent_name; end

  def received_nodoc; end

  # Records the RDoc::TopLevel (file) where this code object was defined
  def record_location(top_level); end

  # The section this CodeObject is in.  Sections allow grouping of constants,
  # attributes and methods inside a class or module.
  def section; end

  # Set the section this CodeObject is in
  def section=(_arg0); end

  # Enable capture of documentation unless documentation has been
  # turned off by :enddoc:
  def start_doc; end

  # Disable capture of documentation
  def stop_doc; end

  # The RDoc::Store for this object.
  def store; end

  # Sets the +store+ that contains this CodeObject
  def store=(store); end

  # Use this to suppress a CodeObject and all its children until the next file
  # it is seen in or documentation is discovered.  A suppressed item with
  # documentation will be displayed while an ignored item with documentation
  # may not be displayed.
  def suppress; end

  # Has this class been suppressed?
  #
  # See also #suppress
  #
  # @return [Boolean]
  def suppressed?; end

  # We are the model of the code, but we know that at some point we will be
  # worked on by viewers. By implementing the Viewable protocol, viewers can
  # associated themselves with these objects.
  def viewer; end

  # We are the model of the code, but we know that at some point we will be
  # worked on by viewers. By implementing the Viewable protocol, viewers can
  # associated themselves with these objects.
  def viewer=(_arg0); end
end

class RDoc::Comment
  include ::RDoc::Text

  # Creates a new comment with +text+ that is found in the RDoc::TopLevel
  # +location+.
  #
  # @return [Comment] a new instance of Comment
  def initialize(text = T.unsafe(nil), location = T.unsafe(nil), language = T.unsafe(nil)); end

  def ==(other); end

  # Overrides the content returned by #parse.  Use when there is no #text
  # source for this comment
  def document=(_arg0); end

  # A comment is empty if its text String is empty.
  #
  # @return [Boolean]
  def empty?; end

  # HACK dubious
  def encode!(encoding); end

  # Look for a 'call-seq' in the comment to override the normal parameter
  # handling.  The :call-seq: is indented from the baseline.  All lines of the
  # same indentation level and prefix are consumed.
  #
  # For example, all of the following will be used as the :call-seq:
  #
  #   # :call-seq:
  #   #   ARGF.readlines(sep=$/)     -> array
  #   #   ARGF.readlines(limit)      -> array
  #   #   ARGF.readlines(sep, limit) -> array
  #   #
  #   #   ARGF.to_a(sep=$/)     -> array
  #   #   ARGF.to_a(limit)      -> array
  #   #   ARGF.to_a(sep, limit) -> array
  def extract_call_seq(method); end

  # The RDoc::TopLevel this comment was found in
  #
  # For duck-typing when merging classes at load time
  def file; end

  # The format of this comment.  Defaults to RDoc::Markup
  def format; end

  # Sets the format of this comment and resets any parsed document
  def format=(format); end

  def inspect; end

  # Line where this Comment was written
  def line; end

  # Line where this Comment was written
  def line=(_arg0); end

  # The RDoc::TopLevel this comment was found in
  def location; end

  # The RDoc::TopLevel this comment was found in
  def location=(_arg0); end

  # Normalizes the text.  See RDoc::Text#normalize_comment for details
  def normalize; end

  # Was this text normalized?
  #
  # @return [Boolean]
  def normalized?; end

  # Parses the comment into an RDoc::Markup::Document.  The parsed document is
  # cached until the text is changed.
  def parse; end

  # Removes private sections from this comment.  Private sections are flush to
  # the comment marker and start with <tt>--</tt> and end with <tt>++</tt>.
  # For C-style comments, a private marker may not start at the opening of the
  # comment.
  #
  #   /*
  #    *--
  #    * private
  #    *++
  #    * public
  #    */
  def remove_private; end

  # The text for this comment
  def text; end

  # Replaces this comment's text with +text+ and resets the parsed document.
  #
  # An error is raised if the comment contains a document but no text.
  #
  # @raise [RDoc::Error]
  def text=(text); end

  # The text for this comment
  #
  # Alias for text
  def to_s; end

  # Returns true if this comment is in TomDoc format.
  #
  # @return [Boolean]
  def tomdoc?; end

  private

  # --
  # TODO deep copy @document
  def initialize_copy(copy); end
end

# A constant
class RDoc::Constant < ::RDoc::CodeObject
  # Creates a new constant with +name+, +value+ and +comment+
  #
  # @return [Constant] a new instance of Constant
  def initialize(name, value, comment); end

  # Constants are ordered by name
  def <=>(other); end

  # Constants are equal when their #parent and #name is the same
  def ==(other); end

  # A constant is documented if it has a comment, or is an alias
  # for a documented class or module.
  #
  # @return [Boolean]
  def documented?; end

  # Full constant name including namespace
  def full_name; end

  def inspect; end

  # The module or class this constant is an alias for
  def is_alias_for; end

  # Sets the module or class this is constant is an alias for.
  def is_alias_for=(_arg0); end

  # Dumps this Constant for use by ri.  See also #marshal_load
  def marshal_dump; end

  # Loads this Constant from +array+.  For a loaded Constant the following
  # methods will return cached values:
  #
  # * #full_name
  # * #parent_name
  def marshal_load(array); end

  # The constant's name
  def name; end

  # The constant's name
  def name=(_arg0); end

  # Path to this constant for use with HTML generator output.
  def path; end

  def pretty_print(q); end

  # Sets the store for this class or module and its contained code objects.
  def store=(store); end

  def to_s; end

  # The constant's value
  def value; end

  # The constant's value
  def value=(_arg0); end

  # The constant's visibility
  def visibility; end

  # The constant's visibility
  def visibility=(_arg0); end
end

# A Context is something that can hold modules, classes, methods, attributes,
# aliases, requires, and includes. Classes, modules, and files are all
# Contexts.
class RDoc::Context < ::RDoc::CodeObject
  include ::Comparable

  # Creates an unnamed empty context with public current visibility
  #
  # @return [Context] a new instance of Context
  def initialize; end

  # Contexts are sorted by full_name
  def <=>(other); end

  # Adds an item of type +klass+ with the given +name+ and +comment+ to the
  # context.
  #
  # Currently only RDoc::Extend and RDoc::Include are supported.
  def add(klass, name, comment); end

  # Adds +an_alias+ that is automatically resolved
  def add_alias(an_alias); end

  # Adds +attribute+ if not already there. If it is (as method(s) or attribute),
  # updates the comment if it was empty.
  #
  # The attribute is registered only if it defines a new method.
  # For instance, <tt>attr_reader :foo</tt> will not be registered
  # if method +foo+ exists, but <tt>attr_accessor :foo</tt> will be registered
  # if method +foo+ exists, but <tt>foo=</tt> does not.
  def add_attribute(attribute); end

  # Adds a class named +given_name+ with +superclass+.
  #
  # Both +given_name+ and +superclass+ may contain '::', and are
  # interpreted relative to the +self+ context. This allows handling correctly
  # examples like these:
  #   class RDoc::Gauntlet < Gauntlet
  #   module Mod
  #     class Object   # implies < ::Object
  #     class SubObject < Object  # this is _not_ ::Object
  #
  # Given <tt>class Container::Item</tt> RDoc assumes +Container+ is a module
  # unless it later sees <tt>class Container</tt>.  +add_class+ automatically
  # upgrades +given_name+ to a class in this case.
  def add_class(class_type, given_name, superclass = T.unsafe(nil)); end

  # Adds the class or module +mod+ to the modules or
  # classes Hash +self_hash+, and to +all_hash+ (either
  # <tt>TopLevel::modules_hash</tt> or <tt>TopLevel::classes_hash</tt>),
  # unless #done_documenting is +true+. Sets the #parent of +mod+
  # to +self+, and its #section to #current_section. Returns +mod+.
  def add_class_or_module(mod, self_hash, all_hash); end

  # Adds +constant+ if not already there. If it is, updates the comment,
  # value and/or is_alias_for of the known constant if they were empty/nil.
  def add_constant(constant); end

  # Adds extension module +ext+ which should be an RDoc::Extend
  def add_extend(ext); end

  # Adds included module +include+ which should be an RDoc::Include
  def add_include(include); end

  # Adds +method+ if not already there. If it is (as method or attribute),
  # updates the comment if it was empty.
  def add_method(method); end

  # Adds a module named +name+.  If RDoc already knows +name+ is a class then
  # that class is returned instead.  See also #add_class.
  def add_module(class_type, name); end

  # Adds an alias from +from+ (a class or module) to +name+ which was defined
  # in +file+.
  def add_module_alias(from, from_name, to, file); end

  # Adds a module by +RDoc::NormalModule+ instance. See also #add_module.
  def add_module_by_normal_module(mod); end

  # Adds +require+ to this context's top level
  def add_require(require); end

  # Returns a section with +title+, creating it if it doesn't already exist.
  # +comment+ will be appended to the section's comment.
  #
  # A section with a +title+ of +nil+ will return the default section.
  #
  # See also RDoc::Context::Section
  def add_section(title, comment = T.unsafe(nil)); end

  # Adds +thing+ to the collection +array+
  def add_to(array, thing); end

  # Class/module aliases
  def aliases; end

  # Is there any content?
  #
  # This means any of: comment, aliases, methods, attributes, external
  # aliases, require, constant.
  #
  # Includes and extends are also checked unless <tt>includes == false</tt>.
  def any_content(includes = T.unsafe(nil)); end

  # All attr* methods
  def attributes; end

  # Block params to be used in the next MethodAttr parsed under this context
  def block_params; end

  # Block params to be used in the next MethodAttr parsed under this context
  def block_params=(_arg0); end

  # Creates the full name for a child with +name+
  def child_name(name); end

  # Class attributes
  def class_attributes; end

  # Class methods
  def class_method_list; end

  # Array of classes in this context
  def classes; end

  # All classes and modules in this namespace
  def classes_and_modules; end

  # Hash of classes keyed by class name
  def classes_hash; end

  # Constants defined
  def constants; end

  # Hash of registered constants.
  def constants_hash; end

  # Current visibility of this line
  def current_line_visibility=(_arg0); end

  # The current documentation section that new items will be added to.  If
  # temporary_section is available it will be used.
  def current_section; end

  # Sets the current documentation section of documentation
  def current_section=(_arg0); end

  # Is part of this thing was defined in +file+?
  #
  # @return [Boolean]
  def defined_in?(file); end

  def display(method_attr); end

  # Iterator for ancestors for duck-typing.  Does nothing.  See
  # RDoc::ClassModule#each_ancestor.
  #
  # This method exists to make it easy to work with Context subclasses that
  # aren't part of RDoc.
  def each_ancestor(&_); end

  # Iterator for attributes
  def each_attribute; end

  # Iterator for classes and modules
  def each_classmodule(&block); end

  # Iterator for constants
  def each_constant; end

  # Iterator for extension modules
  def each_extend; end

  # Iterator for included modules
  def each_include; end

  # Iterator for methods
  def each_method; end

  # Iterator for each section's contents sorted by title.  The +section+, the
  # section's +constants+ and the sections +attributes+ are yielded.  The
  # +constants+ and +attributes+ collections are sorted.
  #
  # To retrieve methods in a section use #methods_by_type with the optional
  # +section+ parameter.
  #
  # NOTE: Do not edit collections yielded by this method
  def each_section; end

  # Modules this context is extended with
  def extends; end

  # Aliases that could not be resolved.
  def external_aliases; end

  # Finds an attribute +name+ with singleton value +singleton+.
  def find_attribute(name, singleton); end

  # Finds an attribute with +name+ in this context
  def find_attribute_named(name); end

  # Finds a class method with +name+ in this context
  def find_class_method_named(name); end

  # Finds a constant with +name+ in this context
  def find_constant_named(name); end

  # Find a module at a higher scope
  def find_enclosing_module_named(name); end

  # Finds an external alias +name+ with singleton value +singleton+.
  def find_external_alias(name, singleton); end

  # Finds an external alias with +name+ in this context
  def find_external_alias_named(name); end

  # Finds a file with +name+ in this context
  def find_file_named(name); end

  # Finds an instance method with +name+ in this context
  def find_instance_method_named(name); end

  # Finds a method, constant, attribute, external alias, module or file
  # named +symbol+ in this context.
  def find_local_symbol(symbol); end

  # Finds a method named +name+ with singleton value +singleton+.
  def find_method(name, singleton); end

  # Finds a instance or module method with +name+ in this context
  def find_method_named(name); end

  # Find a module with +name+ using ruby's scoping rules
  def find_module_named(name); end

  # Look up +symbol+, first as a module, then as a local symbol.
  def find_symbol(symbol); end

  # Look up a module named +symbol+.
  def find_symbol_module(symbol); end

  # The full name for this context.  This method is overridden by subclasses.
  def full_name; end

  # Does this context and its methods and constants all have documentation?
  #
  # (Yes, fully documented doesn't mean everything.)
  #
  # @return [Boolean]
  def fully_documented?; end

  # URL for this with a +prefix+
  def http_url(prefix); end

  # Files this context is found in
  def in_files; end

  # Modules this context includes
  def includes; end

  # Sets the defaults for methods and so-forth
  def initialize_methods_etc; end

  # Instance attributes
  def instance_attributes; end

  # Instance methods
  # --
  # TODO remove this later
  def instance_method_list; end

  # Instance methods
  def instance_methods; end

  # Methods defined in this context
  def method_list; end

  # Breaks method_list into a nested hash by type (<tt>'class'</tt> or
  # <tt>'instance'</tt>) and visibility (+:public+, +:protected+, +:private+).
  #
  # If +section+ is provided only methods in that RDoc::Context::Section will
  # be returned.
  def methods_by_type(section = T.unsafe(nil)); end

  # Hash of registered methods. Attributes are also registered here,
  # twice if they are RW.
  def methods_hash; end

  # Yields AnyMethod and Attr entries matching the list of names in +methods+.
  def methods_matching(methods, singleton = T.unsafe(nil), &block); end

  # Array of modules in this context
  def modules; end

  # Hash of modules keyed by module name
  def modules_hash; end

  # Name of this class excluding namespace.  See also full_name
  def name; end

  # Name to use to generate the url.
  # <tt>#full_name</tt> by default.
  def name_for_path; end

  # Changes the visibility for new methods to +visibility+
  def ongoing_visibility=(visibility); end

  # Params to be used in the next MethodAttr parsed under this context
  def params; end

  # Params to be used in the next MethodAttr parsed under this context
  def params=(_arg0); end

  # Record +top_level+ as a file +self+ is in.
  def record_location(top_level); end

  # Should we remove this context from the documentation?
  #
  # The answer is yes if:
  # * #received_nodoc is +true+
  # * #any_content is +false+ (not counting includes)
  # * All #includes are modules (not a string), and their module has
  #   <tt>#remove_from_documentation? == true</tt>
  # * All classes and modules have <tt>#remove_from_documentation? == true</tt>
  #
  # @return [Boolean]
  def remove_from_documentation?; end

  # Removes methods and attributes with a visibility less than +min_visibility+.
  # --
  # TODO mark the visibility of attributes in the template (if not public?)
  def remove_invisible(min_visibility); end

  # Only called when min_visibility == :public or :private
  def remove_invisible_in(array, min_visibility); end

  # Files this context requires
  def requires; end

  # Tries to resolve unmatched aliases when a method or attribute has just
  # been added.
  def resolve_aliases(added); end

  # Returns RDoc::Context::Section objects referenced in this context for use
  # in a table of contents.
  def section_contents; end

  # Sections in this context
  def sections; end

  def sections_hash; end

  # Given an array +names+ of constants, set the visibility of each constant to
  # +visibility+
  def set_constant_visibility_for(names, visibility); end

  # Sets the current section to a section with +title+.  See also #add_section
  def set_current_section(title, comment); end

  # Given an array +methods+ of method names, set the visibility of each to
  # +visibility+
  def set_visibility_for(methods, visibility, singleton = T.unsafe(nil)); end

  # Sorts sections alphabetically (default) or in TomDoc fashion (none,
  # Public, Internal, Deprecated)
  def sort_sections; end

  # Use this section for the next method, attribute or constant added.
  def temporary_section; end

  # Use this section for the next method, attribute or constant added.
  def temporary_section=(_arg0); end

  def to_s; end

  # Return the TopLevel that owns us
  # --
  # FIXME we can be 'owned' by several TopLevel (see #record_location &
  # #in_files)
  def top_level; end

  # Hash <tt>old_name => [aliases]</tt>, for aliases
  # that haven't (yet) been resolved to a method/attribute.
  # (Not to be confused with the aliases of the context.)
  def unmatched_alias_lists; end

  # Hash <tt>old_name => [aliases]</tt>, for aliases
  # that haven't (yet) been resolved to a method/attribute.
  # (Not to be confused with the aliases of the context.)
  def unmatched_alias_lists=(_arg0); end

  # Upgrades NormalModule +mod+ in +enclosing+ to a +class_type+
  def upgrade_to_class(mod, class_type, enclosing); end

  # Current visibility of this context
  def visibility; end

  # Current visibility of this context
  def visibility=(_arg0); end
end

# A section of documentation like:
#
#   # :section: The title
#   # The body
#
# Sections can be referenced multiple times and will be collapsed into a
# single section.
class RDoc::Context::Section
  include ::RDoc::Text
  include ::RDoc::Generator::Markup

  # Creates a new section with +title+ and +comment+
  #
  # @return [Section] a new instance of Section
  def initialize(parent, title, comment); end

  # Sections are equal when they have the same #title
  def ==(other); end

  # Adds +comment+ to this section
  def add_comment(comment); end

  # Anchor reference for linking to this section
  def aref; end

  # Section comment
  def comment; end

  # Section comments
  def comments; end

  # Sections are equal when they have the same #title
  def eql?(other); end

  # Extracts the comment for this section from the original comment block.
  # If the first line contains :section:, strip it and use the rest.
  # Otherwise remove lines up to the line containing :section:, and look
  # for those lines again at the end and remove them. This lets us write
  #
  #   # :section: The title
  #   # The body
  def extract_comment(comment); end

  def hash; end

  # The files comments in this section come from
  def in_files; end

  def inspect; end

  # Serializes this Section.  The title and parsed comment are saved, but not
  # the section parent which must be restored manually.
  def marshal_dump; end

  # De-serializes this Section.  The section parent must be restored manually.
  def marshal_load(array); end

  # Context this Section lives in
  def parent; end

  # Parses +comment_location+ into an RDoc::Markup::Document composed of
  # multiple RDoc::Markup::Documents with their file set.
  def parse; end

  # The section's title, or 'Top Section' if the title is nil.
  #
  # This is used by the table of contents template so the name is silly.
  def plain_html; end

  # Removes a comment from this section if it is from the same file as
  # +comment+
  def remove_comment(comment); end

  # Section title
  def title; end
end

# RDoc::CrossReference is a reusable way to create cross references for names.
class RDoc::CrossReference
  # Allows cross-references to be created based on the given +context+
  # (RDoc::Context).
  #
  # @return [CrossReference] a new instance of CrossReference
  def initialize(context); end

  # Returns a reference to +name+.
  #
  # If the reference is found and +name+ is not documented +text+ will be
  # returned.  If +name+ is escaped +name+ is returned.  If +name+ is not
  # found +text+ is returned.
  def resolve(name, text); end

  # Returns a method reference to +name+.
  def resolve_method(name); end

  # Hash of references that have been looked-up to their replacements
  def seen; end

  # Hash of references that have been looked-up to their replacements
  def seen=(_arg0); end
end

# Regular expression to match method arguments.
RDoc::CrossReference::METHOD_ARGS_REGEXP_STR = T.let(T.unsafe(nil), String)

# Regular expression to match a single method argument.
RDoc::CrossReference::METHOD_ARG_REGEXP_STR = T.let(T.unsafe(nil), String)

# A subclass of ERB that writes directly to an IO.  Credit to Aaron Patterson
# and Masatoshi SEKI.
#
# To use:
#
#   erbio = RDoc::ERBIO.new '<%= "hello world" %>', nil, nil
#
#   File.open 'hello.txt', 'w' do |io|
#     erbio.result binding
#   end
#
# Note that binding must enclose the io you wish to output on.
class RDoc::ERBIO < ::ERB
  # Defaults +eoutvar+ to 'io', otherwise is identical to ERB's initialize
  #
  # @return [ERBIO] a new instance of ERBIO
  def initialize(str, trim_mode: T.unsafe(nil), eoutvar: T.unsafe(nil)); end

  # Instructs +compiler+ how to write to +io_variable+
  def set_eoutvar(compiler, io_variable); end
end

# Allows an ERB template to be rendered in the context (binding) of an
# existing ERB template evaluation.
class RDoc::ERBPartial < ::ERB
  # Overrides +compiler+ startup to set the +eoutvar+ to an empty string only
  # if it isn't already set.
  def set_eoutvar(compiler, eoutvar = T.unsafe(nil)); end
end

# This class is a wrapper around File IO and Encoding that helps RDoc load
# files and convert them to the correct encoding.
module RDoc::Encoding
  class << self
    # Changes encoding based on +encoding+ without converting and returns new
    # string
    def change_encoding(text, encoding); end

    # Detects the encoding of +string+ based on the magic comment
    def detect_encoding(string); end

    # Reads the contents of +filename+ and handles any encoding directives in
    # the file.
    #
    # The content will be converted to the +encoding+.  If the file cannot be
    # converted a warning will be printed and nil will be returned.
    #
    # If +force_transcode+ is true the document will be transcoded and any
    # unknown character in the target encoding will be replaced with '?'
    def read_file(filename, encoding, force_transcode = T.unsafe(nil)); end

    # Removes magic comments and shebang
    def remove_magic_comment(string); end
  end
end

RDoc::Encoding::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)

class RDoc::Generator::Darkfish
  include ::ERB::Escape
  include ::ERB::Util
  include ::ActiveSupport::CoreExt::ERBUtil
  include ::ActiveSupport::CoreExt::ERBUtilPrivate

  # Initialize a few instance variables before we start
  #
  # @return [Darkfish] a new instance of Darkfish
  def initialize(store, options); end

  # Creates a template from its components and the +body_file+.
  #
  # For backwards compatibility, if +body_file+ contains "<html" the body is
  # used directly.
  def assemble_template(body_file); end

  # The relative path to style sheets and javascript.  By default this is set
  # the same as the rel_prefix.
  def asset_rel_path; end

  # The relative path to style sheets and javascript.  By default this is set
  # the same as the rel_prefix.
  def asset_rel_path=(_arg0); end

  # The path to generate files into, combined with <tt>--op</tt> from the
  # options for a full path.
  def base_dir; end

  # Directory where generated class HTML files live relative to the output
  # dir.
  def class_dir; end

  # Classes and modules to be used by this generator, not necessarily
  # displayed.  See also #modsort
  def classes; end

  # Copies static files from the static_path into the output directory
  def copy_static; end

  # Output progress information if debugging is enabled
  def debug_msg(*msg); end

  # No files will be written when dry_run is true.
  def dry_run; end

  # No files will be written when dry_run is true.
  def dry_run=(_arg0); end

  # Directory where generated class HTML files live relative to the output
  # dir.
  def file_dir; end

  # When false the generate methods return a String instead of writing to a
  # file.  The default is true.
  def file_output; end

  # When false the generate methods return a String instead of writing to a
  # file.  The default is true.
  def file_output=(_arg0); end

  # Files to be displayed by this generator
  def files; end

  # Create the directories the generated docs will live in if they don't
  # already exist.
  def gen_sub_directories; end

  # Build the initial indices and output objects based on an array of TopLevel
  # objects containing the extracted information.
  def generate; end

  # Generates a class file for +klass+
  def generate_class(klass, template_file = T.unsafe(nil)); end

  # Generate a documentation file for each class and module
  def generate_class_files; end

  # Generate a documentation file for each file
  def generate_file_files; end

  # Generate an index page which lists all the classes which are documented.
  def generate_index; end

  # Generate a page file for +file+
  def generate_page(file); end

  # Generates the 404 page for the RDoc servlet
  def generate_servlet_not_found(message); end

  # Generates the servlet root page for the RDoc servlet
  def generate_servlet_root(installed); end

  # Generate an index page which lists all the classes which are documented.
  def generate_table_of_contents; end

  # Return a list of the documented modules sorted by salience first, then
  # by name.
  def get_sorted_module_list(classes); end

  # Try to extract Subversion information out of the first constant whose
  # value looks like a subversion Id tag. If no matching constant is found,
  # and empty hash is returned.
  def get_svninfo(klass); end

  def install_rdoc_static_file(source, destination, options); end

  # The JSON index generator for this Darkfish generator
  def json_index; end

  # Methods to be displayed by this generator
  def methods; end

  # Sorted list of classes and modules to be displayed by this generator
  def modsort; end

  # The output directory
  def outputdir; end

  # Renders the ERb contained in +file_name+ relative to the template
  # directory and returns the result based on the current context.
  def render(file_name); end

  # Load and render the erb template in the given +template_file+ and write
  # it out to +out_file+.
  #
  # Both +template_file+ and +out_file+ should be Pathname-like objects.
  #
  # An io will be yielded which must be captured by binding in the caller.
  def render_template(template_file, out_file = T.unsafe(nil)); end

  # Prepares for generation of output from the current directory
  def setup; end

  # The RDoc::Store that is the source of the generated content
  def store; end

  # The directory where the template files live
  def template_dir; end

  # Retrieves a cache template for +file+, if present, or fills the cache.
  def template_for(file, page = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Creates the result for +template+ with +context+.  If an error is raised a
  # Pathname +template_file+ will indicate the file where the error occurred.
  def template_result(template, context, template_file); end

  # Return a string describing the amount of time in the given number of
  # seconds in terms a human can understand easily.
  def time_delta_string(seconds); end

  # Copy over the stylesheet into the appropriate place in the output
  # directory.
  def write_style_sheet; end
end

class RDoc::Generator::JsonIndex
  include ::RDoc::Text

  # Creates a new generator.  +parent_generator+ is used to determine the
  # class_dir and file_dir of links in the output index.
  #
  # +options+ are the same options passed to the parent generator.
  #
  # @return [JsonIndex] a new instance of JsonIndex
  def initialize(parent_generator, options); end

  # Builds the JSON index as a Hash.
  def build_index; end

  # The directory classes are written to
  def class_dir; end

  # Output progress information if debugging is enabled
  def debug_msg(*msg); end

  # The directory files are written to
  def file_dir; end

  # Writes the JSON index to disk
  def generate; end

  # Compress the search_index.js file using gzip
  def generate_gzipped; end

  def index; end

  # Adds classes and modules to the index
  def index_classes; end

  # Adds methods to the index
  def index_methods; end

  # Adds pages to the index
  def index_pages; end

  def reset(files, classes); end

  # Removes whitespace and downcases +string+
  def search_string(string); end
end

# Generates a POT file.
#
# Here is a translator work flow with the generator.
#
# == Create .pot
#
# You create .pot file by pot formatter:
#
#   % rdoc --format pot
#
# It generates doc/rdoc.pot.
#
# == Create .po
#
# You create .po file from doc/rdoc.pot. This operation is needed only
# the first time. This work flow assumes that you are a translator
# for Japanese.
#
# You create locale/ja/rdoc.po from doc/rdoc.pot. You can use msginit
# provided by GNU gettext or rmsginit provided by gettext gem. This
# work flow uses gettext gem because it is more portable than GNU
# gettext for Rubyists. Gettext gem is implemented by pure Ruby.
#
#   % gem install gettext
#   % mkdir -p locale/ja
#   % rmsginit --input doc/rdoc.pot --output locale/ja/rdoc.po --locale ja
#
# Translate messages in .po
#
# You translate messages in .po by a PO file editor. po-mode.el exists
# for Emacs users. There are some GUI tools such as GTranslator.
# There are some Web services such as POEditor and Tansifex. You can
# edit by your favorite text editor because .po is a text file.
# Generate localized documentation
#
# You can generate localized documentation with locale/ja/rdoc.po:
#
#   % rdoc --locale ja
#
# You can find documentation in Japanese in doc/. Yay!
#
# == Update translation
#
# You need to update translation when your application is added or
# modified messages.
#
# You can update .po by the following command lines:
#
#   % rdoc --format pot
#   % rmsgmerge --update locale/ja/rdoc.po doc/rdoc.pot
#
# You edit locale/ja/rdoc.po to translate new messages.
class RDoc::Generator::POT
  # Set up a new .pot generator
  #
  # @return [POT] a new instance of POT
  def initialize(store, options); end

  def class_dir; end

  # Writes .pot to disk.
  def generate; end

  private

  def extract_messages; end
end

# Extracts message from RDoc::Store
class RDoc::Generator::POT::MessageExtractor
  # Creates a message extractor for +store+.
  #
  # @return [MessageExtractor] a new instance of MessageExtractor
  def initialize(store); end

  # Extracts messages from +store+, stores them into
  # RDoc::Generator::POT::PO and returns it.
  def extract; end

  private

  def entry(msgid, options); end
  def extract_from_klass(klass); end
  def extract_text(text, comment, location = T.unsafe(nil)); end
end

# Generates a PO format text
class RDoc::Generator::POT::PO
  # Creates an object that represents PO format.
  #
  # @return [PO] a new instance of PO
  def initialize; end

  # Adds a PO entry to the PO.
  def add(entry); end

  # Returns PO format text for the PO.
  def to_s; end

  private

  def add_header; end
  def header_entry; end
  def sort_entries; end
end

# A PO entry in PO
class RDoc::Generator::POT::POEntry
  # Creates a PO entry for +msgid+. Other valus can be specified by
  # +options+.
  #
  # @return [POEntry] a new instance of POEntry
  def initialize(msgid, options = T.unsafe(nil)); end

  # The comment content extracted from source file
  def extracted_comment; end

  # The flags of the PO entry
  def flags; end

  # Merges the PO entry with +other_entry+.
  def merge(other_entry); end

  # The msgid content
  def msgid; end

  # The msgstr content
  def msgstr; end

  # The locations where the PO entry is extracted
  def references; end

  # Returns the PO entry in PO format.
  def to_s; end

  # The comment content created by translator (PO editor)
  def translator_comment; end

  private

  def escape(string); end
  def format_comment(mark, comment); end
  def format_extracted_comment; end
  def format_flags; end
  def format_message(message); end
  def format_references; end
  def format_translator_comment; end
  def merge_array(array1, array2); end
  def merge_string(string1, string2); end
end

# Generates ri data files
class RDoc::Generator::RI
  # Set up a new ri generator
  #
  # @return [RI] a new instance of RI
  def initialize(store, options); end

  # Writes the parsed data store to disk for use by ri.
  def generate; end
end

# A message container for a locale.
#
# This object provides the following two features:
#
#   * Loads translated messages from .po file.
#   * Translates a message into the locale.
class RDoc::I18n::Locale
  # Creates a new locale object for +name+ locale. +name+ must
  # follow IETF language tag format.
  #
  # @return [Locale] a new instance of Locale
  def initialize(name); end

  # Loads translation messages from +locale_directory+/+@name+/rdoc.po
  # or +locale_directory+/+@name+.po. The former has high priority.
  #
  # This method requires gettext gem for parsing .po file. If you
  # don't have gettext gem, this method doesn't load .po file. This
  # method warns and returns +false+.
  #
  # Returns +true+ if succeeded, +false+ otherwise.
  def load(locale_directory); end

  # The name of the locale. It uses IETF language tag format
  # +[language[_territory][.codeset][@modifier]]+.
  #
  # See also {BCP 47 - Tags for Identifying
  # Languages}[http://tools.ietf.org/rfc/bcp/bcp47.txt].
  def name; end

  # Translates the +message+ into locale. If there is no translation
  # messages for +message+ in locale, +message+ itself is returned.
  def translate(message); end

  class << self
    # Returns the locale object for +locale_name+.
    def [](locale_name); end

    # Sets the locale object for +locale_name+.
    #
    # Normally, this method is not used. This method is useful for
    # testing.
    def []=(locale_name, locale); end
  end
end

# An i18n supported text.
#
# This object provides the following two features:
#
#   * Extracts translation messages from wrapped raw text.
#   * Translates wrapped raw text in specified locale.
#
# Wrapped raw text is one of String, RDoc::Comment or Array of them.
class RDoc::I18n::Text
  # Creates a new i18n supported text for +raw+ text.
  #
  # @return [Text] a new instance of Text
  def initialize(raw); end

  # Extracts translation target messages and yields each message.
  #
  # Each yielded message is a Hash. It consists of the followings:
  #
  # :type      :: :paragraph
  # :paragraph :: String (The translation target message itself.)
  # :line_no   :: Integer (The line number of the :paragraph is started.)
  #
  # The above content may be added in the future.
  def extract_messages; end

  # Translates raw text into +locale+.
  def translate(locale); end

  private

  def each_line(raw, &block); end

  # @yield [part]
  def emit_empty_line_event(line, line_no); end

  def emit_paragraph_event(paragraph, paragraph_start_line, line_no, &block); end
  def parse(&block); end
end

class RDoc::Markdown
  # Creates a new markdown parser that enables the given +extensions+.
  #
  # @return [Markdown] a new instance of Markdown
  def initialize(extensions = T.unsafe(nil), debug = T.unsafe(nil)); end

  # Alphanumeric = %literals.Alphanumeric
  def _Alphanumeric; end

  # AlphanumericAscii = %literals.AlphanumericAscii
  def _AlphanumericAscii; end

  # AtxHeading = AtxStart:s @Sp AtxInline+:a (@Sp /#*/ @Sp)? @Newline { RDoc::Markup::Heading.new(s, a.join) }
  def _AtxHeading; end

  # AtxInline = !@Newline !(@Sp /#*/ @Sp @Newline) Inline
  def _AtxInline; end

  # AtxStart = < /\#{1,6}/ > { text.length }
  def _AtxStart; end

  # AutoLink = (AutoLinkUrl | AutoLinkEmail)
  def _AutoLink; end

  # AutoLinkEmail = "<" "mailto:"? < /[\w+.\/!%~$-]+/i "@" (!@Newline !">" .)+ > ">" { "mailto:#{text}" }
  def _AutoLinkEmail; end

  # AutoLinkUrl = "<" < /[A-Za-z]+/ "://" (!@Newline !">" .)+ > ">" { text }
  def _AutoLinkUrl; end

  # BOM = %literals.BOM
  def _BOM; end

  # BlankLine = @Sp @Newline { "\n" }
  def _BlankLine; end

  # Block = @BlankLine* (BlockQuote | Verbatim | CodeFence | Table | Note | Reference | HorizontalRule | Heading | OrderedList | BulletList | DefinitionList | HtmlBlock | StyleBlock | Para | Plain)
  def _Block; end

  # BlockQuote = BlockQuoteRaw:a { RDoc::Markup::BlockQuote.new(*a) }
  def _BlockQuote; end

  # BlockQuoteRaw = @StartList:a (">" " "? Line:l { a << l } (!">" !@BlankLine Line:c { a << c })* (@BlankLine:n { a << n })*)+ { inner_parse a.join }
  def _BlockQuoteRaw; end

  # Bullet = !HorizontalRule @NonindentSpace /[+*-]/ @Spacechar+
  def _Bullet; end

  # BulletList = &Bullet (ListTight | ListLoose):a { RDoc::Markup::List.new(:BULLET, *a) }
  def _BulletList; end

  # CharEntity = "&" < /[A-Za-z0-9]+/ > ";" { if entity = HTML_ENTITIES[text] then                  entity.pack 'U*'                else                  "&#{text};"                end              }
  def _CharEntity; end

  # Code = (Ticks1 @Sp < ((!"`" Nonspacechar)+ | !Ticks1 /`+/ | !(@Sp Ticks1) (@Spacechar | @Newline !@BlankLine))+ > @Sp Ticks1 | Ticks2 @Sp < ((!"`" Nonspacechar)+ | !Ticks2 /`+/ | !(@Sp Ticks2) (@Spacechar | @Newline !@BlankLine))+ > @Sp Ticks2 | Ticks3 @Sp < ((!"`" Nonspacechar)+ | !Ticks3 /`+/ | !(@Sp Ticks3) (@Spacechar | @Newline !@BlankLine))+ > @Sp Ticks3 | Ticks4 @Sp < ((!"`" Nonspacechar)+ | !Ticks4 /`+/ | !(@Sp Ticks4) (@Spacechar | @Newline !@BlankLine))+ > @Sp Ticks4 | Ticks5 @Sp < ((!"`" Nonspacechar)+ | !Ticks5 /`+/ | !(@Sp Ticks5) (@Spacechar | @Newline !@BlankLine))+ > @Sp Ticks5) { "<code>#{text}</code>" }
  def _Code; end

  # CodeFence = &{ github? } Ticks3 (@Sp StrChunk:format)? Spnl < ((!"`" Nonspacechar)+ | !Ticks3 /`+/ | Spacechar | @Newline)+ > Ticks3 @Sp @Newline* { verbatim = RDoc::Markup::Verbatim.new text               verbatim.format = format.intern if format.instance_of?(String)               verbatim             }
  def _CodeFence; end

  # DecEntity = "&#" < /[0-9]+/ > ";" { [text.to_i].pack 'U' }
  def _DecEntity; end

  # DefinitionList = &{ definition_lists? } DefinitionListItem+:list { RDoc::Markup::List.new :NOTE, *list.flatten }
  def _DefinitionList; end

  # DefinitionListDefinition = @NonindentSpace ":" @Space Inlines:a @BlankLine+ { paragraph a }
  def _DefinitionListDefinition; end

  # DefinitionListItem = DefinitionListLabel+:label DefinitionListDefinition+:defns { list_items = []                        list_items <<                          RDoc::Markup::ListItem.new(label, defns.shift)                         list_items.concat defns.map { |defn|                          RDoc::Markup::ListItem.new nil, defn                        } unless list_items.empty?                         list_items                      }
  def _DefinitionListItem; end

  # DefinitionListLabel = Inline:label @Sp @Newline { label }
  def _DefinitionListLabel; end

  # Digit = [0-9]
  def _Digit; end

  # Doc = BOM? Block*:a { RDoc::Markup::Document.new(*a.compact) }
  def _Doc; end

  # Emph = (EmphStar | EmphUl)
  def _Emph; end

  # EmphStar = "*" !@Whitespace @StartList:a (!"*" Inline:b { a << b } | StrongStar:b { a << b })+ "*" { emphasis a.join }
  def _EmphStar; end

  # EmphUl = "_" !@Whitespace @StartList:a (!"_" Inline:b { a << b } | StrongUl:b { a << b })+ "_" { emphasis a.join }
  def _EmphUl; end

  # EmptyTitle = ""
  def _EmptyTitle; end

  # Endline = (@LineBreak | @TerminalEndline | @NormalEndline)
  def _Endline; end

  # Entity = (HexEntity | DecEntity | CharEntity):a { a }
  def _Entity; end

  # Enumerator = @NonindentSpace [0-9]+ "." @Spacechar+
  def _Enumerator; end

  # Eof = !.
  def _Eof; end

  # EscapedChar = "\\" !@Newline < /[:\\`|*_{}\[\]()#+.!><-]/ > { text }
  def _EscapedChar; end

  # ExplicitLink = Label:l "(" @Sp Source:s Spnl Title @Sp ")" { "{#{l}}[#{s}]" }
  def _ExplicitLink; end

  # ExtendedSpecialChar = &{ notes? } "^"
  def _ExtendedSpecialChar; end

  # Heading = (SetextHeading | AtxHeading)
  def _Heading; end

  # HexEntity = /&#x/i < /[0-9a-fA-F]+/ > ";" { [text.to_i(16)].pack 'U' }
  def _HexEntity; end

  # HorizontalRule = @NonindentSpace ("*" @Sp "*" @Sp "*" (@Sp "*")* | "-" @Sp "-" @Sp "-" (@Sp "-")* | "_" @Sp "_" @Sp "_" (@Sp "_")*) @Sp @Newline @BlankLine+ { RDoc::Markup::Rule.new 1 }
  def _HorizontalRule; end

  # HtmlAnchor = HtmlOpenAnchor (HtmlAnchor | !HtmlCloseAnchor .)* HtmlCloseAnchor
  def _HtmlAnchor; end

  # HtmlAttribute = (AlphanumericAscii | "-")+ Spnl ("=" Spnl (Quoted | (!">" Nonspacechar)+))? Spnl
  def _HtmlAttribute; end

  # HtmlBlock = < (HtmlBlockInTags | HtmlComment | HtmlBlockSelfClosing | HtmlUnclosed) > @BlankLine+ { if html? then                 RDoc::Markup::Raw.new text               end }
  def _HtmlBlock; end

  # HtmlBlockAddress = HtmlBlockOpenAddress (HtmlBlockAddress | !HtmlBlockCloseAddress .)* HtmlBlockCloseAddress
  def _HtmlBlockAddress; end

  # HtmlBlockBlockquote = HtmlBlockOpenBlockquote (HtmlBlockBlockquote | !HtmlBlockCloseBlockquote .)* HtmlBlockCloseBlockquote
  def _HtmlBlockBlockquote; end

  # HtmlBlockCenter = HtmlBlockOpenCenter (HtmlBlockCenter | !HtmlBlockCloseCenter .)* HtmlBlockCloseCenter
  def _HtmlBlockCenter; end

  # HtmlBlockCloseAddress = "<" Spnl "/" ("address" | "ADDRESS") Spnl ">"
  def _HtmlBlockCloseAddress; end

  # HtmlBlockCloseBlockquote = "<" Spnl "/" ("blockquote" | "BLOCKQUOTE") Spnl ">"
  def _HtmlBlockCloseBlockquote; end

  # HtmlBlockCloseCenter = "<" Spnl "/" ("center" | "CENTER") Spnl ">"
  def _HtmlBlockCloseCenter; end

  # HtmlBlockCloseDd = "<" Spnl "/" ("dd" | "DD") Spnl ">"
  def _HtmlBlockCloseDd; end

  # HtmlBlockCloseDir = "<" Spnl "/" ("dir" | "DIR") Spnl ">"
  def _HtmlBlockCloseDir; end

  # HtmlBlockCloseDiv = "<" Spnl "/" ("div" | "DIV") Spnl ">"
  def _HtmlBlockCloseDiv; end

  # HtmlBlockCloseDl = "<" Spnl "/" ("dl" | "DL") Spnl ">"
  def _HtmlBlockCloseDl; end

  # HtmlBlockCloseDt = "<" Spnl "/" ("dt" | "DT") Spnl ">"
  def _HtmlBlockCloseDt; end

  # HtmlBlockCloseFieldset = "<" Spnl "/" ("fieldset" | "FIELDSET") Spnl ">"
  def _HtmlBlockCloseFieldset; end

  # HtmlBlockCloseForm = "<" Spnl "/" ("form" | "FORM") Spnl ">"
  def _HtmlBlockCloseForm; end

  # HtmlBlockCloseFrameset = "<" Spnl "/" ("frameset" | "FRAMESET") Spnl ">"
  def _HtmlBlockCloseFrameset; end

  # HtmlBlockCloseH1 = "<" Spnl "/" ("h1" | "H1") Spnl ">"
  def _HtmlBlockCloseH1; end

  # HtmlBlockCloseH2 = "<" Spnl "/" ("h2" | "H2") Spnl ">"
  def _HtmlBlockCloseH2; end

  # HtmlBlockCloseH3 = "<" Spnl "/" ("h3" | "H3") Spnl ">"
  def _HtmlBlockCloseH3; end

  # HtmlBlockCloseH4 = "<" Spnl "/" ("h4" | "H4") Spnl ">"
  def _HtmlBlockCloseH4; end

  # HtmlBlockCloseH5 = "<" Spnl "/" ("h5" | "H5") Spnl ">"
  def _HtmlBlockCloseH5; end

  # HtmlBlockCloseH6 = "<" Spnl "/" ("h6" | "H6") Spnl ">"
  def _HtmlBlockCloseH6; end

  # HtmlBlockCloseHead = "<" Spnl "/" ("head" | "HEAD") Spnl ">"
  def _HtmlBlockCloseHead; end

  # HtmlBlockCloseLi = "<" Spnl "/" ("li" | "LI") Spnl ">"
  def _HtmlBlockCloseLi; end

  # HtmlBlockCloseMenu = "<" Spnl "/" ("menu" | "MENU") Spnl ">"
  def _HtmlBlockCloseMenu; end

  # HtmlBlockCloseNoframes = "<" Spnl "/" ("noframes" | "NOFRAMES") Spnl ">"
  def _HtmlBlockCloseNoframes; end

  # HtmlBlockCloseNoscript = "<" Spnl "/" ("noscript" | "NOSCRIPT") Spnl ">"
  def _HtmlBlockCloseNoscript; end

  # HtmlBlockCloseOl = "<" Spnl "/" ("ol" | "OL") Spnl ">"
  def _HtmlBlockCloseOl; end

  # HtmlBlockCloseP = "<" Spnl "/" ("p" | "P") Spnl ">"
  def _HtmlBlockCloseP; end

  # HtmlBlockClosePre = "<" Spnl "/" ("pre" | "PRE") Spnl ">"
  def _HtmlBlockClosePre; end

  # HtmlBlockCloseScript = "<" Spnl "/" ("script" | "SCRIPT") Spnl ">"
  def _HtmlBlockCloseScript; end

  # HtmlBlockCloseTable = "<" Spnl "/" ("table" | "TABLE") Spnl ">"
  def _HtmlBlockCloseTable; end

  # HtmlBlockCloseTbody = "<" Spnl "/" ("tbody" | "TBODY") Spnl ">"
  def _HtmlBlockCloseTbody; end

  # HtmlBlockCloseTd = "<" Spnl "/" ("td" | "TD") Spnl ">"
  def _HtmlBlockCloseTd; end

  # HtmlBlockCloseTfoot = "<" Spnl "/" ("tfoot" | "TFOOT") Spnl ">"
  def _HtmlBlockCloseTfoot; end

  # HtmlBlockCloseTh = "<" Spnl "/" ("th" | "TH") Spnl ">"
  def _HtmlBlockCloseTh; end

  # HtmlBlockCloseThead = "<" Spnl "/" ("thead" | "THEAD") Spnl ">"
  def _HtmlBlockCloseThead; end

  # HtmlBlockCloseTr = "<" Spnl "/" ("tr" | "TR") Spnl ">"
  def _HtmlBlockCloseTr; end

  # HtmlBlockCloseUl = "<" Spnl "/" ("ul" | "UL") Spnl ">"
  def _HtmlBlockCloseUl; end

  # HtmlBlockDd = HtmlBlockOpenDd (HtmlBlockDd | !HtmlBlockCloseDd .)* HtmlBlockCloseDd
  def _HtmlBlockDd; end

  # HtmlBlockDir = HtmlBlockOpenDir (HtmlBlockDir | !HtmlBlockCloseDir .)* HtmlBlockCloseDir
  def _HtmlBlockDir; end

  # HtmlBlockDiv = HtmlBlockOpenDiv (HtmlBlockDiv | !HtmlBlockCloseDiv .)* HtmlBlockCloseDiv
  def _HtmlBlockDiv; end

  # HtmlBlockDl = HtmlBlockOpenDl (HtmlBlockDl | !HtmlBlockCloseDl .)* HtmlBlockCloseDl
  def _HtmlBlockDl; end

  # HtmlBlockDt = HtmlBlockOpenDt (HtmlBlockDt | !HtmlBlockCloseDt .)* HtmlBlockCloseDt
  def _HtmlBlockDt; end

  # HtmlBlockFieldset = HtmlBlockOpenFieldset (HtmlBlockFieldset | !HtmlBlockCloseFieldset .)* HtmlBlockCloseFieldset
  def _HtmlBlockFieldset; end

  # HtmlBlockForm = HtmlBlockOpenForm (HtmlBlockForm | !HtmlBlockCloseForm .)* HtmlBlockCloseForm
  def _HtmlBlockForm; end

  # HtmlBlockFrameset = HtmlBlockOpenFrameset (HtmlBlockFrameset | !HtmlBlockCloseFrameset .)* HtmlBlockCloseFrameset
  def _HtmlBlockFrameset; end

  # HtmlBlockH1 = HtmlBlockOpenH1 (HtmlBlockH1 | !HtmlBlockCloseH1 .)* HtmlBlockCloseH1
  def _HtmlBlockH1; end

  # HtmlBlockH2 = HtmlBlockOpenH2 (HtmlBlockH2 | !HtmlBlockCloseH2 .)* HtmlBlockCloseH2
  def _HtmlBlockH2; end

  # HtmlBlockH3 = HtmlBlockOpenH3 (HtmlBlockH3 | !HtmlBlockCloseH3 .)* HtmlBlockCloseH3
  def _HtmlBlockH3; end

  # HtmlBlockH4 = HtmlBlockOpenH4 (HtmlBlockH4 | !HtmlBlockCloseH4 .)* HtmlBlockCloseH4
  def _HtmlBlockH4; end

  # HtmlBlockH5 = HtmlBlockOpenH5 (HtmlBlockH5 | !HtmlBlockCloseH5 .)* HtmlBlockCloseH5
  def _HtmlBlockH5; end

  # HtmlBlockH6 = HtmlBlockOpenH6 (HtmlBlockH6 | !HtmlBlockCloseH6 .)* HtmlBlockCloseH6
  def _HtmlBlockH6; end

  # HtmlBlockHead = HtmlBlockOpenHead (!HtmlBlockCloseHead .)* HtmlBlockCloseHead
  def _HtmlBlockHead; end

  # HtmlBlockInTags = (HtmlAnchor | HtmlBlockAddress | HtmlBlockBlockquote | HtmlBlockCenter | HtmlBlockDir | HtmlBlockDiv | HtmlBlockDl | HtmlBlockFieldset | HtmlBlockForm | HtmlBlockH1 | HtmlBlockH2 | HtmlBlockH3 | HtmlBlockH4 | HtmlBlockH5 | HtmlBlockH6 | HtmlBlockMenu | HtmlBlockNoframes | HtmlBlockNoscript | HtmlBlockOl | HtmlBlockP | HtmlBlockPre | HtmlBlockTable | HtmlBlockUl | HtmlBlockDd | HtmlBlockDt | HtmlBlockFrameset | HtmlBlockLi | HtmlBlockTbody | HtmlBlockTd | HtmlBlockTfoot | HtmlBlockTh | HtmlBlockThead | HtmlBlockTr | HtmlBlockScript | HtmlBlockHead)
  def _HtmlBlockInTags; end

  # HtmlBlockLi = HtmlBlockOpenLi (HtmlBlockLi | !HtmlBlockCloseLi .)* HtmlBlockCloseLi
  def _HtmlBlockLi; end

  # HtmlBlockMenu = HtmlBlockOpenMenu (HtmlBlockMenu | !HtmlBlockCloseMenu .)* HtmlBlockCloseMenu
  def _HtmlBlockMenu; end

  # HtmlBlockNoframes = HtmlBlockOpenNoframes (HtmlBlockNoframes | !HtmlBlockCloseNoframes .)* HtmlBlockCloseNoframes
  def _HtmlBlockNoframes; end

  # HtmlBlockNoscript = HtmlBlockOpenNoscript (HtmlBlockNoscript | !HtmlBlockCloseNoscript .)* HtmlBlockCloseNoscript
  def _HtmlBlockNoscript; end

  # HtmlBlockOl = HtmlBlockOpenOl (HtmlBlockOl | !HtmlBlockCloseOl .)* HtmlBlockCloseOl
  def _HtmlBlockOl; end

  # HtmlBlockOpenAddress = "<" Spnl ("address" | "ADDRESS") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenAddress; end

  # HtmlBlockOpenBlockquote = "<" Spnl ("blockquote" | "BLOCKQUOTE") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenBlockquote; end

  # HtmlBlockOpenCenter = "<" Spnl ("center" | "CENTER") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenCenter; end

  # HtmlBlockOpenDd = "<" Spnl ("dd" | "DD") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenDd; end

  # HtmlBlockOpenDir = "<" Spnl ("dir" | "DIR") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenDir; end

  # HtmlBlockOpenDiv = "<" Spnl ("div" | "DIV") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenDiv; end

  # HtmlBlockOpenDl = "<" Spnl ("dl" | "DL") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenDl; end

  # HtmlBlockOpenDt = "<" Spnl ("dt" | "DT") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenDt; end

  # HtmlBlockOpenFieldset = "<" Spnl ("fieldset" | "FIELDSET") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenFieldset; end

  # HtmlBlockOpenForm = "<" Spnl ("form" | "FORM") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenForm; end

  # HtmlBlockOpenFrameset = "<" Spnl ("frameset" | "FRAMESET") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenFrameset; end

  # HtmlBlockOpenH1 = "<" Spnl ("h1" | "H1") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH1; end

  # HtmlBlockOpenH2 = "<" Spnl ("h2" | "H2") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH2; end

  # HtmlBlockOpenH3 = "<" Spnl ("h3" | "H3") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH3; end

  # HtmlBlockOpenH4 = "<" Spnl ("h4" | "H4") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH4; end

  # HtmlBlockOpenH5 = "<" Spnl ("h5" | "H5") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH5; end

  # HtmlBlockOpenH6 = "<" Spnl ("h6" | "H6") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenH6; end

  # HtmlBlockOpenHead = "<" Spnl ("head" | "HEAD") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenHead; end

  # HtmlBlockOpenLi = "<" Spnl ("li" | "LI") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenLi; end

  # HtmlBlockOpenMenu = "<" Spnl ("menu" | "MENU") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenMenu; end

  # HtmlBlockOpenNoframes = "<" Spnl ("noframes" | "NOFRAMES") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenNoframes; end

  # HtmlBlockOpenNoscript = "<" Spnl ("noscript" | "NOSCRIPT") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenNoscript; end

  # HtmlBlockOpenOl = "<" Spnl ("ol" | "OL") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenOl; end

  # HtmlBlockOpenP = "<" Spnl ("p" | "P") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenP; end

  # HtmlBlockOpenPre = "<" Spnl ("pre" | "PRE") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenPre; end

  # HtmlBlockOpenScript = "<" Spnl ("script" | "SCRIPT") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenScript; end

  # HtmlBlockOpenTable = "<" Spnl ("table" | "TABLE") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTable; end

  # HtmlBlockOpenTbody = "<" Spnl ("tbody" | "TBODY") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTbody; end

  # HtmlBlockOpenTd = "<" Spnl ("td" | "TD") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTd; end

  # HtmlBlockOpenTfoot = "<" Spnl ("tfoot" | "TFOOT") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTfoot; end

  # HtmlBlockOpenTh = "<" Spnl ("th" | "TH") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTh; end

  # HtmlBlockOpenThead = "<" Spnl ("thead" | "THEAD") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenThead; end

  # HtmlBlockOpenTr = "<" Spnl ("tr" | "TR") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenTr; end

  # HtmlBlockOpenUl = "<" Spnl ("ul" | "UL") Spnl HtmlAttribute* ">"
  def _HtmlBlockOpenUl; end

  # HtmlBlockP = HtmlBlockOpenP (HtmlBlockP | !HtmlBlockCloseP .)* HtmlBlockCloseP
  def _HtmlBlockP; end

  # HtmlBlockPre = HtmlBlockOpenPre (HtmlBlockPre | !HtmlBlockClosePre .)* HtmlBlockClosePre
  def _HtmlBlockPre; end

  # HtmlBlockScript = HtmlBlockOpenScript (!HtmlBlockCloseScript .)* HtmlBlockCloseScript
  def _HtmlBlockScript; end

  # HtmlBlockSelfClosing = "<" Spnl HtmlBlockType Spnl HtmlAttribute* "/" Spnl ">"
  def _HtmlBlockSelfClosing; end

  # HtmlBlockTable = HtmlBlockOpenTable (HtmlBlockTable | !HtmlBlockCloseTable .)* HtmlBlockCloseTable
  def _HtmlBlockTable; end

  # HtmlBlockTbody = HtmlBlockOpenTbody (HtmlBlockTbody | !HtmlBlockCloseTbody .)* HtmlBlockCloseTbody
  def _HtmlBlockTbody; end

  # HtmlBlockTd = HtmlBlockOpenTd (HtmlBlockTd | !HtmlBlockCloseTd .)* HtmlBlockCloseTd
  def _HtmlBlockTd; end

  # HtmlBlockTfoot = HtmlBlockOpenTfoot (HtmlBlockTfoot | !HtmlBlockCloseTfoot .)* HtmlBlockCloseTfoot
  def _HtmlBlockTfoot; end

  # HtmlBlockTh = HtmlBlockOpenTh (HtmlBlockTh | !HtmlBlockCloseTh .)* HtmlBlockCloseTh
  def _HtmlBlockTh; end

  # HtmlBlockThead = HtmlBlockOpenThead (HtmlBlockThead | !HtmlBlockCloseThead .)* HtmlBlockCloseThead
  def _HtmlBlockThead; end

  # HtmlBlockTr = HtmlBlockOpenTr (HtmlBlockTr | !HtmlBlockCloseTr .)* HtmlBlockCloseTr
  def _HtmlBlockTr; end

  # HtmlBlockType = ("ADDRESS" | "BLOCKQUOTE" | "CENTER" | "DD" | "DIR" | "DIV" | "DL" | "DT" | "FIELDSET" | "FORM" | "FRAMESET" | "H1" | "H2" | "H3" | "H4" | "H5" | "H6" | "HR" | "ISINDEX" | "LI" | "MENU" | "NOFRAMES" | "NOSCRIPT" | "OL" | "P" | "PRE" | "SCRIPT" | "TABLE" | "TBODY" | "TD" | "TFOOT" | "TH" | "THEAD" | "TR" | "UL" | "address" | "blockquote" | "center" | "dd" | "dir" | "div" | "dl" | "dt" | "fieldset" | "form" | "frameset" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "hr" | "isindex" | "li" | "menu" | "noframes" | "noscript" | "ol" | "p" | "pre" | "script" | "table" | "tbody" | "td" | "tfoot" | "th" | "thead" | "tr" | "ul")
  def _HtmlBlockType; end

  # HtmlBlockUl = HtmlBlockOpenUl (HtmlBlockUl | !HtmlBlockCloseUl .)* HtmlBlockCloseUl
  def _HtmlBlockUl; end

  # HtmlCloseAnchor = "<" Spnl "/" ("a" | "A") Spnl ">"
  def _HtmlCloseAnchor; end

  # HtmlComment = "<!--" (!"-->" .)* "-->"
  def _HtmlComment; end

  # HtmlOpenAnchor = "<" Spnl ("a" | "A") Spnl HtmlAttribute* ">"
  def _HtmlOpenAnchor; end

  # HtmlTag = "<" Spnl "/"? AlphanumericAscii+ Spnl HtmlAttribute* "/"? Spnl ">"
  def _HtmlTag; end

  # HtmlUnclosed = "<" Spnl HtmlUnclosedType Spnl HtmlAttribute* Spnl ">"
  def _HtmlUnclosed; end

  # HtmlUnclosedType = ("HR" | "hr")
  def _HtmlUnclosedType; end

  # Image = "!" (ExplicitLink | ReferenceLink):a { "rdoc-image:#{a[/\[(.*)\]/, 1]}" }
  def _Image; end

  # InStyleTags = StyleOpen (!StyleClose .)* StyleClose
  def _InStyleTags; end

  # Indent = /\t|    /
  def _Indent; end

  # IndentedLine = Indent Line
  def _IndentedLine; end

  # Inline = (Str | @Endline | UlOrStarLine | @Space | Strong | Emph | Strike | Image | Link | NoteReference | InlineNote | Code | RawHtml | Entity | EscapedChar | Symbol)
  def _Inline; end

  # InlineNote = &{ notes? } "^[" @StartList:a (!"]" Inline:l { a << l })+ "]" { ref = [:inline, @note_order.length]                @footnotes[ref] = paragraph a                 note_for ref              }
  def _InlineNote; end

  # Inlines = (!@Endline Inline:i { i } | @Endline:c !(&{ github? } Ticks3 /[^`\n]*$/) &Inline { c })+:chunks @Endline? { chunks }
  def _Inlines; end

  # Label = "[" (!"^" &{ notes? } | &. &{ !notes? }) @StartList:a (!"]" Inline:l { a << l })* "]" { a.join.gsub(/\s+/, ' ') }
  def _Label; end

  # Line = @RawLine:a { a }
  def _Line; end

  # LineBreak = "  " @NormalEndline { RDoc::Markup::HardBreak.new }
  def _LineBreak; end

  # Link = (ExplicitLink | ReferenceLink | AutoLink)
  def _Link; end

  # ListBlock = !@BlankLine Line:a ListBlockLine*:c { [a, *c] }
  def _ListBlock; end

  # ListBlockLine = !@BlankLine !(Indent? (Bullet | Enumerator)) !HorizontalRule OptionallyIndentedLine
  def _ListBlockLine; end

  # ListContinuationBlock = @StartList:a @BlankLine* { a << "\n" } (Indent ListBlock:b { a.concat b })+ { a }
  def _ListContinuationBlock; end

  # ListItem = (Bullet | Enumerator) @StartList:a ListBlock:b { a << b } (ListContinuationBlock:c { a.push(*c) })* { list_item_from a }
  def _ListItem; end

  # ListItemTight = (Bullet | Enumerator) ListBlock:a (!@BlankLine ListContinuationBlock:b { a.push(*b) })* !ListContinuationBlock { list_item_from a }
  def _ListItemTight; end

  # ListLoose = @StartList:a (ListItem:b @BlankLine* { a << b })+ { a }
  def _ListLoose; end

  # ListTight = ListItemTight+:a @BlankLine* !(Bullet | Enumerator) { a }
  def _ListTight; end

  # Newline = %literals.Newline
  def _Newline; end

  # NonblankIndentedLine = !@BlankLine IndentedLine
  def _NonblankIndentedLine; end

  # NonindentSpace = / {0,3}/
  def _NonindentSpace; end

  # Nonspacechar = !@Spacechar !@Newline .
  def _Nonspacechar; end

  # NormalChar = !(@SpecialChar | @Spacechar | @Newline) .
  def _NormalChar; end

  # NormalEndline = @Sp @Newline !@BlankLine !">" !AtxStart !(Line /={1,}|-{1,}/ @Newline) { "\n" }
  def _NormalEndline; end

  # Note = &{ notes? } @NonindentSpace RawNoteReference:ref ":" @Sp @StartList:a RawNoteBlock:i { a.concat i } (&Indent RawNoteBlock:i { a.concat i })* { @footnotes[ref] = paragraph a                    nil                 }
  def _Note; end

  # NoteReference = &{ notes? } RawNoteReference:ref { note_for ref }
  def _NoteReference; end

  # Notes = (Note | SkipBlock)*
  def _Notes; end

  # OptionallyIndentedLine = Indent? Line
  def _OptionallyIndentedLine; end

  # OrderedList = &Enumerator (ListTight | ListLoose):a { RDoc::Markup::List.new(:NUMBER, *a) }
  def _OrderedList; end

  # Para = @NonindentSpace Inlines:a @BlankLine+ { paragraph a }
  def _Para; end

  # Plain = Inlines:a { paragraph a }
  def _Plain; end

  # Quoted = ("\"" (!"\"" .)* "\"" | "'" (!"'" .)* "'")
  def _Quoted; end

  # RawHtml = < (HtmlComment | HtmlBlockScript | HtmlTag) > { if html? then text else '' end }
  def _RawHtml; end

  # RawLine = (< /[^\r\n]*/ @Newline > | < .+ > @Eof) { text }
  def _RawLine; end

  # RawNoteBlock = @StartList:a (!@BlankLine !RawNoteReference OptionallyIndentedLine:l { a << l })+ < @BlankLine* > { a << text } { a }
  def _RawNoteBlock; end

  # RawNoteReference = "[^" < (!@Newline !"]" .)+ > "]" { text }
  def _RawNoteReference; end

  # RefSrc = < Nonspacechar+ > { text }
  def _RefSrc; end

  # RefTitle = (RefTitleSingle | RefTitleDouble | RefTitleParens | EmptyTitle)
  def _RefTitle; end

  # RefTitleDouble = Spnl "\"" < (!("\"" @Sp @Newline | @Newline) .)* > "\"" { text }
  def _RefTitleDouble; end

  # RefTitleParens = Spnl "(" < (!(")" @Sp @Newline | @Newline) .)* > ")" { text }
  def _RefTitleParens; end

  # RefTitleSingle = Spnl "'" < (!("'" @Sp @Newline | @Newline) .)* > "'" { text }
  def _RefTitleSingle; end

  # Reference = @NonindentSpace !"[]" Label:label ":" Spnl RefSrc:link RefTitle @BlankLine+ { # TODO use title               reference label, link               nil             }
  def _Reference; end

  # ReferenceLink = (ReferenceLinkDouble | ReferenceLinkSingle)
  def _ReferenceLink; end

  # ReferenceLinkDouble = Label:content < Spnl > !"[]" Label:label { link_to content, label, text }
  def _ReferenceLinkDouble; end

  # ReferenceLinkSingle = Label:content < (Spnl "[]")? > { link_to content, content, text }
  def _ReferenceLinkSingle; end

  # References = (Reference | SkipBlock)*
  def _References; end

  # SetextBottom1 = /={1,}/ @Newline
  def _SetextBottom1; end

  # SetextBottom2 = /-{1,}/ @Newline
  def _SetextBottom2; end

  # SetextHeading = (SetextHeading1 | SetextHeading2)
  def _SetextHeading; end

  # SetextHeading1 = &(@RawLine SetextBottom1) @StartList:a (!@Endline Inline:b { a << b })+ @Sp @Newline SetextBottom1 { RDoc::Markup::Heading.new(1, a.join) }
  def _SetextHeading1; end

  # SetextHeading2 = &(@RawLine SetextBottom2) @StartList:a (!@Endline Inline:b { a << b })+ @Sp @Newline SetextBottom2 { RDoc::Markup::Heading.new(2, a.join) }
  def _SetextHeading2; end

  # SkipBlock = (HtmlBlock | (!"#" !SetextBottom1 !SetextBottom2 !@BlankLine @RawLine)+ @BlankLine* | @BlankLine+ | @RawLine)
  def _SkipBlock; end

  # Source = ("<" < SourceContents > ">" | < SourceContents >) { text }
  def _Source; end

  # SourceContents = ((!"(" !")" !">" Nonspacechar)+ | "(" SourceContents ")")*
  def _SourceContents; end

  # Sp = @Spacechar*
  def _Sp; end

  # Space = @Spacechar+ { " " }
  def _Space; end

  # Spacechar = %literals.Spacechar
  def _Spacechar; end

  # SpecialChar = (/[~*_`&\[\]()<!#\\'"]/ | @ExtendedSpecialChar)
  def _SpecialChar; end

  # Spnl = @Sp (@Newline @Sp)?
  def _Spnl; end

  # StarLine = (< /\*{4,}/ > { text } | < @Spacechar /\*+/ &@Spacechar > { text })
  def _StarLine; end

  # StartList = &. { [] }
  def _StartList; end

  # Str = @StartList:a < @NormalChar+ > { a = text } (StrChunk:c { a << c })* { a }
  def _Str; end

  # StrChunk = < (@NormalChar | /_+/ &Alphanumeric)+ > { text }
  def _StrChunk; end

  # Strike = &{ strike? } "~~" !@Whitespace @StartList:a (!"~~" Inline:b { a << b })+ "~~" { strike a.join }
  def _Strike; end

  # Strong = (StrongStar | StrongUl)
  def _Strong; end

  # StrongStar = "**" !@Whitespace @StartList:a (!"**" Inline:b { a << b })+ "**" { strong a.join }
  def _StrongStar; end

  # StrongUl = "__" !@Whitespace @StartList:a (!"__" Inline:b { a << b })+ "__" { strong a.join }
  def _StrongUl; end

  # StyleBlock = < InStyleTags > @BlankLine* { if css? then                     RDoc::Markup::Raw.new text                   end }
  def _StyleBlock; end

  # StyleClose = "<" Spnl "/" ("style" | "STYLE") Spnl ">"
  def _StyleClose; end

  # StyleOpen = "<" Spnl ("style" | "STYLE") Spnl HtmlAttribute* ">"
  def _StyleOpen; end

  # Symbol = < @SpecialChar > { text }
  def _Symbol; end

  # Table = &{ github? } TableHead:header TableLine:line TableRow+:body { table = RDoc::Markup::Table.new(header, line, body) }
  def _Table; end

  # TableAlign = < /:?-+:?/ > @Sp {                 text.start_with?(":") ?                 (text.end_with?(":") ? :center : :left) :                 (text.end_with?(":") ? :right : nil)               }
  def _TableAlign; end

  # TableAlign2 = "|" @Sp TableAlign
  def _TableAlign2; end

  # TableHead = TableItem2+:items "|"? @Newline { items }
  def _TableHead; end

  # TableItem = < /(?:\\.|[^|\n])+/ > { text.strip.gsub(/\\(.)/, '\1')  }
  def _TableItem; end

  # TableItem2 = "|" TableItem
  def _TableItem2; end

  # TableLine = ((TableAlign:align1 TableAlign2*:aligns {[align1, *aligns] }):line | TableAlign2+:line) "|"? @Newline { line }
  def _TableLine; end

  # TableRow = ((TableItem:item1 TableItem2*:items { [item1, *items] }):row | TableItem2+:row) "|"? @Newline { row }
  def _TableRow; end

  # TerminalEndline = @Sp @Newline @Eof
  def _TerminalEndline; end

  # Ticks1 = "`" !"`"
  def _Ticks1; end

  # Ticks2 = "``" !"`"
  def _Ticks2; end

  # Ticks3 = "```" !"`"
  def _Ticks3; end

  # Ticks4 = "````" !"`"
  def _Ticks4; end

  # Ticks5 = "`````" !"`"
  def _Ticks5; end

  # Title = (TitleSingle | TitleDouble | ""):a { a }
  def _Title; end

  # TitleDouble = "\"" (!("\"" @Sp (")" | @Newline)) .)* "\""
  def _TitleDouble; end

  # TitleSingle = "'" (!("'" @Sp (")" | @Newline)) .)* "'"
  def _TitleSingle; end

  # UlLine = (< /_{4,}/ > { text } | < @Spacechar /_+/ &@Spacechar > { text })
  def _UlLine; end

  # UlOrStarLine = (UlLine | StarLine):a { a }
  def _UlOrStarLine; end

  # Verbatim = VerbatimChunk+:a { RDoc::Markup::Verbatim.new(*a.flatten) }
  def _Verbatim; end

  # VerbatimChunk = @BlankLine*:a NonblankIndentedLine+:b { a.concat b }
  def _VerbatimChunk; end

  # Whitespace = (@Spacechar | @Newline)
  def _Whitespace; end

  # root = Doc
  def _root; end

  def apply(rule); end
  def apply_with_args(rule, *args); end
  def break_on_newline=(enable); end
  def break_on_newline?; end
  def css=(enable); end
  def css?; end
  def current_character(target = T.unsafe(nil)); end
  def current_column(target = T.unsafe(nil)); end
  def current_line(target = T.unsafe(nil)); end
  def current_pos_info(target = T.unsafe(nil)); end
  def definition_lists=(enable); end
  def definition_lists?; end

  # Wraps `text` in emphasis for rdoc inline formatting
  def emphasis(text); end

  # :category: Extensions
  #
  # Enables or disables the extension with `name`
  def extension(name, enable); end

  # :category: Extensions
  #
  # Is the extension `name` enabled?
  #
  # @return [Boolean]
  def extension?(name); end

  def external_invoke(other, rule, *args); end

  # Returns the value of attribute failed_rule.
  def failed_rule; end

  # Returns the value of attribute failing_rule_offset.
  def failing_rule_offset; end

  def failure_caret; end
  def failure_character; end
  def failure_info; end
  def failure_oneline; end
  def get_byte; end
  def get_line(no); end
  def get_text(start); end
  def github=(enable); end
  def github?; end
  def grow_lr(rule, args, start_pos, m); end
  def html=(enable); end
  def html?; end

  # Parses `text` in a clone of this parser.  This is used for handling nested
  # lists the same way as markdown_parser.
  def inner_parse(text); end

  def lines; end

  # Finds a link reference for `label` and creates a new link to it with
  # `content` as the link text.  If `label` was not encountered in the
  # reference-gathering parser pass the label and content are reconstructed
  # with the linking `text` (usually whitespace).
  #
  # @raise [ParseError]
  def link_to(content, label = T.unsafe(nil), text = T.unsafe(nil)); end

  # Creates an RDoc::Markup::ListItem by parsing the `unparsed` content from
  # the first parsing pass.
  def list_item_from(unparsed); end

  def match_string(str); end

  # Stores `label` as a note and fills in previously unknown note references.
  def note(label); end

  # Creates a new link for the footnote `reference` and adds the reference to
  # the note order list for proper display at the end of the document.
  def note_for(ref); end

  def notes=(enable); end
  def notes?; end

  # Creates an RDoc::Markup::Paragraph from `parts` and including
  # extension-specific behavior
  def paragraph(parts); end

  # Parses `markdown` into an RDoc::Document
  def parse(markdown); end

  # The internal kpeg parse method
  def peg_parse(rule = T.unsafe(nil)); end

  # Returns the value of attribute pos.
  def pos; end

  # Sets the attribute pos
  #
  # @param value the value to set the attribute pos to.
  def pos=(_arg0); end

  def position_line_offsets; end

  # @raise [ParseError]
  def raise_error; end

  # Stores `label` as a reference to `link` and fills in previously unknown
  # link references.
  def reference(label, link); end

  # Returns the value of attribute result.
  def result; end

  # Sets the attribute result
  #
  # @param value the value to set the attribute result to.
  def result=(_arg0); end

  def scan(reg); end
  def set_failed_rule(name); end

  # Sets the string and current parsing position for the parser.
  def set_string(string, pos); end

  # :stopdoc:
  def setup_foreign_grammar; end

  # Prepares for parsing +str+.  If you define a custom initialize you must
  # call this method before #parse
  def setup_parser(str, debug = T.unsafe(nil)); end

  def show_error(io = T.unsafe(nil)); end
  def show_pos; end

  # Wraps `text` in strike markup for rdoc inline formatting
  def strike(text); end

  def strike=(enable); end
  def strike?; end

  # Returns the value of attribute string.
  def string; end

  # Wraps `text` in strong markup for rdoc inline formatting
  def strong(text); end

  private

  # This is distinct from setup_parser so that a standalone parser
  # can redefine #initialize and still have access to the proper
  # parser setup code.
  # TODO remove when kpeg 0.10 is released
  #
  # @return [Markdown] a new instance of Markdown
  def orig_initialize(str, debug = T.unsafe(nil)); end

  class << self
    # Creates extension methods for the `name` extension to enable and disable
    # the extension and to query if they are active.
    def extension(name); end

    # Parses the `markdown` document into an RDoc::Document using the default
    # extensions.
    def parse(markdown); end

    def rule_info(name, rendered); end
  end
end

class RDoc::Markdown::KpegPosInfo < ::Struct
  # Returns the value of attribute char
  #
  # @return [Object] the current value of char
  def char; end

  # Sets the attribute char
  #
  # @param value [Object] the value to set the attribute char to.
  # @return [Object] the newly set value
  def char=(_); end

  # Returns the value of attribute col
  #
  # @return [Object] the current value of col
  def col; end

  # Sets the attribute col
  #
  # @param value [Object] the value to set the attribute col to.
  # @return [Object] the newly set value
  def col=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute lno
  #
  # @return [Object] the current value of lno
  def lno; end

  # Sets the attribute lno
  #
  # @param value [Object] the value to set the attribute lno to.
  # @return [Object] the newly set value
  def lno=(_); end

  # Returns the value of attribute pos
  #
  # @return [Object] the current value of pos
  def pos; end

  # Sets the attribute pos
  #
  # @param value [Object] the value to set the attribute pos to.
  # @return [Object] the newly set value
  def pos=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This set of literals is for Ruby 1.9 regular expressions and gives full
# unicode support.
#
# Unlike peg-markdown, this set of literals recognizes Unicode alphanumeric
# characters, newlines and spaces.
class RDoc::Markdown::Literals
  # This is distinct from setup_parser so that a standalone parser
  # can redefine #initialize and still have access to the proper
  # parser setup code.
  #
  # @return [Literals] a new instance of Literals
  def initialize(str, debug = T.unsafe(nil)); end

  # Alphanumeric = /\p{Word}/
  def _Alphanumeric; end

  # AlphanumericAscii = /[A-Za-z0-9]/
  def _AlphanumericAscii; end

  # BOM = "uFEFF"
  def _BOM; end

  # Newline = /\n|\r\n?|\p{Zl}|\p{Zp}/
  def _Newline; end

  # NonAlphanumeric = /\p{^Word}/
  def _NonAlphanumeric; end

  # Spacechar = /\t|\p{Zs}/
  def _Spacechar; end

  def apply(rule); end
  def apply_with_args(rule, *args); end
  def current_character(target = T.unsafe(nil)); end
  def current_column(target = T.unsafe(nil)); end
  def current_line(target = T.unsafe(nil)); end
  def current_pos_info(target = T.unsafe(nil)); end
  def external_invoke(other, rule, *args); end

  # Returns the value of attribute failed_rule.
  def failed_rule; end

  # Returns the value of attribute failing_rule_offset.
  def failing_rule_offset; end

  def failure_caret; end
  def failure_character; end
  def failure_info; end
  def failure_oneline; end
  def get_byte; end
  def get_line(no); end
  def get_text(start); end
  def grow_lr(rule, args, start_pos, m); end
  def lines; end
  def match_string(str); end
  def parse(rule = T.unsafe(nil)); end

  # Returns the value of attribute pos.
  def pos; end

  # Sets the attribute pos
  #
  # @param value the value to set the attribute pos to.
  def pos=(_arg0); end

  def position_line_offsets; end

  # @raise [ParseError]
  def raise_error; end

  # Returns the value of attribute result.
  def result; end

  # Sets the attribute result
  #
  # @param value the value to set the attribute result to.
  def result=(_arg0); end

  def scan(reg); end
  def set_failed_rule(name); end

  # Sets the string and current parsing position for the parser.
  def set_string(string, pos); end

  # :startdoc:
  # :stopdoc:
  def setup_foreign_grammar; end

  # Prepares for parsing +str+.  If you define a custom initialize you must
  # call this method before #parse
  def setup_parser(str, debug = T.unsafe(nil)); end

  def show_error(io = T.unsafe(nil)); end
  def show_pos; end

  # Returns the value of attribute string.
  def string; end

  class << self
    def rule_info(name, rendered); end
  end
end

class RDoc::Markdown::Literals::KpegPosInfo < ::Struct
  # Returns the value of attribute char
  #
  # @return [Object] the current value of char
  def char; end

  # Sets the attribute char
  #
  # @param value [Object] the value to set the attribute char to.
  # @return [Object] the newly set value
  def char=(_); end

  # Returns the value of attribute col
  #
  # @return [Object] the current value of col
  def col; end

  # Sets the attribute col
  #
  # @param value [Object] the value to set the attribute col to.
  # @return [Object] the newly set value
  def col=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute lno
  #
  # @return [Object] the current value of lno
  def lno; end

  # Sets the attribute lno
  #
  # @param value [Object] the value to set the attribute lno to.
  # @return [Object] the newly set value
  def lno=(_); end

  # Returns the value of attribute pos
  #
  # @return [Object] the current value of pos
  def pos; end

  # Sets the attribute pos
  #
  # @param value [Object] the value to set the attribute pos to.
  # @return [Object] the newly set value
  def pos=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RDoc::Markdown::Literals::MemoEntry
  # @return [MemoEntry] a new instance of MemoEntry
  def initialize(ans, pos); end

  # Returns the value of attribute ans.
  def ans; end

  # Returns the value of attribute left_rec.
  def left_rec; end

  # Sets the attribute left_rec
  #
  # @param value the value to set the attribute left_rec to.
  def left_rec=(_arg0); end

  def move!(ans, pos, result); end

  # Returns the value of attribute pos.
  def pos; end

  # Returns the value of attribute result.
  def result; end

  # Returns the value of attribute set.
  def set; end
end

class RDoc::Markdown::Literals::RuleInfo
  # @return [RuleInfo] a new instance of RuleInfo
  def initialize(name, rendered); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute rendered.
  def rendered; end
end

class RDoc::Markdown::MemoEntry
  # @return [MemoEntry] a new instance of MemoEntry
  def initialize(ans, pos); end

  # Returns the value of attribute ans.
  def ans; end

  # Returns the value of attribute left_rec.
  def left_rec; end

  # Sets the attribute left_rec
  #
  # @param value the value to set the attribute left_rec to.
  def left_rec=(_arg0); end

  def move!(ans, pos, result); end

  # Returns the value of attribute pos.
  def pos; end

  # Returns the value of attribute result.
  def result; end

  # Returns the value of attribute set.
  def set; end
end

class RDoc::Markdown::RuleInfo
  # @return [RuleInfo] a new instance of RuleInfo
  def initialize(name, rendered); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute rendered.
  def rendered; end
end

class RDoc::Markup
  # Take a block of text and use various heuristics to determine its
  # structure (paragraphs, lists, and so on).  Invoke an event handler as we
  # identify significant chunks.
  #
  # @return [Markup] a new instance of Markup
  def initialize(attribute_manager = T.unsafe(nil)); end

  # Add to the sequences recognized as general markup.
  def add_html(tag, name); end

  # Add to other inline sequences.  For example, we could add WikiWords using
  # something like:
  #
  #    parser.add_regexp_handling(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)
  #
  # Each wiki word will be presented to the output formatter.
  def add_regexp_handling(pattern, name); end

  # Add to the sequences used to add formatting to an individual word (such
  # as *bold*).  Matching entries will generate attributes that the output
  # formatters can recognize by their +name+.
  def add_word_pair(start, stop, name); end

  # An AttributeManager which handles inline markup.
  def attribute_manager; end

  # We take +input+, parse it if necessary, then invoke the output +formatter+
  # using a Visitor to render the result.
  def convert(input, formatter); end

  class << self
    # Parses +str+ into an RDoc::Markup::Document.
    def parse(str); end
  end
end

# An AttrChanger records a change in attributes. It contains a bitmap of the
# attributes to turn on, and a bitmap of those to turn off.
class RDoc::Markup::AttrChanger < ::Struct
  def inspect; end
  def to_s; end
end

# An array of attributes which parallels the characters in a string.
class RDoc::Markup::AttrSpan
  # Creates a new AttrSpan for +length+ characters
  #
  # @return [AttrSpan] a new instance of AttrSpan
  def initialize(length, exclusive); end

  # Accesses flags for character +n+
  def [](n); end

  # Toggles +bits+ from +start+ to +length+
  def set_attrs(start, length, bits); end
end

# Manages changes of attributes in a block of text
class RDoc::Markup::AttributeManager
  # Creates a new attribute manager that understands bold, emphasized and
  # teletype text.
  #
  # @return [AttributeManager] a new instance of AttributeManager
  def initialize; end

  # Adds a markup class with +name+ for words surrounded by HTML tag +tag+.
  # To process emphasis tags:
  #
  #   am.add_html 'em', :EM
  def add_html(tag, name, exclusive = T.unsafe(nil)); end

  # Adds a regexp handling for +pattern+ with +name+.  A simple URL handler
  # would be:
  #
  #   @am.add_regexp_handling(/((https?:)\S+\w)/, :HYPERLINK)
  def add_regexp_handling(pattern, name, exclusive = T.unsafe(nil)); end

  # Adds a markup class with +name+ for words wrapped in the +start+ and
  # +stop+ character.  To make words wrapped with "*" bold:
  #
  #   am.add_word_pair '*', '*', :BOLD
  #
  # @raise [ArgumentError]
  def add_word_pair(start, stop, name, exclusive = T.unsafe(nil)); end

  # Return an attribute object with the given turn_on and turn_off bits set
  def attribute(turn_on, turn_off); end

  # The attributes enabled for this markup object.
  def attributes; end

  # Changes the current attribute from +current+ to +new+
  def change_attribute(current, new); end

  # Used by the tests to change attributes by name from +current_set+ to
  # +new_set+
  def changed_attribute_by_name(current_set, new_set); end

  # Map attributes like <b>text</b>to the sequence
  # \001\002<char>\001\003<char>, where <char> is a per-attribute specific
  # character
  def convert_attrs(str, attrs, exclusive = T.unsafe(nil)); end

  def convert_attrs_matching_word_pairs(str, attrs, exclusive); end
  def convert_attrs_word_pair_map(str, attrs, exclusive); end

  # Converts HTML tags to RDoc attributes
  def convert_html(str, attrs, exclusive = T.unsafe(nil)); end

  # Converts regexp handling sequences to RDoc attributes
  def convert_regexp_handlings(str, attrs, exclusive = T.unsafe(nil)); end

  # Copies +start_pos+ to +end_pos+ from the current string
  def copy_string(start_pos, end_pos); end

  # Debug method that prints a string along with its attributes
  def display_attributes; end

  # @return [Boolean]
  def exclusive?(attr); end

  # A bits of exclusive maps
  def exclusive_bitmap; end

  # Processes +str+ converting attributes, HTML and regexp handlings
  def flow(str); end

  # This maps HTML tags to the corresponding attribute char
  def html_tags; end

  # Escapes regexp handling sequences of text to prevent conversion to RDoc
  def mask_protected_sequences; end

  # This maps delimiters that occur around words (such as *bold* or +tt+)
  # where the start and end delimiters and the same. This lets us optimize
  # the regexp
  def matching_word_pairs; end

  # A \ in front of a character that would normally be processed turns off
  # processing. We do this by turning \< into <#{PROTECT}
  def protectable; end

  # And this maps _regexp handling_ sequences to a name. A regexp handling
  # sequence is something like a WikiWord
  def regexp_handlings; end

  # Splits the string into chunks by attribute change
  def split_into_flow; end

  # Unescapes regexp handling sequences of text
  def unmask_protected_sequences; end

  # And this is used when the delimiters aren't the same. In this case the
  # hash maps a pattern to the attribute character
  def word_pair_map; end
end

RDoc::Markup::AttributeManager::NON_PRINTING_END = T.let(T.unsafe(nil), String)
RDoc::Markup::AttributeManager::NON_PRINTING_START = T.let(T.unsafe(nil), String)

# We manage a set of attributes.  Each attribute has a symbol name and a bit
# value.
class RDoc::Markup::Attributes
  # Creates a new attributes set.
  #
  # @return [Attributes] a new instance of Attributes
  def initialize; end

  # Returns a string representation of +bitmap+
  def as_string(bitmap); end

  # Returns a unique bit for +name+
  def bitmap_for(name); end

  # yields each attribute name in +bitmap+
  def each_name_of(bitmap); end

  # The regexp handling attribute type. See RDoc::Markup#add_regexp_handling
  def regexp_handling; end
end

# An empty line.  This class is a singleton.
class RDoc::Markup::BlankLine
  # Calls #accept_blank_line on +visitor+
  def accept(visitor); end

  def pretty_print(q); end

  class << self
    # RDoc::Markup::BlankLine is a singleton
    def new; end
  end
end

# A quoted section which contains markup items.
class RDoc::Markup::BlockQuote < ::RDoc::Markup::Raw
  # Calls #accept_block_quote on +visitor+
  def accept(visitor); end
end

# A Document containing lists, headings, paragraphs, etc.
class RDoc::Markup::Document
  include ::Enumerable

  # Creates a new Document with +parts+
  #
  # @return [Document] a new instance of Document
  def initialize(*parts); end

  # Appends +part+ to the document
  def <<(part); end

  def ==(other); end

  # Runs this document and all its #items through +visitor+
  def accept(visitor); end

  # Concatenates the given +parts+ onto the document
  def concat(parts); end

  # Enumerator for the parts of this document
  def each(&block); end

  # Does this document have no parts?
  #
  # @return [Boolean]
  def empty?; end

  # The file this document was created from.  See also
  # RDoc::ClassModule#add_comment
  def file; end

  # The file this Document was created from.
  def file=(location); end

  # When this is a collection of documents (#file is not set and this document
  # contains only other documents as its direct children) #merge replaces
  # documents in this class with documents from +other+ when the file matches
  # and adds documents from +other+ when the files do not.
  #
  # The information in +other+ is preferred over the receiver
  def merge(other); end

  # Does this Document contain other Documents?
  #
  # @return [Boolean]
  def merged?; end

  # If a heading is below the given level it will be omitted from the
  # table_of_contents
  def omit_headings_below; end

  # If a heading is below the given level it will be omitted from the
  # table_of_contents
  def omit_headings_below=(_arg0); end

  # The parts of the Document
  def parts; end

  def pretty_print(q); end

  # Appends +parts+ to the document
  def push(*parts); end

  # Returns an Array of headings in the document.
  #
  # Require 'rdoc/markup/formatter' before calling this method.
  def table_of_contents; end
end

# Base class for RDoc markup formatters
#
# Formatters are a visitor that converts an RDoc::Markup tree (from a comment)
# into some kind of output.  RDoc ships with formatters for converting back to
# rdoc, ANSI text, HTML, a Table of Contents and other formats.
#
# If you'd like to write your own Formatter use
# RDoc::Markup::FormatterTestCase.  If you're writing a text-output formatter
# use RDoc::Markup::TextFormatterTestCase which provides extra test cases.
class RDoc::Markup::Formatter
  # Creates a new Formatter
  #
  # @return [Formatter] a new instance of Formatter
  def initialize(options, markup = T.unsafe(nil)); end

  # Adds +document+ to the output
  def accept_document(document); end

  # Adds a regexp handling for links of the form rdoc-...:
  def add_regexp_handling_RDOCLINK; end

  # Adds a regexp handling for links of the form {<text>}[<url>] and
  # <word>[<url>]
  def add_regexp_handling_TIDYLINK; end

  # Add a new set of tags for an attribute. We allow separate start and end
  # tags for flexibility
  def add_tag(name, start, stop); end

  # Allows +tag+ to be decorated with additional information.
  def annotate(tag); end

  # Marks up +content+
  def convert(content); end

  # Converts flow items +flow+
  def convert_flow(flow); end

  # Converts added regexp handlings. See RDoc::Markup#add_regexp_handling
  def convert_regexp_handling(target); end

  # Converts a string to be fancier if desired
  def convert_string(string); end

  # Use ignore in your subclass to ignore the content of a node.
  #
  #   ##
  #   # We don't support raw nodes in ToNoRaw
  #
  #   alias accept_raw ignore
  def ignore(*node); end

  # Are we currently inside tt tags?
  #
  # @return [Boolean]
  def in_tt?; end

  # Turns off tags for +item+ on +res+
  def off_tags(res, item); end

  # Turns on tags for +item+ on +res+
  def on_tags(res, item); end

  # Extracts and a scheme, url and an anchor id from +url+ and returns them.
  def parse_url(url); end

  # Is +tag+ a tt tag?
  #
  # @return [Boolean]
  def tt?(tag); end

  class << self
    # Converts a target url to one that is relative to a given path
    def gen_relative_url(path, target); end
  end
end

# A hard-break in the middle of a paragraph.
class RDoc::Markup::HardBreak
  def ==(other); end

  # Calls #accept_hard_break on +visitor+
  def accept(visitor); end

  def pretty_print(q); end

  class << self
    # RDoc::Markup::HardBreak is a singleton
    def new; end
  end
end

class RDoc::Markup::Heading < ::Struct
  def accept(visitor); end
  def aref; end
  def label(context = T.unsafe(nil)); end
  def plain_html; end
  def pretty_print(q); end

  class << self
    def to_html; end
    def to_label; end
  end
end

# A file included at generation time.  Objects of this class are created by
# RDoc::RD for an extension-less include.
#
# This implementation in incomplete.
class RDoc::Markup::Include
  # Creates a new include that will import +file+ from +include_path+
  #
  # @return [Include] a new instance of Include
  def initialize(file, include_path); end

  def ==(other); end

  # The filename to be included, without extension
  def file; end

  # Directories to search for #file
  def include_path; end

  def pretty_print(q); end
end

# An Indented Paragraph of text
class RDoc::Markup::IndentedParagraph < ::RDoc::Markup::Raw
  # Creates a new IndentedParagraph containing +parts+ indented with +indent+
  # spaces
  #
  # @return [IndentedParagraph] a new instance of IndentedParagraph
  def initialize(indent, *parts); end

  def ==(other); end

  # Calls #accept_indented_paragraph on +visitor+
  def accept(visitor); end

  # The indent in number of spaces
  def indent; end

  # Joins the raw paragraph text and converts inline HardBreaks to the
  # +hard_break+ text followed by the indent.
  def text(hard_break = T.unsafe(nil)); end
end

# A List is a homogeneous set of ListItems.
#
# The supported list types include:
#
# :BULLET::
#   An unordered list
# :LABEL::
#   An unordered definition list, but using an alternate RDoc::Markup syntax
# :LALPHA::
#   An ordered list using increasing lowercase English letters
# :NOTE::
#   An unordered definition list
# :NUMBER::
#   An ordered list using increasing Arabic numerals
# :UALPHA::
#   An ordered list using increasing uppercase English letters
#
# Definition lists behave like HTML definition lists.  Each list item can
# describe multiple terms.  See RDoc::Markup::ListItem for how labels and
# definition are stored as list items.
class RDoc::Markup::List
  # Creates a new list of +type+ with +items+.  Valid list types are:
  # +:BULLET+, +:LABEL+, +:LALPHA+, +:NOTE+, +:NUMBER+, +:UALPHA+
  #
  # @return [List] a new instance of List
  def initialize(type = T.unsafe(nil), *items); end

  # Appends +item+ to the list
  def <<(item); end

  def ==(other); end

  # Runs this list and all its #items through +visitor+
  def accept(visitor); end

  # Is the list empty?
  #
  # @return [Boolean]
  def empty?; end

  # Items in the list
  def items; end

  # Returns the last item in the list
  def last; end

  def pretty_print(q); end

  # Appends +items+ to the list
  def push(*items); end

  # The list's type
  def type; end

  # The list's type
  def type=(_arg0); end
end

# An item within a List that contains paragraphs, headings, etc.
#
# For BULLET, NUMBER, LALPHA and UALPHA lists, the label will always be nil.
# For NOTE and LABEL lists, the list label may contain:
#
# * a single String for a single label
# * an Array of Strings for a list item with multiple terms
# * nil for an extra description attached to a previously labeled list item
class RDoc::Markup::ListItem
  # Creates a new ListItem with an optional +label+ containing +parts+
  #
  # @return [ListItem] a new instance of ListItem
  def initialize(label = T.unsafe(nil), *parts); end

  # Appends +part+ to the ListItem
  def <<(part); end

  def ==(other); end

  # Runs this list item and all its #parts through +visitor+
  def accept(visitor); end

  # Is the ListItem empty?
  #
  # @return [Boolean]
  def empty?; end

  # The label for the ListItem
  def label; end

  # The label for the ListItem
  def label=(_arg0); end

  # Length of parts in the ListItem
  def length; end

  # Parts of the ListItem
  def parts; end

  def pretty_print(q); end

  # Adds +parts+ to the ListItem
  def push(*parts); end
end

# A Paragraph of text
class RDoc::Markup::Paragraph < ::RDoc::Markup::Raw
  # Calls #accept_paragraph on +visitor+
  def accept(visitor); end

  # Joins the raw paragraph text and converts inline HardBreaks to the
  # +hard_break+ text.
  def text(hard_break = T.unsafe(nil)); end
end

# A recursive-descent parser for RDoc markup.
#
# The parser tokenizes an input string then parses the tokens into a Document.
# Documents can be converted into output formats by writing a visitor like
# RDoc::Markup::ToHTML.
#
# The parser only handles the block-level constructs Paragraph, List,
# ListItem, Heading, Verbatim, BlankLine, Rule and BlockQuote.
# Inline markup such as <tt>\+blah\+</tt> is handled separately by
# RDoc::Markup::AttributeManager.
#
# To see what markup the Parser implements read RDoc.  To see how to use
# RDoc markup to format text in your program read RDoc::Markup.
class RDoc::Markup::Parser
  include ::RDoc::Text

  # Creates a new Parser.  See also ::parse
  #
  # @return [Parser] a new instance of Parser
  def initialize; end

  # Builds a Heading of +level+
  def build_heading(level); end

  # Builds a List flush to +margin+
  def build_list(margin); end

  # Builds a Paragraph that is flush to +margin+
  def build_paragraph(margin); end

  # Builds a Verbatim that is indented from +margin+.
  #
  # The verbatim block is shifted left (the least indented lines start in
  # column 0).  Each part of the verbatim is one line of text, always
  # terminated by a newline.  Blank lines always consist of a single newline
  # character, and there is never a single newline at the end of the verbatim.
  def build_verbatim(margin); end

  # Enables display of debugging information
  def debug; end

  # Enables display of debugging information
  def debug=(_arg0); end

  # Pulls the next token from the stream.
  def get; end

  # Parses the tokens into an array of RDoc::Markup::XXX objects,
  # and appends them to the passed +parent+ RDoc::Markup::YYY object.
  #
  # Exits at the end of the token stream, or when it encounters a token
  # in a column less than +indent+ (unless it is a NEWLINE).
  #
  # Returns +parent+.
  def parse(parent, indent = T.unsafe(nil)); end

  # Small hook that is overridden by RDoc::TomDoc
  def parse_text(parent, indent); end

  # Returns the next token on the stream without modifying the stream
  def peek_token; end

  # Creates the StringScanner
  def setup_scanner(input); end

  # Skips the next token if its type is +token_type+.
  #
  # Optionally raises an error if the next token is not of the expected type.
  #
  # @raise [ParseError]
  def skip(token_type, error = T.unsafe(nil)); end

  # Turns text +input+ into a stream of tokens
  def tokenize(input); end

  # Token accessor
  def tokens; end

  # Returns the current token to the token stream
  #
  # @raise [Error]
  def unget; end

  class << self
    # Parses +str+ into a Document.
    #
    # Use RDoc::Markup#parse instead of this method.
    def parse(str); end

    # Returns a token stream for +str+, for testing
    def tokenize(str); end
  end
end

# A simple wrapper of StringScanner that is aware of the current column and lineno
class RDoc::Markup::Parser::MyStringScanner
  # :stopdoc:
  #
  # @return [MyStringScanner] a new instance of MyStringScanner
  def initialize(input); end

  def [](i); end

  # @return [Boolean]
  def eos?; end

  def matched; end
  def newline!; end
  def pos; end
  def scan(re); end
  def unscan(s); end
end

# Handle common directives that can occur in a block of text:
#
#   \:include: filename
#
# Directives can be escaped by preceding them with a backslash.
#
# RDoc plugin authors can register additional directives to be handled by
# using RDoc::Markup::PreProcess::register.
#
# Any directive that is not built-in to RDoc (including those registered via
# plugins) will be stored in the metadata hash on the CodeObject the comment
# is attached to.  See RDoc::Markup@Directives for the list of built-in
# directives.
class RDoc::Markup::PreProcess
  # Creates a new pre-processor for +input_file_name+ that will look for
  # included files in +include_path+
  #
  # @return [PreProcess] a new instance of PreProcess
  def initialize(input_file_name, include_path); end

  # Look for the given file in the directory containing the current file,
  # and then in each of the directories specified in the RDOC_INCLUDE path
  def find_include_file(name); end

  # Look for directives in the given +text+.
  #
  # Options that we don't handle are yielded.  If the block returns false the
  # directive is restored to the text.  If the block returns nil or no block
  # was given the directive is handled according to the registered directives.
  # If a String was returned the directive is replaced with the string.
  #
  # If no matching directive was registered the directive is restored to the
  # text.
  #
  # If +code_object+ is given and the directive is unknown then the
  # directive's parameter is set as metadata on the +code_object+.  See
  # RDoc::CodeObject#metadata for details.
  def handle(text, code_object = T.unsafe(nil), &block); end

  # Performs the actions described by +directive+ and its parameter +param+.
  #
  # +code_object+ is used for directives that operate on a class or module.
  # +prefix+ is used to ensure the replacement for handled directives is
  # correct.  +encoding+ is used for the <tt>include</tt> directive.
  #
  # For a list of directives in RDoc see RDoc::Markup.
  # --
  # When 1.8.7 support is ditched prefix can be defaulted to ''
  def handle_directive(prefix, directive, param, code_object = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # Handles the <tt>:include: _filename_</tt> directive.
  #
  # If the first line of the included file starts with '#', and contains
  # an encoding information in the form 'coding:' or 'coding=', it is
  # removed.
  #
  # If all lines in the included file start with a '#', this leading '#'
  # is removed before inclusion. The included content is indented like
  # the <tt>:include:</tt> directive.
  # --
  # so all content will be verbatim because of the likely space after '#'?
  # TODO shift left the whole file content in that case
  # TODO comment stop/start #-- and #++ in included file must be processed here
  def include_file(name, indent, encoding); end

  # An RDoc::Options instance that will be filled in with overrides from
  # directives
  def options; end

  # An RDoc::Options instance that will be filled in with overrides from
  # directives
  def options=(_arg0); end

  class << self
    # Adds a post-process handler for directives.  The handler will be called
    # with the result RDoc::Comment (or text String) and the code object for the
    # comment (if any).
    def post_process(&block); end

    # Registered post-processors
    def post_processors; end

    # Registers +directive+ as one handled by RDoc.  If a block is given the
    # directive will be replaced by the result of the block, otherwise the
    # directive will be removed from the processed text.
    #
    # The block will be called with the directive name and the directive
    # parameter:
    #
    #   RDoc::Markup::PreProcess.register 'my-directive' do |directive, param|
    #     # replace text, etc.
    #   end
    def register(directive, &block); end

    # Registered directives
    def registered; end

    # Clears all registered directives and post-processors
    def reset; end
  end
end

# A section of text that is added to the output document as-is
class RDoc::Markup::Raw
  # Creates a new Raw containing +parts+
  #
  # @return [Raw] a new instance of Raw
  def initialize(*parts); end

  # Appends +text+
  def <<(text); end

  def ==(other); end

  # Calls #accept_raw+ on +visitor+
  def accept(visitor); end

  # Appends +other+'s parts
  def merge(other); end

  # The component parts of the list
  def parts; end

  def pretty_print(q); end

  # Appends +texts+ onto this Paragraph
  def push(*texts); end

  # The raw text
  def text; end
end

# Hold details of a regexp handling sequence
class RDoc::Markup::RegexpHandling
  # Creates a new regexp handling sequence of +type+ with +text+
  #
  # @return [RegexpHandling] a new instance of RegexpHandling
  def initialize(type, text); end

  # Regexp handlings are equal when the have the same text and type
  def ==(o); end

  def inspect; end

  # Regexp handling text
  def text; end

  # Regexp handling text
  def text=(_arg0); end

  def to_s; end

  # Regexp handling type
  def type; end
end

# A horizontal rule with a weight
class RDoc::Markup::Rule < ::Struct
  # Calls #accept_rule on +visitor+
  def accept(visitor); end

  def pretty_print(q); end
end

# A section of table
class RDoc::Markup::Table
  # Creates new instance
  #
  # @return [Table] a new instance of Table
  def initialize(header, align, body); end

  # :stopdoc:
  def ==(other); end

  def accept(visitor); end

  # alignments of each column
  def align; end

  # alignments of each column
  def align=(_arg0); end

  # body texts of each column
  def body; end

  # body texts of each column
  def body=(_arg0); end

  # headers of each column
  def header; end

  # headers of each column
  def header=(_arg0); end

  def pretty_print(q); end
end

# Outputs RDoc markup with vibrant ANSI color!
class RDoc::Markup::ToAnsi < ::RDoc::Markup::ToRdoc
  # Creates a new ToAnsi visitor that is ready to output vibrant ANSI color!
  #
  # @return [ToAnsi] a new instance of ToAnsi
  def initialize(markup = T.unsafe(nil)); end

  # Overrides indent width to ensure output lines up correctly.
  def accept_list_item_end(list_item); end

  # Adds coloring to note and label list items
  def accept_list_item_start(list_item); end

  # Maps attributes to ANSI sequences
  def init_tags; end

  # Starts accepting with a reset screen
  def start_accepting; end
end

# Outputs RDoc markup with hot backspace action!  You will probably need a
# pager to use this output format.
#
# This formatter won't work on 1.8.6 because it lacks String#chars.
class RDoc::Markup::ToBs < ::RDoc::Markup::ToRdoc
  # Returns a new ToBs that is ready for hot backspace action!
  #
  # @return [ToBs] a new instance of ToBs
  def initialize(markup = T.unsafe(nil)); end

  # Makes heading text bold.
  def accept_heading(heading); end

  # Prepares the visitor for consuming +list_item+
  def accept_list_item_start(list_item); end

  # Turns on or off regexp handling for +convert_string+
  def annotate(tag); end

  # Calls convert_string on the result of convert_regexp_handling
  def convert_regexp_handling(target); end

  # Adds bold or underline mixed with backspaces
  def convert_string(string); end

  # Sets a flag that is picked up by #annotate to do the right thing in
  # #convert_string
  def init_tags; end
end

# Outputs RDoc markup as HTML.
class RDoc::Markup::ToHtml < ::RDoc::Markup::Formatter
  include ::RDoc::Text

  # Creates a new formatter that will output HTML
  #
  # @return [ToHtml] a new instance of ToHtml
  def initialize(options, markup = T.unsafe(nil)); end

  # Adds +blank_line+ to the output
  def accept_blank_line(blank_line); end

  # Adds +block_quote+ to the output
  def accept_block_quote(block_quote); end

  # Adds +heading+ to the output.  The headings greater than 6 are trimmed to
  # level 6.
  def accept_heading(heading); end

  # Finishes consumption of +list+
  def accept_list_end(list); end

  # Finishes consumption of +list_item+
  def accept_list_item_end(list_item); end

  # Prepares the visitor for consuming +list_item+
  def accept_list_item_start(list_item); end

  # Prepares the visitor for consuming +list+
  def accept_list_start(list); end

  # Adds +paragraph+ to the output
  def accept_paragraph(paragraph); end

  # Adds +raw+ to the output
  def accept_raw(raw); end

  # Adds +rule+ to the output
  def accept_rule(rule); end

  # Adds +table+ to the output
  def accept_table(header, body, aligns); end

  # Adds +verbatim+ to the output
  def accept_verbatim(verbatim); end

  # The RDoc::CodeObject HTML is being generated for.  This is used to
  # generate namespaced URI fragments
  def code_object; end

  # The RDoc::CodeObject HTML is being generated for.  This is used to
  # generate namespaced URI fragments
  def code_object=(_arg0); end

  # CGI-escapes +text+
  def convert_string(text); end

  # Returns the generated output
  def end_accepting; end

  # Path to this document for relative links
  def from_path; end

  # Path to this document for relative links
  def from_path=(_arg0); end

  # Generate a link to +url+ with content +text+.  Handles the special cases
  # for img: and link: described under handle_regexp_HYPERLINK
  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  # +target+ is a <code><br></code>
  def handle_regexp_HARD_BREAK(target); end

  # +target+ is a potential link.  The following schemes are handled:
  #
  # <tt>mailto:</tt>::
  #   Inserted as-is.
  # <tt>http:</tt>::
  #   Links are checked to see if they reference an image. If so, that image
  #   gets inserted using an <tt><img></tt> tag. Otherwise a conventional
  #   <tt><a href></tt> is used.
  # <tt>link:</tt>::
  #   Reference to a local file relative to the output directory.
  def handle_regexp_HYPERLINK(target); end

  # +target+ is an rdoc-schemed link that will be converted into a hyperlink.
  #
  # For the +rdoc-ref+ scheme the named reference will be returned without
  # creating a link.
  #
  # For the +rdoc-label+ scheme the footnote and label prefixes are stripped
  # when creating a link.  All other contents will be linked verbatim.
  def handle_regexp_RDOCLINK(target); end

  # This +target+ is a link where the label is different from the URL
  # <tt>label[url]</tt> or <tt>{long label}[url]</tt>
  def handle_regexp_TIDYLINK(target); end

  # Determines the HTML list element for +list_type+ and +open_tag+
  #
  # @raise [RDoc::Error]
  def html_list_name(list_type, open_tag); end

  def in_list_entry; end

  # Adds regexp handlings about link notations.
  def init_link_notation_regexp_handlings; end

  # Adds regexp handlings.
  def init_regexp_handlings; end

  # Maps attributes to HTML tags
  def init_tags; end

  def list; end

  # Returns the HTML end-tag for +list_type+
  def list_end_for(list_type); end

  # Returns the HTML tag for +list_type+, possible using a label from
  # +list_item+
  def list_item_start(list_item, list_type); end

  # Returns true if text is valid ruby syntax
  #
  # @return [Boolean]
  def parseable?(text); end

  def res; end

  # Prepares the visitor for HTML generation
  def start_accepting; end

  # Converts +item+ to HTML using RDoc::Text#to_html
  def to_html(item); end
end

RDoc::Markup::ToHtml::URL_CHARACTERS_REGEXP_STR = T.let(T.unsafe(nil), String)

# Subclass of the RDoc::Markup::ToHtml class that supports looking up method
# names, classes, etc to create links.  RDoc::CrossReference is used to
# generate those links based on the current context.
class RDoc::Markup::ToHtmlCrossref < ::RDoc::Markup::ToHtml
  # Creates a new crossref resolver that generates links relative to +context+
  # which lives at +from_path+ in the generated files.  '#' characters on
  # references are removed unless +show_hash+ is true.  Only method names
  # preceded by '#' or '::' are linked, unless +hyperlink_all+ is true.
  #
  # @raise [ArgumentError]
  # @return [ToHtmlCrossref] a new instance of ToHtmlCrossref
  def initialize(options, from_path, context, markup = T.unsafe(nil)); end

  # RDoc::CodeObject for generating references
  def context; end

  # RDoc::CodeObject for generating references
  def context=(_arg0); end

  # Creates a link to the reference +name+ if the name exists.  If +text+ is
  # given it is used as the link text, otherwise +name+ is used.
  def cross_reference(name, text = T.unsafe(nil), code = T.unsafe(nil)); end

  # Generates links for <tt>rdoc-ref:</tt> scheme URLs and allows
  # RDoc::Markup::ToHtml to handle other schemes.
  def gen_url(url, text); end

  # We're invoked when any text matches the CROSSREF pattern.  If we find the
  # corresponding reference, generate a link.  If the name we're looking for
  # contains no punctuation, we look for it up the module/class chain.  For
  # example, ToHtml is found, even without the <tt>RDoc::Markup::</tt> prefix,
  # because we look for it in module Markup first.
  def handle_regexp_CROSSREF(target); end

  # Handles <tt>rdoc-ref:</tt> scheme links and allows RDoc::Markup::ToHtml to
  # handle other schemes.
  def handle_regexp_HYPERLINK(target); end

  # +target+ is an rdoc-schemed link that will be converted into a hyperlink.
  # For the rdoc-ref scheme the cross-reference will be looked up and the
  # given name will be used.
  #
  # All other contents are handled by
  # {the superclass}[rdoc-ref:RDoc::Markup::ToHtml#handle_regexp_RDOCLINK]
  def handle_regexp_RDOCLINK(target); end

  def init_link_notation_regexp_handlings; end

  # Creates an HTML link to +name+ with the given +text+.
  def link(name, text, code = T.unsafe(nil)); end

  # Should we show '#' characters on method references?
  def show_hash; end

  # Should we show '#' characters on method references?
  def show_hash=(_arg0); end
end

# Outputs RDoc markup as paragraphs with inline markup only.
class RDoc::Markup::ToHtmlSnippet < ::RDoc::Markup::ToHtml
  # Creates a new ToHtmlSnippet formatter that will cut off the input on the
  # next word boundary after the given number of +characters+ or +paragraphs+
  # of text have been encountered.
  #
  # @return [ToHtmlSnippet] a new instance of ToHtmlSnippet
  def initialize(options, characters = T.unsafe(nil), paragraphs = T.unsafe(nil), markup = T.unsafe(nil)); end

  # Adds +heading+ to the output as a paragraph
  def accept_heading(heading); end

  # Finishes consumption of +list_item+
  def accept_list_item_end(list_item); end

  # Prepares the visitor for consuming +list_item+
  def accept_list_item_start(list_item); end

  # Prepares the visitor for consuming +list+
  def accept_list_start(list); end

  # Adds +paragraph+ to the output
  def accept_paragraph(paragraph); end

  # Raw sections are untrusted and ignored
  def accept_raw(*node); end

  # Rules are ignored
  def accept_rule(*node); end

  # Adds +verbatim+ to the output
  def accept_verbatim(verbatim); end

  # Throws +:done+ when paragraph_limit paragraphs have been encountered
  def add_paragraph; end

  # After this many characters the input will be cut off.
  def character_limit; end

  # The number of characters seen so far.
  def characters; end

  # Marks up +content+
  def convert(content); end

  # Converts flow items +flow+
  def convert_flow(flow); end

  # Returns just the text of +link+, +url+ is only used to determine the link
  # type.
  def gen_url(url, text); end

  # Removes escaping from the cross-references in +target+
  def handle_regexp_CROSSREF(target); end

  # +target+ is a <code><br></code>
  def handle_regexp_HARD_BREAK(target); end

  # In snippets, there are no lists
  def html_list_name(list_type, open_tag); end

  # Lists are paragraphs, but notes and labels have a separator
  def list_item_start(list_item, list_type); end

  # The attribute bitmask
  def mask; end

  # Maintains a bitmask to allow HTML elements to be closed properly.  See
  # RDoc::Markup::Formatter.
  def off_tags(res, item); end

  # Maintains a bitmask to allow HTML elements to be closed properly.  See
  # RDoc::Markup::Formatter.
  def on_tags(res, item); end

  # After this many paragraphs the input will be cut off.
  def paragraph_limit; end

  # Count of paragraphs found
  def paragraphs; end

  # Prepares the visitor for HTML snippet generation
  def start_accepting; end

  # Truncates +text+ at the end of the first word after the character_limit.
  def truncate(text); end
end

# Joins the parts of an RDoc::Markup::Paragraph into a single String.
#
# This allows for easier maintenance and testing of Markdown support.
#
# This formatter only works on Paragraph instances.  Attempting to process
# other markup syntax items will not work.
class RDoc::Markup::ToJoinedParagraph < ::RDoc::Markup::Formatter
  # @return [ToJoinedParagraph] a new instance of ToJoinedParagraph
  def initialize; end

  def accept_block_quote(*node); end
  def accept_heading(*node); end
  def accept_list_end(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end

  # Converts the parts of +paragraph+ to a single entry.
  def accept_paragraph(paragraph); end

  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_table(*node); end
  def accept_verbatim(*node); end
  def end_accepting; end
  def start_accepting; end
end

# Creates HTML-safe labels suitable for use in id attributes.  Tidylinks are
# converted to their link part and cross-reference links have the suppression
# marks removed (\\SomeClass is converted to SomeClass).
class RDoc::Markup::ToLabel < ::RDoc::Markup::Formatter
  # Creates a new formatter that will output HTML-safe labels
  #
  # @return [ToLabel] a new instance of ToLabel
  def initialize(markup = T.unsafe(nil)); end

  def accept_blank_line(*node); end
  def accept_block_quote(*node); end
  def accept_heading(*node); end
  def accept_list_end(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end
  def accept_paragraph(*node); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_verbatim(*node); end

  # Converts +text+ to an HTML-safe label
  def convert(text); end

  def end_accepting(*node); end

  # Converts the CROSSREF +target+ to plain text, removing the suppression
  # marker, if any
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  # Converts the TIDYLINK +target+ to just the text part
  def handle_regexp_TIDYLINK(target); end

  def res; end
  def start_accepting(*node); end
end

# Outputs parsed markup as Markdown
class RDoc::Markup::ToMarkdown < ::RDoc::Markup::ToRdoc
  # Creates a new formatter that will output Markdown format text
  #
  # @return [ToMarkdown] a new instance of ToMarkdown
  def initialize(markup = T.unsafe(nil)); end

  # Finishes consumption of `list`
  def accept_list_end(list); end

  # Finishes consumption of `list_item`
  def accept_list_item_end(list_item); end

  # Prepares the visitor for consuming `list_item`
  def accept_list_item_start(list_item); end

  # Prepares the visitor for consuming `list`
  def accept_list_start(list); end

  # Adds `rule` to the output
  def accept_rule(rule); end

  # Outputs `verbatim` indented 4 columns
  def accept_verbatim(verbatim); end

  # Creates a Markdown-style URL from +url+ with +text+.
  def gen_url(url, text); end

  # Handles <tt>rdoc-</tt> type links for footnotes.
  def handle_rdoc_link(url); end

  # Adds a newline to the output
  def handle_regexp_HARD_BREAK(target); end

  # Converts the rdoc-...: links into a Markdown.style links.
  def handle_regexp_RDOCLINK(target); end

  # Converts the RDoc markup tidylink into a Markdown.style link.
  def handle_regexp_TIDYLINK(target); end

  # Maps attributes to HTML sequences
  def init_tags; end
end

# Outputs RDoc markup as RDoc markup! (mostly)
class RDoc::Markup::ToRdoc < ::RDoc::Markup::Formatter
  # Creates a new formatter that will output (mostly) \RDoc markup
  #
  # @return [ToRdoc] a new instance of ToRdoc
  def initialize(markup = T.unsafe(nil)); end

  # Adds +blank_line+ to the output
  def accept_blank_line(blank_line); end

  # Adds +paragraph+ to the output
  def accept_block_quote(block_quote); end

  # Adds +heading+ to the output
  def accept_heading(heading); end

  # Adds +paragraph+ to the output
  def accept_indented_paragraph(paragraph); end

  # Finishes consumption of +list+
  def accept_list_end(list); end

  # Finishes consumption of +list_item+
  def accept_list_item_end(list_item); end

  # Prepares the visitor for consuming +list_item+
  def accept_list_item_start(list_item); end

  # Prepares the visitor for consuming +list+
  def accept_list_start(list); end

  # Adds +paragraph+ to the output
  def accept_paragraph(paragraph); end

  # Adds +raw+ to the output
  def accept_raw(raw); end

  # Adds +rule+ to the output
  def accept_rule(rule); end

  # Adds +table+ to the output
  def accept_table(header, body, aligns); end

  # Outputs +verbatim+ indented 2 columns
  def accept_verbatim(verbatim); end

  # Applies attribute-specific markup to +text+ using RDoc::AttributeManager
  def attributes(text); end

  # Returns the generated output
  def end_accepting; end

  # Adds a newline to the output
  def handle_regexp_HARD_BREAK(target); end

  # Removes preceding \\ from the suppressed crossref +target+
  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  # Current indent amount for output in characters
  def indent; end

  # Current indent amount for output in characters
  def indent=(_arg0); end

  # Maps attributes to HTML sequences
  def init_tags; end

  # Stack of current list indexes for alphabetic and numeric lists
  def list_index; end

  # Stack of list types
  def list_type; end

  # Stack of list widths for indentation
  def list_width; end

  # Prefix for the next list item.  See #use_prefix
  def prefix; end

  # Output accumulator
  def res; end

  # Prepares the visitor for text generation
  def start_accepting; end

  # Adds the stored #prefix to the output and clears it.  Lists generate a
  # prefix for later consumption.
  def use_prefix; end

  # Output width in characters
  def width; end

  # Output width in characters
  def width=(_arg0); end

  # Wraps +text+ to #width
  def wrap(text); end
end

# Extracts just the RDoc::Markup::Heading elements from a
# RDoc::Markup::Document to help build a table of contents
class RDoc::Markup::ToTableOfContents < ::RDoc::Markup::Formatter
  # @return [ToTableOfContents] a new instance of ToTableOfContents
  def initialize; end

  def accept_blank_line(*node); end

  # :stopdoc:
  def accept_block_quote(*node); end

  # Adds +document+ to the output, using its heading cutoff if present
  def accept_document(document); end

  # Adds +heading+ to the table of contents
  def accept_heading(heading); end

  def accept_list_end(*node); end
  def accept_list_end_bullet(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end
  def accept_paragraph(*node); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_table(*node); end
  def accept_verbatim(*node); end

  # Returns the table of contents
  def end_accepting; end

  # Omits headings with a level less than the given level.
  def omit_headings_below; end

  # Omits headings with a level less than the given level.
  def omit_headings_below=(_arg0); end

  # Output accumulator
  def res; end

  # Prepares the visitor for text generation
  def start_accepting; end

  # Returns true if +heading+ is below the display threshold
  #
  # @return [Boolean]
  def suppressed?(heading); end

  class << self
    # Singleton for table-of-contents generation
    def to_toc; end
  end
end

# This Markup outputter is used for testing purposes.
class RDoc::Markup::ToTest < ::RDoc::Markup::Formatter
  def accept_blank_line(blank_line); end
  def accept_heading(heading); end
  def accept_list_end(list); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(raw); end
  def accept_rule(rule); end
  def accept_verbatim(verbatim); end
  def end_accepting; end

  # :section: Visitor
  def start_accepting; end
end

# Extracts sections of text enclosed in plus, tt or code.  Used to discover
# undocumented parameters.
class RDoc::Markup::ToTtOnly < ::RDoc::Markup::Formatter
  # Creates a new tt-only formatter.
  #
  # @return [ToTtOnly] a new instance of ToTtOnly
  def initialize(markup = T.unsafe(nil)); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_blank_line(markup_item); end

  # Adds tts from +block_quote+ to the output
  def accept_block_quote(block_quote); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_heading(markup_item); end

  # Pops the list type for +list+ from #list_type
  def accept_list_end(list); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_list_item_end(markup_item); end

  # Prepares the visitor for consuming +list_item+
  def accept_list_item_start(list_item); end

  # Pushes the list type for +list+ onto #list_type
  def accept_list_start(list); end

  # Adds +paragraph+ to the output
  def accept_paragraph(paragraph); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_raw(markup_item); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_rule(markup_item); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def accept_verbatim(markup_item); end

  # Does nothing to +markup_item+ because it doesn't have any user-built
  # content
  def do_nothing(markup_item); end

  # Returns an Array of items that were wrapped in plus, tt or code.
  def end_accepting; end

  # Stack of list types
  def list_type; end

  # Output accumulator
  def res; end

  # Prepares the visitor for gathering tt sections
  def start_accepting; end

  # Extracts tt sections from +text+
  def tt_sections(text); end
end

# A section of verbatim text
class RDoc::Markup::Verbatim < ::RDoc::Markup::Raw
  # @return [Verbatim] a new instance of Verbatim
  def initialize(*parts); end

  def ==(other); end

  # Calls #accept_verbatim on +visitor+
  def accept(visitor); end

  # Format of this verbatim section
  def format; end

  # Format of this verbatim section
  def format=(_arg0); end

  # Collapses 3+ newlines into two newlines
  def normalize; end

  def pretty_print(q); end

  # Is this verbatim section Ruby code?
  #
  # @return [Boolean]
  def ruby?; end

  # The text of the section
  def text; end
end

# Abstract class representing either a method or an attribute.
class RDoc::MethodAttr < ::RDoc::CodeObject
  include ::Comparable

  # Creates a new MethodAttr from token stream +text+ and method or attribute
  # name +name+.
  #
  # Usually this is called by super from a subclass.
  #
  # @return [MethodAttr] a new instance of MethodAttr
  def initialize(text, name); end

  # Order by #singleton then #name
  def <=>(other); end

  def ==(other); end

  # Abstract method. Contexts in their building phase call this
  # to register a new alias for this known method/attribute.
  #
  # - creates a new AnyMethod/Attribute named <tt>an_alias.new_name</tt>;
  # - adds +self+ as an alias for the new method or attribute
  # - adds the method or attribute to #aliases
  # - adds the method or attribute to +context+.
  #
  # @raise [NotImplementedError]
  def add_alias(an_alias, context); end

  # Prepend +src+ with line numbers.  Relies on the first line of a source
  # code listing having:
  #
  #   # File xxxxx, line dddd
  #
  # If it has this comment then line numbers are added to +src+ and the <tt>,
  # line dddd</tt> portion of the comment is removed.
  def add_line_numbers(src); end

  # Array of other names for this method/attribute
  def aliases; end

  # HTML fragment reference for this method
  def aref; end

  # Prefix for +aref+, defined by subclasses.
  #
  # @raise [NotImplementedError]
  def aref_prefix; end

  # The call_seq or the param_seq with method name, if there is no call_seq.
  def arglists; end

  # Parameters yielded by the called block
  def block_params; end

  # Attempts to sanitize the content passed by the Ruby parser:
  # remove outer parentheses, etc.
  def block_params=(value); end

  # Different ways to call this method
  def call_seq; end

  # Different ways to call this method
  def call_seq=(_arg0); end

  # A method/attribute is documented if any of the following is true:
  # - it has a comment;
  # - it is an alias for a documented method;
  # - it has a +#see+ method that is documented.
  #
  # @return [Boolean]
  def documented?; end

  def find_method_or_attribute(name); end
  def find_see; end

  # Full method/attribute name including namespace
  def full_name; end

  # HTML id-friendly method/attribute name
  def html_name; end

  def initialize_visibility; end
  def inspect; end

  # The method/attribute we're aliasing
  def is_alias_for; end

  # The method/attribute we're aliasing
  def is_alias_for=(_arg0); end

  # Turns the method's token stream into HTML.
  #
  # Prepends line numbers if +options.line_numbers+ is true.
  def markup_code; end

  # Name of this method/attribute.
  def name; end

  # Name of this method/attribute.
  def name=(_arg0); end

  # '::' for a class method/attribute, '#' for an instance method.
  def name_prefix; end

  # Name for output to HTML.  For class methods the full name with a "." is
  # used like +SomeClass.method_name+.  For instance methods the class name is
  # used if +context+ does not match the parent.
  #
  # This is to help prevent people from using :: to call class methods.
  def output_name(context); end

  # Pretty parameter list for this method
  def param_seq; end

  # Parameters for this method
  def params; end

  # Parameters for this method
  def params=(_arg0); end

  # Name of our parent with special handling for un-marshaled methods
  def parent_name; end

  # Path to this method for use with HTML generator output.
  def path; end

  # Method/attribute name with class/instance indicator
  def pretty_name; end

  def pretty_print(q); end

  # Used by RDoc::Generator::JsonIndex to create a record for the search
  # engine.
  def search_record; end

  # A method/attribute to look at,
  # in particular if this method/attribute has no documentation.
  #
  # It can be a method/attribute of the superclass or of an included module,
  # including the Kernel module, which is always appended to the included
  # modules.
  #
  # Returns +nil+ if there is no such method/attribute.
  # The +#is_alias_for+ method/attribute, if any, is not included.
  #
  # Templates may generate a "see also ..." if this method/attribute
  # has documentation, and "see ..." if it does not.
  def see; end

  # Is this a singleton method/attribute?
  def singleton; end

  # Is this a singleton method/attribute?
  def singleton=(_arg0); end

  # Sets the store for this class or module and its contained code objects.
  def store=(store); end

  # Source file token stream
  def text; end

  def to_s; end

  # Type of method/attribute (class or instance)
  def type; end

  # public, protected, private
  def visibility; end

  # public, protected, private
  def visibility=(_arg0); end

  private

  # Resets cached data for the object so it can be rebuilt by accessor methods
  def initialize_copy(other); end
end

# A Mixin adds features from a module into another context.  RDoc::Include and
# RDoc::Extend are both mixins.
class RDoc::Mixin < ::RDoc::CodeObject
  # Creates a new Mixin for +name+ with +comment+
  #
  # @return [Mixin] a new instance of Mixin
  def initialize(name, comment); end

  # Mixins are sorted by name
  def <=>(other); end

  def ==(other); end
  def eql?(other); end

  # Full name based on #module
  def full_name; end

  def hash; end
  def inspect; end

  # Attempts to locate the included module object.  Returns the name if not
  # known.
  #
  # The scoping rules of Ruby to resolve the name of an included module are:
  # - first look into the children of the current context;
  # - if not found, look into the children of included modules,
  #   in reverse inclusion order;
  # - if still not found, go up the hierarchy of names.
  #
  # This method has <code>O(n!)</code> behavior when the module calling
  # include is referencing nonexistent modules.  Avoid calling #module until
  # after all the files are parsed.  This behavior is due to ruby's constant
  # lookup behavior.
  #
  # As of the beginning of October, 2011, no gem includes nonexistent modules.
  def module; end

  # Name of included module
  def name; end

  # Name of included module
  def name=(_arg0); end

  # Sets the store for this class or module and its contained code objects.
  def store=(store); end

  def to_s; end
end

# A normal class, neither singleton nor anonymous
class RDoc::NormalClass < ::RDoc::ClassModule
  # The ancestors of this class including modules.  Unlike Module#ancestors,
  # this class is not included in the result.  The result will contain both
  # RDoc::ClassModules and Strings.
  def ancestors; end

  def aref_prefix; end

  # The definition of this class, <tt>class MyClassName</tt>
  def definition; end

  def direct_ancestors; end
  def inspect; end
  def pretty_print(q); end
  def to_s; end
end

# A normal module, like NormalClass
class RDoc::NormalModule < ::RDoc::ClassModule
  def aref_prefix; end

  # The definition of this module, <tt>module MyModuleName</tt>
  def definition; end

  def inspect; end

  # This is a module, returns true
  #
  # @return [Boolean]
  def module?; end

  def pretty_print(q); end

  # Modules don't have one, raises NoMethodError
  #
  # @raise [NoMethodError]
  def superclass; end
end

# RDoc::Options handles the parsing and storage of options
#
# == Saved Options
#
# You can save some options like the markup format in the
# <tt>.rdoc_options</tt> file in your gem.  The easiest way to do this is:
#
#   rdoc --markup tomdoc --write-options
#
# Which will automatically create the file and fill it with the options you
# specified.
#
# The following options will not be saved since they interfere with the user's
# preferences or with the normal operation of RDoc:
#
# * +--coverage-report+
# * +--dry-run+
# * +--encoding+
# * +--force-update+
# * +--format+
# * +--pipe+
# * +--quiet+
# * +--template+
# * +--verbose+
#
# == Custom Options
#
# Generators can hook into RDoc::Options to add generator-specific command
# line options.
#
# When <tt>--format</tt> is encountered in ARGV, RDoc calls ::setup_options on
# the generator class to add extra options to the option parser.  Options for
# custom generators must occur after <tt>--format</tt>.  <tt>rdoc --help</tt>
# will list options for all installed generators.
#
# Example:
#
#   class RDoc::Generator::Spellcheck
#     RDoc::RDoc.add_generator self
#
#     def self.setup_options rdoc_options
#       op = rdoc_options.option_parser
#
#       op.on('--spell-dictionary DICTIONARY',
#             RDoc::Options::Path) do |dictionary|
#         rdoc_options.spell_dictionary = dictionary
#       end
#     end
#   end
#
# Of course, RDoc::Options does not respond to +spell_dictionary+ by default
# so you will need to add it:
#
#   class RDoc::Options
#
#     ##
#     # The spell dictionary used by the spell-checking plugin.
#
#     attr_accessor :spell_dictionary
#
#   end
#
# == Option Validators
#
# OptionParser validators will validate and cast user input values.  In
# addition to the validators that ship with OptionParser (String, Integer,
# Float, TrueClass, FalseClass, Array, Regexp, Date, Time, URI, etc.),
# RDoc::Options adds Path, PathArray and Template.
class RDoc::Options
  # @return [Options] a new instance of Options
  def initialize(loaded_options = T.unsafe(nil)); end

  def ==(other); end

  # Character-set for HTML output.  #encoding is preferred over #charset
  def charset; end

  # Character-set for HTML output.  #encoding is preferred over #charset
  def charset=(_arg0); end

  # Check that the files on the command line exist
  def check_files; end

  # Ensure only one generator is loaded
  def check_generator; end

  # If true, only report on undocumented files
  def coverage_report; end

  # If true, only report on undocumented files
  def coverage_report=(_arg0); end

  # Set the title, but only if not already set. Used to set the title
  # from a source file, so that a title set from the command line
  # will have the priority.
  def default_title=(string); end

  # If true, RDoc will not write any files.
  def dry_run; end

  # If true, RDoc will not write any files.
  def dry_run=(_arg0); end

  # The output encoding.  All input files will be transcoded to this encoding.
  #
  # The default encoding is UTF-8.  This is set via --encoding.
  def encoding; end

  # The output encoding.  All input files will be transcoded to this encoding.
  #
  # The default encoding is UTF-8.  This is set via --encoding.
  def encoding=(_arg0); end

  # Create a regexp for #exclude
  def exclude; end

  # Files matching this pattern will be excluded
  def exclude=(_arg0); end

  # The list of files to be processed
  def files; end

  # The list of files to be processed
  def files=(_arg0); end

  # Completes any unfinished option setup business such as filtering for
  # existent files, creating a regexp for #exclude and setting a default
  # #template.
  def finish; end

  # Fixes the page_dir to be relative to the root_dir and adds the page_dir to
  # the files list.
  def finish_page_dir; end

  # Create the output even if the output directory does not look
  # like an rdoc output directory
  def force_output; end

  # Create the output even if the output directory does not look
  # like an rdoc output directory
  def force_output=(_arg0); end

  # Scan newer sources than the flag file if true.
  def force_update; end

  # Scan newer sources than the flag file if true.
  def force_update=(_arg0); end

  # Formatter to mark up text with
  def formatter; end

  # Formatter to mark up text with
  def formatter=(_arg0); end

  # Description of the output generator (set with the <tt>--format</tt> option)
  def generator; end

  # Description of the output generator (set with the <tt>--format</tt> option)
  def generator=(_arg0); end

  # Returns a properly-space list of generators and their descriptions.
  def generator_descriptions; end

  # For #==
  def generator_name; end

  # Loaded generator options.  Used to prevent --help from loading the same
  # options multiple times.
  def generator_options; end

  # Loaded generator options.  Used to prevent --help from loading the same
  # options multiple times.
  def generator_options=(_arg0); end

  # Old rdoc behavior: hyperlink all words that match a method name,
  # even if not preceded by '#' or '::'
  def hyperlink_all; end

  # Old rdoc behavior: hyperlink all words that match a method name,
  # even if not preceded by '#' or '::'
  def hyperlink_all=(_arg0); end

  def init_ivars; end
  def init_with(map); end

  # Include line numbers in the source code
  def line_numbers; end

  # Include line numbers in the source code
  def line_numbers=(_arg0); end

  # The output locale.
  def locale; end

  # The output locale.
  def locale=(_arg0); end

  # The directory where locale data live.
  def locale_dir; end

  # The directory where locale data live.
  def locale_dir=(_arg0); end

  # Name of the file, class or module to display in the initial index page (if
  # not specified the first file we encounter is used)
  def main_page; end

  # Name of the file, class or module to display in the initial index page (if
  # not specified the first file we encounter is used)
  def main_page=(_arg0); end

  # The default markup format.  The default is 'rdoc'.  'markdown', 'tomdoc'
  # and 'rd' are also built-in.
  def markup; end

  # The default markup format.  The default is 'rdoc'.  'markdown', 'tomdoc'
  # and 'rd' are also built-in.
  def markup=(_arg0); end

  # The name of the output directory
  def op_dir; end

  # The name of the output directory
  def op_dir=(_arg0); end

  # The OptionParser for this instance
  def option_parser; end

  # The OptionParser for this instance
  def option_parser=(_arg0); end

  # Output heading decorations?
  def output_decoration; end

  # Output heading decorations?
  def output_decoration=(_arg0); end

  def override(map); end

  # Directory where guides, FAQ, and other pages not associated with a class
  # live.  You may leave this unset if these are at the root of your project.
  def page_dir; end

  # Directory where guides, FAQ, and other pages not associated with a class
  # live.  You may leave this unset if these are at the root of your project.
  def page_dir=(_arg0); end

  # Parses command line options.
  def parse(argv); end

  # Is RDoc in pipe mode?
  def pipe; end

  # Is RDoc in pipe mode?
  def pipe=(_arg0); end

  # Don't display progress as we process the files
  def quiet; end

  # Set quietness to +bool+
  def quiet=(bool); end

  # Array of directories to search for files to satisfy an :include:
  def rdoc_include; end

  # Array of directories to search for files to satisfy an :include:
  def rdoc_include=(_arg0); end

  # Root of the source documentation will be generated for.  Set this when
  # building documentation outside the source directory.  Defaults to the
  # current directory.
  def root; end

  # Root of the source documentation will be generated for.  Set this when
  # building documentation outside the source directory.  Defaults to the
  # current directory.
  def root=(_arg0); end

  # Removes directories from +path+ that are outside the current directory
  def sanitize_path(path); end

  # Set up an output generator for the named +generator_name+.
  #
  # If the found generator responds to :setup_options it will be called with
  # the options instance.  This allows generators to add custom options or set
  # default options.
  def setup_generator(generator_name = T.unsafe(nil)); end

  # Include the '#' at the front of hyperlinked instance method names
  def show_hash; end

  # Include the '#' at the front of hyperlinked instance method names
  def show_hash=(_arg0); end

  # Indicates if files of test suites should be skipped
  def skip_tests; end

  # Indicates if files of test suites should be skipped
  def skip_tests=(_arg0); end

  # Directory to copy static files from
  def static_path; end

  # Directory to copy static files from
  def static_path=(_arg0); end

  # The number of columns in a tab
  def tab_width; end

  # The number of columns in a tab
  def tab_width=(_arg0); end

  # Template to be used when generating output
  def template; end

  # Template to be used when generating output
  def template=(_arg0); end

  # Directory the template lives in
  def template_dir; end

  # Directory the template lives in
  def template_dir=(_arg0); end

  # Finds the template dir for +template+
  def template_dir_for(template); end

  # Additional template stylesheets
  def template_stylesheets; end

  # Additional template stylesheets
  def template_stylesheets=(_arg0); end

  # Documentation title
  def title; end

  # Documentation title
  def title=(_arg0); end

  # For dumping YAML
  def to_yaml(*options); end

  # Should RDoc update the timestamps in the output dir?
  def update_output_dir; end

  # Should RDoc update the timestamps in the output dir?
  def update_output_dir=(_arg0); end

  # Verbosity, zero means quiet
  def verbosity; end

  # Verbosity, zero means quiet
  def verbosity=(_arg0); end

  # Minimum visibility of a documented method. One of +:public+, +:protected+,
  # +:private+ or +:nodoc+.
  #
  # The +:nodoc+ visibility ignores all directives related to visibility.  The
  # directive.
  def visibility; end

  # Sets the minimum visibility of a documented method.
  #
  # Accepts +:public+, +:protected+, +:private+, +:nodoc+, or +:all+.
  #
  # When +:all+ is passed, visibility is set to +:private+, similarly to
  # RDOCOPT="--all", see #visibility for more information.
  def visibility=(visibility); end

  # Displays a warning using Kernel#warn if we're being verbose
  def warn(message); end

  # URL of web cvs frontend
  def webcvs; end

  # URL of web cvs frontend
  def webcvs=(_arg0); end

  # Writes the YAML file .rdoc_options to the current directory containing the
  # parsed options.
  def write_options; end

  def yaml_initialize(tag, map); end

  class << self
    # Loads options from .rdoc_options if the file exists, otherwise creates a
    # new RDoc::Options instance.
    #
    # @raise [RDoc::Error]
    def load_options; end
  end
end

# A parser is simple a class that subclasses RDoc::Parser and implements #scan
# to fill in an RDoc::TopLevel with parsed data.
#
# The initialize method takes an RDoc::TopLevel to fill with parsed content,
# the name of the file to be parsed, the content of the file, an RDoc::Options
# object and an RDoc::Stats object to inform the user of parsed items.  The
# scan method is then called to parse the file and must return the
# RDoc::TopLevel object.  By calling super these items will be set for you.
#
# In order to be used by RDoc the parser needs to register the file extensions
# it can parse.  Use ::parse_files_matching to register extensions.
#
#   require 'rdoc'
#
#   class RDoc::Parser::Xyz < RDoc::Parser
#     parse_files_matching /\.xyz$/
#
#     def initialize top_level, file_name, content, options, stats
#       super
#
#       # extra initialization if needed
#     end
#
#     def scan
#       # parse file and fill in @top_level
#     end
#   end
class RDoc::Parser
  # Creates a new Parser storing +top_level+, +file_name+, +content+,
  # +options+ and +stats+ in instance variables.  In +@preprocess+ an
  # RDoc::Markup::PreProcess object is created which allows processing of
  # directives.
  #
  # @return [Parser] a new instance of Parser
  def initialize(top_level, file_name, content, options, stats); end

  # The name of the file being parsed
  def file_name; end

  # Normalizes tabs in +body+
  def handle_tab_width(body); end

  class << self
    # Alias an extension to another extension. After this call, files ending
    # "new_ext" will be parsed using the same parser as "old_ext"
    def alias_extension(old_ext, new_ext); end

    # Determines if the file is a "binary" file which basically means it has
    # content that an RDoc parser shouldn't try to consume.
    #
    # @return [Boolean]
    def binary?(file); end

    # Return a parser that can handle a particular extension
    def can_parse(file_name); end

    # Returns a parser that can handle the extension for +file_name+.  This does
    # not depend upon the file being readable.
    def can_parse_by_name(file_name); end

    # Returns the file type from the modeline in +file_name+
    def check_modeline(file_name); end

    # Finds and instantiates the correct parser for the given +file_name+ and
    # +content+.
    def for(top_level, file_name, content, options, stats); end

    # Record which file types this parser can understand.
    #
    # It is ok to call this multiple times.
    def parse_files_matching(regexp); end

    # An Array of arrays that maps file extension (or name) regular
    # expressions to parser classes that will parse matching filenames.
    #
    # Use parse_files_matching to register a parser's file extensions.
    def parsers; end

    # Removes an emacs-style modeline from the first line of the document
    def remove_modeline(content); end

    # If there is a <tt>markup: parser_name</tt> comment at the front of the
    # file, use it to determine the parser.  For example:
    #
    #   # markup: rdoc
    #   # Class comment can go here
    #
    #   class C
    #   end
    #
    # The comment should appear as the first line of the +content+.
    #
    # If the content contains a shebang or editor modeline the comment may
    # appear on the second or third line.
    #
    # Any comment style may be used to hide the markup comment.
    def use_markup(content); end

    # Checks if +file+ is a zip file in disguise.  Signatures from
    # http://www.garykessler.net/library/file_sigs.html
    #
    # @return [Boolean]
    def zip?(file); end
  end
end

# RDoc::Parser::C attempts to parse C extension files.  It looks for
# the standard patterns that you find in extensions: +rb_define_class+,
# +rb_define_method+ and so on.  It tries to find the corresponding
# C source for the methods and extract comments, but if we fail
# we don't worry too much.
#
# The comments associated with a Ruby method are extracted from the C
# comment block associated with the routine that _implements_ that
# method, that is to say the method whose name is given in the
# +rb_define_method+ call. For example, you might write:
#
#   /*
#    * Returns a new array that is a one-dimensional flattening of this
#    * array (recursively). That is, for every element that is an array,
#    * extract its elements into the new array.
#    *
#    *    s = [ 1, 2, 3 ]           #=> [1, 2, 3]
#    *    t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]
#    *    a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
#    *    a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#    */
#    static VALUE
#    rb_ary_flatten(VALUE ary)
#    {
#        ary = rb_obj_dup(ary);
#        rb_ary_flatten_bang(ary);
#        return ary;
#    }
#
#    ...
#
#    void
#    Init_Array(void)
#    {
#      ...
#      rb_define_method(rb_cArray, "flatten", rb_ary_flatten, 0);
#
# Here RDoc will determine from the +rb_define_method+ line that there's a
# method called "flatten" in class Array, and will look for the implementation
# in the method +rb_ary_flatten+. It will then use the comment from that
# method in the HTML output. This method must be in the same source file
# as the +rb_define_method+.
#
# The comment blocks may include special directives:
#
# [Document-class: +name+]
#   Documentation for the named class.
#
# [Document-module: +name+]
#   Documentation for the named module.
#
# [Document-const: +name+]
#   Documentation for the named +rb_define_const+.
#
#   Constant values can be supplied on the first line of the comment like so:
#
#     /* 300: The highest possible score in bowling */
#     rb_define_const(cFoo, "PERFECT", INT2FIX(300));
#
#   The value can contain internal colons so long as they are escaped with a \
#
# [Document-global: +name+]
#   Documentation for the named +rb_define_global_const+
#
# [Document-variable: +name+]
#   Documentation for the named +rb_define_variable+
#
# [Document-method\: +method_name+]
#   Documentation for the named method.  Use this when the method name is
#   unambiguous.
#
# [Document-method\: <tt>ClassName::method_name</tt>]
#   Documentation for a singleton method in the given class.  Use this when
#   the method name alone is ambiguous.
#
# [Document-method\: <tt>ClassName#method_name</tt>]
#   Documentation for a instance method in the given class.  Use this when the
#   method name alone is ambiguous.
#
# [Document-attr: +name+]
#   Documentation for the named attribute.
#
# [call-seq:  <i>text up to an empty line</i>]
#   Because C source doesn't give descriptive names to Ruby-level parameters,
#   you need to document the calling sequence explicitly
#
# In addition, RDoc assumes by default that the C method implementing a
# Ruby function is in the same source file as the rb_define_method call.
# If this isn't the case, add the comment:
#
#   rb_define_method(....);  // in filename
#
# As an example, we might have an extension that defines multiple classes
# in its Init_xxx method. We could document them using
#
#   /*
#    * Document-class:  MyClass
#    *
#    * Encapsulate the writing and reading of the configuration
#    * file. ...
#    */
#
#   /*
#    * Document-method: read_value
#    *
#    * call-seq:
#    *   cfg.read_value(key)            -> value
#    *   cfg.read_value(key} { |key| }  -> value
#    *
#    * Return the value corresponding to +key+ from the configuration.
#    * In the second form, if the key isn't found, invoke the
#    * block and return its value.
#    */
class RDoc::Parser::C < ::RDoc::Parser
  include ::RDoc::Text

  # Prepares for parsing a C file.  See RDoc::Parser#initialize for details on
  # the arguments.
  #
  # @return [C] a new instance of C
  def initialize(top_level, file_name, content, options, stats); end

  # Add alias, either from a direct alias definition, or from two
  # method that reference the same function.
  def add_alias(var_name, class_obj, old_name, new_name, comment); end

  # Maps C variable names to names of Ruby classes or modules
  def classes; end

  # C file the parser is parsing
  def content; end

  # C file the parser is parsing
  def content=(_arg0); end

  # Scans #content for rb_define_alias
  def do_aliases; end

  # Scans #content for rb_attr and rb_define_attr
  def do_attrs; end

  # Scans #content for boot_defclass
  def do_boot_defclass; end

  # Scans #content for rb_define_class, boot_defclass, rb_define_class_under
  # and rb_singleton_class
  def do_classes_and_modules; end

  # Scans #content for rb_define_variable, rb_define_readonly_variable,
  # rb_define_const and rb_define_global_const
  def do_constants; end

  # Scans #content for rb_include_module
  def do_includes; end

  # Scans #content for rb_define_method, rb_define_singleton_method,
  # rb_define_module_function, rb_define_private_method,
  # rb_define_global_function and define_filetest_function
  def do_methods; end

  # Creates classes and module that were missing were defined due to the file
  # order being different than the declaration order.
  def do_missing; end

  # Dependencies from a missing enclosing class to the classes in
  # missing_dependencies that depend upon it.
  def enclosure_dependencies; end

  # Finds the comment for an alias on +class_name+ from +new_name+ to
  # +old_name+
  def find_alias_comment(class_name, new_name, old_name); end

  # Finds a comment for rb_define_attr, rb_attr or Document-attr.
  #
  # +var_name+ is the C class variable the attribute is defined on.
  # +attr_name+ is the attribute's name.
  #
  # +read+ and +write+ are the read/write flags ('1' or '0').  Either both or
  # neither must be provided.
  def find_attr_comment(var_name, attr_name, read = T.unsafe(nil), write = T.unsafe(nil)); end

  # Find the C code corresponding to a Ruby method
  def find_body(class_name, meth_name, meth_obj, file_content, quiet = T.unsafe(nil)); end

  # Finds a RDoc::NormalClass or RDoc::NormalModule for +raw_name+
  def find_class(raw_name, name, base_name = T.unsafe(nil)); end

  # Look for class or module documentation above Init_+class_name+(void),
  # in a Document-class +class_name+ (or module) comment or above an
  # rb_define_class (or module).  If a comment is supplied above a matching
  # Init_ and a rb_define_class the Init_ comment is used.
  #
  #   /*
  #    * This is a comment for Foo
  #    */
  #   Init_Foo(void) {
  #       VALUE cFoo = rb_define_class("Foo", rb_cObject);
  #   }
  #
  #   /*
  #    * Document-class: Foo
  #    * This is a comment for Foo
  #    */
  #   Init_foo(void) {
  #       VALUE cFoo = rb_define_class("Foo", rb_cObject);
  #   }
  #
  #   /*
  #    * This is a comment for Foo
  #    */
  #   VALUE cFoo = rb_define_class("Foo", rb_cObject);
  def find_class_comment(class_name, class_mod); end

  # Finds a comment matching +type+ and +const_name+ either above the
  # comment or in the matching Document- section.
  def find_const_comment(type, const_name, class_name = T.unsafe(nil)); end

  # Handles modifiers in +comment+ and updates +meth_obj+ as appropriate.
  def find_modifiers(comment, meth_obj); end

  # Finds a <tt>Document-method</tt> override for +meth_obj+ on +class_name+
  def find_override_comment(class_name, meth_obj); end

  # Generate a Ruby-method table
  def gen_body_table(file_content); end

  # Generate a const table
  def gen_const_table(file_content); end

  # Creates a new RDoc::Attr +attr_name+ on class +var_name+ that is either
  # +read+, +write+ or both
  def handle_attr(var_name, attr_name, read, write); end

  # Creates a new RDoc::NormalClass or RDoc::NormalModule based on +type+
  # named +class_name+ in +parent+ which was assigned to the C +var_name+.
  def handle_class_module(var_name, type, class_name, parent, in_module); end

  # Adds constants.  By providing some_value: at the start of the comment you
  # can override the C value of the comment to give a friendly definition.
  #
  #   /* 300: The perfect score in bowling */
  #   rb_define_const(cFoo, "PERFECT", INT2FIX(300));
  #
  # Will override <tt>INT2FIX(300)</tt> with the value +300+ in the output
  # RDoc.  Values may include quotes and escaped colons (\:).
  def handle_constants(type, var_name, const_name, definition); end

  # Removes #ifdefs that would otherwise confuse us
  def handle_ifdefs_in(body); end

  # Adds an RDoc::AnyMethod +meth_name+ defined on a class or module assigned
  # to +var_name+.  +type+ is the type of method definition function used.
  # +singleton_method+ and +module_function+ create a singleton method.
  def handle_method(type, var_name, meth_name, function, param_count, source_file = T.unsafe(nil)); end

  # Registers a singleton class +sclass_var+ as a singleton of +class_var+
  def handle_singleton(sclass_var, class_var); end

  # Maps C variable names to names of Ruby classes (and singleton classes)
  def known_classes; end

  # Loads the variable map with the given +name+ from the RDoc::Store, if
  # present.
  def load_variable_map(map_name); end

  # Look for directives in a normal comment block:
  #
  #   /*
  #    * :title: My Awesome Project
  #    */
  #
  # This method modifies the +comment+
  def look_for_directives_in(context, comment); end

  # Classes found while parsing the C file that were not yet registered due to
  # a missing enclosing class.  These are processed by do_missing
  def missing_dependencies; end

  # Creates a RDoc::Comment instance.
  def new_comment(text = T.unsafe(nil), location = T.unsafe(nil), language = T.unsafe(nil)); end

  # Extracts parameters from the +method_body+ and returns a method
  # parameter string.  Follows 1.9.3dev's scan-arg-spec, see README.EXT
  def rb_scan_args(method_body); end

  # Removes lines that are commented out that might otherwise get picked up
  # when scanning for classes and methods
  def remove_commented_out_lines; end

  # Extracts the classes, modules, methods, attributes, constants and aliases
  # from a C file and returns an RDoc::TopLevel for this file
  def scan; end

  # Maps C variable names to names of Ruby singleton classes
  def singleton_classes; end

  # The TopLevel items in the parsed file belong to
  def top_level; end
end

# :stopdoc:
RDoc::Parser::C::BOOL_ARG_PATTERN = T.let(T.unsafe(nil), Regexp)

RDoc::Parser::C::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# A ChangeLog file parser.
#
# This parser converts a ChangeLog into an RDoc::Markup::Document.  When
# viewed as HTML a ChangeLog page will have an entry for each day's entries in
# the sidebar table of contents.
#
# This parser is meant to parse the MRI ChangeLog, but can be used to parse any
# {GNU style Change
# Log}[http://www.gnu.org/prep/standards/html_node/Style-of-Change-Logs.html].
class RDoc::Parser::ChangeLog < ::RDoc::Parser
  include ::RDoc::Parser::Text

  # Attaches the +continuation+ of the previous line to the +entry_body+.
  #
  # Continued function listings are joined together as a single entry.
  # Continued descriptions are joined to make a single paragraph.
  def continue_entry_body(entry_body, continuation); end

  # Creates an RDoc::Markup::Document given the +groups+ of ChangeLog entries.
  def create_document(groups); end

  # Returns a list of ChangeLog entries an RDoc::Markup nodes for the given
  # +entries+.
  def create_entries(entries); end

  # Returns an RDoc::Markup::List containing the given +items+ in the
  # ChangeLog
  def create_items(items); end

  # Groups +entries+ by date.
  def group_entries(entries); end

  # Parse date in ISO-8601, RFC-2822, or default of Git
  def parse_date(date); end

  # Parses the entries in the ChangeLog.
  #
  # Returns an Array of each ChangeLog entry in order of parsing.
  #
  # A ChangeLog entry is an Array containing the ChangeLog title (date and
  # committer) and an Array of ChangeLog items (file and function changed with
  # description).
  #
  # An example result would be:
  #
  #    [ 'Tue Dec  4 08:33:46 2012  Eric Hodel  <drbrain@segment7.net>',
  #      [ 'README.EXT:  Converted to RDoc format',
  #        'README.EXT.ja:  ditto']]
  def parse_entries; end

  # Converts the ChangeLog into an RDoc::Markup::Document
  def scan; end
end

# The extension for Git commit log
module RDoc::Parser::ChangeLog::Git
  # Returns a list of ChangeLog entries as
  # RDoc::Parser::ChangeLog::Git::LogEntry list for the given
  # +entries+.
  def create_entries(entries); end

  # Parses the entries in the Git commit logs
  def parse_entries; end

  # Parses auxiliary info.  Currentry `base-url` to expand
  # references is effective.
  def parse_info(info); end
end

RDoc::Parser::ChangeLog::Git::HEADING_LEVEL = T.let(T.unsafe(nil), Integer)

class RDoc::Parser::ChangeLog::Git::LogEntry < ::Struct
  # @return [LogEntry] a new instance of LogEntry
  def initialize(base, commit, author, email, date, contents); end

  def accept(visitor); end
  def aref; end

  # Returns the value of attribute author
  #
  # @return [Object] the current value of author
  def author; end

  # Sets the attribute author
  #
  # @param value [Object] the value to set the attribute author to.
  # @return [Object] the newly set value
  def author=(_); end

  # Returns the value of attribute base
  #
  # @return [Object] the current value of base
  def base; end

  # Sets the attribute base
  #
  # @param value [Object] the value to set the attribute base to.
  # @return [Object] the newly set value
  def base=(_); end

  # Returns the value of attribute commit
  #
  # @return [Object] the current value of commit
  def commit; end

  # Sets the attribute commit
  #
  # @param value [Object] the value to set the attribute commit to.
  # @return [Object] the newly set value
  def commit=(_); end

  # Returns the value of attribute contents
  #
  # @return [Object] the current value of contents
  def contents; end

  # Sets the attribute contents
  #
  # @param value [Object] the value to set the attribute contents to.
  # @return [Object] the newly set value
  def contents=(_); end

  # Returns the value of attribute date
  #
  # @return [Object] the current value of date
  def date; end

  # Sets the attribute date
  #
  # @param value [Object] the value to set the attribute date to.
  # @return [Object] the newly set value
  def date=(_); end

  # Returns the value of attribute email
  #
  # @return [Object] the current value of email
  def email; end

  # Sets the attribute email
  #
  # @param value [Object] the value to set the attribute email to.
  # @return [Object] the newly set value
  def email=(_); end

  def label(context = T.unsafe(nil)); end
  def level; end
  def pretty_print(q); end
  def text; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Parse a Markdown format file.  The parsed RDoc::Markup::Document is attached
# as a file comment.
class RDoc::Parser::Markdown < ::RDoc::Parser
  include ::RDoc::Parser::Text

  # Creates an Markdown-format TopLevel for the given file.
  def scan; end
end

# Parse a RD format file.  The parsed RDoc::Markup::Document is attached as a
# file comment.
class RDoc::Parser::RD < ::RDoc::Parser
  include ::RDoc::Parser::Text

  # Creates an rd-format TopLevel for the given file.
  def scan; end
end

# Wrapper for Ripper lex states
class RDoc::Parser::RipperStateLex
  # New lexer for +code+.
  #
  # @return [RipperStateLex] a new instance of RipperStateLex
  def initialize(code); end

  def get_squashed_tk; end

  private

  def get_embdoc_tk(tk); end
  def get_heredoc_tk(heredoc_name, indent); end
  def get_op_tk(tk); end
  def get_regexp_tk(tk); end
  def get_string_tk(tk); end
  def get_symbol_tk(tk); end
  def get_words_tk(tk); end

  # @return [Boolean]
  def heredoc_end?(name, indent, tk); end

  def retrieve_heredoc_info(tk); end

  class << self
    # Returns +true+ if lex state will be +END+ after +token+.
    #
    # @return [Boolean]
    def end?(token); end

    # Returns tokens parsed from +code+.
    def parse(code); end
  end
end

RDoc::Parser::RipperStateLex::EXPR_ARG = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_ARG_ANY = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_BEG = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_BEG_ANY = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_CLASS = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_CMDARG = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_DOT = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_END = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_ENDARG = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_ENDFN = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_END_ANY = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_FITEM = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_FNAME = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_LABEL = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_LABELED = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_MID = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_NONE = T.let(T.unsafe(nil), Integer)
RDoc::Parser::RipperStateLex::EXPR_VALUE = T.let(T.unsafe(nil), Integer)

class RDoc::Parser::RipperStateLex::InnerStateLex < ::Ripper::Filter
  # @return [InnerStateLex] a new instance of InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

# TODO: Remove this constants after Ruby 2.4 EOL
RDoc::Parser::RipperStateLex::RIPPER_HAS_LEX_STATE = T.let(T.unsafe(nil), TrueClass)

class RDoc::Parser::RipperStateLex::Token < ::Struct
  # Returns the value of attribute char_no
  #
  # @return [Object] the current value of char_no
  def char_no; end

  # Sets the attribute char_no
  #
  # @param value [Object] the value to set the attribute char_no to.
  # @return [Object] the newly set value
  def char_no=(_); end

  # Returns the value of attribute kind
  #
  # @return [Object] the current value of kind
  def kind; end

  # Sets the attribute kind
  #
  # @param value [Object] the value to set the attribute kind to.
  # @return [Object] the newly set value
  def kind=(_); end

  # Returns the value of attribute line_no
  #
  # @return [Object] the current value of line_no
  def line_no; end

  # Sets the attribute line_no
  #
  # @param value [Object] the value to set the attribute line_no to.
  # @return [Object] the newly set value
  def line_no=(_); end

  # Returns the value of attribute state
  #
  # @return [Object] the current value of state
  def state; end

  # Sets the attribute state
  #
  # @param value [Object] the value to set the attribute state to.
  # @return [Object] the newly set value
  def state=(_); end

  # Returns the value of attribute text
  #
  # @return [Object] the current value of text
  def text; end

  # Sets the attribute text
  #
  # @param value [Object] the value to set the attribute text to.
  # @return [Object] the newly set value
  def text=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Extracts code elements from a source file returning a TopLevel object
# containing the constituent file elements.
#
# This file is based on rtags
#
# RubyParser understands how to document:
# * classes
# * modules
# * methods
# * constants
# * aliases
# * private, public, protected
# * private_class_function, public_class_function
# * private_constant, public_constant
# * module_function
# * attr, attr_reader, attr_writer, attr_accessor
# * extra accessors given on the command line
# * metaprogrammed methods
# * require
# * include
#
# == Method Arguments
#
# --
# NOTE: I don't think this works, needs tests, remove the paragraph following
# this block when known to work
#
# The parser extracts the arguments from the method definition.  You can
# override this with a custom argument definition using the :args: directive:
#
#   ##
#   # This method tries over and over until it is tired
#
#   def go_go_go(thing_to_try, tries = 10) # :args: thing_to_try
#     puts thing_to_try
#     go_go_go thing_to_try, tries - 1
#   end
#
# If you have a more-complex set of overrides you can use the :call-seq:
# directive:
# ++
#
# The parser extracts the arguments from the method definition.  You can
# override this with a custom argument definition using the :call-seq:
# directive:
#
#   ##
#   # This method can be called with a range or an offset and length
#   #
#   # :call-seq:
#   #   my_method(Range)
#   #   my_method(offset, length)
#
#   def my_method(*args)
#   end
#
# The parser extracts +yield+ expressions from method bodies to gather the
# yielded argument names.  If your method manually calls a block instead of
# yielding or you want to override the discovered argument names use
# the :yields: directive:
#
#   ##
#   # My method is awesome
#
#   def my_method(&block) # :yields: happy, times
#     block.call 1, 2
#   end
#
# == Metaprogrammed Methods
#
# To pick up a metaprogrammed method, the parser looks for a comment starting
# with '##' before an identifier:
#
#   ##
#   # This is a meta-programmed method!
#
#   add_my_method :meta_method, :arg1, :arg2
#
# The parser looks at the token after the identifier to determine the name, in
# this example, :meta_method.  If a name cannot be found, a warning is printed
# and 'unknown is used.
#
# You can force the name of a method using the :method: directive:
#
#   ##
#   # :method: some_method!
#
# By default, meta-methods are instance methods.  To indicate that a method is
# a singleton method instead use the :singleton-method: directive:
#
#   ##
#   # :singleton-method:
#
# You can also use the :singleton-method: directive with a name:
#
#   ##
#   # :singleton-method: some_method!
#
# You can define arguments for metaprogrammed methods via either the
# :call-seq:, :arg: or :args: directives.
#
# Additionally you can mark a method as an attribute by
# using :attr:, :attr_reader:, :attr_writer: or :attr_accessor:.  Just like
# for :method:, the name is optional.
#
#   ##
#   # :attr_reader: my_attr_name
#
# == Hidden methods and attributes
#
# You can provide documentation for methods that don't appear using
# the :method:, :singleton-method: and :attr: directives:
#
#   ##
#   # :attr_writer: ghost_writer
#   # There is an attribute here, but you can't see it!
#
#   ##
#   # :method: ghost_method
#   # There is a method here, but you can't see it!
#
#   ##
#   # this is a comment for a regular method
#
#   def regular_method() end
#
# Note that by default, the :method: directive will be ignored if there is a
# standard rdocable item following it.
class RDoc::Parser::Ruby < ::RDoc::Parser
  include ::RDoc::TokenStream
  include ::RDoc::Parser::RubyTools

  # Creates a new Ruby parser.
  #
  # @return [Ruby] a new instance of Ruby
  def initialize(top_level, file_name, content, options, stats); end

  # Look for the first comment in a file that isn't a shebang line.
  def collect_first_comment; end

  # Consumes trailing whitespace from the token stream
  def consume_trailing_spaces; end

  # Creates a new attribute in +container+ with +name+.
  def create_attr(container, single, name, rw, comment); end

  # Creates a module alias in +container+ at +rhs_name+ (or at the top-level
  # for "::") with the name from +constant+.
  def create_module_alias(container, constant, rhs_name); end

  # Aborts with +msg+
  def error(msg); end

  # Looks for a true or false token.
  def get_bool; end

  # Look for the name of a class of module (optionally with a leading :: or
  # with :: separated named) and return the ultimate name, the associated
  # container, and the given name (with the ::).
  def get_class_or_module(container, ignore_constants = T.unsafe(nil)); end

  # Return a superclass, which can be either a constant of an expression
  def get_class_specification; end

  # Parse a constant, which might be qualified by one or more class or module
  # names
  def get_constant; end

  # Little hack going on here. In the statement:
  #
  #   f = 2*(1+yield)
  #
  # We see the RPAREN as the next token, so we need to exit early.  This still
  # won't catch all cases (such as "a = yield + 1"
  def get_end_token(tk); end

  # Get an included module that may be surrounded by parens
  def get_included_module_with_optional_parens; end

  # Retrieves the method container for a singleton method.
  def get_method_container(container, name_t); end

  # Extracts a name or symbol from the token stream.
  def get_symbol_or_name; end

  # Retrieves the read token stream and replaces +pattern+ with +replacement+
  # using gsub.  If the result is only a ";" returns an empty string.
  def get_tkread_clean(pattern, replacement); end

  # Extracts the visibility information for the visibility token +tk+
  # and +single+ class type identifier.
  #
  # Returns the visibility type (a string), the visibility (a symbol) and
  # +singleton+ if the methods following should be converted to singleton
  # methods.
  def get_visibility_information(tk, single); end

  # Look for directives in a normal comment block:
  #
  #   # :stopdoc:
  #   # Don't display comment from this point forward
  #
  # This routine modifies its +comment+ parameter.
  def look_for_directives_in(container, comment); end

  # Adds useful info about the parser to +message+
  def make_message(message); end

  # Creates a comment with the correct format
  def new_comment(comment, line_no = T.unsafe(nil)); end

  # Parses an +alias+ in +context+ with +comment+
  def parse_alias(context, single, tk, comment); end

  # Creates an RDoc::Attr for the name following +tk+, setting the comment to
  # +comment+.
  def parse_attr(context, single, tk, comment); end

  # Creates an RDoc::Attr for each attribute listed after +tk+, setting the
  # comment for each to +comment+.
  def parse_attr_accessor(context, single, tk, comment); end

  # Extracts call parameters from the token stream.
  def parse_call_parameters(tk); end

  # Parses a class in +context+ with +comment+
  def parse_class(container, single, tk, comment); end

  # Parses and creates a regular class
  def parse_class_regular(container, declaration_context, single, name_t, given_name, comment); end

  # Parses a singleton class in +container+ with the given +name+ and
  # +comment+.
  def parse_class_singleton(container, name, comment); end

  # Generates an RDoc::Method or RDoc::Attr from +comment+ by looking for
  # :method: or :attr: directives in +comment+.
  def parse_comment(container, tk, comment); end

  # Parse a comment that is describing an attribute in +container+ with the
  # given +name+ and +comment+.
  def parse_comment_attr(container, type, name, comment); end

  def parse_comment_ghost(container, text, name, column, line_no, comment); end

  # Creates an RDoc::Method on +container+ from +comment+ if there is a
  # Signature section in the comment
  def parse_comment_tomdoc(container, tk, comment); end

  # Parses a constant in +context+ with +comment+.  If +ignore_constants+ is
  # true, no found constants will be added to RDoc.
  def parse_constant(container, tk, comment, ignore_constants = T.unsafe(nil)); end

  def parse_constant_body(container, constant, is_array_or_hash); end

  # Parses a Module#private_constant or Module#public_constant call from +tk+.
  def parse_constant_visibility(container, single, tk); end

  # Parses an +include+ or +extend+, indicated by the +klass+ and adds it to
  # +container+ # with +comment+
  def parse_extend_or_include(klass, container, comment); end

  # Parses identifiers that can create new methods or change visibility.
  #
  # Returns true if the comment was not consumed.
  def parse_identifier(container, single, tk, comment); end

  # Parses an +included+ with a block feature of ActiveSupport::Concern.
  def parse_included_with_activesupport_concern(container, comment); end

  # Parses a meta-programmed attribute and creates an RDoc::Attr.
  #
  # To create foo and bar attributes on class C with comment "My attributes":
  #
  #   class C
  #
  #     ##
  #     # :attr:
  #     #
  #     # My attributes
  #
  #     my_attr :foo, :bar
  #
  #   end
  #
  # To create a foo attribute on class C with comment "My attribute":
  #
  #   class C
  #
  #     ##
  #     # :attr: foo
  #     #
  #     # My attribute
  #
  #     my_attr :foo, :bar
  #
  #   end
  def parse_meta_attr(context, single, tk, comment); end

  # Parses a meta-programmed method
  def parse_meta_method(container, single, tk, comment); end

  # Parses the name of a metaprogrammed method.  +comment+ is used to
  # determine the name while +tk+ is used in an error message if the name
  # cannot be determined.
  def parse_meta_method_name(comment, tk); end

  # Parses the parameters and block for a meta-programmed method.
  def parse_meta_method_params(container, single, meth, tk, comment); end

  # Parses a normal method defined by +def+
  def parse_method(container, single, tk, comment); end

  # Parses a method that needs to be ignored.
  def parse_method_dummy(container); end

  # Parses the name of a method in +container+.
  #
  # Returns the method name, the container it is in (for def Foo.name) and if
  # it is a singleton or regular method.
  def parse_method_name(container); end

  # For the given +container+ and initial name token +name_t+ the method name
  # is parsed from the token stream for a regular method.
  def parse_method_name_regular(container, name_t); end

  # For the given +container+ and initial name token +name_t+ the method name
  # and the new +container+ (if necessary) are parsed from the token stream
  # for a singleton method.
  def parse_method_name_singleton(container, name_t); end

  # Extracts +yield+ parameters from +method+
  def parse_method_or_yield_parameters(method = T.unsafe(nil), modifiers = T.unsafe(nil)); end

  # Capture the method's parameters. Along the way, look for a comment
  # containing:
  #
  #    # yields: ....
  #
  # and add this as the block_params for the method
  def parse_method_parameters(method); end

  # Parses the parameters and body of +meth+
  def parse_method_params_and_body(container, single, meth, added_container); end

  # Parses an RDoc::NormalModule in +container+ with +comment+
  def parse_module(container, single, tk, comment); end

  # Parses an RDoc::Require in +context+ containing +comment+
  def parse_require(context, comment); end

  # Parses a rescue
  def parse_rescue; end

  # The core of the Ruby parser.
  def parse_statements(container, single = T.unsafe(nil), current_method = T.unsafe(nil), comment = T.unsafe(nil)); end

  # Parse up to +no+ symbol arguments
  def parse_symbol_arg(no = T.unsafe(nil)); end

  # Parses up to +no+ symbol arguments surrounded by () and places them in
  # +args+.
  def parse_symbol_arg_paren(no); end

  # Parses up to +no+ symbol arguments separated by spaces and places them in
  # +args+.
  def parse_symbol_arg_space(no, tk); end

  # Returns symbol text from the next token
  def parse_symbol_in_arg; end

  # Parses statements in the top-level +container+
  def parse_top_level_statements(container); end

  # Determines the visibility in +container+ from +tk+
  def parse_visibility(container, single, tk); end

  # Determines the block parameter for +context+
  def parse_yield(context, single, tk, method); end

  # Directives are modifier comments that can appear after class, module, or
  # method names. For example:
  #
  #   def fred # :yields: a, b
  #
  # or:
  #
  #
  # We return the directive name and any parameters as a two element array if
  # the name is in +allowed+.  A directive can be found anywhere up to the end
  # of the current line.
  def read_directive(allowed); end

  # Handles directives following the definition for +context+ (any
  # RDoc::CodeObject) if the directives are +allowed+ at this point.
  #
  # See also RDoc::Markup::PreProcess#handle_directive
  def read_documentation_modifiers(context, allowed); end

  # Records the location of this +container+ in the file for this parser and
  # adds it to the list of classes and modules in the file.
  def record_location(container); end

  # Retrieve comment body without =begin/=end
  def retrieve_comment_body(tk); end

  # Scans this Ruby file for Ruby constructs
  def scan; end

  # skip the var [in] part of a 'for' statement
  def skip_for_variable; end

  # Skips the next method in +container+
  def skip_method(container); end

  # while, until, and for have an optional do
  def skip_optional_do_after_expression; end

  # Skip opening parentheses and yield the block.
  # Skip closing parentheses too when exists.
  def skip_parentheses(&block); end

  # Skip spaces until a comment is found
  def skip_tkspace_comment(skip_nl = T.unsafe(nil)); end

  # Marks containers between +container+ and +ancestor+ as ignored
  def suppress_parents(container, ancestor); end

  # Return +true+ if +tk+ is a newline.
  #
  # @return [Boolean]
  def tk_nl?(tk); end

  # Updates visibility in +container+ from +vis_type+ and +vis+.
  def update_visibility(container, vis_type, vis, singleton); end

  # Prints +message+ to +$stderr+ unless we're being quiet
  def warn(message); end
end

# Collection of methods for writing parsers
module RDoc::Parser::RubyTools
  # Adds a token listener +obj+, but you should probably use token_listener
  def add_token_listener(obj); end

  # Fetches the next token from the scanner
  def get_tk; end

  # Reads and returns all tokens up to one of +tokens+.  Leaves the matched
  # token in the token list.
  def get_tk_until(*tokens); end

  # Retrieves a String representation of the read tokens
  def get_tkread; end

  # Peek equivalent for get_tkread
  def peek_read; end

  # Peek at the next token, but don't remove it from the stream
  def peek_tk; end

  # Removes the token listener +obj+
  def remove_token_listener(obj); end

  # Resets the tools
  def reset; end

  # Skips whitespace tokens including newlines
  def skip_tkspace; end

  # Skips whitespace tokens excluding newlines
  def skip_tkspace_without_nl; end

  # Has +obj+ listen to tokens
  def token_listener(obj); end

  # Returns +tk+ to the scanner
  def unget_tk(tk); end
end

# Parse a non-source file. We basically take the whole thing as one big
# comment.
class RDoc::Parser::Simple < ::RDoc::Parser
  include ::RDoc::Parser::Text

  # Prepare to parse a plain file
  #
  # @return [Simple] a new instance of Simple
  def initialize(top_level, file_name, content, options, stats); end

  def content; end

  # Removes the encoding magic comment from +text+
  def remove_coding_comment(text); end

  # Removes private comments.
  #
  # Unlike RDoc::Comment#remove_private this implementation only looks for two
  # dashes at the beginning of the line.  Three or more dashes are considered
  # to be a rule and ignored.
  def remove_private_comment(comment); end

  # Extract the file contents and attach them to the TopLevel as a comment
  def scan; end
end

class RDoc::RD
  class << self
    # Parses +rd+ source and returns an RDoc::Markup::Document.  If the
    # <tt>=begin</tt> or <tt>=end</tt> lines are missing they will be added.
    def parse(rd); end
  end
end

# RD format parser for headings, paragraphs, lists, verbatim sections that
# exist as blocks.
class RDoc::RD::BlockParser < ::Racc::Parser
  # Creates a new RDoc::RD::BlockParser.  Use #parse to parse an rd-format
  # document.
  #
  # @return [BlockParser] a new instance of BlockParser
  def initialize; end

  # reduce 0 omitted
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_17(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_19(val, _values, result); end

  # @raise [ParseError]
  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end

  # reduce 26 omitted
  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_34(val, _values, result); end
  def _reduce_35(val, _values, result); end
  def _reduce_36(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_39(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_40(val, _values, result); end
  def _reduce_41(val, _values, result); end
  def _reduce_42(val, _values, result); end
  def _reduce_43(val, _values, result); end
  def _reduce_44(val, _values, result); end
  def _reduce_45(val, _values, result); end
  def _reduce_46(val, _values, result); end
  def _reduce_47(val, _values, result); end
  def _reduce_48(val, _values, result); end
  def _reduce_49(val, _values, result); end
  def _reduce_5(val, _values, result); end
  def _reduce_50(val, _values, result); end
  def _reduce_51(val, _values, result); end
  def _reduce_52(val, _values, result); end

  # reduce 53 omitted
  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  # reduce 56 omitted
  def _reduce_57(val, _values, result); end

  def _reduce_6(val, _values, result); end

  # reduce 61 omitted
  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end

  # reduce 70 omitted
  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  # reduce 7 omitted
  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end
  def _reduce_none(val, _values, result); end

  # Adds footnote +content+ to the document
  def add_footnote(content); end

  # Adds label +label+ to the document
  def add_label(label); end

  # Retrieves the content of +values+ as a single String
  def content(values); end

  # Footnotes for this document
  def footnotes; end

  # Path to find included files in
  def include_path; end

  # Path to find included files in
  def include_path=(_arg0); end

  # Labels for items in this document
  def labels; end

  # Current line number
  def line_index; end

  # Returns the next token from the document
  def next_token; end

  # Raises a ParseError when invalid formatting is found
  #
  # @raise [ParseError]
  def on_error(et, ev, _values); end

  # Creates a paragraph for +value+
  def paragraph(value); end

  # Parses +src+ and returns an RDoc::Markup::Document.
  def parse(src); end

  private

  # Cuts off excess whitespace in +src+
  def cut_off(src); end

  # Formats line numbers +line_numbers+ prettily
  def format_line_num(*line_numbers); end

  # Retrieves the content for +file+ from the include_path
  def get_included(file); end

  # Yields to the given block if +indent+ matches the current indent, otherwise
  # an indentation token is processed.
  def if_current_indent_equal(indent); end

  # Parses subtree +src+
  def parse_subtree(src); end

  def set_term_to_element(parent, term); end
end

RDoc::RD::BlockParser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)

# Inline keeps track of markup and labels to create proper links.
class RDoc::RD::Inline
  # Initializes the Inline with +rdoc+ and +inline+
  #
  # @return [Inline] a new instance of Inline
  def initialize(rdoc, reference); end

  def ==(other); end

  # Appends +more+ to this inline.  +more+ may be a String or another Inline.
  def append(more); end

  def inspect; end

  # The markup of this reference in RDoc format
  def rdoc; end

  # The text of the reference
  def reference; end

  # The markup of this reference in RDoc format
  def to_s; end

  class << self
    # Creates a new Inline for +rdoc+ and +reference+.
    #
    # +rdoc+ may be another Inline or a String.  If +reference+ is not given it
    # will use the text from +rdoc+.
    def new(rdoc, reference = T.unsafe(nil)); end
  end
end

# RD format parser for inline markup such as emphasis, links, footnotes, etc.
class RDoc::RD::InlineParser < ::Racc::Parser
  # Creates a new parser for inline markup in the rd format.  The +block_parser+
  # is used to for footnotes and labels in the inline text.
  #
  # @return [InlineParser] a new instance of InlineParser
  def initialize(block_parser); end

  # reduce 100 omitted
  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  # reduce 108 omitted
  def _reduce_109(val, _values, result); end

  # reduce 110 omitted
  def _reduce_111(val, _values, result); end

  # reduce 112 omitted
  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end
  def _reduce_115(val, _values, result); end

  # reduce 12 omitted
  def _reduce_13(val, _values, result); end

  # reduce 135 omitted
  def _reduce_136(val, _values, result); end

  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_17(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_19(val, _values, result); end

  # reduce 1 omitted
  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end

  # reduce 28 omitted
  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_34(val, _values, result); end

  # reduce 35 omitted
  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_39(val, _values, result); end
  def _reduce_40(val, _values, result); end
  def _reduce_41(val, _values, result); end

  # reduce 42 omitted
  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end
  def _reduce_45(val, _values, result); end
  def _reduce_46(val, _values, result); end

  # reduce 56 omitted
  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end
  def _reduce_59(val, _values, result); end
  def _reduce_60(val, _values, result); end

  # reduce 61 omitted
  def _reduce_62(val, _values, result); end

  # reduce 63 omitted
  def _reduce_64(val, _values, result); end

  # reduce 77 omitted
  def _reduce_78(val, _values, result); end

  # reduce 137 omitted
  def _reduce_none(val, _values, result); end

  # Creates a new RDoc::RD::Inline for the +rdoc+ markup and the raw +reference+
  def inline(rdoc, reference = T.unsafe(nil)); end

  # Returns the next token from the inline text
  def next_token; end

  # Returns words following an error
  def next_words_on_error; end

  # Raises a ParseError when invalid formatting is found
  #
  # @raise [ParseError]
  def on_error(et, ev, values); end

  # Parses the +inline+ text from RD format into RDoc format.
  def parse(inline); end

  # Returns words before the error
  def prev_words_on_error(ev); end

  private

  # Returns the last line of +src+
  def last_line(src); end
end

RDoc::RD::InlineParser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)

# This is the driver for generating RDoc output.  It handles file parsing and
# generation of output.
#
# To use this class to generate RDoc output via the API, the recommended way
# is:
#
#   rdoc = RDoc::RDoc.new
#   options = RDoc::Options.load_options # returns an RDoc::Options instance
#   # set extra options
#   rdoc.document options
#
# You can also generate output like the +rdoc+ executable:
#
#   rdoc = RDoc::RDoc.new
#   rdoc.document argv
#
# Where +argv+ is an array of strings, each corresponding to an argument you'd
# give rdoc on the command line.  See <tt>rdoc --help</tt> for details.
class RDoc::RDoc
  # Creates a new RDoc::RDoc instance.  Call #document to parse files and
  # generate documentation.
  #
  # @return [RDoc] a new instance of RDoc
  def initialize; end

  # Generates documentation or a coverage report depending upon the settings
  # in +options+.
  #
  # +options+ can be either an RDoc::Options instance or an array of strings
  # equivalent to the strings that would be passed on the command line like
  # <tt>%w[-q -o doc -t My\ Doc\ Title]</tt>.  #document will automatically
  # call RDoc::Options#finish if an options instance was given.
  #
  # For a list of options, see either RDoc::Options or <tt>rdoc --help</tt>.
  #
  # By default, output will be stored in a directory called "doc" below the
  # current directory, so make sure you're somewhere writable before invoking.
  def document(options); end

  # Report an error message and exit
  #
  # @raise [RDoc::Error]
  def error(msg); end

  # Gathers a set of parseable files from the files and directories listed in
  # +files+.
  def gather_files(files); end

  # Generates documentation for +file_info+ (from #parse_files) into the
  # output dir using the generator selected
  # by the RDoc options
  def generate; end

  # Generator instance used for creating output
  def generator; end

  # Generator instance used for creating output
  def generator=(_arg0); end

  # Turns RDoc from stdin into HTML
  def handle_pipe; end

  # Installs a siginfo handler that prints the current filename.
  def install_siginfo_handler; end

  # Hash of files and their last modified times.
  def last_modified; end

  # Return a list of the files to be processed in a directory. We know that
  # this directory doesn't have a .document file, so we're looking for real
  # files. However we may well contain subdirectories which must be tested
  # for .document files.
  def list_files_in_directory(dir); end

  # Given a list of files and directories, create a list of all the Ruby
  # files they contain.
  #
  # If +force_doc+ is true we always add the given files, if false, only
  # add files that we guarantee we can parse.  It is true when looking at
  # files given on the command line, false when recursing through
  # subdirectories.
  #
  # The effect of this is that if you want a file with a non-standard
  # extension parsed, you must name it explicitly.
  def normalized_file_list(relative_files, force_doc = T.unsafe(nil), exclude_pattern = T.unsafe(nil)); end

  # RDoc options
  def options; end

  # RDoc options
  def options=(_arg0); end

  # Return the path name of the flag file in an output directory.
  def output_flag_file(op_dir); end

  # The .document file contains a list of file and directory name patterns,
  # representing candidates for documentation. It may also contain comments
  # (starting with '#')
  def parse_dot_doc_file(in_dir, filename); end

  # Parses +filename+ and returns an RDoc::TopLevel
  def parse_file(filename); end

  # Parse each file on the command line, recursively entering directories.
  def parse_files(files); end

  # Removes a siginfo handler and replaces the previous
  def remove_siginfo_handler; end

  # Removes file extensions known to be unparseable from +files+ and TAGS
  # files for emacs and vim.
  def remove_unparseable(files); end

  # Create an output dir if it doesn't exist. If it does exist, but doesn't
  # contain the flag file <tt>created.rid</tt> then we refuse to use it, as
  # we may clobber some manually generated documentation
  def setup_output_dir(dir, force); end

  # Accessor for statistics.  Available after each call to parse_files
  def stats; end

  # The current documentation store
  def store; end

  # Sets the current documentation tree to +store+ and sets the store's rdoc
  # driver to this instance.
  def store=(store); end

  # Update the flag file in an output directory.
  def update_output_dir(op_dir, time, last = T.unsafe(nil)); end

  class << self
    # Add +klass+ that can generate output after parsing
    def add_generator(klass); end

    # Active RDoc::RDoc instance
    def current; end

    # Sets the active RDoc::RDoc instance
    def current=(rdoc); end
  end
end

# List of directory names skipped if test suites should be skipped
RDoc::RDoc::TEST_SUITE_DIRECTORY_NAMES = T.let(T.unsafe(nil), Array)

# List of directory names always skipped
RDoc::RDoc::UNCONDITIONALLY_SKIPPED_DIRECTORIES = T.let(T.unsafe(nil), Array)

# The RI driver implements the command-line ri tool.
#
# The driver supports:
# * loading RI data from:
#   * Ruby's standard library
#   * RubyGems
#   * ~/.rdoc
#   * A user-supplied directory
# * Paging output (uses RI_PAGER environment variable, PAGER environment
#   variable or the less, more and pager programs)
# * Interactive mode with tab-completion
# * Abbreviated names (ri Zl shows Zlib documentation)
# * Colorized output
# * Merging output from multiple RI data sources
class RDoc::RI::Driver
  # Creates a new driver using +initial_options+ from ::process_args
  #
  # @return [Driver] a new instance of Driver
  def initialize(initial_options = T.unsafe(nil)); end

  # Adds paths for undocumented classes +also_in+ to +out+
  def add_also_in(out, also_in); end

  # Adds a class header to +out+ for class +name+ which is described in
  # +classes+.
  def add_class(out, name, classes); end

  # Adds +extends+ to +out+
  def add_extends(out, extends); end

  # Adds a list of +extensions+ to this module of the given +type+ to +out+.
  # add_includes and add_extends call this, so you should use those directly.
  def add_extension_modules(out, type, extensions); end

  # Renders multiple included +modules+ from +store+ to +out+.
  def add_extension_modules_multiple(out, store, modules); end

  # Adds a single extension module +include+ from +store+ to +out+
  def add_extension_modules_single(out, store, include); end

  # Adds "(from ...)" to +out+ for +store+
  def add_from(out, store); end

  # Adds +includes+ to +out+
  def add_includes(out, includes); end

  # Looks up the method +name+ and adds it to +out+
  def add_method(out, name); end

  # Adds documentation for all methods in +klass+ to +out+
  def add_method_documentation(out, klass); end

  # Adds a list of +methods+ to +out+ with a heading of +name+
  def add_method_list(out, methods, name); end

  # Returns ancestor classes of +klass+
  def ancestors_of(klass); end

  def check_did_you_mean; end

  # For RubyGems backwards compatibility
  def class_cache; end

  # Builds a RDoc::Markup::Document from +found+, +klasess+ and +includes+
  def class_document(name, found, klasses, includes, extends); end

  # Adds the class +comment+ to +out+.
  def class_document_comment(out, comment); end

  # Adds the constants from +klass+ to the Document +out+.
  def class_document_constants(out, klass); end

  # Hash mapping a known class or module to the stores it can be loaded from
  def classes; end

  # Returns the stores wherein +name+ is found along with the classes,
  # extends and includes that match it
  def classes_and_includes_and_extends_for(name); end

  # Completes +name+ based on the caches.  For Readline
  def complete(name); end

  def complete_klass(name, klass, selector, method, completions); end
  def complete_method(name, klass, selector, completions); end

  # Converts +document+ to text and writes it to the pager
  def display(document); end

  # Outputs formatted RI data for class +name+.  Groups undocumented classes
  def display_class(name); end

  # Outputs formatted RI data for method +name+
  def display_method(name); end

  # Outputs formatted RI data for the class or method +name+.
  #
  # Returns true if +name+ was found, false if it was not an alternative could
  # be guessed, raises an error if +name+ couldn't be guessed.
  def display_name(name); end

  # Displays each name in +name+
  def display_names(names); end

  # Outputs formatted RI data for page +name+.
  def display_page(name); end

  # Outputs a formatted RI page list for the pages in +store+.
  def display_page_list(store, pages = T.unsafe(nil), search = T.unsafe(nil)); end

  # Expands abbreviated klass +klass+ into a fully-qualified class.  "Zl::Da"
  # will be expanded to Zlib::DataError.
  def expand_class(klass); end

  # Expands the class portion of +name+ into a fully-qualified class.  See
  # #expand_class.
  def expand_name(name); end

  # Filters the methods in +found+ trying to find a match for +name+.
  def filter_methods(found, name); end

  # Yields items matching +name+ including the store they were found in, the
  # class being searched for, the class they were found in (an ancestor) the
  # types of methods to look up (from #method_type), and the method name being
  # searched for
  def find_methods(name); end

  # Finds a store that matches +name+ which can be the name of a gem, "ruby",
  # "home" or "site".
  #
  # See also RDoc::Store#source
  #
  # @raise [RDoc::RI::Driver::NotFoundError]
  def find_store(name); end

  # Creates a new RDoc::Markup::Formatter.  If a formatter is given with -f,
  # use it.  If we're outputting to a pager, use bs, otherwise ansi.
  def formatter(io); end

  # Runs ri interactively using Readline if it is available.
  def interactive; end

  # Lists classes known to ri starting with +names+.  If +names+ is empty all
  # known classes are shown.
  def list_known_classes(names = T.unsafe(nil)); end

  # Returns an Array of methods matching +name+
  def list_methods_matching(name); end

  # Loads RI data for method +name+ on +klass+ from +store+.  +type+ and
  # +cache+ indicate if it is a class or instance method.
  def load_method(store, cache, klass, type, name); end

  # Returns an Array of RI data for methods matching +name+
  def load_methods_matching(name); end

  # Returns a filtered list of methods matching +name+
  def lookup_method(name); end

  # Builds a RDoc::Markup::Document from +found+, +klasses+ and +includes+
  def method_document(name, filtered); end

  # Returns the type of method (:both, :instance, :class) for +selector+
  def method_type(selector); end

  # Returns a regular expression for +name+ that will match an
  # RDoc::AnyMethod's name.
  def name_regexp(name); end

  # Paginates output through a pager program.
  def page; end

  # Are we using a pager?
  #
  # @return [Boolean]
  def paging?; end

  # Extracts the class, selector and method name parts from +name+ like
  # Foo::Bar#baz.
  #
  # NOTE: Given Foo::Bar, Bar is considered a class even though it may be a
  # method
  def parse_name(name); end

  # Renders the +klass+ from +store+ to +out+.  If the klass has no
  # documentable items the class is added to +also_in+ instead.
  def render_class(out, store, klass, also_in); end

  def render_method(out, store, method, name); end
  def render_method_arguments(out, arglists); end
  def render_method_comment(out, method, alias_for = T.unsafe(nil)); end
  def render_method_superclass(out, method); end

  # Looks up and displays ri data according to the options given.
  def run; end

  # Sets up a pager program to pass output through.  Tries the RI_PAGER and
  # PAGER environment variables followed by pager, less then more.
  def setup_pager; end

  # Show all method documentation following a class or module
  def show_all; end

  # Show all method documentation following a class or module
  def show_all=(_arg0); end

  # Starts a WEBrick server for ri.
  def start_server; end

  # An RDoc::RI::Store for each entry in the RI path
  def stores; end

  # An RDoc::RI::Store for each entry in the RI path
  def stores=(_arg0); end

  # Controls the user of the pager vs $stdout
  def use_stdout; end

  # Controls the user of the pager vs $stdout
  def use_stdout=(_arg0); end

  class << self
    # Default options for ri
    def default_options; end

    # Dump +data_path+ using pp
    def dump(data_path); end

    # Parses +argv+ and returns a Hash of options
    def process_args(argv); end

    # Runs the ri command line executable using +argv+
    def run(argv = T.unsafe(nil)); end
  end
end

# Raised when a name isn't found in the ri data stores
class RDoc::RI::Driver::NotFoundError < ::RDoc::RI::Driver::Error
  # @return [NotFoundError] a new instance of NotFoundError
  def initialize(klass, suggestion_proc = T.unsafe(nil)); end

  def message; end

  # Name that wasn't found
  def name; end
end

# For RubyGems backwards compatibility
module RDoc::RI::Formatter; end

RDoc::RI::Store = RDoc::Store

# A file loaded by \#require
class RDoc::Require < ::RDoc::CodeObject
  # Creates a new Require that loads +name+ with +comment+
  #
  # @return [Require] a new instance of Require
  def initialize(name, comment); end

  def inspect; end

  # Name of the required file
  def name; end

  # Name of the required file
  def name=(_arg0); end

  def to_s; end

  # The RDoc::TopLevel corresponding to this require, or +nil+ if not found.
  def top_level; end
end

# This is a WEBrick servlet that allows you to browse ri documentation.
#
# You can show documentation through either `ri --server` or, with RubyGems
# 2.0 or newer, `gem server`.  For ri, the server runs on port 8214 by
# default.  For RubyGems the server runs on port 8808 by default.
#
# You can use this servlet in your own project by mounting it on a WEBrick
# server:
#
#   require 'webrick'
#
#   server = WEBrick::HTTPServer.new Port: 8000
#
#   server.mount '/', RDoc::Servlet
#
# If you want to mount the servlet some other place than the root, provide the
# base path when mounting:
#
#   server.mount '/rdoc', RDoc::Servlet, '/rdoc'
class RDoc::Servlet < ::WEBrick::HTTPServlet::AbstractServlet
  # Creates a new WEBrick servlet.
  #
  # Use +mount_path+ when mounting the servlet somewhere other than /.
  #
  # Use +extra_doc_dirs+ for additional documentation directories.
  #
  # +server+ is provided automatically by WEBrick when mounting.  +stores+ and
  # +cache+ are provided automatically by the servlet.
  #
  # @return [Servlet] a new instance of Servlet
  def initialize(server, stores, cache, mount_path = T.unsafe(nil), extra_doc_dirs = T.unsafe(nil)); end

  # Serves the asset at the path in +req+ for +generator_name+ via +res+.
  def asset(generator_name, req, res); end

  # Maps an asset type to its path on the filesystem
  def asset_dirs; end

  # GET request entry point.  Fills in +res+ for the path, etc. in +req+.
  def do_GET(req, res); end

  # Fills in +res+ with the class, module or page for +req+ from +store+.
  #
  # +path+ is relative to the mount_path and is used to determine the class,
  # module or page name (/RDoc/Servlet.html becomes RDoc::Servlet).
  # +generator+ is used to create the page.
  def documentation_page(store, generator, path, req, res); end

  # Creates the JSON search index on +res+ for the given +store+.  +generator+
  # must respond to \#json_index to build.  +req+ is ignored.
  def documentation_search(store, generator, req, res); end

  # Returns the RDoc::Store and path relative to +mount_path+ for
  # documentation at +path+.
  def documentation_source(path); end

  # Generates an error page for the +exception+ while handling +req+ on +res+.
  def error(exception, req, res); end

  # Instantiates a Darkfish generator for +store+
  def generator_for(store); end

  # Handles the If-Modified-Since HTTP header on +req+ for +path+.  If the
  # file has not been modified a Not Modified response is returned.  If the
  # file has been modified a Last-Modified header is added to +res+.
  def if_modified_since(req, res, path = T.unsafe(nil)); end

  # Returns an Array of installed documentation.
  #
  # Each entry contains the documentation name (gem name, 'Ruby
  # Documentation', etc.), the path relative to the mount point, whether the
  # documentation exists, the type of documentation (See RDoc::RI::Paths#each)
  # and the filesystem to the RDoc::Store for the documentation.
  def installed_docs; end

  # Returns a 404 page built by +generator+ for +req+ on +res+.
  def not_found(generator, req, res, message = T.unsafe(nil)); end

  # An RDoc::Options instance used for rendering options
  def options; end

  # Enumerates the ri paths.  See RDoc::RI::Paths#each
  def ri_paths(&block); end

  # Generates the root page on +res+.  +req+ is ignored.
  def root(req, res); end

  # Generates a search index for the root page on +res+.  +req+ is ignored.
  def root_search(req, res); end

  # Displays documentation for +req+ on +res+, whether that be HTML or some
  # asset.
  def show_documentation(req, res); end

  # Returns an RDoc::Store for the given +source_name+ ('ruby' or a gem name).
  def store_for(source_name); end

  class << self
    # Creates an instance of this servlet that shares cached data between
    # requests.
    def get_instance(server, *options); end
  end
end

# A singleton class
class RDoc::SingleClass < ::RDoc::ClassModule
  # Adds the superclass to the included modules.
  def ancestors; end

  def aref_prefix; end

  # The definition of this singleton class, <tt>class << MyClassName</tt>
  def definition; end

  def pretty_print(q); end
end

# RDoc statistics collector which prints a summary and report of a project's
# documentation totals.
class RDoc::Stats
  include ::RDoc::Text

  # Creates a new Stats that will have +num_files+.  +verbosity+ defaults to 1
  # which will create an RDoc::Stats::Normal outputter.
  #
  # @return [Stats] a new instance of Stats
  def initialize(store, num_files, verbosity = T.unsafe(nil)); end

  # Records the parsing of an alias +as+.
  def add_alias(as); end

  # Records the parsing of an attribute +attribute+
  def add_attribute(attribute); end

  # Records the parsing of a class +klass+
  def add_class(klass); end

  # Records the parsing of +constant+
  def add_constant(constant); end

  # Records the parsing of +file+
  def add_file(file); end

  # Records the parsing of +method+
  def add_method(method); end

  # Records the parsing of a module +mod+
  def add_module(mod); end

  # Call this to mark the beginning of parsing for display purposes
  def begin_adding; end

  # Calculates documentation totals and percentages for classes, modules,
  # constants, attributes and methods.
  def calculate; end

  # Output level for the coverage report
  def coverage_level; end

  # Sets coverage report level.  Accepted values are:
  #
  # false or nil:: No report
  # 0:: Classes, modules, constants, attributes, methods
  # 1:: Level 0 + method parameters
  def coverage_level=(level); end

  # Returns the length and number of undocumented items in +collection+.
  def doc_stats(collection); end

  # Call this to mark the end of parsing for display purposes
  def done_adding; end

  # Count of files parsed during parsing
  def files_so_far; end

  # The documentation status of this project.  +true+ when 100%, +false+ when
  # less than 100% and +nil+ when unknown.
  #
  # Set by calling #calculate
  #
  # @return [Boolean]
  def fully_documented?; end

  # A report that says you did a great job!
  def great_job; end

  # Total number of files found
  def num_files; end

  # Calculates the percentage of items documented.
  def percent_doc; end

  # Returns a report on which items are not documented
  def report; end

  # Returns a report on undocumented attributes in ClassModule +cm+
  def report_attributes(cm); end

  # Returns a report on undocumented items in ClassModule +cm+
  def report_class_module(cm); end

  # Returns a report on undocumented constants in ClassModule +cm+
  def report_constants(cm); end

  # Returns a report on undocumented methods in ClassModule +cm+
  def report_methods(cm); end

  # Returns a summary of the collected statistics.
  def summary; end

  # Determines which parameters in +method+ were not documented.  Returns a
  # total parameter count and an Array of undocumented methods.
  def undoc_params(method); end
end

# Stats printer that prints just the files being documented with a progress
# bar
class RDoc::Stats::Normal < ::RDoc::Stats::Quiet
  def begin_adding; end
  def done_adding; end

  # Prints a file with a progress bar
  def print_file(files_so_far, filename); end
end

# Stats printer that prints nothing
class RDoc::Stats::Quiet
  # Creates a new Quiet that will print nothing
  #
  # @return [Quiet] a new instance of Quiet
  def initialize(num_files); end

  # Prints a message at the beginning of parsing
  def begin_adding(*_arg0); end

  # Prints when RDoc is done
  def done_adding(*_arg0); end

  # Prints when an alias is added
  def print_alias(*_arg0); end

  # Prints when an attribute is added
  def print_attribute(*_arg0); end

  # Prints when a class is added
  def print_class(*_arg0); end

  # Prints when a constant is added
  def print_constant(*_arg0); end

  # Prints when a file is added
  def print_file(*_arg0); end

  # Prints when a method is added
  def print_method(*_arg0); end

  # Prints when a module is added
  def print_module(*_arg0); end
end

# Stats printer that prints everything documented, including the documented
# status
class RDoc::Stats::Verbose < ::RDoc::Stats::Normal
  # Returns a marker for RDoc::CodeObject +co+ being undocumented
  def nodoc(co); end

  def print_alias(as); end
  def print_attribute(attribute); end
  def print_class(klass); end
  def print_constant(constant); end
  def print_file(files_so_far, file); end
  def print_method(method); end
  def print_module(mod); end
end

# A set of rdoc data for a single project (gem, path, etc.).
#
# The store manages reading and writing ri data for a project and maintains a
# cache of methods, classes and ancestors in the store.
#
# The store maintains a #cache of its contents for faster lookup.  After
# adding items to the store it must be flushed using #save_cache.  The cache
# contains the following structures:
#
#    @cache = {
#      :ancestors        => {}, # class name => ancestor names
#      :attributes       => {}, # class name => attributes
#      :class_methods    => {}, # class name => class methods
#      :instance_methods => {}, # class name => instance methods
#      :modules          => [], # classes and modules in this store
#      :pages            => [], # page names
#    }
# --
# TODO need to prune classes
class RDoc::Store
  # Creates a new Store of +type+ that will load or save to +path+
  #
  # @return [Store] a new instance of Store
  def initialize(path = T.unsafe(nil), type = T.unsafe(nil)); end

  # Adds +module+ as an enclosure (namespace) for the given +variable+ for C
  # files.
  def add_c_enclosure(variable, namespace); end

  # Adds C variables from an RDoc::Parser::C
  def add_c_variables(c_parser); end

  # Adds the file with +name+ as an RDoc::TopLevel to the store.  Returns the
  # created RDoc::TopLevel.
  def add_file(absolute_name, relative_name: T.unsafe(nil), parser: T.unsafe(nil)); end

  # Returns all classes discovered by RDoc
  def all_classes; end

  # Returns all classes and modules discovered by RDoc
  def all_classes_and_modules; end

  # All TopLevels known to RDoc
  def all_files; end

  # Returns all modules discovered by RDoc
  def all_modules; end

  # Ancestors cache accessor.  Maps a klass name to an Array of its ancestors
  # in this store.  If Foo in this store inherits from Object, Kernel won't be
  # listed (it will be included from ruby's ri store).
  def ancestors; end

  # Attributes cache accessor.  Maps a class to an Array of its attributes.
  def attributes; end

  # Maps C variables to class or module names for each parsed C file.
  def c_class_variables; end

  # Stores the name of the C variable a class belongs to.  This helps wire up
  # classes defined from C across files.
  def c_enclosure_classes; end

  def c_enclosure_names; end

  # Maps C variables to singleton class names for each parsed C file.
  def c_singleton_class_variables; end

  # The contents of the Store
  def cache; end

  # Path to the cache file
  def cache_path; end

  # Path to the ri data for +klass_name+
  def class_file(klass_name); end

  # Class methods cache accessor.  Maps a class to an Array of its class
  # methods (not full name).
  def class_methods; end

  # Path where data for +klass_name+ will be stored (methods or class data)
  def class_path(klass_name); end

  # Hash of all classes known to RDoc
  def classes_hash; end

  # Removes empty items and ensures item in each collection are unique and
  # sorted
  def clean_cache_collection(collection); end

  # Prepares the RDoc code object tree for use by a generator.
  #
  # It finds unique classes/modules defined, and replaces classes/modules that
  # are aliases for another one by a copy with RDoc::ClassModule#is_alias_for
  # set.
  #
  # It updates the RDoc::ClassModule#constant_aliases attribute of "real"
  # classes or modules.
  #
  # It also completely removes the classes and modules that should be removed
  # from the documentation and the methods that have a visibility below
  # +min_visibility+, which is the <tt>--visibility</tt> option.
  #
  # See also RDoc::Context#remove_from_documentation?
  def complete(min_visibility); end

  # If true this Store will not write any files
  def dry_run; end

  # If true this Store will not write any files
  def dry_run=(_arg0); end

  # The encoding of the contents in the Store
  def encoding; end

  # The encoding of the contents in the Store
  def encoding=(_arg0); end

  # Hash of all files known to RDoc
  def files_hash; end

  # Finds the enclosure (namespace) for the given C +variable+.
  def find_c_enclosure(variable); end

  # Finds the class with +name+ in all discovered classes
  def find_class_named(name); end

  # Finds the class with +name+ starting in namespace +from+
  def find_class_named_from(name, from); end

  # Finds the class or module with +name+
  def find_class_or_module(name); end

  # Finds the file with +name+ in all discovered files
  def find_file_named(name); end

  # Finds the module with +name+ in all discovered modules
  def find_module_named(name); end

  # Returns the RDoc::TopLevel that is a text file and has the given
  # +file_name+
  def find_text_page(file_name); end

  # Finds unique classes/modules defined in +all_hash+,
  # and returns them as an array. Performs the alias
  # updates in +all_hash+: see ::complete.
  # --
  # TODO  aliases should be registered by Context#add_module_alias
  def find_unique(all_hash); end

  # Fixes the erroneous <tt>BasicObject < Object</tt> in 1.9.
  #
  # Because we assumed all classes without a stated superclass
  # inherit from Object, we have the above wrong inheritance.
  #
  # We fix BasicObject right away if we are running in a Ruby
  # version >= 1.9.
  def fix_basic_object_inheritance; end

  # Friendly rendition of #path
  def friendly_path; end

  def inspect; end

  # Instance methods cache accessor.  Maps a class to an Array of its
  # instance methods (not full name).
  def instance_methods; end

  # Loads all items from this store into memory.  This recreates a
  # documentation tree for use by a generator
  def load_all; end

  # Loads cache file for this store
  def load_cache; end

  # Loads ri data for +klass_name+ and hooks it up to this store.
  def load_class(klass_name); end

  # Loads ri data for +klass_name+
  def load_class_data(klass_name); end

  # Loads ri data for +method_name+ in +klass_name+
  def load_method(klass_name, method_name); end

  # Loads ri data for +page_name+
  def load_page(page_name); end

  # Gets the main page for this RDoc store.  This page is used as the root of
  # the RDoc server.
  def main; end

  # Sets the main page for this RDoc store.
  def main=(page); end

  # Converts the variable => ClassModule map +variables+ from a C parser into
  # a variable => class name map.
  def make_variable_map(variables); end

  # Path to the ri data for +method_name+ in +klass_name+
  def method_file(klass_name, method_name); end

  # Modules cache accessor.  An Array of all the module (and class) names in
  # the store.
  def module_names; end

  # Hash of all modules known to RDoc
  def modules_hash; end

  # Returns the RDoc::TopLevel that is a text file and has the given +name+
  def page(name); end

  # Path to the ri data for +page_name+
  def page_file(page_name); end

  # Path this store reads or writes
  def path; end

  # Path this store reads or writes
  def path=(_arg0); end

  # The RDoc::RDoc driver for this parse tree.  This allows classes consulting
  # the documentation tree to access user-set options, for example.
  def rdoc; end

  # The RDoc::RDoc driver for this parse tree.  This allows classes consulting
  # the documentation tree to access user-set options, for example.
  def rdoc=(_arg0); end

  # Removes from +all_hash+ the contexts that are nodoc or have no content.
  #
  # See RDoc::Context#remove_from_documentation?
  def remove_nodoc(all_hash); end

  # Saves all entries in the store
  def save; end

  # Writes the cache file for this store
  def save_cache; end

  # Writes the ri data for +klass+ (or module)
  def save_class(klass); end

  # Writes the ri data for +method+ on +klass+
  def save_method(klass, method); end

  # Writes the ri data for +page+
  def save_page(page); end

  # Source of the contents of this store.
  #
  # For a store from a gem the source is the gem name.  For a store from the
  # home directory the source is "home".  For system ri store (the standard
  # library documentation) the source is"ruby".  For a store from the site
  # ri directory the store is "site".  For other stores the source is the
  # #path.
  def source; end

  # Gets the title for this RDoc store.  This is used as the title in each
  # page on the RDoc server
  def title; end

  # Sets the title page for this RDoc store.
  def title=(title); end

  # Type of ri datastore this was loaded from.  See RDoc::RI::Driver,
  # RDoc::RI::Paths.
  def type; end

  # Type of ri datastore this was loaded from.  See RDoc::RI::Driver,
  # RDoc::RI::Paths.
  def type=(_arg0); end

  # Returns the unique classes discovered by RDoc.
  #
  # ::complete must have been called prior to using this method.
  def unique_classes; end

  # Returns the unique classes and modules discovered by RDoc.
  # ::complete must have been called prior to using this method.
  def unique_classes_and_modules; end

  # Returns the unique modules discovered by RDoc.
  # ::complete must have been called prior to using this method.
  def unique_modules; end

  # The lazy constants alias will be discovered in passing
  def unmatched_constant_alias; end

  # Sets the parser of +absolute_name+, unless it from a source code file.
  def update_parser_of_file(absolute_name, parser); end

  private

  def marshal_load(file); end
end

RDoc::Store::MarshalFilter = T.let(T.unsafe(nil), Proc)

# Raised when a stored file for a class, module, page or method is missing.
class RDoc::Store::MissingFileError < ::RDoc::Store::Error
  # Creates a new MissingFileError for the missing +file+ for the given
  # +name+ that should have been in the +store+.
  #
  # @return [MissingFileError] a new instance of MissingFileError
  def initialize(store, file, name); end

  # The file the #name should be saved as
  def file; end

  def message; end

  # The name of the object the #file would be loaded from
  def name; end

  # The store the file should exist in
  def store; end
end

# RDoc::Task creates the following rake tasks to generate and clean up RDoc
# output:
#
# [rdoc]
#   Main task for this RDoc task.
#
# [clobber_rdoc]
#   Delete all the rdoc files.  This target is automatically added to the main
#   clobber target.
#
# [rerdoc]
#   Rebuild the rdoc files from scratch, even if they are not out of date.
#
# [rdoc:coverage]
#   Print RDoc coverage report for all rdoc files.
#
# Simple Example:
#
#   require 'rdoc/task'
#
#   RDoc::Task.new do |rdoc|
#     rdoc.main = "README.rdoc"
#     rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
#   end
#
# The +rdoc+ object passed to the block is an RDoc::Task object. See the
# attributes list for the RDoc::Task class for available customization options.
#
# == Specifying different task names
#
# You may wish to give the task a different name, such as if you are
# generating two sets of documentation.  For instance, if you want to have a
# development set of documentation including private methods:
#
#   require 'rdoc/task'
#
#   RDoc::Task.new :rdoc_dev do |rdoc|
#     rdoc.main = "README.rdoc"
#     rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
#     rdoc.options << "--all"
#   end
#
# The tasks would then be named :<em>rdoc_dev</em>,
# :clobber_<em>rdoc_dev</em>, and :re<em>rdoc_dev</em>.
#
# If you wish to have completely different task names, then pass a Hash as
# first argument. With the <tt>:rdoc</tt>, <tt>:clobber_rdoc</tt> and
# <tt>:rerdoc</tt> options, you can customize the task names to your liking.
#
# For example:
#
#   require 'rdoc/task'
#
#   RDoc::Task.new(:rdoc => "rdoc", :clobber_rdoc => "rdoc:clean",
#                  :rerdoc => "rdoc:force")
#
# This will create the tasks <tt>:rdoc</tt>, <tt>:rdoc:clean</tt>,
# <tt>:rdoc:force</tt>, and <tt>:rdoc:coverage</tt>.
class RDoc::Task < ::Rake::TaskLib
  # Create an RDoc task with the given name. See the RDoc::Task class overview
  # for documentation.
  #
  # @return [Task] a new instance of Task
  # @yield [_self]
  # @yieldparam _self [RDoc::Task] the object that the method was called on
  def initialize(name = T.unsafe(nil)); end

  # The block passed to this method will be called just before running the
  # RDoc generator. It is allowed to modify RDoc::Task attributes inside the
  # block.
  def before_running_rdoc(&block); end

  # Ensures that +names+ only includes names for the :rdoc, :clobber_rdoc and
  # :rerdoc.  If other names are given an ArgumentError is raised.
  def check_names(names); end

  # Task description for the clobber rdoc task or its renamed equivalent
  def clobber_task_description; end

  # Task description for the coverage task or its renamed description
  def coverage_task_description; end

  # Sets default task values
  def defaults; end

  # Create the tasks defined by this task lib.
  def define; end

  # Whether to run the rdoc process as an external shell (default is false)
  def external; end

  # Whether to run the rdoc process as an external shell (default is false)
  def external=(_arg0); end

  # Name of format generator (<tt>--format</tt>) used by rdoc. (defaults to
  # rdoc's default)
  def generator; end

  # Name of format generator (<tt>--format</tt>) used by rdoc. (defaults to
  # rdoc's default)
  def generator=(_arg0); end

  # All source is inline now.  This method is deprecated
  def inline_source; end

  # All source is inline now.  This method is deprecated
  def inline_source=(value); end

  # Name of file to be used as the main, top level file of the RDoc. (default
  # is none)
  def main; end

  # Name of file to be used as the main, top level file of the RDoc. (default
  # is none)
  def main=(_arg0); end

  # Comment markup format.  rdoc, rd and tomdoc are supported.  (default is
  # 'rdoc')
  def markup; end

  # Comment markup format.  rdoc, rd and tomdoc are supported.  (default is
  # 'rdoc')
  def markup=(_arg0); end

  # Name of the main, top level task.  (default is :rdoc)
  def name; end

  # Name of the main, top level task.  (default is :rdoc)
  def name=(_arg0); end

  # List of options that will be supplied to RDoc
  def option_list; end

  # Additional list of options to be passed rdoc.  (default is [])
  def options; end

  # Additional list of options to be passed rdoc.  (default is [])
  def options=(_arg0); end

  # Name of directory to receive the html output files. (default is "html")
  def rdoc_dir; end

  # Name of directory to receive the html output files. (default is "html")
  def rdoc_dir=(_arg0); end

  # List of files to be included in the rdoc generation. (default is [])
  def rdoc_files; end

  # List of files to be included in the rdoc generation. (default is [])
  def rdoc_files=(_arg0); end

  # Task description for the rdoc task or its renamed equivalent
  def rdoc_task_description; end

  # Task description for the rerdoc task or its renamed description
  def rerdoc_task_description; end

  # Name of template to be used by rdoc. (defaults to rdoc's default)
  def template; end

  # Name of template to be used by rdoc. (defaults to rdoc's default)
  def template=(_arg0); end

  # Title of RDoc documentation. (defaults to rdoc's default)
  def title; end

  # Title of RDoc documentation. (defaults to rdoc's default)
  def title=(_arg0); end

  private

  def clobber_task_name; end
  def coverage_task_name; end
  def rdoc_target; end
  def rdoc_task_name; end
  def rerdoc_task_name; end
end

# Methods for manipulating comment text
module RDoc::Text
  # Expands tab characters in +text+ to eight spaces
  def expand_tabs(text); end

  # Flush +text+ left based on the shortest line
  def flush_left(text); end

  # The language for this text.  This affects stripping comments
  # markers.
  def language; end

  # The language for this text.  This affects stripping comments
  # markers.
  def language=(_arg0); end

  # Convert a string in markup format into HTML.
  #
  # Requires the including class to implement #formatter
  def markup(text); end

  # Strips hashes, expands tabs then flushes +text+ to the left
  def normalize_comment(text); end

  # Normalizes +text+ then builds a RDoc::Markup::Document from it
  def parse(text, format = T.unsafe(nil)); end

  # The first +limit+ characters of +text+ as HTML
  def snippet(text, limit = T.unsafe(nil)); end

  # Strips leading # characters from +text+
  def strip_hashes(text); end

  # Strips leading and trailing \n characters from +text+
  def strip_newlines(text); end

  # Strips /* */ style comments
  def strip_stars(text); end

  def to_html(text); end

  # Wraps +txt+ to +line_len+
  def wrap(txt, line_len = T.unsafe(nil)); end

  class << self
    # Transcodes +character+ to +encoding+ with a +fallback+ character.
    def encode_fallback(character, encoding, fallback); end
  end
end

# Character class to be separated by a space when concatenating
# lines.
RDoc::Text::SPACE_SEPARATED_LETTER_CLASS = T.let(T.unsafe(nil), Regexp)

# A TokenStream is a list of tokens, gathered during the parse of some entity
# (say a method). Entities populate these streams by being registered with the
# lexer. Any class can collect tokens by including TokenStream. From the
# outside, you use such an object by calling the start_collecting_tokens
# method, followed by calls to add_token and pop_token.
module RDoc::TokenStream
  # Adds one +token+ to the collected tokens
  def add_token(token); end

  # Adds +tokens+ to the collected tokens
  def add_tokens(tokens); end

  # Starts collecting tokens
  def collect_tokens; end

  # Remove the last token from the collected tokens
  def pop_token; end

  # Starts collecting tokens
  def start_collecting_tokens; end

  # Current token stream
  def token_stream; end

  # Returns a string representation of the token stream
  def tokens_to_s; end

  class << self
    # Converts +token_stream+ to HTML wrapping various tokens with
    # <tt><span></tt> elements. Some tokens types are wrapped in spans
    # with the given class names. Other token types are not wrapped in spans.
    def to_html(token_stream); end
  end
end

# A parser for TomDoc based on TomDoc 1.0.0-rc1 (02adef9b5a)
#
# The TomDoc specification can be found at:
#
# http://tomdoc.org
#
# The latest version of the TomDoc specification can be found at:
#
# https://github.com/mojombo/tomdoc/blob/master/tomdoc.md
#
# To choose TomDoc as your only default format see RDoc::Options@Saved+Options
# for instructions on setting up a <code>.rdoc_options</code> file to store
# your project default.
#
# There are a few differences between this parser and the specification.  A
# best-effort was made to follow the specification as closely as possible but
# some choices to deviate were made.
#
# A future version of RDoc will warn when a MUST or MUST NOT is violated and
# may warn when a SHOULD or SHOULD NOT is violated.  RDoc will always try
# to emit documentation even if given invalid TomDoc.
#
# Here are some implementation choices this parser currently makes:
#
# This parser allows rdoc-style inline markup but you should not depended on
# it.
#
# This parser allows a space between the comment and the method body.
#
# This parser does not require the default value to be described for an
# optional argument.
#
# This parser does not examine the order of sections.  An Examples section may
# precede the Arguments section.
#
# This class is documented in TomDoc format.  Since this is a subclass of the
# RDoc markup parser there isn't much to see here, unfortunately.
class RDoc::TomDoc < ::RDoc::Markup::Parser
  # Public: Creates a new TomDoc parser.  See also RDoc::Markup::parse
  #
  # @return [TomDoc] a new instance of TomDoc
  def initialize; end

  # Internal: Builds a heading from the token stream
  #
  # level - The level of heading to create
  #
  # Returns an RDoc::Markup::Heading
  def build_heading(level); end

  # Internal: Builds a paragraph from the token stream
  #
  # margin - Unused
  #
  # Returns an RDoc::Markup::Paragraph.
  def build_paragraph(margin); end

  # Internal: Builds a verbatim from the token stream.  A verbatim in the
  # Examples section will be marked as in Ruby format.
  #
  # margin - The indentation from the margin for lines that belong to this
  #          verbatim section.
  #
  # Returns an RDoc::Markup::Verbatim
  def build_verbatim(margin); end

  # Detects a section change to "Returns" and adds a heading
  def parse_text(parent, indent); end

  # Internal: Turns text into an Array of tokens
  #
  # text - A String containing TomDoc-format text.
  #
  # Returns self.
  def tokenize(text); end

  # Internal: Token accessor
  def tokens; end

  class << self
    # Internal: Adds a post-processor which sets the RDoc section based on the
    # comment's status.
    #
    # Returns nothing.
    def add_post_processor; end

    # Public: Parses TomDoc from text
    #
    # text - A String containing TomDoc-format text.
    #
    # Examples
    #
    #   RDoc::TomDoc.parse <<-TOMDOC
    #   This method does some things
    #
    #   Returns nothing.
    #   TOMDOC
    #   # => #<RDoc::Markup::Document:0xXXX @parts=[...], @file=nil>
    #
    # Returns an RDoc::Markup::Document representing the TomDoc format.
    def parse(text); end

    # Internal: Extracts the Signature section's method signature
    #
    # comment - An RDoc::Comment that will be parsed and have the signature
    #           extracted
    #
    # Returns a String containing the signature and nil if not
    def signature(comment); end
  end
end

# A TopLevel context is a representation of the contents of a single file
class RDoc::TopLevel < ::RDoc::Context
  # Creates a new TopLevel for the file at +absolute_name+.  If documentation
  # is being generated outside the source dir +relative_name+ is relative to
  # the source directory.
  #
  # @return [TopLevel] a new instance of TopLevel
  def initialize(absolute_name, relative_name = T.unsafe(nil)); end

  # An RDoc::TopLevel is equal to another with the same relative_name
  def ==(other); end

  # Absolute name of this file
  def absolute_name; end

  # Absolute name of this file
  def absolute_name=(_arg0); end

  # Adds +an_alias+ to +Object+ instead of +self+.
  def add_alias(an_alias); end

  # Adds +constant+ to +Object+ instead of +self+.
  def add_constant(constant); end

  # Adds +include+ to +Object+ instead of +self+.
  def add_include(include); end

  # Adds +method+ to +Object+ instead of +self+.
  def add_method(method); end

  # Adds class or module +mod+. Used in the building phase
  # by the Ruby parser.
  def add_to_classes_or_modules(mod); end

  # Base name of this file
  def base_name; end

  # All the classes or modules that were declared in
  # this file. These are assigned to either +#classes_hash+
  # or +#modules_hash+ once we know what they really are.
  def classes_or_modules; end

  # Returns a URL for this source file on some web repository.  Use the -W
  # command line option to set.
  def cvs_url; end

  def diagram; end
  def diagram=(_arg0); end

  # Only a TopLevel that contains text file) will be displayed.  See also
  # RDoc::CodeObject#display?
  #
  # @return [Boolean]
  def display?; end

  # An RDoc::TopLevel is equal to another with the same relative_name
  def eql?(other); end

  # This TopLevel's File::Stat struct
  def file_stat; end

  # This TopLevel's File::Stat struct
  def file_stat=(_arg0); end

  # See RDoc::TopLevel::find_class_or_module
  # --
  # TODO Why do we search through all classes/modules found, not just the
  #       ones of this instance?
  def find_class_or_module(name); end

  # Finds a class or module named +symbol+
  def find_local_symbol(symbol); end

  # Finds a module or class with +name+
  def find_module_named(name); end

  # Returns the relative name of this file
  def full_name; end

  # An RDoc::TopLevel has the same hash as another with the same
  # relative_name
  def hash; end

  # URL for this with a +prefix+
  def http_url(prefix); end

  def inspect; end

  # Time this file was last modified, if known
  def last_modified; end

  # Dumps this TopLevel for use by ri.  See also #marshal_load
  def marshal_dump; end

  # Loads this TopLevel from +array+.
  def marshal_load(array); end

  # Base name of this file
  def name; end

  # Returns the NormalClass "Object", creating it if not found.
  #
  # Records +self+ as a location in "Object".
  def object_class; end

  # Base name of this file without the extension
  def page_name; end

  # The parser class that processed this file
  def parser; end

  # Sets the parser for this toplevel context, also the store.
  def parser=(val); end

  # Path to this file for use with HTML generator output.
  def path; end

  def pretty_print(q); end

  # Relative name of this file
  def relative_name; end

  # Relative name of this file
  def relative_name=(_arg0); end

  # Search record used by RDoc::Generator::JsonIndex
  def search_record; end

  # Is this TopLevel from a text file instead of a source code file?
  #
  # @return [Boolean]
  def text?; end

  def to_s; end
end

# :stopdoc:
module Rake
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
end

# For backwards compatibility
Rake::RDocTask = RDoc::Task
