# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `jbuilder` gem.
# Please instead update this file by running `bin/tapioca gem jbuilder`.

class Jbuilder < ::ActiveSupport::ProxyObject
  def initialize(options = T.unsafe(nil)); end

  def array!(collection = T.unsafe(nil), *attributes, &block); end
  def attributes!; end
  def call(object, *attributes, &block); end
  def child!; end
  def deep_format_keys!(value = T.unsafe(nil)); end
  def extract!(object, *attributes); end
  def ignore_nil!(value = T.unsafe(nil)); end
  def key_format!(*args); end
  def merge!(object); end
  def method_missing(*args, &block); end
  def nil!; end
  def null!; end
  def set!(key, value = T.unsafe(nil), *args, &block); end
  def target!; end

  private

  def _blank?(value = T.unsafe(nil)); end
  def _extract_hash_values(object, attributes); end
  def _extract_method_values(object, attributes); end
  def _format_keys(hash_or_array); end
  def _is_collection?(object); end
  def _key(key); end
  def _map_collection(collection); end
  def _merge_block(key); end
  def _merge_values(current_value, updates); end
  def _object_respond_to?(object, *methods); end
  def _scope; end
  def _set_value(key, value); end

  class << self
    def deep_format_keys(value = T.unsafe(nil)); end
    def encode(*args, &block); end
    def ignore_nil(value = T.unsafe(nil)); end
    def key_format(*args); end
  end
end

class Jbuilder::ArrayError < ::StandardError
  class << self
    def build(key); end
  end
end

Jbuilder::BLANK = T.let(T.unsafe(nil), Jbuilder::Blank)

class Jbuilder::Blank
  def ==(other); end
  def empty?; end
end

module Jbuilder::CollectionRenderable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Jbuilder::CollectionRenderable::ClassMethods

  private

  def build_rendered_collection(templates, _spacer); end
  def build_rendered_template(content, template, layout = T.unsafe(nil)); end
  def json; end
end

module Jbuilder::CollectionRenderable::ClassMethods
  def supported?; end
end

class Jbuilder::CollectionRenderable::ScopedIterator < ::SimpleDelegator
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  def initialize(obj, scope); end

  def each; end
  def each_with_info; end
end

class Jbuilder::CollectionRenderer < ::ActionView::CollectionRenderer
  include ::Jbuilder::CollectionRenderable
  extend ::Jbuilder::CollectionRenderable::ClassMethods

  def initialize(lookup_context, options, &scope); end

  private

  def collection_with_template(view, template, layout, collection); end
end

class Jbuilder::KeyFormatter
  def initialize(*args); end

  def format(key); end

  private

  def initialize_copy(original); end
end

class Jbuilder::MergeError < ::StandardError
  class << self
    def build(current_value, updates); end
  end
end

Jbuilder::NON_ENUMERABLES = T.let(T.unsafe(nil), Set)

class Jbuilder::NullError < ::NoMethodError
  class << self
    def build(key); end
  end
end

class Jbuilder::Railtie < ::Rails::Railtie; end

class JbuilderHandler
  def default_format; end
  def default_format=(val); end

  class << self
    def call(template, source = T.unsafe(nil)); end
    def default_format; end
    def default_format=(val); end
  end
end

class JbuilderTemplate < ::Jbuilder
  def initialize(context, *args); end

  def array!(collection = T.unsafe(nil), *args); end
  def cache!(key = T.unsafe(nil), options = T.unsafe(nil)); end
  def cache_if!(condition, *args, &block); end
  def cache_root!(key = T.unsafe(nil), options = T.unsafe(nil)); end
  def partial!(*args); end
  def set!(name, object = T.unsafe(nil), *args); end
  def target!; end

  private

  def _cache_fragment_for(key, options, &block); end
  def _cache_key(key, options); end
  def _fragment_name_with_digest(key, options); end
  def _is_active_model?(object); end
  def _partial_options?(options); end
  def _read_fragment_cache(key, options = T.unsafe(nil)); end
  def _render_active_model_partial(object); end
  def _render_explicit_partial(name_or_options, locals = T.unsafe(nil)); end
  def _render_partial(options); end
  def _render_partial_with_options(options); end
  def _set_inline_partial(name, object, options); end
  def _write_fragment_cache(key, options = T.unsafe(nil)); end

  class << self
    def template_lookup_options; end
    def template_lookup_options=(_arg0); end
  end
end
