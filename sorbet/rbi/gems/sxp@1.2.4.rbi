# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sxp` gem.
# Please instead update this file by running `bin/tapioca gem sxp`.

# Extensions for Ruby's `Array` class.
class Array
  include ::Enumerable

  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil), **options); end
end

# Extensions for Ruby's `BigDecimal` class.
class BigDecimal < ::Numeric
  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Float` class.
class Float < ::Numeric
  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Hash` class.
class Hash
  include ::Enumerable

  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Integer` class.
class Integer < ::Numeric
  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

Integer::GMP_VERSION = T.let(T.unsafe(nil), String)

# Extensions for Ruby's `Object` class.
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::MakeMakefile

  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype2?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(_arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = T.unsafe(nil)); end
  def inspect; end
  def language; end
  def language=(_arg0); end
  def language?; end
  def literal?; end
  def object; end
  def plain?; end
  def simple?; end
  def squish(*other_string); end
  def squish!; end
  def to_s; end
  def to_sxp(**options); end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end

  protected

  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def datatype_map; end
    def datatyped_class(uri); end
    def inherited(child); end
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

class RDF::Literal::Double < ::RDF::Literal::Numeric
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def abs; end
  def canonicalize!; end
  def ceil; end
  def finite?; end
  def floor; end
  def infinite?; end
  def nan?; end
  def nonzero?; end
  def round; end
  def to_s; end
  def to_sxp(**options); end
  def zero?; end
end

class RDF::Node
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(id = T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def anonymous?; end
  def dup; end
  def eql?(other); end
  def hash; end
  def id; end
  def id=(_arg0); end
  def labeled?; end
  def make_unique!; end
  def node?; end
  def original; end
  def original=(_arg0); end
  def to_s; end
  def to_sxp(**options); end
  def to_sym; end
  def to_unique_base; end
  def unlabeled?; end

  class << self
    def cache; end
    def intern(id); end
    def uuid(format: T.unsafe(nil)); end
  end
end

class RDF::Query
  include ::Enumerable
  include ::RDF::Countable

  def initialize(*patterns, solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), validate: T.unsafe(nil), **options, &block); end

  def +(other); end
  def <<(pattern); end
  def ==(other); end
  def apply_graph_name(graph_name = T.unsafe(nil)); end
  def bind(solution); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def executable?; end
  def execute(queryable, bindings: T.unsafe(nil), solutions: T.unsafe(nil), graph_name: T.unsafe(nil), name: T.unsafe(nil), **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(_arg0); end
  def has_blank_nodes?; end
  def has_variables?(*args); end
  def matched?; end
  def named?; end
  def ndvars; end
  def node?; end
  def optimize(**options); end
  def optimize!(**options); end
  def optimize_without_expression!(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def query_yields_boolean?; end
  def query_yields_solutions?; end
  def query_yields_statements?; end
  def rewrite(&block); end
  def solutions; end
  def to_sparql(top_level: T.unsafe(nil), filter_ops: T.unsafe(nil), **options); end
  def to_sxp(**options); end
  def to_sxp_bin; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?(*args); end
  def variable_count; end
  def variables; end
  def variables?(*args); end
  def vars; end

  protected

  def compile_hash_patterns(hash_patterns); end

  class << self
    def Solutions(*args); end
    def execute(queryable, patterns = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class RDF::Query::Pattern < ::RDF::Statement
  def initialize(subject = T.unsafe(nil), predicate = T.unsafe(nil), object = T.unsafe(nil), options = T.unsafe(nil)); end

  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(_arg0); end
  def dup; end
  def eql?(other); end
  def executable?; end
  def execute(queryable, bindings = T.unsafe(nil), &block); end
  def has_variables?; end
  def initialize!; end
  def ndvars; end
  def optional?; end
  def options; end
  def solution(statement); end
  def to_s; end
  def to_sxp(**options); end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def var_values(var, statement); end
  def variable_count; end
  def variable_terms(name = T.unsafe(nil)); end
  def variables; end
  def variables?; end
  def vars; end

  class << self
    def from(pattern, graph_name: T.unsafe(nil), **options); end
  end
end

class RDF::Query::Variable
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger

  def initialize(name = T.unsafe(nil), value = T.unsafe(nil), distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end

  def ==(other); end
  def ===(other); end
  def bind(value); end
  def bind!(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def evaluate(bindings, **options); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def name; end
  def name=(_arg0); end
  def named?; end
  def optimize(**options); end
  def to_base; end
  def to_h; end
  def to_s; end
  def to_sparql(**options); end
  def to_sxp(**options); end
  def to_sym; end
  def unbind; end
  def unbind!; end
  def unbound?; end
  def value; end
  def value=(_arg0); end
  def var_values(var, term); end
  def variable?(*args); end
  def variables; end
end

class RDF::URI
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression
  include ::RDF::Term

  def initialize(*args, validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def +(other); end
  def /(fragment); end
  def ==(other); end
  def ===(other); end
  def =~(pattern); end
  def _dump(level); end
  def absolute?; end
  def authority; end
  def authority=(value); end
  def canonicalize; end
  def canonicalize!; end
  def dup; end
  def end_with?(string); end
  def ends_with?(string); end
  def eql?(other); end
  def fragment; end
  def fragment=(value); end
  def freeze; end
  def has_parent?; end
  def hash; end
  def hier?; end
  def host; end
  def host=(value); end
  def inspect; end
  def join(*uris); end
  def length; end
  def lexical; end
  def lexical=(value); end
  def normalize; end
  def normalize!; end
  def normalized_authority; end
  def normalized_fragment; end
  def normalized_host; end
  def normalized_password; end
  def normalized_path; end
  def normalized_port; end
  def normalized_query; end
  def normalized_scheme; end
  def normalized_user; end
  def normalized_userinfo; end
  def object; end
  def parent; end
  def parent?; end
  def parse(value); end
  def password; end
  def password=(value); end
  def path; end
  def path=(value); end
  def pname(prefixes: T.unsafe(nil)); end
  def port; end
  def port=(value); end
  def qname(prefixes: T.unsafe(nil)); end
  def query; end
  def query=(value); end
  def query_values(return_type = T.unsafe(nil)); end
  def query_values=(value); end
  def relative?; end
  def relativize(base_uri); end
  def request_uri; end
  def root; end
  def root?; end
  def scheme; end
  def scheme=(value); end
  def size; end
  def to_h; end
  def to_s; end
  def to_str; end
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil), **options); end
  def to_uri; end
  def uri?; end
  def url?; end
  def urn?; end
  def user; end
  def user=(value); end
  def userinfo; end
  def userinfo=(value); end
  def valid?; end
  def validate!; end
  def value; end

  private

  def format_authority; end
  def format_userinfo(append = T.unsafe(nil)); end
  def normalize_segment(value, expr, downcase = T.unsafe(nil)); end

  class << self
    def _load(data); end
    def cache; end
    def decode(str); end
    def encode(str, expr); end
    def intern(str, *args, **options); end
    def normalize_path(path); end
    def parse(str); end
  end
end

# Extensions for Ruby's `Regexp` class.
class Regexp
  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

class Regexp::TimeoutError < ::RegexpError; end

module SXP
  class << self
    # Reads one S-expression from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}]
    # @return [Object]
    def parse(input, **options); end

    # Reads all S-expressions from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def parse_all(input, **options); end

    # Reads all S-expressions from a given input file.
    #
    # @param filename [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def parse_file(filename, **options); end

    # Reads all S-expressions from the given input files.
    #
    # @overload read_files
    # @overload read_files
    # @return [Enumerable<Object>]
    def parse_files(*filenames); end

    # Reads all S-expressions from a given input URL using the HTTP or FTP
    # protocols.
    #
    # @deprecated
    # @param url [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def parse_uri(url, **options); end

    # Reads all S-expressions from a given input URL using the HTTP or FTP
    # protocols.
    #
    # @param url [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def parse_url(url, **options); end

    # Reads one S-expression from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}]
    # @return [Object]
    def read(input, **options); end

    # Reads all S-expressions from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def read_all(input, **options); end

    # Reads all S-expressions from a given input file.
    #
    # @param filename [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def read_file(filename, **options); end

    # Reads all S-expressions from the given input files.
    #
    # @overload read_files
    # @overload read_files
    # @return [Enumerable<Object>]
    def read_files(*filenames); end

    # Reads all S-expressions from a given input URL using the HTTP or FTP
    # protocols.
    #
    # @deprecated
    # @param url [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def read_uri(url, **options); end

    # Reads all S-expressions from a given input URL using the HTTP or FTP
    # protocols.
    #
    # @param url [String, #to_s]
    # @param options [Hash{Symbol => Object}]
    # @return [Enumerable<Object>]
    def read_url(url, **options); end

    # Write an internal S-Expression as a formatted SXP
    #
    # @param[Array<Object>] sxp
    # @param[#write] output
    def write(sxp, output = T.unsafe(nil)); end
  end
end

# An S-expression generator.
#
# Takes an object and pretty-prints it using reasonable indentation rules
class SXP::Generator
  # Initialize output with a stack of IO buffers
  #
  # @param buffer [#write]
  # @return [Generator] a new instance of Generator
  def initialize(buffer); end

  # Render an element.
  # For Array, this recursively renders each constituent into blocks.
  # If the agregate length of a block is less than MIN_BLOCK characters,
  # combine each constituent block into a single line.
  #
  # Rendering does not perform final formatting, but returns a recursive
  # array of blocks which are each ultimattely formattted onto their
  # own line with leading whitespace.
  #
  # @param sexp [Object]
  # @return [Block]
  def render(sexp); end

  class << self
    # Format S-expressions to STDOUT
    #
    # @param sxps [Array]
    # @return [Object]
    def print(*sxps); end

    # Format S-expressions to a String
    #
    # @param sxps [Array]
    # @return [Object]
    def string(*sxps); end

    # Write formatted S-expressions to an IO like object
    #
    # @param out [Object]
    # @param sxps [Array]
    # @return [Object]
    def write(out, *sxps); end
  end
end

# A basic block containing constituent
# objects, either blocks or strings.
class SXP::Generator::Block
  # @param obj [Object]
  # @param indent [Integer]
  # @param prefixes [Hash{Symbol => RDF::URI}] (nil)
  # @param base_uri [RDF::URI] (nil)
  # @return [Block] a new instance of Block
  def initialize(obj, indent, prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end

  # Format block
  #
  # @return [String]
  def formatted; end

  # @attr amount [Integer] of indent applied to this block
  def indent; end

  # Aggregate length over each element accounting for spaces
  #
  # @return [Integer] If indent is not not nil, returns zero
  def length; end

  # Determins if this block is an SXP, or not
  #
  # @return [Boolean]
  def sxp?; end

  # Turn block into a string in S-expression form
  # This should only be called on a block when
  # no indentation is to be applied
  #
  # @return [String]
  def to_sxp(prefixes: T.unsafe(nil), base_uri: T.unsafe(nil)); end

  private

  def do_indent(offset = T.unsafe(nil)); end
end

SXP::Generator::Block::BLOCK_MIN_LENGTH = T.let(T.unsafe(nil), Integer)

# A singly-linked list.
class SXP::List < ::SXP::Pair
  include ::Enumerable

  # @param elements [Array]
  # @return [List] a new instance of List
  # @yield [list]
  # @yieldparam list [List]
  def initialize(elements = T.unsafe(nil), &block); end

  # @param other [Object]
  # @return [Object]
  def &(other); end

  # @param times [Object]
  # @return [Object]
  def *(times); end

  # @param other [Object]
  # @return [Object]
  def +(other); end

  # @param other [Object]
  # @return [Object]
  def -(other); end

  # @param object [Object]
  # @return [Object]
  def <<(object); end

  # @param other [Object]
  # @return [Object]
  def <=>(other); end

  # @param other [Object]
  # @return [Object]
  def ==(other); end

  # @param args [Array]
  # @return [Object]
  def [](*args); end

  # @param args [Array]
  # @raise [NotImplementedError]
  # @return [Object]
  def []=(*args); end

  # @param object [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  def assoc(object); end

  # @param index [Integer]
  # @return [Object]
  def at(index); end

  # @return [Object]
  def clear; end

  # @raise [NotImplementedError]
  # @return [Object]
  def collect!(&block); end

  # @return [Object]
  def compact; end

  # @raise [NotImplementedError]
  # @return [Object]
  def compact!; end

  # @param other [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  def concat(other); end

  # @param object [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  def delete(object, &block); end

  # @param index [Integer]
  # @raise [NotImplementedError]
  # @return [Object]
  def delete_at(index); end

  # @raise [NotImplementedError]
  # @return [Object]
  def delete_if(&block); end

  # @return [Enumerator]
  def each(&block); end

  # @return [Enumerator]
  def each_index(&block); end

  # @return [Boolean]
  def empty?; end

  # @param other [Object]
  # @return [Boolean]
  def eql?(other); end

  # @param args [Array]
  # @return [Object]
  def fetch(*args, &block); end

  # @param args [Array]
  # @raise [NotImplementedError]
  # @return [Object]
  def fill(*args, &block); end

  # @param count [Integer]
  # @return [Object]
  def first(count = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  # @return [Object]
  def flatten; end

  # @raise [NotImplementedError]
  # @return [Object]
  def flatten!; end

  # @return [Object]
  def head; end

  # @param object [Object]
  # @return [Object]
  def include?(object); end

  # @param object [Object]
  # @return [Object]
  def index(object); end

  # @param index [Integer]
  # @param objects [Array]
  # @raise [NotImplementedError]
  # @return [Object]
  def insert(index, *objects); end

  # @return [String]
  def inspect; end

  # @param separator [String]
  # @return [Object]
  def join(separator = T.unsafe(nil)); end

  # @param count [Integer]
  # @return [Object]
  def last(count = T.unsafe(nil)); end

  # @return [Integer]
  def length; end

  # @return [Object]
  def map!(&block); end

  # @return [Integer]
  def nitems; end

  # @param template [Object]
  # @return [Object]
  def pack(template); end

  # @raise [NotImplementedError]
  # @return [Object]
  def pop; end

  # @param objects [Array]
  # @raise [NotImplementedError]
  # @return [Object]
  def push(*objects); end

  # @param key [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  def rassoc(key); end

  # @raise [NotImplementedError]
  # @return [Object]
  def reject!(&block); end

  # @param other_list [Object]
  # @return [Object]
  def replace(other_list); end

  # @return [Object]
  def rest; end

  # @return [Object]
  def reverse; end

  # @raise [NotImplementedError]
  # @return [Object]
  def reverse!; end

  # @return [Object]
  def reverse_each(&block); end

  # @param object [Object]
  # @return [Object]
  def rindex(object); end

  # @raise [NotImplementedError]
  # @return [Object]
  def shift; end

  # @return [Integer]
  def size; end

  # @param args [Array]
  # @return [Object]
  def slice(*args); end

  # @param args [Array]
  # @raise [NotImplementedError]
  # @return [Object]
  def slice!(*args); end

  # @return [Object]
  def sort(&block); end

  # @raise [NotImplementedError]
  # @return [Object]
  def sort!; end

  # @return [Object]
  def tail; end

  # @return [List]
  def to_list; end

  # @return [Pair]
  def to_pair; end

  # @return [String]
  def to_s; end

  # @return [Object]
  def transpose; end

  # @return [Object]
  def uniq; end

  # @raise [NotImplementedError]
  # @return [Object]
  def uniq!; end

  # @param objects [Array]
  # @return [Object]
  def unshift(*objects); end

  # @param selector [Array]
  # @return [Object]
  def values_at(*selector); end

  # @param other [Object]
  # @return [Object]
  def |(other); end

  class << self
    # @param elements [Array]
    # @return [Object]
    def [](*elements); end
  end
end

class SXP::Pair
  # @param head [Object]
  # @param tail [Object]
  # @return [Pair] a new instance of Pair
  def initialize(head = T.unsafe(nil), tail = T.unsafe(nil)); end

  # Returns `true` if the tail of this pair is not `nil` or another pair.
  #
  # @return [Boolean]
  # @see https:/srfi.schemers.org/srfi-1/srfi-1.html#ImproperLists
  def dotted?; end

  # Returns `true` if the head and tail of this pair are both `nil`.
  #
  # @return [Boolean]
  def empty?; end

  # @return [Object]
  def head; end

  # @return [Object]
  def head=(_arg0); end

  # Returns a developer-friendly representation of this pair.
  #
  # @return [String]
  def inspect; end

  # Returns `true` if the tail of this pair is `nil` or another pair.
  #
  # @return [Boolean]
  # @see https:/srfi.schemers.org/srfi-1/srfi-1.html#ImproperLists
  def proper?; end

  # @return [Object]
  def tail; end

  # @return [Object]
  def tail=(_arg0); end

  # Returns an array representation of this pair.
  #
  # @return [Array]
  def to_a; end
end

# The base class for S-expression parsers.
class SXP::Reader
  include ::Enumerable

  # Initializes the reader.
  #
  # @param input [IO, StringIO, String]
  # @param options [Hash{Symbol => Object}]
  # @return [Reader] a new instance of Reader
  def initialize(input, **options, &block); end

  # @return [Enumerator]
  # @yield [object]
  # @yieldparam object [Object]
  def each(&block); end

  # @return [Object]
  def input; end

  # @return [Hash]
  def options; end

  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => Object}]
  # @return [Object]
  def read(eof: T.unsafe(nil), eol: T.unsafe(nil), list_term: T.unsafe(nil), **options); end

  # @param options [Hash{Symbol => Object}] See {#read}
  # @return [Array]
  def read_all(**options); end

  # @raise [NotImplementedError]
  # @return [Object]
  def read_atom; end

  # @raise [NotImplementedError]
  # @return [String]
  def read_character; end

  # Reads all S-expressions from the given input files.
  #
  # @overload read_files
  # @overload read_files
  # @return [Enumerable<Object>]
  def read_files(*filenames); end

  # @param base [Integer]
  # @return [Integer]
  def read_integer(base = T.unsafe(nil)); end

  # @param list_term [String] (nil)
  #   String expected to terminate the list
  # @return [Array]
  def read_list(list_term = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  # @return [String]
  def read_literal; end

  # @raise [NotImplementedError]
  # @return [Object]
  def read_sharp; end

  # @raise [NotImplementedError]
  # @return [String]
  def read_string; end

  # @return [Object]
  def read_token; end

  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => Object}]
  # @return [Object]
  def skip(eof: T.unsafe(nil), eol: T.unsafe(nil), list_term: T.unsafe(nil), **options); end

  protected

  # @return [Boolean]
  def eof?; end

  # @return [String]
  def peek_char; end

  # @raise [EOF]
  # @return [String]
  def read_char; end

  # @param count [Integer]
  # @return [String]
  def read_chars(count = T.unsafe(nil)); end

  # @raise [EOF]
  # @return [String]
  def skip_char; end

  # @return [void]
  def skip_comments; end

  # @return [void]
  def skip_line; end

  # Unread the string, putting back into the input stream
  #
  # @param string [String]
  def unread(string); end

  class << self
    # Reads one S-expression from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}] See {#read}
    # @return [Object]
    def read(input, **options); end

    # Reads all S-expressions from the given input stream.
    #
    # @param input [IO, StringIO, String]
    # @param options [Hash{Symbol => Object}] See {#read}
    # @return [Enumerable<Object>]
    def read_all(input, **options); end

    # Reads all S-expressions from a given input file.
    #
    # @param filename [String, #to_s]
    # @param options [Hash{Symbol => Object}] See {#read}
    # @return [Enumerable<Object>]
    def read_file(filename, **options); end

    # Reads all S-expressions from a given input URL using the HTTP or FTP
    # protocols.
    #
    # @param url [String, #to_s]
    # @param options [Hash{Symbol => Object}] See {#read}
    # @return [Enumerable<Object>]
    def read_url(url, **options); end
  end
end

# A basic S-expression parser.
class SXP::Reader::Basic < ::SXP::Reader
  # @return [Object]
  def read_atom; end

  # @return [String]
  def read_character; end

  # @return [String]
  def read_literal; end

  # @return [String]
  def read_string; end

  # @return [Object]
  def read_token; end
end

SXP::Reader::Basic::ATOM = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::INTEGER = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::LPARENS = T.let(T.unsafe(nil), Array)
SXP::Reader::Basic::RATIONAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Basic::RPARENS = T.let(T.unsafe(nil), Array)

# A Common Lisp S-expressions parser.
#
# @see https:/www.cs.cmu.edu/Groups/AI/html/cltl/clm/node14.html
class SXP::Reader::CommonLisp < ::SXP::Reader::Basic
  # Initializes the reader.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param input [IO, StringIO, String]
  # @param options [Hash{Symbol => Object}]
  # @return [CommonLisp] a new instance of CommonLisp
  def initialize(input, **options, &block); end

  # Based on Basic#read_atom, but adds 't' and 'nil' atoms.
  #
  # @return [Object]
  def read_atom; end

  # Read characters sequences like `#\backspace`. Otherwise,
  # reads a single character. Requires the ability to put
  # eroneously read characters back in the input stream
  #
  # @return [String]
  # @see https:/www.cs.cmu.edu/Groups/AI/html/cltl/clm/node22.html
  def read_character; end

  # Reads `#'mapcar` forms.
  #
  # @return [Array]
  def read_function; end

  # Reads `'foobar` forms.
  #
  # @return [Array]
  def read_quote; end

  # @return [Object]
  def read_sharp; end

  # @return [Symbol]
  def read_symbol(delimiter = T.unsafe(nil)); end

  # @return [Object]
  def read_token; end

  # Reads `#(1 2 3)` forms.
  #
  # @return [Array]
  def read_vector; end

  # @return [void]
  def skip_comments; end
end

# Escape characters, used in the form `#\Backspace`. Case is treated
# insensitively
#
# @see https:/www.cs.cmu.edu/Groups/AI/html/cltl/clm/node22.html
SXP::Reader::CommonLisp::CHARACTERS = T.let(T.unsafe(nil), Hash)

SXP::Reader::CommonLisp::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_10 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_16 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_2 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::INTEGER_BASE_8 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::CommonLisp::OPTIONS = T.let(T.unsafe(nil), Hash)
SXP::Reader::CommonLisp::RATIONAL = T.let(T.unsafe(nil), Regexp)
class SXP::Reader::EOF < ::SXP::Reader::Error; end
class SXP::Reader::Error < ::StandardError; end

# An extended S-expression parser.
class SXP::Reader::Extended < ::SXP::Reader::Basic
  # @return [Object]
  def read_token; end

  # @return [void]
  def skip_comments; end
end

SXP::Reader::Extended::ATOM = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Extended::LPARENS = T.let(T.unsafe(nil), Array)
SXP::Reader::Extended::RPARENS = T.let(T.unsafe(nil), Array)

# A SPARQL Syntax Expressions (SSE) parser.
#
# Requires [RDF.rb](https:/rubygems.org/gems/rdf/).
#
# @see https:/openjena.org/wiki/SSE
class SXP::Reader::SPARQL < ::SXP::Reader::Extended
  # Initializes the reader.
  #
  # @param input [IO, StringIO, String]
  # @param options [Hash{Symbol => Object}]
  # @return [SPARQL] a new instance of SPARQL
  def initialize(input, **options, &block); end

  # Base URI as specified or when parsing parsing a BASE token using the immediately following
  # token, which must be a URI.
  def base_uri; end

  # Base URI as specified or when parsing parsing a BASE token using the immediately following
  # token, which must be a URI.
  def base_uri=(_arg0); end

  # Defines the given named URI prefix for this parser.
  #
  # @example Defining a URI prefix
  #   parser.prefix :dc, RDF::URI('http://purl.org/dc/terms/')
  # @example Returning a URI prefix
  #   parser.prefix(:dc)    #=> RDF::URI('http://purl.org/dc/terms/')
  # @param name [Symbol, #to_s]
  # @param uri [RDF::URI, #to_s]
  # @return [RDF::URI]
  def prefix(name, uri = T.unsafe(nil)); end

  # Prefixes defined while parsing
  #
  # @return [Hash{Object => RDF::URI}]
  def prefixes; end

  # Prefixes defined while parsing
  #
  # @return [Hash{Object => RDF::URI}]
  def prefixes=(_arg0); end

  # Reads an SSE Atom
  #
  # Atoms parsed including `base`, `prefix`, `true`, `false`, numeric, BNodes and variables.
  #
  # Creates `RDF::Literal`, `RDF::Node`, or `RDF::Query::Variable` instances where appropriate.
  #
  # @return [Object]
  def read_atom; end

  # Reads literals corresponding to SPARQL/Turtle/Notation-3 syntax
  #
  # @example
  #   "a plain literal"
  #   "a literal with a language"@en
  #   "a typed literal"^^<http://example/>
  #   "a typed literal with a PNAME"^^xsd:string
  # @return [RDF::Literal]
  def read_rdf_literal; end

  # Reads a URI in SPARQL/Turtle/Notation-3 syntax
  #
  # @example
  #   <http://example/>
  # @return [RDF::URI]
  def read_rdf_uri; end

  # Reads SSE Tokens, including `RDF::Literal`, `RDF::URI` and `RDF::Node`.
  #
  # Performs forward reference for prefix and base URI representations and saves in
  # {#base_uri} and {#prefixes} accessors.
  #
  # Transforms tokens matching a {PNAME} pattern into `RDF::URI` instances if a match is
  # found with a previously identified {PREFIX}.
  #
  # @return [Object]
  def read_token; end

  # @return [void]
  def skip_comments; end

  # Return variable allocated to an ID.
  # If no ID is provided, a new variable
  # is allocated. Otherwise, any previous assignment will be used.
  #
  # The variable has a #distinguished? method applied depending on if this
  # is a disinguished or non-distinguished variable. Non-distinguished
  # variables are effectively the same as BNodes.
  #
  # @return [RDF::Query::Variable]
  def variable(id, distinguished: T.unsafe(nil), existential: T.unsafe(nil)); end
end

# Alias for rdf:type
SXP::Reader::SPARQL::A = T.let(T.unsafe(nil), Regexp)

# Base token, causes next URI to be treated as the `base_uri` for further URI expansion
SXP::Reader::SPARQL::BASE = T.let(T.unsafe(nil), Regexp)

# BNode with identifier
SXP::Reader::SPARQL::BNODE_ID = T.let(T.unsafe(nil), Regexp)

# Anonymous BNode
SXP::Reader::SPARQL::BNODE_NEW = T.let(T.unsafe(nil), Regexp)

SXP::Reader::SPARQL::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::DOUBLE = T.let(T.unsafe(nil), Regexp)

# Distinguished existential variable
SXP::Reader::SPARQL::EVAR_ID = T.let(T.unsafe(nil), Regexp)

SXP::Reader::SPARQL::EXPONENT = T.let(T.unsafe(nil), Regexp)
SXP::Reader::SPARQL::FALSE = T.let(T.unsafe(nil), Regexp)

# Non-distinguished existential variable
SXP::Reader::SPARQL::ND_EVAR = T.let(T.unsafe(nil), Regexp)

# Non-distinguished variable
SXP::Reader::SPARQL::ND_VAR = T.let(T.unsafe(nil), Regexp)

SXP::Reader::SPARQL::NIL = T.let(T.unsafe(nil), Regexp)

# A QName, subject to expansion to URIs using {PREFIX}
SXP::Reader::SPARQL::PNAME = T.let(T.unsafe(nil), Regexp)

# Prefix token, causes following prefix and URI pairs to be used for transforming
# {PNAME} tokens into URIs.
SXP::Reader::SPARQL::PREFIX = T.let(T.unsafe(nil), Regexp)

SXP::Reader::SPARQL::RDF_TYPE = T.let(T.unsafe(nil), RDF::URI)
SXP::Reader::SPARQL::TRUE = T.let(T.unsafe(nil), Regexp)

# Distinguished variable
SXP::Reader::SPARQL::VAR_ID = T.let(T.unsafe(nil), Regexp)

# A Scheme R4RS S-expressions parser.
#
# @see https:/people.csail.mit.edu/jaffer/r4rs_9.html#SEC65
class SXP::Reader::Scheme < ::SXP::Reader::Extended
  # Initializes the reader.
  #
  # @option options
  # @param input [IO, StringIO, String]
  # @param options [Hash{Symbol => Object}]
  # @return [Scheme] a new instance of Scheme
  def initialize(input, version: T.unsafe(nil), **options, &block); end

  # @return [Object]
  def read_atom; end

  # Read characters sequences like `#\space`. Otherwise,
  # reads a single character. Requires the ability to put
  # eroneously read characters back in the input stream
  #
  # @return [String]
  # @see https:/people.csail.mit.edu/jaffer/r4rs_9.html#SEC65
  def read_character; end

  # @return [Object]
  def read_sharp; end

  # @return [Object]
  def read_token; end
end

# Escape characters, used in the form `#\newline`. Case is treated
# insensitively
#
# @see https:/people.csail.mit.edu/jaffer/r4rs_9.html#SEC65
SXP::Reader::Scheme::CHARACTERS = T.let(T.unsafe(nil), Hash)

SXP::Reader::Scheme::DECIMAL = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_10 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_16 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_2 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::INTEGER_BASE_8 = T.let(T.unsafe(nil), Regexp)
SXP::Reader::Scheme::RATIONAL = T.let(T.unsafe(nil), Regexp)

module SXP::VERSION
  class << self
    # @return [Array(Integer, Integer, Integer)]
    def to_a; end

    # @return [String]
    def to_s; end

    # @return [String]
    def to_str; end
  end
end

SXP::VERSION::EXTRA = T.let(T.unsafe(nil), T.untyped)
SXP::VERSION::MAJOR = T.let(T.unsafe(nil), String)
SXP::VERSION::MINOR = T.let(T.unsafe(nil), String)
SXP::VERSION::STRING = T.let(T.unsafe(nil), String)
SXP::VERSION::TINY = T.let(T.unsafe(nil), String)
SXP::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

# Extensions for Ruby's `String` class.
class String
  include ::Comparable

  # Returns the SXP representation of this object. Uses SPARQL-like escaping.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Symbol` class.
class Symbol
  include ::Comparable

  # Returns `true` if this is a keyword symbol.
  #
  # @return [Boolean]
  def keyword?; end

  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Time` class.
class Time
  include ::Comparable

  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end

# Extensions for Ruby's `Vector` class.
class Vector
  # Returns the SXP representation of this object.
  #
  # @return [String]
  def to_sxp(**options); end
end
