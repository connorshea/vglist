# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rspec_rails` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rspec_rails`.

# FIXME: This is a workaround for the following issue:
# https://github.com/rubocop/rubocop-rspec_rails/issues/8
module RuboCop; end

module RuboCop::Cop; end
module RuboCop::Cop::RSpecRails; end

# Checks that tests use RSpec `before` hook over Rails `setup` method.
#
# @example
#   # bad
#   setup do
#   allow(foo).to receive(:bar)
#   end
#
#   # good
#   before do
#   allow(foo).to receive(:bar)
#   end
class RuboCop::Cop::RSpecRails::AvoidSetupHook < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def setup_call(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpecRails::AvoidSetupHook::MSG = T.let(T.unsafe(nil), String)

# Checks that tests use `have_http_status` instead of equality matchers.
#
# @example ResponseMethods: ['response', 'last_response'] (default)
#   # bad
#   expect(response.status).to be(200)
#   expect(last_response.code).to eq("200")
#
#   # good
#   expect(response).to have_http_status(200)
#   expect(last_response).to have_http_status(200)
# @example ResponseMethods: ['foo_response']
#   # bad
#   expect(foo_response.status).to be(200)
#
#   # good
#   expect(foo_response).to have_http_status(200)
#
#   # also good
#   expect(response).to have_http_status(200)
#   expect(last_response).to have_http_status(200)
class RuboCop::Cop::RSpecRails::HaveHttpStatus < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def match_status(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def response_methods; end

  # @return [Boolean]
  def response_methods?(name); end
end

RuboCop::Cop::RSpecRails::HaveHttpStatus::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpecRails::HaveHttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)
RuboCop::Cop::RSpecRails::HaveHttpStatus::RUNNERS = T.let(T.unsafe(nil), Set)

# Enforces use of symbolic or numeric value to describe HTTP status.
#
# This cop inspects only `have_http_status` calls.
# So, this cop does not check if a method starting with `be_*` is used
# when setting for `EnforcedStyle: symbolic` or
# `EnforcedStyle: numeric`.
#
# @example `EnforcedStyle: symbolic` (default)
#   # bad
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status "403" }
#
#   # good
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status :forbidden }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: numeric`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status "forbidden" }
#
#   # good
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status 403 }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: be_status`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status "forbidden" }
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status "403" }
#
#   # good
#   it { is_expected.to be_ok }
#   it { is_expected.to be_not_found }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
class RuboCop::Cop::RSpecRails::HttpStatus < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def http_status(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def checker_class; end
end

class RuboCop::Cop::RSpecRails::HttpStatus::BeStatusStyleChecker < ::RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase
  def offense_range; end

  # @return [Boolean]
  def offensive?; end

  def prefer; end

  private

  def normalize_str; end
  def number; end
  def symbol; end
end

class RuboCop::Cop::RSpecRails::HttpStatus::NumericStyleChecker < ::RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase
  # @return [Boolean]
  def offensive?; end

  def prefer; end

  private

  def number; end
  def symbol; end
end

RuboCop::Cop::RSpecRails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase
  # @return [StyleCheckerBase] a new instance of StyleCheckerBase
  def initialize(node); end

  # @return [Boolean]
  def allowed_symbol?; end

  def current; end

  # @return [Boolean]
  def custom_http_status_code?; end

  def message; end

  # Returns the value of attribute node.
  def node; end

  def offense_range; end
end

RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase::ALLOWED_STATUSES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::RSpecRails::HttpStatus::SymbolicStyleChecker < ::RuboCop::Cop::RSpecRails::HttpStatus::StyleCheckerBase
  # @return [Boolean]
  def offensive?; end

  def prefer; end

  private

  def number; end
  def symbol; end
end

# Identifies redundant spec type.
#
# After setting up rspec-rails, you will have enabled
# `config.infer_spec_type_from_file_location!` by default in
# spec/rails_helper.rb. This cop works in conjunction with this config.
# If you disable this config, disable this cop as well.
#
# @example
#   # bad
#   # spec/models/user_spec.rb
#   RSpec.describe User, type: :model do
#   end
#
#   # good
#   # spec/models/user_spec.rb
#   RSpec.describe User do
#   end
#
#   # good
#   # spec/models/user_spec.rb
#   RSpec.describe User, type: :common do
#   end
# @example `Inferences` configuration
#   # .rubocop.yml
#   # RSpecRails/InferredSpecType:
#   #   Inferences:
#   #     services: service
#
#   # bad
#   # spec/services/user_spec.rb
#   RSpec.describe User, type: :service do
#   end
#
#   # good
#   # spec/services/user_spec.rb
#   RSpec.describe User do
#   end
#
#   # good
#   # spec/services/user_spec.rb
#   RSpec.describe User, type: :common do
#   end
class RuboCop::Cop::RSpecRails::InferredSpecType < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # @param node [RuboCop::AST::BlockNode]
  # @return [RuboCop::AST::PairNode, nil]
  def describe_with_type(param0 = T.unsafe(nil)); end

  # @param node [RuboCop::AST::BlockNode]
  def on_block(node); end

  # @param node [RuboCop::AST::BlockNode]
  def on_numblock(node); end

  private

  # @param corrector [RuboCop::AST::Corrector]
  # @param node [RuboCop::AST::Node]
  def autocorrect(corrector, node); end

  # @param node [RuboCop::AST::PairNode]
  # @return [RuboCop::AST::Node]
  def detect_removable_node(node); end

  # @return [String]
  def file_path; end

  # @return [Hash]
  def inferences; end

  # @param node [RuboCop::AST::PairNode]
  # @return [Boolean]
  def inferred_type?(node); end

  # @return [Symbol, nil]
  def inferred_type_from_file_path; end

  # @param node [RuboCop::AST::Node]
  # @return [Parser::Source::Range]
  def remove_range(node); end
end

RuboCop::Cop::RSpecRails::InferredSpecType::MSG = T.let(T.unsafe(nil), String)

# Check if using Minitest-like matchers.
#
# Check the use of minitest-like matchers
# starting with `assert_` or `refute_`.
#
# @example
#   # bad
#   assert_equal(a, b)
#   assert_equal a, b, "must be equal"
#   assert_not_includes a, b
#   refute_equal(a, b)
#   assert_nil a
#   refute_empty(b)
#   assert_true(a)
#   assert_false(a)
#
#   # good
#   expect(b).to eq(a)
#   expect(b).to(eq(a), "must be equal")
#   expect(a).not_to include(b)
#   expect(b).not_to eq(a)
#   expect(a).to eq(nil)
#   expect(a).not_to be_empty
#   expect(a).to be(true)
#   expect(a).to be(false)
class RuboCop::Cop::RSpecRails::MinitestAssertions < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def message(preferred); end
  def on_assertion(node, assertion); end
  def on_send(node); end
end

# TODO: replace with `BasicAssertion.subclasses` in Ruby 3.1+
RuboCop::Cop::RSpecRails::MinitestAssertions::ASSERTION_MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [BasicAssertion] a new instance of BasicAssertion
  def initialize(expected, actual, failure_message); end

  # Returns the value of attribute actual.
  def actual; end

  # @raise [NotImplementedError]
  def assertion; end

  # Returns the value of attribute expected.
  def expected; end

  # Returns the value of attribute failure_message.
  def failure_message; end

  # @return [Boolean]
  def negated?(node); end

  def replaced(node); end

  class << self
    # @raise [NotImplementedError]
    def minitest_assertion; end
  end
end

class RuboCop::Cop::RSpecRails::MinitestAssertions::EmptyAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::EmptyAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::EqualAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(expected, actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::EqualAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::FalseAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::FalseAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::InDeltaAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  # @return [InDeltaAssertion] a new instance of InDeltaAssertion
  def initialize(expected, actual, delta, fail_message); end

  def assertion; end

  class << self
    def match(expected, actual, delta, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::InDeltaAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::IncludesAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(collection, expected, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::IncludesAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::InstanceOfAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(expected, actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::InstanceOfAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::KindOfAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(expected, actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::KindOfAssertion::MATCHERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpecRails::MinitestAssertions::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::RSpecRails::MinitestAssertions::MatchAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(matcher, actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::MatchAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::NilAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::NilAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::PredicateAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(subject, predicate, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::PredicateAssertion::MATCHERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpecRails::MinitestAssertions::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpecRails::MinitestAssertions::TrueAssertion < ::RuboCop::Cop::RSpecRails::MinitestAssertions::BasicAssertion
  def assertion; end

  class << self
    def match(actual, failure_message); end
    def minitest_assertion(param0 = T.unsafe(nil)); end
  end
end

RuboCop::Cop::RSpecRails::MinitestAssertions::TrueAssertion::MATCHERS = T.let(T.unsafe(nil), Array)

# Enforces use of `be_invalid` or `not_to` for negated be_valid.
#
# @example EnforcedStyle: not_to (default)
#   # bad
#   expect(foo).to be_invalid
#
#   # good
#   expect(foo).not_to be_valid
#
#   # good (with method chain)
#   expect(foo).to be_invalid.and be_odd
# @example EnforcedStyle: be_invalid
#   # bad
#   expect(foo).not_to be_valid
#
#   # good
#   expect(foo).to be_invalid
#
#   # good (with method chain)
#   expect(foo).to be_invalid.or be_even
class RuboCop::Cop::RSpecRails::NegationBeValid < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def be_invalid?(param0 = T.unsafe(nil)); end
  def not_to?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def message(_matcher); end

  # @return [Boolean]
  def offense?(node); end

  def offense_range(node); end
  def replaced_matcher; end
  def replaced_runner; end
end

RuboCop::Cop::RSpecRails::NegationBeValid::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpecRails::NegationBeValid::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer to travel in `before` rather than `around`.
#
# @example
#   # bad
#   around do |example|
#   freeze_time do
#   example.run
#   end
#   end
#
#   # good
#   before { freeze_time }
class RuboCop::Cop::RSpecRails::TravelAround < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def extract_run_in_travel(param0 = T.unsafe(nil)); end
  def match_around_each?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_numblock(node); end

  private

  def autocorrect(corrector, node, run_node, around_node); end

  # @param node [RuboCop::AST::BlockNode]
  # @return [RuboCop::AST::BlockNode, nil]
  def extract_surrounding_around_block(node); end
end

RuboCop::Cop::RSpecRails::TravelAround::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpecRails::TravelAround::TRAVEL_METHOD_NAMES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Registry
  def initialize(cops = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def contains_cop_matching?(names); end
  def cops; end
  def cops_for_department(department); end
  def department?(name); end
  def department_missing?(badge, name); end
  def departments; end
  def disabled(config); end
  def dismiss(cop); end
  def each(&block); end
  def enabled(config); end
  def enabled?(cop, config); end
  def enabled_pending_cop?(cop_cfg, config); end
  def enlist(cop); end
  def find_by_cop_name(cop_name); end
  def find_cops_by_directive(directive); end
  def freeze; end
  def length; end
  def names; end
  def names_for_department(department); end
  def options; end
  def print_warning(name, path); end
  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end
  def qualify_badge(badge); end
  def select(&block); end
  def sort!; end
  def to_h; end
  def unqualified_cop_names; end
  def with_department(department); end
  def without_department(department); end

  private

  def clear_enrollment_queue; end
  def initialize_copy(reg); end
  def registered?(badge); end
  def resolve_badge(given_badge, real_badge, source_path); end
  def with(cops); end

  class << self
    def all; end
    def global; end
    def qualified_cop?(name); end
    def qualified_cop_name(name, origin); end
    def reset!; end
    def with_temporary_global(temp_global = T.unsafe(nil)); end
  end
end

module RuboCop::RSpecRails; end

# Version information for the RSpec Rails RuboCop plugin.
module RuboCop::RSpecRails::Version; end

RuboCop::RSpecRails::Version::STRING = T.let(T.unsafe(nil), String)
