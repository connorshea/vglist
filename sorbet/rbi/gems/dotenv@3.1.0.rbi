# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dotenv` gem.
# Please instead update this file by running `bin/tapioca gem dotenv`.

# Shim to load environment variables from `.env files into `ENV`.
module Dotenv
  extend ::Dotenv

  # Returns the value of attribute instrumenter.
  def instrumenter; end

  # Sets the attribute instrumenter
  #
  # @param value the value to set the attribute instrumenter to.
  def instrumenter=(_arg0); end

  # Loads environment variables from one or more `.env` files. See `#parse` for more details.
  def load(*filenames, overwrite: T.unsafe(nil), ignore: T.unsafe(nil)); end

  # Same as `#load`, but raises Errno::ENOENT if any files don't exist
  def load!(*filenames); end

  # Modify `ENV` for the block and restore it to its previous state afterwards.
  #
  # Note that the block is synchronized to prevent concurrent modifications to `ENV`,
  # so multiple threads will be executed serially.
  #
  # @param env [Hash] Hash of keys and values to set in `ENV`
  def modify(env = T.unsafe(nil), &block); end

  # same as `#load`, but will overwrite existing values in `ENV`
  def overload(*filenames); end

  # same as `#overwrite`, but raises Errno::ENOENT if any files don't exist
  def overload!(*filenames); end

  # same as `#load`, but will overwrite existing values in `ENV`
  def overwrite(*filenames); end

  # same as `#overwrite`, but raises Errno::ENOENT if any files don't exist
  def overwrite!(*filenames); end

  # Parses the given files, yielding for each file if a block is given.
  #
  # @param filenames [String, Array<String>] Files to parse
  # @param overwrite [Boolean] Overwrite existing `ENV` values
  # @param ignore [Boolean] Ignore non-existent files
  # @param block [Proc] Block to yield for each parsed `Dotenv::Environment`
  # @return [Hash] parsed key/value pairs
  def parse(*filenames, overwrite: T.unsafe(nil), ignore: T.unsafe(nil), &block); end

  # @raise [MissingKeys]
  def require_keys(*keys); end

  # Restore `ENV` to a given state
  #
  # @param env [Hash] Hash of keys and values to restore, defaults to the last saved state
  # @param safe [Boolean] Is it safe to modify `ENV`? Defaults to `true` in the main thread, otherwise raises an error.
  def restore(env = T.unsafe(nil), safe: T.unsafe(nil)); end

  # Save the current `ENV` to be restored later
  def save; end

  # Update `ENV` with the given hash of keys and values
  #
  # @param env [Hash] Hash of keys and values to set in `ENV`
  # @param overwrite [Boolean] Overwrite existing `ENV` values
  def update(env = T.unsafe(nil), overwrite: T.unsafe(nil)); end

  private

  def instrument(name, payload = T.unsafe(nil), &block); end
end

# A diff between multiple states of ENV.
class Dotenv::Diff
  # Create a new diff. If given a block, the state of ENV after the block will be preserved as
  # the final state for comparison. Otherwise, the current ENV will be the final state.
  #
  # @param a [Hash] the initial state, defaults to a snapshot of current ENV
  # @param b [Hash] the final state, defaults to the current ENV
  # @return [Diff] a new instance of Diff
  # @yield [diff] a block to execute before recording the final state
  def initialize(a: T.unsafe(nil), b: T.unsafe(nil), &block); end

  # The initial state
  def a; end

  # Return a Hash of keys added with their new values
  def added; end

  # Returns true if any keys were added, removed, or changed
  #
  # @return [Boolean]
  def any?; end

  # The final or current state
  def b; end

  # Returns of Hash of keys changed with an array of their previous and new values
  def changed; end

  # Returns a Hash of all added, changed, and removed keys and their new values
  def env; end

  # Returns a Hash of keys removed with their previous values
  def removed; end

  private

  def snapshot; end
end

# A `.env` file that will be read and parsed into a Hash
class Dotenv::Environment < ::Hash
  # Create a new Environment
  #
  # @param filename [String] the path to the file to read
  # @param overwrite [Boolean] whether the parser should assume existing values will be overwritten
  # @return [Environment] a new instance of Environment
  def initialize(filename, overwrite: T.unsafe(nil)); end

  # Returns the value of attribute filename.
  def filename; end

  def load; end

  # Returns the value of attribute overwrite.
  def overwrite; end

  def read; end
end

class Dotenv::Error < ::StandardError; end

# Error raised when encountering a syntax error while parsing a .env file.
class Dotenv::FormatError < ::SyntaxError; end

# Logs instrumented events
#
# Usage:
#   require "active_support/notifications"
#   require "dotenv/log_subscriber"
#   Dotenv.instrumenter = ActiveSupport::Notifications
class Dotenv::LogSubscriber < ::ActiveSupport::LogSubscriber
  def load(event); end
  def logger; end
  def restore(event); end
  def save(event); end
  def update(event); end

  private

  def color_env_constant; end
  def color_filename(filename); end
  def color_var(name); end
end

class Dotenv::MissingKeys < ::Dotenv::Error
  # @return [MissingKeys] a new instance of MissingKeys
  def initialize(keys); end
end

# Parses the `.env` file format into key/value pairs.
# It allows for variable substitutions, command substitutions, and exporting of variables.
class Dotenv::Parser
  # @return [Parser] a new instance of Parser
  def initialize(string, overwrite: T.unsafe(nil)); end

  def call; end

  private

  def expand_newlines(value); end
  def parse_line(line); end
  def parse_value(value); end
  def perform_substitutions(value, maybe_quote); end
  def unescape_characters(value); end
  def unescape_value(value, maybe_quote); end

  # @return [Boolean]
  def variable_not_set?(line); end

  class << self
    def call(*_arg0, **_arg1, &_arg2); end

    # Returns the value of attribute substitutions.
    def substitutions; end
  end
end

Dotenv::Parser::LINE = T.let(T.unsafe(nil), Regexp)

# Rails integration for using Dotenv to load ENV variables from a file
class Dotenv::Rails < ::Rails::Railtie
  # @return [Rails] a new instance of Rails
  def initialize; end

  def autorestore(*_arg0, **_arg1, &_arg2); end
  def autorestore=(arg); end
  def deprecator; end

  # The current environment that the app is running in.
  #
  # When running `rake`, the Rails application is initialized in development, so we have to
  # check which rake tasks are being run to determine the environment.
  #
  # See https://github.com/bkeepers/dotenv/issues/219
  def env; end

  def files(*_arg0, **_arg1, &_arg2); end
  def files=(arg); end

  # Public: Load dotenv
  #
  # This will get called during the `before_configuration` callback, but you
  # can manually call `Dotenv::Rails.load` if you needed it sooner.
  def load; end

  def logger(*_arg0, **_arg1, &_arg2); end

  # Set a new logger and replay logs
  def logger=(new_logger); end

  def overload; end
  def overwrite(*_arg0, **_arg1, &_arg2); end
  def overwrite=(arg); end

  # Internal: `Rails.root` is nil in Rails 4.1 before the application is
  # initialized, so this falls back to the `RAILS_ROOT` environment variable,
  # or the current working directory.
  def root; end

  class << self
    # Rails uses `#method_missing` to delegate all class methods to the
    # instance, which means `Kernel#load` gets called here. We don't want that.
    def load; end
  end
end

Dotenv::Rails::TEST_RAKE_TASKS = T.let(T.unsafe(nil), Regexp)
Dotenv::Railtie = Dotenv::Rails

# A logger that can be used before the apps real logger is initialized.
class Dotenv::ReplayLogger < ::Logger
  # @return [ReplayLogger] a new instance of ReplayLogger
  def initialize; end

  # Override the add method to store logs so we can replay them to a real logger later.
  def add(*args, &block); end

  # Replay the store logs to a real logger.
  def replay(logger); end
end

# An internal monitor to synchronize access to ENV in multi-threaded environments.
Dotenv::SEMAPHORE = T.let(T.unsafe(nil), Monitor)

module Dotenv::Substitutions; end

# Substitute shell commands in a value.
#
#   SHA=$(git rev-parse HEAD)
module Dotenv::Substitutions::Command
  class << self
    def call(value, _env, overwrite: T.unsafe(nil)); end
  end
end

# Substitute variables in a value.
#
#   HOST=example.com
#   URL="https://$HOST"
module Dotenv::Substitutions::Variable
  class << self
    def call(value, env, overwrite: T.unsafe(nil)); end

    private

    def substitute(match, variable, env); end
  end
end
