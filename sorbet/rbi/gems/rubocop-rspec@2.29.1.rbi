# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rspec` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rspec`.

module RuboCop; end

class RuboCop::AST::Node < ::Parser::AST::Node
  include ::RuboCop::RSpec::Node
end

module RuboCop::Cop; end
module RuboCop::Cop::RSpec; end

# Checks that left braces for adjacent single line lets are aligned.
#
# @example
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz) { bar }
#   let(:a) { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
class RuboCop::Cop::RSpec::AlignLeftLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def token_aligner; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::AlignLeftLetBrace::MSG = T.let(T.unsafe(nil), String)

# Checks that right braces for adjacent single line lets are aligned.
#
# @example
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar      }
#   let(:a)      { b        }
class RuboCop::Cop::RSpec::AlignRightLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def token_aligner; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::AlignRightLetBrace::MSG = T.let(T.unsafe(nil), String)

# Check that instances are not being stubbed globally.
#
# Prefer instance doubles over stubbing any instance of a class
#
# @example
#   # bad
#   describe MyClass do
#   before { allow_any_instance_of(MyClass).to receive(:foo) }
#   end
#
#   # good
#   describe MyClass do
#   let(:my_instance) { instance_double(MyClass) }
#
#   before do
#   allow(MyClass).to receive(:new).and_return(my_instance)
#   allow(my_instance).to receive(:foo)
#   end
#   end
class RuboCop::Cop::RSpec::AnyInstance < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
end

RuboCop::Cop::RSpec::AnyInstance::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::AnyInstance::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that around blocks actually run the test.
#
# @example
#   # bad
#   around do
#   some_method
#   end
#
#   around do |test|
#   some_method
#   end
#
#   # good
#   around do |test|
#   some_method
#   test.call
#   end
#
#   around do |test|
#   some_method
#   test.run
#   end
class RuboCop::Cop::RSpec::AroundBlock < ::RuboCop::Cop::RSpec::Base
  def find_arg_usage(param0); end
  def hook_block(param0 = T.unsafe(nil)); end
  def hook_numblock(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_numblock(node); end

  private

  def add_no_arg_offense(node); end
  def check_for_numblock(block); end
  def check_for_unused_proxy(block, proxy); end
end

RuboCop::Cop::RSpec::AroundBlock::MSG_NO_ARG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::AroundBlock::MSG_UNUSED_ARG = T.let(T.unsafe(nil), String)

# @abstract parent class to RSpec cops
class RuboCop::Cop::RSpec::Base < ::RuboCop::Cop::Base
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::RSpec::Language::NodePattern

  # Set the config for dynamic DSL configuration-aware helpers
  # that have no other means of accessing the configuration.
  def on_new_investigation; end

  class << self
    # Invoke the original inherited hook so our cops are recognized
    def inherited(subclass); end
  end
end

# Check for expectations where `be` is used without argument.
#
# The `be` matcher is too generic, as it pass on everything that is not
# nil or false. If that is the exact intend, use `be_truthy`. In all other
# cases it's better to specify what exactly is the expected value.
#
# @example
#   # bad
#   expect(foo).to be
#
#   # good
#   expect(foo).to be_truthy
#   expect(foo).to be 1.0
#   expect(foo).to be(true)
class RuboCop::Cop::RSpec::Be < ::RuboCop::Cop::RSpec::Base
  def be_without_args(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::Be::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Be::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer using `be_empty` when checking for an empty array.
#
# @example
#   # bad
#   expect(array).to contain_exactly
#   expect(array).to match_array([])
#
#   # good
#   expect(array).to be_empty
class RuboCop::Cop::RSpec::BeEmpty < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def expect_array_matcher?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeEmpty::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for expectations where `be(...)` can replace `eq(...)`.
#
# The `be` matcher compares by identity while the `eq` matcher compares
# using `==`. Booleans and nil can be compared by identity and therefore
# the `be` matcher is preferable as it is a more strict test.
#
# @example
#   # bad
#   expect(foo).to eq(true)
#   expect(foo).to eq(false)
#   expect(foo).to eq(nil)
#
#   # good
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeEq < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def eq_type_with_identity?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeEq::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeEq::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for expectations where `be(...)` can replace `eql(...)`.
#
# The `be` matcher compares by identity while the `eql` matcher
# compares using `eql?`. Integers, floats, booleans, symbols, and nil
# can be compared by identity and therefore the `be` matcher is
# preferable as it is a more strict test.
#
# This cop only looks for instances of `expect(...).to eql(...)`. We
# do not check `to_not` or `not_to` since `!eql?` is more strict
# than `!equal?`. We also do not try to flag `eq` because if
# `a == b`, and `b` is comparable by identity, `a` is still not
# necessarily the same type as `b` since the `#==` operator can
# coerce objects for comparison.
#
# @example
#   # bad
#   expect(foo).to eql(1)
#   expect(foo).to eql(1.0)
#   expect(foo).to eql(true)
#   expect(foo).to eql(false)
#   expect(foo).to eql(:bar)
#   expect(foo).to eql(nil)
#
#   # good
#   expect(foo).to be(1)
#   expect(foo).to be(1.0)
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(:bar)
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeEql < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def eql_type_with_identity(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeEql::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeEql::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Ensures a consistent style is used when matching `nil`.
#
# You can either use the more specific `be_nil` matcher, or the more
# generic `be` matcher with a `nil` argument.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: be_nil` (default)
#   # bad
#   expect(foo).to be(nil)
#
#   # good
#   expect(foo).to be_nil
# @example `EnforcedStyle: be`
#   # bad
#   expect(foo).to be_nil
#
#   # good
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeNil < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def be_nil_matcher?(param0 = T.unsafe(nil)); end
  def nil_value_expectation?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_be_nil_style(node); end
  def check_be_style(node); end
end

RuboCop::Cop::RSpec::BeNil::BE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeNil::BE_NIL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that before/after(:all/:context) isn't being used.
#
# @example
#   # bad - Faster but risk of state leaking between examples
#   describe MyClass do
#   before(:all) { Widget.create }
#   after(:context) { Widget.delete_all }
#   end
#
#   # good - Slower but examples are properly isolated
#   describe MyClass do
#   before(:each) { Widget.create }
#   after(:each) { Widget.delete_all }
#   end
class RuboCop::Cop::RSpec::BeforeAfterAll < ::RuboCop::Cop::RSpec::Base
  def before_or_after_all(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeforeAfterAll::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeforeAfterAll::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)
module RuboCop::Cop::RSpec::Capybara; end

# Checks that no expectations are set on Capybara's `current_path`.
#
# The
# https://www.rubydoc.info/github/teamcapybara/capybara/master/Capybara/RSpecMatchers#have_current_path-instance_method[`have_current_path` matcher]
# should be used on `page` to set expectations on Capybara's
# current path, since it uses
# https://github.com/teamcapybara/capybara/blob/master/README.md#asynchronous-javascript-ajax-and-friends[Capybara's waiting functionality]
# which ensures that preceding actions (like `click_link`) have
# completed.
#
# This cop does not support autocorrection in some cases.
#
# @example
#   # bad
#   expect(current_path).to eq('/callback')
#
#   # good
#   expect(page).to have_current_path('/callback')
#
#   # bad (does not support autocorrection)
#   expect(page.current_path).to match(variable)
#
#   # good
#   expect(page).to have_current_path('/callback')
RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation = RuboCop::Cop::Capybara::CurrentPathExpectation

# Checks for consistent method usage in feature specs.
#
# By default, the cop disables all Capybara-specific methods that have
# the same native RSpec method (e.g. are just aliases). Some teams
# however may prefer using some of the Capybara methods (like `feature`)
# to make it obvious that the test uses Capybara, while still disable
# the rest of the methods, like `given` (alias for `let`), `background`
# (alias for `before`), etc. You can configure which of the methods to
# be enabled by using the EnabledMethods configuration option.
#
# @example
#   # bad
#   feature 'User logs in' do
#   given(:user) { User.new }
#
#   background do
#   visit new_session_path
#   end
#
#   scenario 'with OAuth' do
#   # ...
#   end
#   end
#
#   # good
#   describe 'User logs in' do
#   let(:user) { User.new }
#
#   before do
#   visit new_session_path
#   end
#
#   it 'with OAuth' do
#   # ...
#   end
#   end
class RuboCop::Cop::RSpec::Capybara::FeatureMethods < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def capybara_speak(param0 = T.unsafe(nil)); end
  def feature_method(param0 = T.unsafe(nil)); end
  def message(range); end
  def on_block(node); end

  private

  # @return [Boolean]
  def enabled?(method_name); end

  def enabled_methods; end
end

# https://github.com/teamcapybara/capybara/blob/e283c1aeaa72441f5403963577e16333bf111a81/lib/capybara/rspec/features.rb#L31-L36
RuboCop::Cop::RSpec::Capybara::FeatureMethods::MAP = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::RSpec::Capybara::FeatureMethods::MSG = T.let(T.unsafe(nil), String)

# Checks for usage of deprecated style methods.
#
# @example when using `assert_style`
#   # bad
#   page.find(:css, '#first').assert_style(display: 'block')
#
#   # good
#   page.find(:css, '#first').assert_matches_style(display: 'block')
# @example when using `has_style?`
#   # bad
#   expect(page.find(:css, 'first')
#   .has_style?(display: 'block')).to be true
#
#   # good
#   expect(page.find(:css, 'first')
#   .matches_style?(display: 'block')).to be true
# @example when using `have_style`
#   # bad
#   expect(page).to have_style(display: 'block')
#
#   # good
#   expect(page).to match_style(display: 'block')
RuboCop::Cop::RSpec::Capybara::MatchStyle = RuboCop::Cop::Capybara::MatchStyle

# Enforces use of `have_no_*` or `not_to` for negated expectations.
#
# @example EnforcedStyle: not_to (default)
#   # bad
#   expect(page).to have_no_selector
#   expect(page).to have_no_css('a')
#
#   # good
#   expect(page).not_to have_selector
#   expect(page).not_to have_css('a')
# @example EnforcedStyle: have_no
#   # bad
#   expect(page).not_to have_selector
#   expect(page).not_to have_css('a')
#
#   # good
#   expect(page).to have_no_selector
#   expect(page).to have_no_css('a')
RuboCop::Cop::RSpec::Capybara::NegationMatcher = RuboCop::Cop::Capybara::NegationMatcher

# Checks for there is a more specific actions offered by Capybara.
#
# @example
#
#   # bad
#   find('a').click
#   find('button.cls').click
#   find('a', exact_text: 'foo').click
#   find('div button').click
#
#   # good
#   click_link
#   click_button(class: 'cls')
#   click_link(exact_text: 'foo')
#   find('div').click_button
RuboCop::Cop::RSpec::Capybara::SpecificActions = RuboCop::Cop::Capybara::SpecificActions

# Checks if there is a more specific finder offered by Capybara.
#
# @example
#   # bad
#   find('#some-id')
#   find('[visible][id=some-id]')
#
#   # good
#   find_by_id('some-id')
#   find_by_id('some-id', visible: true)
RuboCop::Cop::RSpec::Capybara::SpecificFinders = RuboCop::Cop::Capybara::SpecificFinders

# Checks for there is a more specific matcher offered by Capybara.
#
# @example
#
#   # bad
#   expect(page).to have_selector('button')
#   expect(page).to have_no_selector('button.cls')
#   expect(page).to have_css('button')
#   expect(page).to have_no_css('a.cls', href: 'http://example.com')
#   expect(page).to have_css('table.cls')
#   expect(page).to have_css('select')
#   expect(page).to have_css('input', exact_text: 'foo')
#
#   # good
#   expect(page).to have_button
#   expect(page).to have_no_button(class: 'cls')
#   expect(page).to have_button
#   expect(page).to have_no_link('foo', class: 'cls', href: 'http://example.com')
#   expect(page).to have_table(class: 'cls')
#   expect(page).to have_select
#   expect(page).to have_field('foo')
RuboCop::Cop::RSpec::Capybara::SpecificMatcher = RuboCop::Cop::Capybara::SpecificMatcher

# Checks for boolean visibility in Capybara finders.
#
# Capybara lets you find elements that match a certain visibility
# using the `:visible` option. `:visible` accepts both boolean and
# symbols as values, however using booleans can have unwanted
# effects. `visible: false` does not find just invisible elements,
# but both visible and invisible elements. For expressiveness and
# clarity, use one of the # symbol values, `:all`, `:hidden` or
# `:visible`.
# Read more in
# https://www.rubydoc.info/gems/capybara/Capybara%2FNode%2FFinders:all[the documentation].
#
# @example
#   # bad
#   expect(page).to have_selector('.foo', visible: false)
#   expect(page).to have_css('.foo', visible: true)
#   expect(page).to have_link('my link', visible: false)
#
#   # good
#   expect(page).to have_selector('.foo', visible: :visible)
#   expect(page).to have_css('.foo', visible: :all)
#   expect(page).to have_link('my link', visible: :hidden)
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher = RuboCop::Cop::Capybara::VisibilityMatcher

# Prefer negated matchers over `to change.by(0)`.
#
# In the case of composite expectations, cop suggest using the
# negation matchers of `RSpec::Matchers#change`.
#
# By default the cop does not support autocorrect of
# compound expectations, but if you set the
# negated matcher for `change`, e.g. `not_change` with
# the `NegatedMatcher` option, the cop will perform the autocorrection.
#
# @example NegatedMatcher: ~ (default)
#   # bad
#   expect { run }.to change(Foo, :bar).by(0)
#   expect { run }.to change { Foo.bar }.by(0)
#
#   # bad - compound expectations (does not support autocorrection)
#   expect { run }
#   .to change(Foo, :bar).by(0)
#   .and change(Foo, :baz).by(0)
#   expect { run }
#   .to change { Foo.bar }.by(0)
#   .and change { Foo.baz }.by(0)
#
#   # good
#   expect { run }.not_to change(Foo, :bar)
#   expect { run }.not_to change { Foo.bar }
#
#   # good - compound expectations
#   define_negated_matcher :not_change, :change
#   expect { run }
#   .to not_change(Foo, :bar)
#   .and not_change(Foo, :baz)
#   expect { run }
#   .to not_change { Foo.bar }
#   .and not_change { Foo.baz }
# @example NegatedMatcher: not_change
#   # bad (support autocorrection to good case)
#   expect { run }
#   .to change(Foo, :bar).by(0)
#   .and change(Foo, :baz).by(0)
#   expect { run }
#   .to change { Foo.bar }.by(0)
#   .and change { Foo.baz }.by(0)
#
#   # good
#   define_negated_matcher :not_change, :change
#   expect { run }
#   .to not_change(Foo, :bar)
#   .and not_change(Foo, :baz)
#   expect { run }
#   .to not_change { Foo.bar }
#   .and not_change { Foo.baz }
class RuboCop::Cop::RSpec::ChangeByZero < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def change_nodes(param0); end
  def expect_change_with_arguments(param0 = T.unsafe(nil)); end
  def expect_change_with_block(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node, change_node); end
  def autocorrect_compound(corrector, node); end

  # @return [Boolean]
  def compound_expectations?(node); end

  def insert_operator(corrector, node, change_node); end
  def message(change_node); end
  def message_compound(change_node); end
  def negated_matcher; end
  def preferred_method; end
  def register_offense(node, change_node); end
  def remove_by_zero(corrector, node, change_node); end
  def replace_node(node, change_node); end
end

RuboCop::Cop::RSpec::ChangeByZero::CHANGE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::RSpec::ChangeByZero::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ChangeByZero::MSG_COMPOUND = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ChangeByZero::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Enforces consistent use of `be_a` or `be_kind_of`.
#
# @example EnforcedStyle: be_a (default)
#   # bad
#   expect(object).to be_kind_of(String)
#   expect(object).to be_a_kind_of(String)
#
#   # good
#   expect(object).to be_a(String)
#   expect(object).to be_an(String)
# @example EnforcedStyle: be_kind_of
#   # bad
#   expect(object).to be_a(String)
#   expect(object).to be_an(String)
#
#   # good
#   expect(object).to be_kind_of(String)
#   expect(object).to be_a_kind_of(String)
class RuboCop::Cop::RSpec::ClassCheck < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def format_message(node); end

  # @return [Boolean]
  def offending?(node); end

  def preferred_method_name; end

  # @return [Boolean]
  def preferred_method_name?(method_name); end

  def preferred_method_names; end
end

RuboCop::Cop::RSpec::ClassCheck::METHOD_NAMES_FOR_BE_A = T.let(T.unsafe(nil), Set)
RuboCop::Cop::RSpec::ClassCheck::METHOD_NAMES_FOR_KIND_OF = T.let(T.unsafe(nil), Set)
RuboCop::Cop::RSpec::ClassCheck::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ClassCheck::PREFERRED_METHOD_NAME_BY_STYLE = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::RSpec::ClassCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Help methods for working with nodes containing comments.
module RuboCop::Cop::RSpec::CommentsHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation

  def begin_pos_with_comment(node); end
  def buffer; end
  def end_line_position(node); end
  def source_range_with_comment(node); end
  def start_line_position(node); end
end

# Checks where `contain_exactly` is used.
#
# This cop checks for the following:
# - Prefer `match_array` when matching array values.
# - Prefer `be_empty` when using `contain_exactly` with no arguments.
#
# @example
#   # bad
#   it { is_expected.to contain_exactly(*array1, *array2) }
#
#   # good
#   it { is_expected.to match_array(array1 + array2) }
#
#   # good
#   it { is_expected.to contain_exactly(content, *array) }
class RuboCop::Cop::RSpec::ContainExactly < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def autocorrect_for_populated_array(node, corrector); end
  def check_populated_collection(node); end
end

RuboCop::Cop::RSpec::ContainExactly::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ContainExactly::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# `context` should not be used for specifying methods.
#
# @example
#   # bad
#   context '#foo_bar' do
#   # ...
#   end
#
#   context '.foo_bar' do
#   # ...
#   end
#
#   # good
#   describe '#foo_bar' do
#   # ...
#   end
#
#   describe '.foo_bar' do
#   # ...
#   end
class RuboCop::Cop::RSpec::ContextMethod < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def context_method(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def method_name?(description); end
end

RuboCop::Cop::RSpec::ContextMethod::MSG = T.let(T.unsafe(nil), String)

# Checks that `context` docstring starts with an allowed prefix.
#
# The default list of prefixes is minimal. Users are encouraged to tailor
# the configuration to meet project needs. Other acceptable prefixes may
# include `if`, `unless`, `for`, `before`, `after`, or `during`.
# They may consist of multiple words if desired.
#
# This cop can be customized allowed context description pattern
# with `AllowedPatterns`. By default, there are no checking by pattern.
#
# @example `Prefixes` configuration
#   # .rubocop.yml
#   # RSpec/ContextWording:
#   #   Prefixes:
#   #     - when
#   #     - with
#   #     - without
#   #     - if
#   #     - unless
#   #     - for
# @example
#   # bad
#   context 'the display name not present' do
#   # ...
#   end
#
#   # good
#   context 'when the display name is not present' do
#   # ...
#   end
# @example `AllowedPatterns` configuration
#
#   # .rubocop.yml
#   # RSpec/ContextWording:
#   #   AllowedPatterns:
#   #     - とき$
# @example
#   # bad
#   context '条件を満たす' do
#   # ...
#   end
#
#   # good
#   context '条件を満たすとき' do
#   # ...
#   end
# @see http://www.betterspecs.org/#contexts
class RuboCop::Cop::RSpec::ContextWording < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::AllowedPattern

  def context_wording(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def allowed_patterns; end

  # @return [Boolean]
  def bad_pattern?(node); end

  def description(context); end
  def expect_patterns; end
  def prefix_regexes; end
  def prefixes; end
end

RuboCop::Cop::RSpec::ContextWording::MSG = T.let(T.unsafe(nil), String)

# Check that the first argument to the top-level describe is a constant.
#
# It can be configured to ignore strings when certain metadata is passed.
#
# Ignores Rails and Aruba `type` metadata by default.
#
# @example `IgnoredMetadata` configuration
#   # .rubocop.yml
#   # RSpec/DescribeClass:
#   #   IgnoredMetadata:
#   #     type:
#   #       - request
#   #       - controller
# @example
#   # bad
#   describe 'Do something' do
#   end
#
#   # good
#   describe TestedClass do
#   subject { described_class }
#   end
#
#   describe 'TestedClass::VERSION' do
#   subject { Object.const_get(self.class.description) }
#   end
#
#   describe "A feature example", type: :feature do
#   end
class RuboCop::Cop::RSpec::DescribeClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def example_group_with_ignored_metadata?(param0 = T.unsafe(nil)); end
  def not_a_const_described(param0 = T.unsafe(nil)); end
  def on_top_level_group(node); end
  def sym_pair(param0 = T.unsafe(nil)); end

  private

  def ignored_metadata; end

  # @return [Boolean]
  def ignored_metadata?(node); end

  # @return [Boolean]
  def string_constant?(described); end
end

RuboCop::Cop::RSpec::DescribeClass::MSG = T.let(T.unsafe(nil), String)

# Checks that the second argument to `describe` specifies a method.
#
# @example
#   # bad
#   describe MyClass, 'do something' do
#   end
#
#   # good
#   describe MyClass, '#my_instance_method' do
#   end
#
#   describe MyClass, '.my_class_method' do
#   end
class RuboCop::Cop::RSpec::DescribeMethod < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def method_name?(param0 = T.unsafe(nil)); end
  def on_top_level_group(node); end
  def second_string_literal_argument(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def method_name_prefix?(description); end
end

RuboCop::Cop::RSpec::DescribeMethod::MSG = T.let(T.unsafe(nil), String)

# Avoid describing symbols.
#
# @example
#   # bad
#   describe :my_method do
#   # ...
#   end
#
#   # good
#   describe '#my_method' do
#   # ...
#   end
# @see https://github.com/rspec/rspec-core/issues/1610
class RuboCop::Cop::RSpec::DescribeSymbol < ::RuboCop::Cop::RSpec::Base
  def describe_symbol?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::DescribeSymbol::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::DescribeSymbol::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that tests use `described_class`.
#
# If the first argument of describe is a class, the class is exposed to
# each example via described_class.
#
# This cop can be configured using the `EnforcedStyle`, `SkipBlocks`
# and `OnlyStaticConstants` options.
# `OnlyStaticConstants` is only relevant when `EnforcedStyle` is
# `described_class`.
#
# There's a known caveat with rspec-rails's `controller` helper that
# runs its block in a different context, and `described_class` is not
# available to it. `SkipBlocks` option excludes detection in all
# non-RSpec related blocks.
#
# To narrow down this setting to only a specific directory, it is
# possible to use an overriding configuration file local to that
# directory.
#
# @example `EnforcedStyle: described_class` (default)
#   # bad
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { described_class.do_something }
#   end
# @example `OnlyStaticConstants: true` (default)
#   # good
#   describe MyClass do
#   subject { MyClass::CONSTANT }
#   end
# @example `OnlyStaticConstants: false`
#   # bad
#   describe MyClass do
#   subject { MyClass::CONSTANT }
#   end
# @example `EnforcedStyle: explicit`
#   # bad
#   describe MyClass do
#   subject { described_class.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
# @example `SkipBlocks: true`
#   # spec/controllers/.rubocop.yml
#   # RSpec/DescribedClass:
#   #   SkipBlocks: true
#
#   # acceptable
#   describe MyConcern do
#   controller(ApplicationController) do
#   include MyConcern
#   end
#   end
class RuboCop::Cop::RSpec::DescribedClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::Namespace
  extend ::RuboCop::Cop::AutoCorrector

  def common_instance_exec_closure?(param0 = T.unsafe(nil)); end
  def contains_described_class?(param0); end
  def described_constant(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def rspec_block?(param0 = T.unsafe(nil)); end
  def scope_changing_syntax?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def allowed?(node); end

  def autocorrect(corrector, match); end

  # @example
  #   # nil represents base constant
  #   collapse_namespace([], [:C])                # => [:C]
  #   collapse_namespace([:A, :B], [:C])          # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [:B, :C])      # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [nil, :C])     # => [nil, :C]
  #   collapse_namespace([:A, :B], [nil, :B, :C]) # => [nil, :B, :C]
  # @param namespace [Array<Symbol>]
  # @param const [Array<Symbol>]
  # @return [Array<Symbol>]
  def collapse_namespace(namespace, const); end

  # @example
  #   const_name(s(:const, nil, :C))                # => [:C]
  #   const_name(s(:const, s(:const, nil, :M), :C)) # => [:M, :C]
  #   const_name(s(:const, s(:cbase), :C))          # => [nil, :C]
  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  def const_name(node); end

  # @yield [node]
  def find_usage(node, &block); end

  def full_const_name(node); end
  def message(offense); end

  # @return [Boolean]
  def offensive?(node); end

  # @return [Boolean]
  def offensive_described_class?(node); end

  # @return [Boolean]
  def only_static_constants?; end

  # @return [Boolean]
  def scope_change?(node); end

  # @return [Boolean]
  def skippable_block?(node); end
end

RuboCop::Cop::RSpec::DescribedClass::DESCRIBED_CLASS = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::DescribedClass::MSG = T.let(T.unsafe(nil), String)

# Avoid opening modules and defining specs within them.
#
# @example
#   # bad
#   module MyModule
#   RSpec.describe MyClass do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe MyModule::MyClass do
#   # ...
#   end
# @see https://github.com/rubocop/rubocop-rspec/issues/735
class RuboCop::Cop::RSpec::DescribedClassModuleWrapping < ::RuboCop::Cop::RSpec::Base
  def include_rspec_blocks?(param0); end
  def on_module(node); end
end

RuboCop::Cop::RSpec::DescribedClassModuleWrapping::MSG = T.let(T.unsafe(nil), String)

# Enforces custom RSpec dialects.
#
# A dialect can be based on the following RSpec methods:
#
# - describe, context, feature, example_group
# - xdescribe, xcontext, xfeature
# - fdescribe, fcontext, ffeature
# - shared_examples, shared_examples_for, shared_context
# - it, specify, example, scenario, its
# - fit, fspecify, fexample, fscenario, focus
# - xit, xspecify, xexample, xscenario, skip
# - pending
# - prepend_before, before, append_before,
# - around
# - prepend_after, after, append_after
# - let, let!
# - subject, subject!
# - expect, is_expected, expect_any_instance_of
#
# By default all of the RSpec methods and aliases are allowed. By setting
# a config like:
#
#   RSpec/Dialect:
#     PreferredMethods:
#       context: describe
#
# You can expect the following behavior:
#
# @example
#   # bad
#   context 'display name presence' do
#   # ...
#   end
#
#   # good
#   describe 'display name presence' do
#   # ...
#   end
class RuboCop::Cop::RSpec::Dialect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def rspec_method?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::Dialect::MSG = T.let(T.unsafe(nil), String)

# Avoid duplicated metadata.
#
# @example
#   # bad
#   describe 'Something', :a, :a
#
#   # good
#   describe 'Something', :a
class RuboCop::Cop::RSpec::DuplicatedMetadata < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::Metadata
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_metadata(symbols, _hash); end

  private

  def autocorrect(corrector, node); end

  # @return [Boolean]
  def duplicated?(node); end

  def on_metadata_symbol(node); end
end

RuboCop::Cop::RSpec::DuplicatedMetadata::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group does not include any tests.
#
# @example usage
#   # bad
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   context 'extra chunky' do   # flagged by rubocop
#   let(:chunkiness) { true }
#   end
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   pending 'will add tests later'
#   end
class RuboCop::Cop::RSpec::EmptyExampleGroup < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # Match example group blocks and yield their body
  #
  # @example source that matches
  #   describe 'example group' do
  #   it { is_expected.to be }
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] example group body
  def example_group_body(param0 = T.unsafe(nil)); end

  # Match examples, example groups and includes
  #
  # @example source that matches
  #   it { is_expected.to fly }
  #   describe('non-empty example groups too') { }
  #   it_behaves_like 'an animal'
  #   it_behaves_like('a cat') { let(:food) { 'milk' } }
  #   it_has_root_access
  #   skip
  #   it 'will be implemented later'
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def example_or_group_or_include?(param0 = T.unsafe(nil)); end

  # Matches examples defined in scopes where they could run
  #
  # @example source that matches
  #   it { expect(myself).to be_run }
  #   describe { it { i_run_as_well } }
  # @example source that does not match
  #   before { it { whatever here won't run anyway } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples?(param0 = T.unsafe(nil)); end

  # Match examples or examples inside blocks
  #
  # @example source that matches
  #   it { expect(drink).to be_cold }
  #   context('when winter') { it { expect(drink).to be_hot } }
  #   (1..5).each { |divisor| it { is_expected.to divide_by(divisor) } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples_directly_or_in_block?(param0 = T.unsafe(nil)); end

  # Match examples defined inside a block which is not a hook
  #
  # @example source that matches
  #   %w(r g b).each do |color|
  #   it { is_expected.to have_color(color) }
  #   end
  # @example source that does not match
  #   before do
  #   it { is_expected.to fall_into_oblivion }
  #   end
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples_inside_block?(param0 = T.unsafe(nil)); end

  def on_block(node); end

  private

  # @return [Boolean]
  def conditionals_with_examples?(body); end

  # @return [Boolean]
  def examples_in_branches?(condition_node); end

  # @return [Boolean]
  def offensive?(body); end

  def removed_range(node); end
end

RuboCop::Cop::RSpec::EmptyExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks for empty before and after hooks.
#
# @example
#   # bad
#   before {}
#   after do; end
#   before(:all) do
#   end
#   after(:all) { }
#
#   # good
#   before { create_users }
#   after do
#   cleanup_users
#   end
#   before(:all) do
#   create_feed
#   end
#   after(:all) { cleanup_feed }
class RuboCop::Cop::RSpec::EmptyHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def empty_hook?(param0 = T.unsafe(nil)); end
  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#   it 'does that' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#
#   it 'does that' do
#   end
#   end
#
#   # fair - it's ok to have non-separated one-liners
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
# @example with AllowConsecutiveOneLiners configuration
#   # rubocop.yml
#   # RSpec/EmptyLineAfterExample:
#   #   AllowConsecutiveOneLiners: false
#
#   # bad
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
class RuboCop::Cop::RSpec::EmptyLineAfterExample < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  # @return [Boolean]
  def allow_consecutive_one_liners?; end

  # @return [Boolean]
  def allowed_one_liner?(node); end

  # @return [Boolean]
  def consecutive_one_liner?(node); end

  # @return [Boolean]
  def next_one_line_example?(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterExample::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example group blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#   describe '#baz' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#
#   describe '#baz' do
#   end
#   end
class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after the last let block.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:something) { other }
#   it { does_something }
#
#   # good
#   let(:foo) { bar }
#   let(:something) { other }
#
#   it { does_something }
class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterFinalLet::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after hook blocks.
#
# `AllowConsecutiveOneLiners` configures whether adjacent
# one-line definitions are considered an offense.
#
# @example
#   # bad
#   before { do_something }
#   it { does_something }
#
#   # bad
#   after { do_something }
#   it { does_something }
#
#   # bad
#   around { |test| test.run }
#   it { does_something }
#
#   # good
#   after { do_something }
#
#   it { does_something }
#
#   # fair - it's ok to have non-separated one-liners hooks
#   around { |test| test.run }
#   after { do_something }
#
#   it { does_something }
# @example with AllowConsecutiveOneLiners configuration
#   # rubocop.yml
#   # RSpec/EmptyLineAfterHook:
#   #   AllowConsecutiveOneLiners: false
#
#   # bad
#   around { |test| test.run }
#   after { do_something }
#
#   it { does_something }
#
#   # good
#   around { |test| test.run }
#
#   after { do_something }
#
#   it { does_something }
class RuboCop::Cop::RSpec::EmptyLineAfterHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_numblock(node); end

  private

  # @return [Boolean]
  def chained_single_line_hooks?(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after subject block.
#
# @example
#   # bad
#   subject(:obj) { described_class }
#   let(:foo) { bar }
#
#   # good
#   subject(:obj) { described_class }
#
#   let(:foo) { bar }
class RuboCop::Cop::RSpec::EmptyLineAfterSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterSubject::MSG = T.let(T.unsafe(nil), String)

# Helps determine the offending location if there is not an empty line
# following the node. Allows comments to follow directly after
# in the following cases.
# - followed by empty line(s)
module RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp

  # @return [Boolean]
  def last_child?(node); end

  # @yield [offending_loc(enable_directive_line || final_end_line)]
  def missing_separating_line(node); end

  def missing_separating_line_offense(node); end
  def offending_loc(last_line); end
end

# Avoid empty metadata hash.
#
# @example EnforcedStyle: symbol (default)
#   # bad
#   describe 'Something', {}
#
#   # good
#   describe 'Something'
class RuboCop::Cop::RSpec::EmptyMetadata < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::Metadata
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_metadata(_symbols, hash); end

  private

  def remove_empty_metadata(corrector, node); end
end

RuboCop::Cop::RSpec::EmptyMetadata::MSG = T.let(T.unsafe(nil), String)

# Check that the `output` matcher is not called with an empty string.
#
# @example
#   # bad
#   expect { foo }.to output('').to_stdout
#   expect { bar }.not_to output('').to_stderr
#
#   # good
#   expect { foo }.not_to output.to_stdout
#   expect { bar }.to output.to_stderr
class RuboCop::Cop::RSpec::EmptyOutput < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def matching_empty_output(param0 = T.unsafe(nil)); end
  def on_send(send_node); end
end

RuboCop::Cop::RSpec::EmptyOutput::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::EmptyOutput::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use `eq` instead of `be ==` to compare objects.
#
# @example
#   # bad
#   expect(foo).to be == 42
#
#   # good
#   expect(foo).to eq 42
class RuboCop::Cop::RSpec::Eq < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def be_equals(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def offense_range(matcher); end
end

RuboCop::Cop::RSpec::Eq::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Eq::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for long examples.
#
# A long example is usually more difficult to understand. Consider
# extracting out some behavior, e.g. with a `let` block, or a helper
# method.
#
# You can set constructs you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', 'heredoc', and 'method_call'.
# Each construct will be counted as one line regardless of
# its actual size.
#
# @example
#   # bad
#   it do
#   service = described_class.new
#   more_setup
#   more_setup
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it do
#   service = described_class.new
#   result = service.call
#   expect(result).to be(true)
#   end
# @example CountAsOne: ['array', 'heredoc', 'method_call']
#
#   it do
#   array = [         # +1
#   1,
#   2
#   ]
#
#   hash = {          # +3
#   key: 'value'
#   }
#
#   msg = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#
#   foo(            # +1
#   1,
#   2
#   )
#   end               # 6 points
class RuboCop::Cop::RSpec::ExampleLength < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::CodeLength

  def on_block(node); end

  private

  def cop_label; end
end

RuboCop::Cop::RSpec::ExampleLength::LABEL = T.let(T.unsafe(nil), String)

# Checks for examples without a description.
#
# RSpec allows for auto-generated example descriptions when there is no
# description provided or the description is an empty one.
# It is acceptable to use `specify` without a description
#
# This cop removes empty descriptions.
# It also defines whether auto-generated description is allowed, based
# on the configured style.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example
#   # always good
#   specify do
#   result = service.call
#   expect(result).to be(true)
#   end
# @example `EnforcedStyle: always_allow` (default)
#   # bad
#   it('') { is_expected.to be_good }
#   specify '' do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
#   specify do
#   result = service.call
#   expect(result).to be(true)
#   end
# @example `EnforcedStyle: single_line_only`
#   # bad
#   it('') { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
class RuboCop::Cop::RSpec::ExampleWithoutDescription < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def example_description(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def check_example_without_description(node); end

  # @return [Boolean]
  def disallow_empty_description?(node); end
end

RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_ADD_DESCRIPTION = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_DEFAULT_ARGUMENT = T.let(T.unsafe(nil), String)

# Checks for common mistakes in example descriptions.
#
# This cop will correct docstrings that begin with 'should' and 'it'.
# This cop will also look for insufficient examples and call them out.
#
# The autocorrect is experimental - use with care! It can be configured
# with CustomTransform (e.g. have => has) and IgnoredWords (e.g. only).
#
# Use the DisallowedExamples setting to prevent unclear or insufficient
# descriptions. Please note that this config will not be treated as
# case sensitive.
#
# @example
#   # bad
#   it 'should find nothing' do
#   end
#
#   it 'will find nothing' do
#   end
#
#   # good
#   it 'finds nothing' do
#   end
# @example
#   # bad
#   it 'it does things' do
#   end
#
#   # good
#   it 'does things' do
#   end
# @example `DisallowedExamples: ['works']` (default)
#   # bad
#   it 'works' do
#   end
#
#   # good
#   it 'marks the task as done' do
#   end
# @see http://betterspecs.org/#should
class RuboCop::Cop::RSpec::ExampleWording < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def it_description(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def add_wording_offense(node, message); end
  def custom_transform; end
  def docstring(node); end
  def ignored_words; end

  # @return [Boolean]
  def insufficient_docstring?(description_node); end

  def insufficient_examples; end
  def preprocess(message); end
  def replacement_text(node); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  def text(node); end
end

RuboCop::Cop::RSpec::ExampleWording::IT_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::RSpec::ExampleWording::MSG_INSUFFICIENT_DESCRIPTION = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::MSG_IT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::MSG_SHOULD = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::MSG_WILL = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::SHOULD_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::RSpec::ExampleWording::WILL_PREFIX = T.let(T.unsafe(nil), Regexp)

# Checks for excessive whitespace in example descriptions.
#
# @example
#   # bad
#   it '  has  excessive   spacing  ' do
#   end
#
#   # good
#   it 'has excessive spacing' do
#   end
# @example
#   # bad
#   context '  when a condition   is met  ' do
#   end
#
#   # good
#   context 'when a condition is met' do
#   end
class RuboCop::Cop::RSpec::ExcessiveDocstringSpacing < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_description(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @param node [RuboCop::AST::Node]
  # @param text [String]
  def add_whitespace_offense(node, text); end

  def docstring(node); end

  # @param text [String]
  # @return [Boolean]
  def excessive_whitespace?(text); end

  # @param text [String]
  def strip_excessive_whitespace(text); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  def text(node); end
end

RuboCop::Cop::RSpec::ExcessiveDocstringSpacing::MSG = T.let(T.unsafe(nil), String)

# Checks for `expect(...)` calls containing literal values.
#
# Autocorrection is performed when the expected is not a literal.
#
# @example
#   # bad
#   expect(5).to eq(price)
#   expect(/foo/).to eq(pattern)
#   expect("John").to eq(name)
#
#   # good
#   expect(price).to eq(5)
#   expect(pattern).to eq(/foo/)
#   expect(name).to eq("John")
#
#   # bad (not supported autocorrection)
#   expect(false).to eq(true)
class RuboCop::Cop::RSpec::ExpectActual < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def expect_literal(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def complex_literal?(node); end

  # This is not implemented using a NodePattern because it seems
  # to not be able to match against an explicit (nil) sexp
  #
  # @return [Boolean]
  def literal?(node); end

  # @return [Boolean]
  def simple_literal?(node); end
end

RuboCop::Cop::RSpec::ExpectActual::COMPLEX_LITERALS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::CORRECTABLE_MATCHERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectActual::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::SIMPLE_LITERALS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::SKIPPED_MATCHERS = T.let(T.unsafe(nil), Array)

# Checks for consistent style of change matcher.
#
# Enforces either passing object and attribute as arguments to the matcher
# or passing a block that reads the attribute value.
#
# This cop can be configured using the `EnforcedStyle` option.
#
# @example `EnforcedStyle: method_call` (default)
#   # bad
#   expect { run }.to change { Foo.bar }
#   expect { run }.to change { foo.baz }
#
#   # good
#   expect { run }.to change(Foo, :bar)
#   expect { run }.to change(foo, :baz)
#   # also good when there are arguments or chained method calls
#   expect { run }.to change { Foo.bar(:count) }
#   expect { run }.to change { user.reload.name }
# @example `EnforcedStyle: block`
#   # bad
#   expect { run }.to change(Foo, :bar)
#
#   # good
#   expect { run }.to change { Foo.bar }
class RuboCop::Cop::RSpec::ExpectChange < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def expect_change_with_arguments(param0 = T.unsafe(nil)); end
  def expect_change_with_block(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::ExpectChange::MSG_BLOCK = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectChange::MSG_CALL = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectChange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Do not use `expect` in hooks such as `before`.
#
# @example
#   # bad
#   before do
#   expect(something).to eq 'foo'
#   end
#
#   # bad
#   after do
#   expect_any_instance_of(Something).to receive(:foo)
#   end
#
#   # good
#   it do
#   expect(something).to eq 'foo'
#   end
class RuboCop::Cop::RSpec::ExpectInHook < ::RuboCop::Cop::RSpec::Base
  def expectation(param0); end
  def on_block(node); end
  def on_numblock(node); end

  private

  def message(expect, hook); end
end

RuboCop::Cop::RSpec::ExpectInHook::MSG = T.let(T.unsafe(nil), String)

# Checks for opportunities to use `expect { ... }.to output`.
#
# @example
#   # bad
#   $stdout = StringIO.new
#   my_app.print_report
#   $stdout = STDOUT
#   expect($stdout.string).to eq('Hello World')
#
#   # good
#   expect { my_app.print_report }.to output('Hello World').to_stdout
class RuboCop::Cop::RSpec::ExpectOutput < ::RuboCop::Cop::RSpec::Base
  def on_gvasgn(node); end

  private

  # Detect if we are inside the scope of a single example
  #
  # We want to encourage using `expect { ... }.to output` so
  # we only care about situations where you would replace with
  # an expectation. Therefore, assignments to stderr or stdout
  # within a `before(:all)` or otherwise outside of an example
  # don't matter.
  #
  # @return [Boolean]
  def inside_example_scope?(node); end
end

RuboCop::Cop::RSpec::ExpectOutput::MSG = T.let(T.unsafe(nil), String)

# A helper for `explicit` style
module RuboCop::Cop::RSpec::ExplicitHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def predicate_matcher?(param0 = T.unsafe(nil)); end
  def predicate_matcher_block?(param0 = T.unsafe(nil)); end

  private

  def allowed_explicit_matchers; end
  def check_explicit(node); end
  def corrector_explicit(corrector, to_node, actual, matcher, block_child); end

  # @return [Boolean]
  def heredoc_argument?(matcher); end

  def message_explicit(matcher); end
  def move_predicate(corrector, actual, matcher, block_child); end

  # @return [Boolean]
  def predicate_matcher_name?(name); end

  # @return [Boolean]
  def replaceable_matcher?(matcher); end

  def replacement_matcher(node); end
  def to_predicate_method(matcher); end

  # @return [Boolean]
  def uncorrectable_matcher?(node, matcher); end
end

RuboCop::Cop::RSpec::ExplicitHelper::BUILT_IN_MATCHERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExplicitHelper::MSG_EXPLICIT = T.let(T.unsafe(nil), String)
module RuboCop::Cop::RSpec::FactoryBot; end

# Always declare attribute values as blocks.
#
# @example
#   # bad
#   kind [:active, :rejected].sample
#
#   # good
#   kind { [:active, :rejected].sample }
#
#   # bad
#   closed_at 1.day.from_now
#
#   # good
#   closed_at { 1.day.from_now }
#
#   # bad
#   count 1
#
#   # good
#   count { 1 }
RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically = RuboCop::Cop::FactoryBot::AttributeDefinedStatically

# Use a consistent style for parentheses in factory bot calls.
#
# @example
#
#   # bad
#   create :user
#   build(:user)
#   create(:login)
#   create :login
# @example `EnforcedStyle: require_parentheses` (default)
#
#   # good
#   create(:user)
#   create(:user)
#   create(:login)
#   build(:login)
# @example `EnforcedStyle: omit_parentheses`
#
#   # good
#   create :user
#   build :user
#   create :login
#   create :login
#
#   # also good
#   # when method name and first argument are not on same line
#   create(
#   :user
#   )
#   build(
#   :user,
#   name: 'foo'
#   )
RuboCop::Cop::RSpec::FactoryBot::ConsistentParenthesesStyle = RuboCop::Cop::FactoryBot::ConsistentParenthesesStyle

# Checks for create_list usage.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: create_list` (default)
#   # bad
#   3.times { create :user }
#
#   # good
#   create_list :user, 3
#
#   # bad
#   3.times { create :user, age: 18 }
#
#   # good - index is used to alter the created models attributes
#   3.times { |n| create :user, age: n }
#
#   # good - contains a method call, may return different values
#   3.times { create :user, age: rand }
# @example `EnforcedStyle: n_times`
#   # bad
#   create_list :user, 3
#
#   # good
#   3.times { create :user }
RuboCop::Cop::RSpec::FactoryBot::CreateList = RuboCop::Cop::FactoryBot::CreateList

# Use string value when setting the class attribute explicitly.
#
# This cop would promote faster tests by lazy-loading of
# application files. Also, this could help you suppress potential
# bugs in combination with external libraries by avoiding a preload
# of application files from the factory files.
#
# @example
#   # bad
#   factory :foo, class: Foo do
#   end
#
#   # good
#   factory :foo, class: 'Foo' do
#   end
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName = RuboCop::Cop::FactoryBot::FactoryClassName

# Checks for name style for argument of FactoryBot::Syntax::Methods.
#
# @example EnforcedStyle: symbol (default)
#   # bad
#   create('user')
#   build "user", username: "NAME"
#
#   # good
#   create(:user)
#   build :user, username: "NAME"
# @example EnforcedStyle: string
#   # bad
#   create(:user)
#   build :user, username: "NAME"
#
#   # good
#   create('user')
#   build "user", username: "NAME"
RuboCop::Cop::RSpec::FactoryBot::FactoryNameStyle = RuboCop::Cop::FactoryBot::FactoryNameStyle

# Use shorthands from `FactoryBot::Syntax::Methods` in your specs.
#
# @example
#   # bad
#   FactoryBot.create(:bar)
#   FactoryBot.build(:bar)
#   FactoryBot.attributes_for(:bar)
#
#   # good
#   create(:bar)
#   build(:bar)
#   attributes_for(:bar)
RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods = RuboCop::Cop::FactoryBot::SyntaxMethods

# Help methods for file.
module RuboCop::Cop::RSpec::FileHelp
  def expanded_file_path; end
end

# Checks that spec file paths are consistent and well-formed.
#
# This cop is deprecated.
# We plan to remove it in the next major version update to 3.0.
# The migration targets are `RSpec/SpecFilePathSuffix`
# and `RSpec/SpecFilePathFormat`.
# If you are using this cop, please plan for migration.
#
# By default, this checks that spec file paths are consistent with the
# test subject and enforces that it reflects the described
# class/module and its optionally called out method.
#
# With the configuration option `IgnoreMethods` the called out method will
# be ignored when determining the enforced path.
#
# With the configuration option `CustomTransform` modules or classes can
# be specified that should not as usual be transformed from CamelCase to
# snake_case (e.g. 'RuboCop' => 'rubocop' ).
#
# With the configuration option `SpecSuffixOnly` test files will only
# be checked to ensure they end in '_spec.rb'. This option disables
# checking for consistency in the test subject or test methods.
#
# @example
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # bad
#   my_class_spec.rb         # describe MyClass, '#method'
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_method_spec.rb  # describe MyClass, '#method'
#
#   # good
#   my_class/method_spec.rb  # describe MyClass, '#method'
# @example when configuration is `IgnoreMethods: true`
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
# @example when configuration is `SpecSuffixOnly: true`
#   # good
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
class RuboCop::Cop::RSpec::FilePath < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup
  include ::RuboCop::Cop::RSpec::Namespace

  def example_group(param0 = T.unsafe(nil)); end
  def on_top_level_example_group(node); end
  def routing_metadata?(param0); end

  private

  def camel_to_snake_case(string); end
  def custom_transform; end
  def ensure_correct_file_path(send_node, example_group, arguments); end
  def expanded_file_path; end
  def expected_path(constant); end

  # @return [Boolean]
  def filename_ends_with?(pattern); end

  # @return [Boolean]
  def ignore_methods?; end

  def name_pattern(method_name); end
  def pattern_for(example_group, arguments); end
  def pattern_for_spec_suffix_only; end

  # @return [Boolean]
  def relevant_rubocop_rspec_file?(_file); end

  # @return [Boolean]
  def routing_spec?(args); end

  # @return [Boolean]
  def routing_spec_path?; end

  # @return [Boolean]
  def spec_suffix_only?; end
end

RuboCop::Cop::RSpec::FilePath::MSG = T.let(T.unsafe(nil), String)

# Helps find the true end location of nodes which might contain heredocs.
module RuboCop::Cop::RSpec::FinalEndLocation
  def final_end_location(start_node); end
end

# Checks if examples are focused.
#
# This cop does not support autocorrection in some cases.
#
# @example
#   # bad
#   describe MyClass, focus: true do
#   end
#
#   describe MyClass, :focus do
#   end
#
#   fdescribe MyClass do
#   end
#
#   # good
#   describe MyClass do
#   end
#
#   # bad
#   fdescribe 'test' do; end
#
#   # good
#   describe 'test' do; end
#
#   # bad
#   fdescribe 'test' do; end
#
#   # good
#   describe 'test' do; end
#
#   # bad
#   shared_examples 'test', focus: true do; end
#
#   # good
#   shared_examples 'test' do; end
#
#   # bad
#   shared_context 'test', focus: true do; end
#
#   # good
#   shared_context 'test' do; end
#
#   # bad (does not support autocorrection)
#   focus 'test' do; end
class RuboCop::Cop::RSpec::Focus < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def focusable_selector?(param0 = T.unsafe(nil)); end
  def focused_block?(param0 = T.unsafe(nil)); end
  def metadata(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def correct_send(corrector, focus); end

  # @yield [node]
  def focus_metadata(node, &block); end

  def with_surrounding(focus); end
end

RuboCop::Cop::RSpec::Focus::MSG = T.let(T.unsafe(nil), String)

# Checks the arguments passed to `before`, `around`, and `after`.
#
# This cop checks for consistent style when specifying RSpec
# hooks which run for each example. There are three supported
# styles: "implicit", "each", and "example." All styles have
# the same behavior.
#
# @example `EnforcedStyle: implicit` (default)
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # good
#   before do
#   # ...
#   end
# @example `EnforcedStyle: each`
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:each) do
#   # ...
#   end
# @example `EnforcedStyle: example`
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:example) do
#   # ...
#   end
class RuboCop::Cop::RSpec::HookArgument < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_numblock(node); end
  def scoped_hook(param0 = T.unsafe(nil)); end
  def unscoped_hook(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, _node, method_send); end
  def check_implicit(method_send); end
  def explicit_message(scope); end
  def hook(node, &block); end

  # @return [Boolean]
  def implicit_style?; end
end

RuboCop::Cop::RSpec::HookArgument::EXPLICIT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::HookArgument::IMPLICIT_MSG = T.let(T.unsafe(nil), String)

# Checks for before/around/after hooks that come after an example.
#
# @example
#   # bad
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   before { prepare }
#   after { clean_up }
#
#   # good
#   before { prepare }
#   after { clean_up }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
class RuboCop::Cop::RSpec::HooksBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_or_group?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_numblock(node); end

  private

  def autocorrect(corrector, node, first_example); end
  def check_hooks(node); end
  def find_first_example(node); end

  # @return [Boolean]
  def multiline_block?(block); end
end

RuboCop::Cop::RSpec::HooksBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks for equality assertions with identical expressions on both sides.
#
# @example
#   # bad
#   expect(foo.bar).to eq(foo.bar)
#   expect(foo.bar).to eql(foo.bar)
#
#   # good
#   expect(foo.bar).to eq(2)
#   expect(foo.bar).to eql(2)
class RuboCop::Cop::RSpec::IdenticalEqualityAssertion < ::RuboCop::Cop::RSpec::Base
  def equality_check?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::IdenticalEqualityAssertion::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::IdenticalEqualityAssertion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that implicit block expectation syntax is not used.
#
# Prefer using explicit block expectations.
#
# @example
#   # bad
#   subject { -> { do_something } }
#   it { is_expected.to change(something).to(new_value) }
#
#   # good
#   it 'changes something to a new value' do
#   expect { do_something }.to change(something).to(new_value)
#   end
class RuboCop::Cop::RSpec::ImplicitBlockExpectation < ::RuboCop::Cop::RSpec::Base
  def implicit_expect(param0 = T.unsafe(nil)); end
  def lambda?(param0 = T.unsafe(nil)); end
  def lambda_subject?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def find_subject(block_node); end

  # @return [Boolean]
  def multi_statement_example_group?(node); end

  def nearest_subject(node); end
end

RuboCop::Cop::RSpec::ImplicitBlockExpectation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitBlockExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that a consistent implicit expectation style is used.
#
# This cop can be configured using the `EnforcedStyle` option
# and supports the `--auto-gen-config` flag.
#
# @example `EnforcedStyle: is_expected` (default)
#   # bad
#   it { should be_truthy }
#
#   # good
#   it { is_expected.to be_truthy }
# @example `EnforcedStyle: should`
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { should be_truthy }
class RuboCop::Cop::RSpec::ImplicitExpect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def implicit_expect(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def is_expected_range(source_map); end
  def offending_expect(node); end
  def offense_message(offending_source); end
  def replacement_source(offending_source); end
end

RuboCop::Cop::RSpec::ImplicitExpect::ENFORCED_REPLACEMENTS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::RSpec::ImplicitExpect::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitExpect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for usage of implicit subject (`is_expected` / `should`).
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: single_line_only` (default)
#   # bad
#   it do
#   is_expected.to be_truthy
#   end
#
#   # good
#   it { is_expected.to be_truthy }
#   it do
#   expect(subject).to be_truthy
#   end
# @example `EnforcedStyle: single_statement_only`
#   # bad
#   it do
#   foo = 1
#   is_expected.to be_truthy
#   end
#
#   # good
#   it do
#   foo = 1
#   expect(subject).to be_truthy
#   end
#   it do
#   is_expected.to be_truthy
#   end
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { expect(subject).to be_truthy }
# @example `EnforcedStyle: require_implicit`
#   # bad
#   it { expect(subject).to be_truthy }
#
#   # good
#   it { is_expected.to be_truthy }
#
#   # bad
#   it do
#   expect(subject).to be_truthy
#   end
#
#   # good
#   it do
#   is_expected.to be_truthy
#   end
#
#   # good
#   it { expect(named_subject).to be_truthy }
class RuboCop::Cop::RSpec::ImplicitSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def explicit_unnamed_subject?(param0 = T.unsafe(nil)); end
  def implicit_subject?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def example_of(node); end

  # @return [Boolean]
  def implicit_subject_in_non_its?(node); end

  # @return [Boolean]
  def implicit_subject_in_non_its_and_non_single_line?(node); end

  # @return [Boolean]
  def implicit_subject_in_non_its_and_non_single_statement?(node); end

  # @return [Boolean]
  def invalid?(node); end

  # @return [Boolean]
  def its?(node); end

  def message(_node); end

  # @return [Boolean]
  def single_line?(node); end

  # @return [Boolean]
  def single_statement?(node); end
end

RuboCop::Cop::RSpec::ImplicitSubject::MSG_REQUIRE_EXPLICIT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitSubject::MSG_REQUIRE_IMPLICIT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitSubject::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Do not set up test data using indexes (e.g., `item_1`, `item_2`).
#
# It makes reading the test harder because it's not clear what exactly
# is tested by this particular example.
#
# The configurable options `AllowedIdentifiers` and `AllowedPatterns`
# will also read those set in `Naming/VariableNumber`.
#
# @example `Max: 1 (default)`
#   # bad
#   let(:item_1) { create(:item) }
#   let(:item_2) { create(:item) }
#
#   let(:item1) { create(:item) }
#   let(:item2) { create(:item) }
#
#   # good
#
#   let(:visible_item) { create(:item, visible: true) }
#   let(:invisible_item) { create(:item, visible: false) }
# @example `Max: 2`
#   # bad
#   let(:item_1) { create(:item) }
#   let(:item_2) { create(:item) }
#   let(:item_3) { create(:item) }
#
#   # good
#   let(:item_1) { create(:item) }
#   let(:item_2) { create(:item) }
# @example `AllowedIdentifiers: ['item_1', 'item_2']`
#   # good
#   let(:item_1) { create(:item) }
#   let(:item_2) { create(:item) }
# @example `AllowedPatterns: ['item']`
#   # good
#   let(:item_1) { create(:item) }
#   let(:item_2) { create(:item) }
class RuboCop::Cop::RSpec::IndexedLet < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::AllowedPattern

  def let_name(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def allowed_identifiers; end
  def cop_config_patterns_values; end
  def filter_indexed_lets(candidates); end

  # @return [Boolean]
  def indexed_let?(node); end

  def let_name_stripped_index(node); end
end

RuboCop::Cop::RSpec::IndexedLet::INDEX_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::RSpec::IndexedLet::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::IndexedLet::SUFFIX_INDEX_REGEX = T.let(T.unsafe(nil), Regexp)

# A helper for `inflected` style
module RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def be_bool?(param0 = T.unsafe(nil)); end
  def be_boolthy?(param0 = T.unsafe(nil)); end
  def predicate_in_actual?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def boolean_matcher?(node); end

  def check_inflected(node); end
  def message_inflected(predicate); end

  # @return [Boolean]
  def predicate?(sym); end

  def remove_predicate(corrector, predicate); end
  def rewrite_matcher(corrector, predicate, matcher); end
  def to_predicate_matcher(name); end

  # @return [Boolean]
  def true?(to_symbol, matcher); end
end

RuboCop::Cop::RSpec::InflectedHelper::MSG_INFLECTED = T.let(T.unsafe(nil), String)

# Helps you identify whether a given node
# is within an example group or not.
module RuboCop::Cop::RSpec::InsideExampleGroup
  private

  # @return [Boolean]
  def example_group_root?(node); end

  # @return [Boolean]
  def example_group_root_with_siblings?(node); end

  # @return [Boolean]
  def inside_example_group?(node); end
end

# Checks for `instance_double` used with `have_received`.
#
# @example
#   # bad
#   it do
#   foo = instance_double(Foo).as_null_object
#   expect(foo).to have_received(:bar)
#   end
#
#   # good
#   it do
#   foo = instance_spy(Foo)
#   expect(foo).to have_received(:bar)
#   end
class RuboCop::Cop::RSpec::InstanceSpy < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def have_received_usage(param0); end
  def null_double(param0); end
  def on_block(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::InstanceSpy::MSG = T.let(T.unsafe(nil), String)

# Checks for instance variable usage in specs.
#
# This cop can be configured with the option `AssignmentOnly` which
# will configure the cop to only register offenses on instance
# variable usage if the instance variable is also assigned within
# the spec
#
# @example
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
# @example with AssignmentOnly configuration
#   # rubocop.yml
#   # RSpec/InstanceVariable:
#   #   AssignmentOnly: true
#
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # allowed
#   describe MyClass do
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
class RuboCop::Cop::RSpec::InstanceVariable < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def custom_matcher?(param0 = T.unsafe(nil)); end
  def dynamic_class?(param0 = T.unsafe(nil)); end
  def ivar_assigned?(param0, param1); end
  def ivar_usage(param0); end
  def on_top_level_group(node); end

  private

  # @return [Boolean]
  def assignment_only?; end

  # @return [Boolean]
  def valid_usage?(node); end
end

RuboCop::Cop::RSpec::InstanceVariable::MSG = T.let(T.unsafe(nil), String)

# Check for `specify` with `is_expected` and one-liner expectations.
#
# @example
#   # bad
#   specify { is_expected.to be_truthy }
#
#   # good
#   it { is_expected.to be_truthy }
#
#   # good
#   specify do
#   # ...
#   end
#   specify { expect(sqrt(4)).to eq(2) }
class RuboCop::Cop::RSpec::IsExpectedSpecify < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def offense?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::IsExpectedSpecify::IS_EXPECTED_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::RSpec::IsExpectedSpecify::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::IsExpectedSpecify::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that only one `it_behaves_like` style is used.
#
# @example `EnforcedStyle: it_behaves_like` (default)
#   # bad
#   it_should_behave_like 'a foo'
#
#   # good
#   it_behaves_like 'a foo'
# @example `EnforcedStyle: it_should_behave_like`
#   # bad
#   it_behaves_like 'a foo'
#
#   # good
#   it_should_behave_like 'a foo'
class RuboCop::Cop::RSpec::ItBehavesLike < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def example_inclusion_offense(param0 = T.unsafe(nil), param1); end
  def on_send(node); end

  private

  def message(_node); end
end

RuboCop::Cop::RSpec::ItBehavesLike::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ItBehavesLike::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that `all` matcher is used instead of iterating over an array.
#
# @example
#   # bad
#   it 'validates users' do
#   [user1, user2, user3].each { |user| expect(user).to be_valid }
#   end
#
#   # good
#   it 'validates users' do
#   expect([user1, user2, user3]).to all(be_valid)
#   end
class RuboCop::Cop::RSpec::IteratedExpectation < ::RuboCop::Cop::RSpec::Base
  def each?(param0 = T.unsafe(nil)); end
  def each_numblock?(param0 = T.unsafe(nil)); end
  def expectation?(param0 = T.unsafe(nil), param1); end
  def on_block(node); end
  def on_numblock(node); end

  private

  # @return [Boolean]
  def only_expectations?(body, arg); end

  # @return [Boolean]
  def single_expectation?(body, arg); end
end

RuboCop::Cop::RSpec::IteratedExpectation::MSG = T.let(T.unsafe(nil), String)

# Enforce that subject is the first definition in the test.
#
# @example
#   # bad
#   let(:params) { blah }
#   subject { described_class.new(params) }
#
#   before { do_something }
#   subject { described_class.new(params) }
#
#   it { expect_something }
#   subject { described_class.new(params) }
#   it { expect_something_else }
#
#   # good
#   subject { described_class.new(params) }
#   let(:params) { blah }
#
#   # good
#   subject { described_class.new(params) }
#   before { do_something }
#
#   # good
#   subject { described_class.new(params) }
#   it { expect_something }
#   it { expect_something_else }
class RuboCop::Cop::RSpec::LeadingSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, node, sibling); end
  def check_previous_nodes(node); end

  # @return [Boolean]
  def offending?(node); end

  def offending_node(node); end
  def parent(node); end
end

RuboCop::Cop::RSpec::LeadingSubject::MSG = T.let(T.unsafe(nil), String)

# Checks that no class, module, or constant is declared.
#
# Constants, including classes and modules, when declared in a block
# scope, are defined in global namespace, and leak between examples.
#
# If several examples may define a `DummyClass`, instead of being a
# blank slate class as it will be in the first example, subsequent
# examples will be reopening it and modifying its behavior in
# unpredictable ways.
# Even worse when a class that exists in the codebase is reopened.
#
# Anonymous classes are fine, since they don't result in global
# namespace name clashes.
#
# @example Constants leak between examples
#   # bad
#   describe SomeClass do
#   OtherClass = Struct.new
#   CONSTANT_HERE = 'I leak into global namespace'
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   stub_const('OtherClass', Struct.new)
#   stub_const('CONSTANT_HERE', 'I only exist during this example')
#   end
#   end
# @example
#   # bad
#   describe SomeClass do
#   class FooClass < described_class
#   def double_that
#   some_base_method * 2
#   end
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
#
#   # good - anonymous class, no constant needs to be defined
#   describe SomeClass do
#   let(:foo_class) do
#   Class.new(described_class) do
#   def double_that
#   some_base_method * 2
#   end
#   end
#   end
#
#   it { expect(foo_class.new.double_that).to eq(4) }
#   end
#
#   # good - constant is stubbed
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('FooClass', foo_class)
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
# @example
#   # bad
#   describe SomeClass do
#   module SomeModule
#   class SomeClass
#   def do_something
#   end
#   end
#   end
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('SomeModule::SomeClass', foo_class)
#   end
#   end
# @see https://rspec.info/features/3-12/rspec-mocks/mutating-constants
class RuboCop::Cop::RSpec::LeakyConstantDeclaration < ::RuboCop::Cop::RSpec::Base
  def on_casgn(node); end
  def on_class(node); end
  def on_module(node); end

  private

  # @return [Boolean]
  def inside_describe_block?(node); end
end

RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CLASS = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CONST = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_MODULE = T.let(T.unsafe(nil), String)

# Checks for `let` definitions that come after an example.
#
# @example
#   # bad
#   let(:foo) { bar }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   let(:some) { other }
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
#
#   # good
#   let(:foo) { bar }
#   let(:some) { other }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
class RuboCop::Cop::RSpec::LetBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_or_group?(param0 = T.unsafe(nil)); end
  def include_examples?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, first_example); end
  def check_let_declarations(node); end

  # @return [Boolean]
  def example_group_with_include_examples?(body); end

  def find_first_example(node); end

  # @return [Boolean]
  def multiline_block?(block); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::LetBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks unreferenced `let!` calls being used for test setup.
#
# @example
#   # bad
#   let!(:my_widget) { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
#
#   # good
#   it 'counts widgets' do
#   create(:widget)
#   expect(Widget.count).to eq(1)
#   end
#
#   # good
#   before { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
class RuboCop::Cop::RSpec::LetSetup < ::RuboCop::Cop::RSpec::Base
  def example_or_shared_group_or_including?(param0 = T.unsafe(nil)); end
  def let_bang(param0 = T.unsafe(nil)); end
  def method_called?(param0, param1); end
  def on_block(node); end

  private

  def child_let_bang(node, &block); end
  def unused_let_bang(node); end
end

RuboCop::Cop::RSpec::LetSetup::MSG = T.let(T.unsafe(nil), String)

# Helper methods to location.
module RuboCop::Cop::RSpec::LocationHelp
  private

  # @example
  #   foo 1, 2
  #   ^^^^^
  # @param node [RuboCop::AST::SendNode]
  # @return [Parser::Source::Range]
  def arguments_with_whitespace(node); end

  # @example
  #   foo { bar }
  #   ^^^^^^^^
  # @param node [RuboCop::AST::SendNode]
  # @return [Parser::Source::Range]
  def block_with_whitespace(node); end

  class << self
    # @example
    #   foo 1, 2
    #   ^^^^^
    # @param node [RuboCop::AST::SendNode]
    # @return [Parser::Source::Range]
    def arguments_with_whitespace(node); end

    # @example
    #   foo { bar }
    #   ^^^^^^^^
    # @param node [RuboCop::AST::SendNode]
    # @return [Parser::Source::Range]
    def block_with_whitespace(node); end
  end
end

# Checks where `match_array` is used.
#
# This cop checks for the following:
# - Prefer `contain_exactly` when matching an array with values.
# - Prefer `eq` when using `match_array` with an empty array literal.
#
# @example
#   # bad
#   it { is_expected.to match_array([content1, content2]) }
#
#   # good
#   it { is_expected.to contain_exactly(content1, content2) }
#
#   # good
#   it { is_expected.to match_array([content] + array) }
#
#   # good
#   it { is_expected.to match_array(%w(tremble in fear foolish mortals)) }
class RuboCop::Cop::RSpec::MatchArray < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def match_array_with_empty_array?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_populated_array(node); end
end

RuboCop::Cop::RSpec::MatchArray::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MatchArray::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that chains of messages are not being stubbed.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar, :baz).and_return(42)
#
#   # good
#   thing = Thing.new(baz: 42)
#   allow(foo).to receive(:bar).and_return(thing)
class RuboCop::Cop::RSpec::MessageChain < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
end

RuboCop::Cop::RSpec::MessageChain::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for consistent message expectation style.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: allow` (default)
#
#   # bad
#   expect(foo).to receive(:bar)
#
#   # good
#   allow(foo).to receive(:bar)
# @example `EnforcedStyle: expect`
#
#   # bad
#   allow(foo).to receive(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
class RuboCop::Cop::RSpec::MessageExpectation < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def message_expectation(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def receive_message?(param0); end

  private

  # @return [Boolean]
  def preferred_style?(expectation); end
end

RuboCop::Cop::RSpec::MessageExpectation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that message expectations are set using spies.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: have_received` (default)
#
#   # bad
#   expect(foo).to receive(:bar)
#   do_something
#
#   # good
#   allow(foo).to receive(:bar) # or use instance_spy
#   do_something
#   expect(foo).to have_received(:bar)
# @example `EnforcedStyle: receive`
#
#   # bad
#   allow(foo).to receive(:bar)
#   do_something
#   expect(foo).to have_received(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
#   do_something
class RuboCop::Cop::RSpec::MessageSpies < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def message_expectation(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def receive_message(param0); end

  private

  def error_message(receiver); end

  # @return [Boolean]
  def preferred_style?(expectation); end

  def receive_message_matcher(node); end
end

RuboCop::Cop::RSpec::MessageSpies::MSG_HAVE_RECEIVED = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageSpies::MSG_RECEIVE = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageSpies::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Helper methods to find RSpec metadata.
module RuboCop::Cop::RSpec::Metadata
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def metadata_in_block(param0, param1); end
  def on_block(node); end

  # @raise [::NotImplementedError]
  def on_metadata(_symbols, _hash); end

  def on_numblock(node); end
  def rspec_configure(param0 = T.unsafe(nil)); end
  def rspec_metadata(param0 = T.unsafe(nil)); end

  private

  def on_metadata_arguments(metadata_arguments); end
end

# Use consistent metadata style.
#
# This cop does not support autocorrection in the case of
# `EnforcedStyle: hash` where the trailing metadata type is ambiguous.
# (e.g. `describe 'Something', :a, b`)
#
# @example EnforcedStyle: symbol (default)
#   # bad
#   describe 'Something', a: true
#
#   # good
#   describe 'Something', :a
# @example EnforcedStyle: hash
#   # bad
#   describe 'Something', :a
#
#   # good
#   describe 'Something', a: true
class RuboCop::Cop::RSpec::MetadataStyle < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::Metadata
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def extract_metadata_hash(param0 = T.unsafe(nil)); end
  def match_ambiguous_trailing_metadata?(param0 = T.unsafe(nil)); end
  def match_boolean_metadata_pair?(param0 = T.unsafe(nil)); end
  def on_metadata(symbols, hash); end

  private

  def autocorrect_pair(corrector, node); end
  def autocorrect_symbol(corrector, node); end

  # @return [Boolean]
  def bad_metadata_pair?(node); end

  # @return [Boolean]
  def bad_metadata_symbol?(_node); end

  def format_symbol_to_pair_source(node); end
  def insert_pair(corrector, node); end
  def insert_pair_as_last_argument(corrector, node); end
  def insert_pair_to_empty_hash_metadata(corrector, node, hash_node); end
  def insert_pair_to_non_empty_hash_metadata(corrector, node, hash_node); end
  def insert_symbol(corrector, node); end
  def message_for_style; end
  def on_metadata_pair(node); end
  def on_metadata_symbol(node); end
  def remove_pair(corrector, node); end
  def remove_pair_following(corrector, node); end
  def remove_pair_preceding(corrector, node); end
  def remove_symbol(corrector, node); end
end

# Checks that the first argument to an example group is not empty.
#
# @example
#   # bad
#   describe do
#   end
#
#   RSpec.describe do
#   end
#
#   # good
#   describe TestedClass do
#   end
#
#   describe "A feature example" do
#   end
class RuboCop::Cop::RSpec::MissingExampleGroupArgument < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end
end

RuboCop::Cop::RSpec::MissingExampleGroupArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for multiple top-level example groups.
#
# Multiple descriptions for the same class or module should either
# be nested or separated into different test files.
#
# @example
#   # bad
#   describe MyClass, '.do_something' do
#   end
#   describe MyClass, '.do_something_else' do
#   end
#
#   # good
#   describe MyClass do
#   describe '.do_something' do
#   end
#   describe '.do_something_else' do
#   end
#   end
class RuboCop::Cop::RSpec::MultipleDescribes < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end
end

RuboCop::Cop::RSpec::MultipleDescribes::MSG = T.let(T.unsafe(nil), String)

# Checks if examples contain too many `expect` calls.
#
# This cop is configurable using the `Max` option
# and works with `--auto-gen-config`.
#
# @example
#   # bad
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
#
#   # good
#   describe UserCreator do
#   it 'sets the users name' do
#   expect(user.name).to eq("John")
#   end
#
#   it 'sets the users age' do
#   expect(user.age).to eq(22)
#   end
#   end
# @example `aggregate_failures: true` (default)
#   # good - the cop ignores when RSpec aggregates failures
#   describe UserCreator do
#   it 'builds a user', :aggregate_failures do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @example `aggregate_failures: false`
#   # Detected as an offense
#   describe UserCreator do
#   it 'builds a user', aggregate_failures: false do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @example `Max: 1` (default)
#   # bad
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @example `Max: 2`
#   # good
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @see http://betterspecs.org/#single Single expectation test
class RuboCop::Cop::RSpec::MultipleExpectations < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax

  def aggregate_failures?(param0 = T.unsafe(nil), param1); end
  def aggregate_failures_block?(param0 = T.unsafe(nil)); end
  def expect?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def example_with_aggregate_failures?(example_node); end

  def find_aggregate_failures(example_node); end
  def find_expectation(node, &block); end
  def flag_example(node, expectation_count:); end
  def max_expectations; end
end

RuboCop::Cop::RSpec::MultipleExpectations::ANYTHING = T.let(T.unsafe(nil), Proc)
RuboCop::Cop::RSpec::MultipleExpectations::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MultipleExpectations::TRUE = T.let(T.unsafe(nil), Proc)

# Checks if example groups contain too many `let` and `subject` calls.
#
# This cop is configurable using the `Max` option and the `AllowSubject`
# which will configure the cop to only register offenses on calls to
# `let` and not calls to `subject`.
#
# @example
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#
#   context 'when stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
#
#   # good
#   describe MyClass do
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   context 'when stuff' do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:booger) { [] }
#   end
#
#   context 'when other stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
# @example when disabling AllowSubject configuration
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   AllowSubject: false
#
#   # bad - `subject` counts towards memoized helpers
#   describe MyClass do
#   subject { {} }
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   end
# @example with Max configuration
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   Max: 1
#
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   end
class RuboCop::Cop::RSpec::MultipleMemoizedHelpers < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::Variable

  def on_block(node); end
  def on_new_investigation; end

  private

  def all_helpers(node); end

  # @return [Boolean]
  def allow_subject?; end

  # Returns the value of attribute example_group_memoized_helpers.
  def example_group_memoized_helpers; end

  def helpers(node); end
  def max; end
  def variable_nodes(node); end
end

RuboCop::Cop::RSpec::MultipleMemoizedHelpers::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group defines `subject` multiple times.
#
# This cop does not support autocorrection in some cases.
# The autocorrect behavior for this cop depends on the type of
# duplication:
#
#   - If multiple named subjects are defined then this probably indicates
#     that the overwritten subjects (all subjects except the last
#     definition) are effectively being used to define helpers. In this
#     case they are replaced with `let`.
#
#   - If multiple unnamed subjects are defined though then this can *only*
#     be dead code and we remove the overwritten subject definitions.
#
#   - If subjects are defined with `subject!` then we don't autocorrect.
#     This is enough of an edge case that people can just move this to
#     a `before` hook on their own
#
# @example
#   # bad
#   describe Foo do
#   subject(:user) { User.new }
#   subject(:post) { Post.new }
#   end
#
#   # good
#   describe Foo do
#   let(:user) { User.new }
#   subject(:post) { Post.new }
#   end
#
#   # bad (does not support autocorrection)
#   describe Foo do
#   subject!(:user) { User.new }
#   subject!(:post) { Post.new }
#   end
#
#   # good
#   describe Foo do
#   before do
#   User.new
#   Post.new
#   end
#   end
class RuboCop::Cop::RSpec::MultipleSubjects < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, subject); end

  # @return [Boolean]
  def named_subject?(node); end

  def remove_autocorrect(corrector, node); end
  def rename_autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::MultipleSubjects::MSG = T.let(T.unsafe(nil), String)

# Checks for explicitly referenced test subjects.
#
# RSpec lets you declare an "implicit subject" using `subject { ... }`
# which allows for tests like `it { is_expected.to be_valid }`.
# If you need to reference your test subject you should explicitly
# name it using `subject(:your_subject_name) { ... }`. Your test subjects
# should be the most important object in your tests so they deserve
# a descriptive name.
#
# This cop can be configured in your configuration using `EnforcedStyle`,
# and `IgnoreSharedExamples` which will not report offenses for implicit
# subjects in shared example groups.
#
# @example `EnforcedStyle: always` (default)
#   # bad
#   RSpec.describe User do
#   subject { described_class.new }
#
#   it 'is valid' do
#   expect(subject.valid?).to be(true)
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   subject(:user) { described_class.new }
#
#   it 'is valid' do
#   expect(user.valid?).to be(true)
#   end
#   end
#
#   # also good
#   RSpec.describe User do
#   subject(:user) { described_class.new }
#
#   it { is_expected.to be_valid }
#   end
# @example `EnforcedStyle: named_only`
#   # bad
#   RSpec.describe User do
#   subject(:user) { described_class.new }
#
#   it 'is valid' do
#   expect(subject.valid?).to be(true)
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   subject(:user) { described_class.new }
#
#   it 'is valid' do
#   expect(user.valid?).to be(true)
#   end
#   end
#
#   # also good
#   RSpec.describe User do
#   subject { described_class.new }
#
#   it { is_expected.to be_valid }
#   end
#
#   # acceptable
#   RSpec.describe User do
#   subject { described_class.new }
#
#   it 'is valid' do
#   expect(subject.valid?).to be(true)
#   end
#   end
class RuboCop::Cop::RSpec::NamedSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def example_or_hook_block?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def shared_example?(param0 = T.unsafe(nil)); end
  def subject_usage(param0); end

  private

  # @return [Boolean]
  def allow_explicit_subject?(node); end

  # @return [Boolean]
  def always?; end

  def check_explicit_subject(node); end
  def find_subject(block_node); end

  # @return [Boolean]
  def ignored_shared_example?(node); end

  # @return [Boolean]
  def named_only?(node); end

  def nearest_subject(node); end

  # @return [Boolean]
  def subject_definition_is_named?(node); end
end

RuboCop::Cop::RSpec::NamedSubject::MSG = T.let(T.unsafe(nil), String)

# Helps to find namespace of the node.
module RuboCop::Cop::RSpec::Namespace
  private

  # @example
  #   namespace(node) # => ['A', 'B', 'C']
  # @param node [RuboCop::AST::Node]
  # @return [Array<String>]
  def namespace(node); end
end

# Checks for nested example groups.
#
# This cop is configurable using the `Max` option
# and supports `--auto-gen-config`.
#
# @example
#   # bad
#   context 'when using some feature' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   context 'when user is signed in' do  # flagged by rubocop
#   let(:user) do
#   UserCreate.call(user_attributes)
#   end
#
#   let(:user_attributes) do
#   {
#   name: 'John',
#   age:  22,
#   role: role
#   }
#   end
#
#   context 'when user is an admin' do # flagged by rubocop
#   let(:role) { 'admin' }
#
#   it 'blah blah'
#   it 'yada yada'
#   end
#   end
#   end
#
#   # good
#   context 'using some feature as an admin' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   let(:user) do
#   UserCreate.call(
#   name: 'John',
#   age:  22,
#   role: 'admin'
#   )
#   end
#
#   it 'blah blah'
#   it 'yada yada'
#   end
# @example `Max: 3` (default)
#   # bad
#   describe Foo do
#   context 'foo' do
#   context 'bar' do
#   context 'baz' do # flagged by rubocop
#   end
#   end
#   end
#   end
# @example `Max: 2`
#   # bad
#   describe Foo do
#   context 'foo' do
#   context 'bar' do # flagged by rubocop
#   context 'baz' do # flagged by rubocop
#   end
#   end
#   end
#   end
# @example `AllowedGroups: [] (default)`
#   describe Foo do # <-- nested groups 1
#   context 'foo' do # <-- nested groups 2
#   context 'bar' do # <-- nested groups 3
#   end
#   end
#   end
# @example `AllowedGroups: [path]`
#   describe Foo do # <-- nested groups 1
#   path '/foo' do # <-- nested groups 1 (not counted)
#   context 'bar' do # <-- nested groups 2
#   end
#   end
#   end
class RuboCop::Cop::RSpec::NestedGroups < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end

  private

  def allowed_groups; end

  # @return [Boolean]
  def count_up_nesting?(node, example_group); end

  # @yield [node, nesting]
  def find_nested_example_groups(node, nesting: T.unsafe(nil), &block); end

  def max_nesting; end
  def max_nesting_config; end
  def message(nesting); end
end

RuboCop::Cop::RSpec::NestedGroups::DEPRECATED_MAX_KEY = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NestedGroups::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NestedGroups::MSG = T.let(T.unsafe(nil), String)

# Checks if an example contains any expectation.
#
# All RSpec's example and expectation methods are covered by default.
# If you are using your own custom methods,
# add the following configuration:
#
#   RSpec:
#     Language:
#       Examples:
#         Regular:
#           - custom_it
#       Expectations:
#         - custom_expect
#
# This cop can be customized with an allowed expectation methods pattern
# with an `AllowedPatterns` option. ^expect_ and ^assert_ are allowed
# by default.
#
# @example
#   # bad
#   it do
#   a?
#   end
#
#   # good
#   it do
#   expect(a?).to be(true)
#   end
# @example `AllowedPatterns` configuration
#
#   # .rubocop.yml
#   # RSpec/NoExpectationExample:
#   #   AllowedPatterns:
#   #     - ^expect_
#   #     - ^assert_
# @example
#   # bad
#   it do
#   not_expect_something
#   end
#
#   # good
#   it do
#   expect_something
#   end
#
#   it do
#   assert_something
#   end
class RuboCop::Cop::RSpec::NoExpectationExample < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RSpec::SkipOrPending

  # @param node [RuboCop::AST::Node]
  # @return [Boolean]
  def includes_expectation?(param0); end

  # @param node [RuboCop::AST::Node]
  # @return [Boolean]
  def includes_skip_example?(param0); end

  # @param node [RuboCop::AST::BlockNode]
  def on_block(node); end

  # @param node [RuboCop::AST::BlockNode]
  def on_numblock(node); end

  # @param node [RuboCop::AST::Node]
  # @return [Boolean]
  def regular_or_focused_example?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::NoExpectationExample::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent method usage for negating expectations.
#
# @example `EnforcedStyle: not_to` (default)
#   # bad
#   it '...' do
#   expect(false).to_not be_true
#   end
#
#   # good
#   it '...' do
#   expect(false).not_to be_true
#   end
# @example `EnforcedStyle: to_not`
#   # bad
#   it '...' do
#   expect(false).not_to be_true
#   end
#
#   # good
#   it '...' do
#   expect(false).to_not be_true
#   end
class RuboCop::Cop::RSpec::NotToNot < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def not_to_not_offense(param0 = T.unsafe(nil), param1); end
  def on_send(node); end

  private

  def message(_node); end
end

RuboCop::Cop::RSpec::NotToNot::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NotToNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks if there is a let/subject that overwrites an existing one.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:foo) { baz }
#
#   subject(:foo) { bar }
#   let(:foo) { baz }
#
#   let(:foo) { bar }
#   let!(:foo) { baz }
#
#   # good
#   subject(:test) { something }
#   let(:foo) { bar }
#   let(:baz) { baz }
#   let!(:other) { other }
class RuboCop::Cop::RSpec::OverwritingSetup < ::RuboCop::Cop::RSpec::Base
  def first_argument_name(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def setup?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def common_setup?(node); end

  def find_duplicates(node); end
end

RuboCop::Cop::RSpec::OverwritingSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for any pending or skipped examples.
#
# @example
#   # bad
#   describe MyClass do
#   it "should be true"
#   end
#
#   describe MyClass do
#   it "should be true", skip: true do
#   expect(1).to eq(2)
#   end
#   end
#
#   describe MyClass do
#   it "should be true" do
#   pending
#   end
#   end
#
#   describe MyClass do
#   xit "should be true" do
#   end
#   end
#
#   # good
#   describe MyClass do
#   end
class RuboCop::Cop::RSpec::Pending < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::SkipOrPending

  def on_send(node); end
  def pending_block?(param0 = T.unsafe(nil)); end
  def skippable?(param0 = T.unsafe(nil)); end
  def skippable_example?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def skipped?(node); end

  # @return [Boolean]
  def skipped_regular_example_without_body?(node); end
end

RuboCop::Cop::RSpec::Pending::MSG = T.let(T.unsafe(nil), String)

# Checks for pending or skipped examples without reason.
#
# @example
#   # bad
#   pending 'does something' do
#   end
#
#   # bad
#   it 'does something', :pending do
#   end
#
#   # bad
#   it 'does something' do
#   pending
#   end
#
#   # bad
#   xdescribe 'something' do
#   end
#
#   # bad
#   skip 'does something' do
#   end
#
#   # bad
#   it 'does something', :skip do
#   end
#
#   # bad
#   it 'does something' do
#   skip
#   end
#
#   # bad
#   it 'does something'
#
#   # good
#   it 'does something' do
#   pending 'reason'
#   end
#
#   # good
#   it 'does something' do
#   skip 'reason'
#   end
#
#   # good
#   it 'does something', pending: 'reason' do
#   end
#
#   # good
#   it 'does something', skip: 'reason' do
#   end
class RuboCop::Cop::RSpec::PendingWithoutReason < ::RuboCop::Cop::RSpec::Base
  def metadata_without_reason?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def pending_step_without_reason?(param0 = T.unsafe(nil)); end
  def skipped_by_example_group_method?(param0 = T.unsafe(nil)); end
  def skipped_by_example_method?(param0 = T.unsafe(nil)); end
  def skipped_by_example_method_with_block?(param0 = T.unsafe(nil)); end
  def skipped_in_example?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def block_node_example_group?(node); end

  def on_pending_by_metadata(node); end
  def on_skipped_by_example_group_method(node); end
  def on_skipped_by_example_method(node); end
  def on_skipped_by_in_example_method(node); end
  def parent_node(node); end
end

RuboCop::Cop::RSpec::PendingWithoutReason::MSG = T.let(T.unsafe(nil), String)

# Prefer using predicate matcher over using predicate method directly.
#
# RSpec defines magic matchers for predicate methods.
# This cop recommends to use the predicate matcher instead of using
# predicate method directly.
#
# @example Strict: true, EnforcedStyle: inflected (default)
#   # bad
#   expect(foo.something?).to be_truthy
#
#   # good
#   expect(foo).to be_something
#
#   # also good - It checks "true" strictly.
#   expect(foo.something?).to be(true)
# @example Strict: false, EnforcedStyle: inflected
#   # bad
#   expect(foo.something?).to be_truthy
#   expect(foo.something?).to be(true)
#
#   # good
#   expect(foo).to be_something
# @example Strict: true, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be(true)
#
#   # bad - no autocorrect
#   expect(foo)
#   .to be_something(<<~TEXT)
#   bar
#   TEXT
#
#   # good
#   expect(foo.something?(<<~TEXT)).to be(true)
#   bar
#   TEXT
# @example Strict: false, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be_truthy
class RuboCop::Cop::RSpec::PredicateMatcher < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::Cop::RSpec::ExplicitHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::PredicateMatcher::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
module RuboCop::Cop::RSpec::Rails; end

# Checks that tests use RSpec `before` hook over Rails `setup`
# method.
#
# @example
#   # bad
#   setup do
#   allow(foo).to receive(:bar)
#   end
#
#   # good
#   before do
#   allow(foo).to receive(:bar)
#   end
RuboCop::Cop::RSpec::Rails::AvoidSetupHook = RuboCop::Cop::RSpecRails::AvoidSetupHook

# Checks that tests use `have_http_status` instead of equality matchers.
#
# @example ResponseMethods: ['response', 'last_response'] (default)
#   # bad
#   expect(response.status).to be(200)
#   expect(last_response.code).to eq("200")
#
#   # good
#   expect(response).to have_http_status(200)
#   expect(last_response).to have_http_status(200)
# @example ResponseMethods: ['foo_response']
#   # bad
#   expect(foo_response.status).to be(200)
#
#   # good
#   expect(foo_response).to have_http_status(200)
#
#   # also good
#   expect(response).to have_http_status(200)
#   expect(last_response).to have_http_status(200)
RuboCop::Cop::RSpec::Rails::HaveHttpStatus = RuboCop::Cop::RSpecRails::HaveHttpStatus

# Enforces use of symbolic or numeric value to describe HTTP status.
#
# This cop inspects only `have_http_status` calls.
# So, this cop does not check if a method starting with `be_*` is
# used when setting for `EnforcedStyle: symbolic` or
# `EnforcedStyle: numeric`.
#
# @example `EnforcedStyle: symbolic` (default)
#   # bad
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status "403" }
#
#   # good
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status :forbidden }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: numeric`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status "forbidden" }
#
#   # good
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status 403 }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: be_status`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status "forbidden" }
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status "403" }
#
#   # good
#   it { is_expected.to be_ok }
#   it { is_expected.to be_not_found }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
RuboCop::Cop::RSpec::Rails::HttpStatus = RuboCop::Cop::RSpecRails::HttpStatus

# Identifies redundant spec type.
#
# After setting up rspec-rails, you will have enabled
# `config.infer_spec_type_from_file_location!` by default in
# spec/rails_helper.rb. This cop works in conjunction with
# this config.
# If you disable this config, disable this cop as well.
#
# @example
#   # bad
#   # spec/models/user_spec.rb
#   RSpec.describe User, type: :model do
#   end
#
#   # good
#   # spec/models/user_spec.rb
#   RSpec.describe User do
#   end
#
#   # good
#   # spec/models/user_spec.rb
#   RSpec.describe User, type: :common do
#   end
# @example `Inferences` configuration
#   # .rubocop.yml
#   # RSpec/Rails/InferredSpecType:
#   #   Inferences:
#   #     services: service
#
#   # bad
#   # spec/services/user_spec.rb
#   RSpec.describe User, type: :service do
#   end
#
#   # good
#   # spec/services/user_spec.rb
#   RSpec.describe User do
#   end
#
#   # good
#   # spec/services/user_spec.rb
#   RSpec.describe User, type: :common do
#   end
RuboCop::Cop::RSpec::Rails::InferredSpecType = RuboCop::Cop::RSpecRails::InferredSpecType

# Check if using Minitest-like matchers.
#
# Check the use of minitest-like matchers
# starting with `assert_` or `refute_`.
#
# @example
#   # bad
#   assert_equal(a, b)
#   assert_equal a, b, "must be equal"
#   assert_not_includes a, b
#   refute_equal(a, b)
#   assert_nil a
#   refute_empty(b)
#   assert_true(a)
#   assert_false(a)
#
#   # good
#   expect(b).to eq(a)
#   expect(b).to(eq(a), "must be equal")
#   expect(a).not_to include(b)
#   expect(b).not_to eq(a)
#   expect(a).to eq(nil)
#   expect(a).not_to be_empty
#   expect(a).to be(true)
#   expect(a).to be(false)
RuboCop::Cop::RSpec::Rails::MinitestAssertions = RuboCop::Cop::RSpecRails::MinitestAssertions

# Enforces use of `be_invalid` or `not_to` for negated be_valid.
#
# @example EnforcedStyle: not_to (default)
#   # bad
#   expect(foo).to be_invalid
#
#   # good
#   expect(foo).not_to be_valid
#
#   # good (with method chain)
#   expect(foo).to be_invalid.and be_odd
# @example EnforcedStyle: be_invalid
#   # bad
#   expect(foo).not_to be_valid
#
#   # good
#   expect(foo).to be_invalid
#
#   # good (with method chain)
#   expect(foo).to be_invalid.or be_even
RuboCop::Cop::RSpec::Rails::NegationBeValid = RuboCop::Cop::RSpecRails::NegationBeValid

# Prefer to travel in `before` rather than `around`.
#
# @example
#   # bad
#   around do |example|
#   freeze_time do
#   example.run
#   end
#   end
#
#   # good
#   before { freeze_time }
RuboCop::Cop::RSpec::Rails::TravelAround = RuboCop::Cop::RSpecRails::TravelAround

# Check for `once` and `twice` receive counts matchers usage.
#
# @example
#   # bad
#   expect(foo).to receive(:bar).exactly(1).times
#   expect(foo).to receive(:bar).exactly(2).times
#   expect(foo).to receive(:bar).at_least(1).times
#   expect(foo).to receive(:bar).at_least(2).times
#   expect(foo).to receive(:bar).at_most(1).times
#   expect(foo).to receive(:bar).at_most(2).times
#
#   # good
#   expect(foo).to receive(:bar).once
#   expect(foo).to receive(:bar).twice
#   expect(foo).to receive(:bar).at_least(:once)
#   expect(foo).to receive(:bar).at_least(:twice)
#   expect(foo).to receive(:bar).at_most(:once)
#   expect(foo).to receive(:bar).at_most(:twice).times
class RuboCop::Cop::RSpec::ReceiveCounts < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def receive_counts(param0 = T.unsafe(nil)); end
  def stub?(param0); end

  private

  def autocorrect(corrector, node, range); end
  def matcher_for(method, count); end
  def message_for(node, source); end
  def range(node, offending_node); end
end

RuboCop::Cop::RSpec::ReceiveCounts::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReceiveCounts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for multiple messages stubbed on the same object.
#
# @example
#   # bad
#   before do
#   allow(Service).to receive(:foo).and_return(bar)
#   allow(Service).to receive(:baz).and_return(qux)
#   end
#
#   # good
#   before do
#   allow(Service).to receive_messages(foo: bar, baz: qux)
#   end
#
#   # good - ignore same message
#   before do
#   allow(Service).to receive(:foo).and_return(bar)
#   allow(Service).to receive(:foo).and_return(qux)
#   end
class RuboCop::Cop::RSpec::ReceiveMessages < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def allow_argument(param0 = T.unsafe(nil)); end
  def allow_receive_message?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def receive_and_return_argument(param0 = T.unsafe(nil)); end
  def receive_arg(param0); end
  def receive_node(param0); end

  private

  def add_repeated_lines_and_arguments(items); end
  def arguments(items); end

  # @return [Boolean]
  def heredoc_or_splat?(node); end

  def item_range_by_whole_lines(item); end
  def message(repeated_lines); end
  def normalize_receive_arg(receive_arg); end
  def normalize_return_arg(return_arg); end
  def register_offense(item, repeated_lines, args); end
  def repeated_receive_message(node); end
  def replace_to_receive_messages(corrector, item, args); end

  # @return [Boolean]
  def requires_quotes?(value); end

  def uniq_items(items); end
end

RuboCop::Cop::RSpec::ReceiveMessages::MSG = T.let(T.unsafe(nil), String)

# Prefer `not_to receive(...)` over `receive(...).never`.
#
# @example
#   # bad
#   expect(foo).to receive(:bar).never
#
#   # good
#   expect(foo).not_to receive(:bar)
class RuboCop::Cop::RSpec::ReceiveNever < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def method_on_stub?(param0); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::ReceiveNever::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReceiveNever::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Remove redundant `around` hook.
#
# @example
#   # bad
#   around do |example|
#   example.run
#   end
#
#   # good
class RuboCop::Cop::RSpec::RedundantAround < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def match_redundant_around_hook_block?(param0 = T.unsafe(nil)); end
  def match_redundant_around_hook_send?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_numblock(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::RedundantAround::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::RedundantAround::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for redundant predicate matcher.
#
# @example
#   # bad
#   expect(foo).to be_exist(bar)
#   expect(foo).not_to be_include(bar)
#   expect(foo).to be_all(bar)
#
#   # good
#   expect(foo).to exist(bar)
#   expect(foo).not_to include(bar)
#   expect(foo).to all be(bar)
class RuboCop::Cop::RSpec::RedundantPredicateMatcher < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def message(bad_method, good_method); end

  # @return [Boolean]
  def replaceable_arguments?(node); end

  def replaced_method_name(method_name); end
end

RuboCop::Cop::RSpec::RedundantPredicateMatcher::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::RedundantPredicateMatcher::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that `remove_const` is not used in specs.
#
# @example
#   # bad
#   it 'does something' do
#   Object.send(:remove_const, :SomeConstant)
#   end
#
#   before do
#   SomeClass.send(:remove_const, :SomeConstant)
#   end
class RuboCop::Cop::RSpec::RemoveConst < ::RuboCop::Cop::RSpec::Base
  # Check for offenses
  def on_send(node); end

  def remove_const(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::RemoveConst::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::RemoveConst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for repeated description strings in example groups.
#
# @example
#   # bad
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid when first and last name are present' do
#   # ...
#   end
#
#   it 'is valid when last name only is present' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid', :flag do
#   # ...
#   end
#   end
class RuboCop::Cop::RSpec::RepeatedDescription < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end

  private

  def example_signature(example); end
  def its_signature(example); end

  # Select examples in the current scope with repeated description strings
  def repeated_descriptions(node); end

  def repeated_its(node); end
end

RuboCop::Cop::RSpec::RepeatedDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated examples within example groups.
#
# @example
#
#   it 'is valid' do
#   expect(user).to be_valid
#   end
#
#   it 'validates the user' do
#   expect(user).to be_valid
#   end
class RuboCop::Cop::RSpec::RepeatedExample < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end

  private

  def example_signature(example); end
  def repeated_examples(node); end
end

RuboCop::Cop::RSpec::RepeatedExample::MSG = T.let(T.unsafe(nil), String)

# Check for repeated describe and context block body.
#
# @example
#   # bad
#   describe 'cool feature x' do
#   it { cool_predicate }
#   end
#
#   describe 'cool feature y' do
#   it { cool_predicate }
#   end
#
#   # good
#   describe 'cool feature' do
#   it { cool_predicate }
#   end
#
#   describe 'another cool feature' do
#   it { another_predicate }
#   end
#
#   # good
#   context 'when case x', :tag do
#   it { cool_predicate }
#   end
#
#   context 'when case y' do
#   it { cool_predicate }
#   end
#
#   # good
#   context Array do
#   it { is_expected.to respond_to :each }
#   end
#
#   context Hash do
#   it { is_expected.to respond_to :each }
#   end
class RuboCop::Cop::RSpec::RepeatedExampleGroupBody < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::SkipOrPending

  def body(param0 = T.unsafe(nil)); end
  def const_arg(param0 = T.unsafe(nil)); end
  def metadata(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_example_groups?(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(groups); end
  def message(group, repeats); end
  def repeated_group_bodies(node); end
  def signature_keys(group); end
end

RuboCop::Cop::RSpec::RepeatedExampleGroupBody::MSG = T.let(T.unsafe(nil), String)

# Check for repeated example group descriptions.
#
# @example
#   # bad
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'cool feature' do
#   # example group
#   end
#
#   # bad
#   context 'when case x' do
#   # example group
#   end
#
#   describe 'when case x' do
#   # example group
#   end
#
#   # good
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'another cool feature' do
#   # example group
#   end
#
#   # good
#   context 'when case x' do
#   # example group
#   end
#
#   context 'when another case' do
#   # example group
#   end
class RuboCop::Cop::RSpec::RepeatedExampleGroupDescription < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::SkipOrPending

  def doc_string_and_metadata(param0 = T.unsafe(nil)); end
  def empty_description?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_example_groups?(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(groups); end
  def message(group, repeats); end
  def repeated_group_descriptions(node); end
end

RuboCop::Cop::RSpec::RepeatedExampleGroupDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated include of shared examples.
#
# @example
#   # bad
#   describe 'foo' do
#   include_examples 'cool stuff'
#   include_examples 'cool stuff'
#   end
#
#   # bad
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'thing'
#   end
#
#   # bad
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a duck'
#   end
#
#   # good
#   describe 'foo' do
#   include_examples 'cool stuff'
#   end
#
#   describe 'bar' do
#   include_examples 'cool stuff'
#   end
#
#   # good
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'person'
#   end
#
#   # good
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a goose'
#   end
class RuboCop::Cop::RSpec::RepeatedIncludeExample < ::RuboCop::Cop::RSpec::Base
  def include_examples?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_include_examples?(param0 = T.unsafe(nil)); end
  def shared_examples_name(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(items); end

  # @return [Boolean]
  def literal_include_examples?(node); end

  def message(item, repeats); end
  def repeated_include_examples(node); end
  def signature_keys(item); end
end

RuboCop::Cop::RSpec::RepeatedIncludeExample::MSG = T.let(T.unsafe(nil), String)

# Checks for repeated calls to subject missing that it is memoized.
#
# @example
#   # bad
#   it do
#   subject
#   expect { subject }.to not_change { A.count }
#   end
#
#   it do
#   expect { subject }.to change { A.count }
#   expect { subject }.to not_change { A.count }
#   end
#
#   # good
#   it do
#   expect { my_method }.to change { A.count }
#   expect { my_method }.to not_change { A.count }
#   end
#
#   # also good
#   it do
#   expect { subject.a }.to change { A.count }
#   expect { subject.b }.to not_change { A.count }
#   end
class RuboCop::Cop::RSpec::RepeatedSubjectCall < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end

  # Find a named or unnamed subject definition
  #
  # @example anonymous subject
  #   subject?(parse('subject { foo }').ast) do |name|
  #   name # => :subject
  #   end
  # @example named subject
  #   subject?(parse('subject(:thing) { foo }').ast) do |name|
  #   name # => :thing
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [Symbol] subject name
  def subject?(param0 = T.unsafe(nil)); end

  def subject_calls(param0, param1); end

  private

  def detect_offense(subject_node); end
  def detect_offenses_in_block(node, subject_names = T.unsafe(nil)); end
  def detect_offenses_in_example(node, subject_names); end
  def detect_subjects_in_scope(node); end
  def expect_block(node); end
end

RuboCop::Cop::RSpec::RepeatedSubjectCall::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent style of stub's return setting.
#
# Enforces either `and_return` or block-style return in the cases
# where the returned value is constant. Ignores dynamic returned values
# are the result would be different
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: and_return` (default)
#   # bad
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#
#   # good
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar) { bar.baz }
# @example `EnforcedStyle: block`
#   # bad
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#
#   # good
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar).and_return(bar.baz)
class RuboCop::Cop::RSpec::ReturnFromStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def and_return_value(param0); end
  def contains_stub?(param0); end
  def on_block(node); end
  def on_send(node); end
  def stub_with_block?(param0 = T.unsafe(nil)); end

  private

  def check_and_return_call(node); end
  def check_block_body(block); end

  # @return [Boolean]
  def dynamic?(node); end
end

class RuboCop::Cop::RSpec::ReturnFromStub::AndReturnCallCorrector
  # @return [AndReturnCallCorrector] a new instance of AndReturnCallCorrector
  def initialize(node); end

  def call(corrector); end

  private

  # Returns the value of attribute arg.
  def arg; end

  # @return [Boolean]
  def hash_without_braces?; end

  # @return [Boolean]
  def heredoc?; end

  # Returns the value of attribute node.
  def node; end

  def range; end

  # Returns the value of attribute receiver.
  def receiver; end

  def replacement; end
end

class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
  # @return [BlockBodyCorrector] a new instance of BlockBodyCorrector
  def initialize(block); end

  def call(corrector); end

  private

  # Returns the value of attribute block.
  def block; end

  # Returns the value of attribute body.
  def body; end

  # @return [Boolean]
  def heredoc?; end

  # Returns the value of attribute node.
  def node; end
end

RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector::NULL_BLOCK_BODY = T.let(T.unsafe(nil), T.untyped)
RuboCop::Cop::RSpec::ReturnFromStub::MSG_AND_RETURN = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReturnFromStub::MSG_BLOCK = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReturnFromStub::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for let scattered across the example group.
#
# Group lets together
#
# @example
#   # bad
#   describe Foo do
#   let(:foo) { 1 }
#   subject { Foo }
#   let(:bar) { 2 }
#   before { prepare }
#   let!(:baz) { 3 }
#   end
#
#   # good
#   describe Foo do
#   subject { Foo }
#   before { prepare }
#   let(:foo) { 1 }
#   let(:bar) { 2 }
#   let!(:baz) { 3 }
#   end
class RuboCop::Cop::RSpec::ScatteredLet < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def check_let_declarations(body); end
end

RuboCop::Cop::RSpec::ScatteredLet::MSG = T.let(T.unsafe(nil), String)

# Checks for setup scattered across multiple hooks in an example group.
#
# Unify `before`, `after`, and `around` hooks when possible.
#
# @example
#   # bad
#   describe Foo do
#   before { setup1 }
#   before { setup2 }
#   end
#
#   # good
#   describe Foo do
#   before do
#   setup1
#   setup2
#   end
#   end
class RuboCop::Cop::RSpec::ScatteredSetup < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, first_occurrence, occurrence); end
  def lines_msg(numbers); end
  def message(occurrences, occurrence); end
  def repeated_hooks(node); end
end

RuboCop::Cop::RSpec::ScatteredSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for proper shared_context and shared_examples usage.
#
# If there are no examples defined, use shared_context.
# If there is no setup defined, use shared_examples.
#
# @example
#   # bad
#   RSpec.shared_context 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
#
#   # good
#   RSpec.shared_examples 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
# @example
#   # bad
#   RSpec.shared_examples 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
#
#   # good
#   RSpec.shared_context 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
class RuboCop::Cop::RSpec::SharedContext < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def context?(param0); end
  def examples?(param0); end
  def on_block(node); end
  def shared_context(param0 = T.unsafe(nil)); end
  def shared_example(param0 = T.unsafe(nil)); end

  private

  def context_with_only_examples(node); end
  def examples_with_only_context(node); end
end

RuboCop::Cop::RSpec::SharedContext::MSG_CONTEXT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SharedContext::MSG_EXAMPLES = T.let(T.unsafe(nil), String)

# Checks for consistent style for shared example names.
#
# Enforces either `string` or `symbol` for shared example names.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: string` (default)
#   # bad
#   it_behaves_like :foo_bar_baz
#   it_should_behave_like :foo_bar_baz
#   shared_examples :foo_bar_baz
#   shared_examples_for :foo_bar_baz
#   include_examples :foo_bar_baz
#
#   # good
#   it_behaves_like 'foo bar baz'
#   it_should_behave_like 'foo bar baz'
#   shared_examples 'foo bar baz'
#   shared_examples_for 'foo bar baz'
#   include_examples 'foo bar baz'
# @example `EnforcedStyle: symbol`
#   # bad
#   it_behaves_like 'foo bar baz'
#   it_should_behave_like 'foo bar baz'
#   shared_examples 'foo bar baz'
#   shared_examples_for 'foo bar baz'
#   include_examples 'foo bar baz'
#
#   # good
#   it_behaves_like :foo_bar_baz
#   it_should_behave_like :foo_bar_baz
#   shared_examples :foo_bar_baz
#   shared_examples_for :foo_bar_baz
#   include_examples :foo_bar_baz
class RuboCop::Cop::RSpec::SharedExamples < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def shared_examples(param0 = T.unsafe(nil)); end

  private

  def new_checker(ast_node); end

  # @return [Boolean]
  def offense?(ast_node); end
end

class RuboCop::Cop::RSpec::SharedExamples::StringChecker
  # @return [StringChecker] a new instance of StringChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  def preferred_style; end
end

RuboCop::Cop::RSpec::SharedExamples::StringChecker::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::RSpec::SharedExamples::SymbolChecker
  # @return [SymbolChecker] a new instance of SymbolChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  def preferred_style; end
end

RuboCop::Cop::RSpec::SharedExamples::SymbolChecker::MSG = T.let(T.unsafe(nil), String)

# Checks that chains of messages contain more than one element.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar).and_return(42)
#
#   # good
#   allow(foo).to receive(:bar).and_return(42)
#
#   # also good
#   allow(foo).to receive(:bar, :baz)
#   allow(foo).to receive("bar.baz")
class RuboCop::Cop::RSpec::SingleArgumentMessageChain < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def message_chain(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def single_key_hash?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node, method, arg); end
  def autocorrect_array_arg(corrector, arg); end
  def autocorrect_hash_arg(corrector, arg); end
  def key_to_arg(node); end
  def replacement(method); end

  # @return [Boolean]
  def single_element_array?(node); end

  # @return [Boolean]
  def valid_usage?(node); end
end

RuboCop::Cop::RSpec::SingleArgumentMessageChain::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SingleArgumentMessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for passing a block to `skip` within examples.
#
# @example
#   # bad
#   it 'does something' do
#   skip 'not yet implemented' do
#   do_something
#   end
#   end
#
#   # good
#   it 'does something' do
#   skip 'not yet implemented'
#   do_something
#   end
#
#   # good - when outside example
#   skip 'not yet implemented' do
#   end
class RuboCop::Cop::RSpec::SkipBlockInsideExample < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end
  def on_numblock(node); end

  private

  # @return [Boolean]
  def inside_example?(node); end
end

RuboCop::Cop::RSpec::SkipBlockInsideExample::MSG = T.let(T.unsafe(nil), String)

# Helps check offenses with variable definitions
module RuboCop::Cop::RSpec::SkipOrPending
  extend ::RuboCop::AST::NodePattern::Macros

  # Match skip/pending statements inside a block (e.g. `context`)
  #
  # @example source that matches
  #   context 'when color is blue' do
  #   skip 'not implemented yet'
  #   pending 'not implemented yet'
  #   end
  # @example source that does not match
  #   skip 'not implemented yet'
  #   pending 'not implemented yet'
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def skip_or_pending_inside_block?(param0 = T.unsafe(nil)); end

  def skipped_in_metadata?(param0 = T.unsafe(nil)); end
end

# Sort RSpec metadata alphabetically.
#
# @example
#   # bad
#   describe 'Something', :b, :a
#   context 'Something', foo: 'bar', baz: true
#   it 'works', :b, :a, foo: 'bar', baz: true
#
#   # good
#   describe 'Something', :a, :b
#   context 'Something', baz: true, foo: 'bar'
#   it 'works', :a, :b, baz: true, foo: 'bar'
class RuboCop::Cop::RSpec::SortMetadata < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::Metadata
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_metadata(symbols, hash); end

  private

  def crime_scene(symbols, pairs); end
  def replacement(symbols, pairs); end
  def sort_pairs(pairs); end
  def sort_symbols(symbols); end

  # @return [Boolean]
  def sorted?(symbols, pairs); end
end

RuboCop::Cop::RSpec::SortMetadata::MSG = T.let(T.unsafe(nil), String)

# Checks that spec file paths are consistent and well-formed.
#
# @example
#   # bad
#   whatever_spec.rb         # describe MyClass
#   my_class_spec.rb         # describe MyClass, '#method'
#
#   # good
#   my_class_spec.rb         # describe MyClass
#   my_class_method_spec.rb  # describe MyClass, '#method'
#   my_class/method_spec.rb  # describe MyClass, '#method'
# @example `CustomTransform: {RuboCop=>rubocop, RSpec=>rspec}` (default)
#   # good
#   rubocop_spec.rb          # describe RuboCop
#   rspec_spec.rb            # describe RSpec
# @example `IgnoreMethods: false` (default)
#   # bad
#   my_class_spec.rb         # describe MyClass, '#method'
# @example `IgnoreMethods: true`
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
# @example `IgnoreMetadata: {type=>routing}` (default)
#   # good
#   whatever_spec.rb         # describe MyClass, type: :routing do; end
class RuboCop::Cop::RSpec::SpecFilePathFormat < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup
  include ::RuboCop::Cop::RSpec::Namespace
  include ::RuboCop::Cop::RSpec::FileHelp

  def example_group_arguments(param0 = T.unsafe(nil)); end
  def metadata_key_value(param0); end
  def on_top_level_example_group(node); end

  private

  def camel_to_snake_case(string); end
  def correct_path_pattern(class_name, arguments); end
  def custom_transform; end
  def ensure_correct_file_path(send_node, class_name, arguments); end
  def expected_path(constant); end

  # @return [Boolean]
  def filename_ends_with?(pattern); end

  # @return [Boolean]
  def ignore?(method_name); end

  def ignore_metadata; end

  # @return [Boolean]
  def ignore_metadata?(arguments); end

  # @return [Boolean]
  def ignore_methods?; end

  def name_pattern(method_name); end
end

RuboCop::Cop::RSpec::SpecFilePathFormat::MSG = T.let(T.unsafe(nil), String)

# Checks that spec file paths suffix are consistent and well-formed.
#
# @example
#   # bad
#   my_class/foo_specorb.rb   # describe MyClass
#   spec/models/user.rb       # describe User
#   spec/models/user_specxrb  # describe User
#
#   # good
#   my_class_spec.rb          # describe MyClass
#
#   # good - shared examples are allowed
#   spec/models/user.rb       # shared_examples_for 'foo'
class RuboCop::Cop::RSpec::SpecFilePathSuffix < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup
  include ::RuboCop::Cop::RSpec::FileHelp

  def on_top_level_example_group(node); end

  private

  # @return [Boolean]
  def correct_path?; end
end

RuboCop::Cop::RSpec::SpecFilePathSuffix::MSG = T.let(T.unsafe(nil), String)

# Checks that message expectations do not have a configured response.
#
# @example
#   # bad
#   expect(foo).to receive(:bar).with(42).and_return("hello world")
#
#   # good (without spies)
#   allow(foo).to receive(:bar).with(42).and_return("hello world")
#   expect(foo).to receive(:bar).with(42)
class RuboCop::Cop::RSpec::StubbedMock < ::RuboCop::Cop::RSpec::Base
  def configured_response?(param0 = T.unsafe(nil)); end

  # Match expectation
  #
  # @example source that matches
  #   is_expected.to be_in_the_bar
  # @example source that matches
  #   expect(cocktail).to contain_exactly(:fresh_orange_juice, :campari)
  # @example source that matches
  #   expect_any_instance_of(Officer).to be_alert
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] expectation, method name, matcher
  def expectation(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response in block-pass
  #
  # @example source that matches
  #   receive(:foo, &canned)
  # @example source that matches
  #   receive_message_chain(:foo, :bar, &canned)
  # @example source that matches
  #   receive(:foo).with('bar', &canned)
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_blockpass(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response
  #
  # @example source that matches
  #   receive(:foo).and_return('bar')
  # @example source that matches
  #   receive(:lower).and_raise(SomeError)
  # @example source that matches
  #   receive(:redirect).and_call_original
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_configured_response(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response defined as a hash
  #
  # @example source that matches
  #   receive_messages(foo: 'bar', baz: 'qux')
  # @example source that matches
  #   receive_message_chain(:foo, bar: 'baz')
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_hash(param0 = T.unsafe(nil)); end

  # Match matcher with a return block
  #
  # @example source that matches
  #   receive(:foo) { 'bar' }
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_return_block(param0 = T.unsafe(nil)); end

  # Match message expectation matcher
  #
  # @example source that matches
  #   receive(:foo)
  # @example source that matches
  #   receive_message_chain(:foo, :bar)
  # @example source that matches
  #   receive(:foo).with('bar')
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def message_expectation?(param0 = T.unsafe(nil)); end

  def on_send(node); end

  private

  def msg(method_name); end
  def on_expectation(expectation, method_name, matcher); end
  def replacement(method_name); end
end

RuboCop::Cop::RSpec::StubbedMock::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::StubbedMock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Ensure that subject is defined using subject helper.
#
# @example
#   # bad
#   let(:subject) { foo }
#   let!(:subject) { foo }
#   subject(:subject) { foo }
#   subject!(:subject) { foo }
#
#   # bad
#   block = -> {}
#   let(:subject, &block)
#
#   # good
#   subject(:test_subject) { foo }
class RuboCop::Cop::RSpec::SubjectDeclaration < ::RuboCop::Cop::RSpec::Base
  def offensive_subject_declaration?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def message_for(offense); end
end

RuboCop::Cop::RSpec::SubjectDeclaration::MSG_LET = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SubjectDeclaration::MSG_REDUNDANT = T.let(T.unsafe(nil), String)

# Checks for stubbed test subjects.
#
# Checks nested subject stubs for innermost subject definition
# when subject is also defined in parent example groups.
#
# @example
#   # bad
#   describe Article do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#
#   # bad
#   describe Article do
#   subject(:foo) { Article.new }
#
#   context 'nested subject' do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#   end
#
#   # good
#   describe Article do
#   subject(:article) { Article.new(author: nil) }
#
#   it 'indicates that the author is unknown' do
#   expect(article.description).to include('by an unknown author')
#   end
#   end
# @see https://robots.thoughtbot.com/don-t-stub-the-system-under-test
# @see https://penelope.zone/2015/12/27/introducing-rspec-smells-and-where-to-find-them.html#smell-1-stubjec
class RuboCop::Cop::RSpec::SubjectStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # Find a memoized helper
  def let?(param0 = T.unsafe(nil)); end

  # Match `allow` and `expect(...).to receive`
  #
  # @example source that matches
  #   allow(foo).to  receive(:bar)
  #   allow(foo).to  receive(:bar).with(1)
  #   allow(foo).to  receive(:bar).with(1).and_return(2)
  #   expect(foo).to receive(:bar)
  #   expect(foo).to receive(:bar).with(1)
  #   expect(foo).to receive(:bar).with(1).and_return(2)
  def message_expectation?(param0 = T.unsafe(nil), param1); end

  def message_expectation_matcher?(param0); end
  def on_top_level_group(node); end

  # Find a named or unnamed subject definition
  #
  # @example anonymous subject
  #   subject?(parse('subject { foo }').ast) do |name|
  #   name # => :subject
  #   end
  # @example named subject
  #   subject?(parse('subject(:thing) { foo }').ast) do |name|
  #   name # => :thing
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [Symbol] subject name
  def subject?(param0 = T.unsafe(nil)); end

  private

  def find_all_explicit(node); end
  def find_subject_expectations(node, subject_names = T.unsafe(nil), &block); end
end

RuboCop::Cop::RSpec::SubjectStub::MSG = T.let(T.unsafe(nil), String)

# Helper methods for top level example group cops
module RuboCop::Cop::RSpec::TopLevelGroup
  extend ::RuboCop::AST::NodePattern::Macros

  def on_new_investigation; end
  def top_level_groups; end

  private

  # Dummy methods to be overridden in the consumer
  def on_top_level_example_group(_node); end

  def on_top_level_group(_node); end
  def root_node; end

  # @return [Boolean]
  def top_level_group?(node); end

  def top_level_nodes(node); end
end

# Description should be descriptive.
#
# If example group or example contains only `execute string`, numbers
# and regular expressions, the description is not clear.
#
# @example
#   # bad
#   describe `time` do
#   # ...
#   end
#
#   # bad
#   context /when foo/ do
#   # ...
#   end
#
#   # bad
#   it 10000 do
#   # ...
#   end
#
#   # good
#   describe Foo do
#   # ...
#   end
#
#   # good
#   describe '#foo' do
#   # ...
#   end
#
#   # good
#   context "when #{foo} is bar" do
#   # ...
#   end
#
#   # good
#   it 'does something' do
#   # ...
#   end
class RuboCop::Cop::RSpec::UndescriptiveLiteralsDescription < ::RuboCop::Cop::RSpec::Base
  def example_groups_or_example?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def offense?(node); end
end

RuboCop::Cop::RSpec::UndescriptiveLiteralsDescription::MSG = T.let(T.unsafe(nil), String)

# Checks for a specified error in checking raised errors.
#
# Enforces one of an Exception type, a string, or a regular
# expression to match against the exception message as a parameter
# to `raise_error`
#
# @example
#   # bad
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error
#
#   # good
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(StandardError)
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error('error')
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(/err/)
#
#   expect { do_something }.not_to raise_error
class RuboCop::Cop::RSpec::UnspecifiedException < ::RuboCop::Cop::RSpec::Base
  def empty_raise_error_or_exception(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def block_with_args?(node); end

  # @return [Boolean]
  def empty_exception_matcher?(node); end
end

RuboCop::Cop::RSpec::UnspecifiedException::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::UnspecifiedException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Helps check offenses with variable definitions
module RuboCop::Cop::RSpec::Variable
  extend ::RuboCop::AST::NodePattern::Macros

  def variable_definition?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::Variable::Helpers = RuboCop::RSpec::Language::Helpers
RuboCop::Cop::RSpec::Variable::Subjects = RuboCop::RSpec::Language::Subjects

# Checks that memoized helpers names are symbols or strings.
#
# @example EnforcedStyle: symbols (default)
#   # bad
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
#
#   # good
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
# @example EnforcedStyle: strings
#   # bad
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
#
#   # good
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
class RuboCop::Cop::RSpec::VariableDefinition < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::Variable
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def correct_variable(variable); end

  # @return [Boolean]
  def string?(node); end

  # @return [Boolean]
  def style_offense?(variable); end

  # @return [Boolean]
  def symbol?(node); end
end

RuboCop::Cop::RSpec::VariableDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks that memoized helper names use the configured style.
#
# Variables can be excluded from checking using the `AllowedPatterns`
# option.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
#
#   # good
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
# @example EnforcedStyle: camelCase
#   # bad
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
#
#   # good
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
# @example AllowedPatterns configuration
#   # rubocop.yml
#   # RSpec/VariableName:
#   #   EnforcedStyle: snake_case
#   #   AllowedPatterns:
#   #     - ^userFood
# @example
#   # okay because it matches the `^userFood` regex in `AllowedPatterns`
#   subject(:userFood_1) { 'spaghetti' }
#   let(:userFood_2) { 'fettuccine' }
class RuboCop::Cop::RSpec::VariableName < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RSpec::Variable
  include ::RuboCop::Cop::RSpec::InsideExampleGroup

  def on_send(node); end

  private

  def message(style); end
end

RuboCop::Cop::RSpec::VariableName::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent verified double reference style.
#
# Only investigates references that are one of the supported styles.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: constant` (default)
#   # bad
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
# @example `EnforcedStyle: string`
#   # bad
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
# @example Reference is not in the supported style list. No enforcement
#
#   # good
#   let(:foo) do
#   instance_double(@klass, method_name: 'returned_value')
#   end
# @see https://rspec.info/features/3-12/rspec-mocks/verifying-doubles
class RuboCop::Cop::RSpec::VerifiedDoubleReference < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def verified_double(param0 = T.unsafe(nil)); end

  private

  def correct_style(offense); end

  # @return [Boolean]
  def opposing_style?(class_reference); end
end

RuboCop::Cop::RSpec::VerifiedDoubleReference::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VerifiedDoubleReference::REFERENCE_TYPE_STYLES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::RSpec::VerifiedDoubleReference::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Prefer using verifying doubles over normal doubles.
#
# @example
#   # bad
#   let(:foo) do
#   double(method_name: 'returned value')
#   end
#
#   # bad
#   let(:foo) do
#   double("ClassName", method_name: 'returned value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double("ClassName", method_name: 'returned value')
#   end
# @see https://rspec.info/features/3-12/rspec-mocks/verifying-doubles
class RuboCop::Cop::RSpec::VerifiedDoubles < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
  def unverified_double(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def symbol?(name); end
end

RuboCop::Cop::RSpec::VerifiedDoubles::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VerifiedDoubles::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks void `expect()`.
#
# @example
#   # bad
#   expect(something)
#
#   # good
#   expect(something).to be(1)
class RuboCop::Cop::RSpec::VoidExpect < ::RuboCop::Cop::RSpec::Base
  def expect?(param0 = T.unsafe(nil)); end
  def expect_block?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end

  private

  def check_expect(node); end

  # @return [Boolean]
  def void?(expect); end
end

RuboCop::Cop::RSpec::VoidExpect::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VoidExpect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for calling a block within a stub.
#
# @example
#   # bad
#   allow(foo).to receive(:bar) { |&block| block.call(1) }
#
#   # good
#   expect(foo).to receive(:bar).and_yield(1)
class RuboCop::Cop::RSpec::Yield < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_arg(param0 = T.unsafe(nil)); end
  def block_call?(param0 = T.unsafe(nil), param1); end
  def method_on_stub?(param0); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, range); end
  def block_range(node); end

  # @return [Boolean]
  def calling_block?(node, block); end

  def convert_block_to_yield(node); end
  def generate_replacement(node); end
end

RuboCop::Cop::RSpec::Yield::MSG = T.let(T.unsafe(nil), String)
module RuboCop::Cop::Style; end

class RuboCop::Cop::Style::TrailingCommaInArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  def on_csend(node); end
  def on_send(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

# RuboCop RSpec project namespace
module RuboCop::RSpec; end

# Shared behavior for aligning braces for single line lets
class RuboCop::RSpec::AlignLetBrace
  include ::RuboCop::RSpec::Language
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # @return [AlignLetBrace] a new instance of AlignLetBrace
  def initialize(root, token); end

  def indent_for(node); end
  def offending_tokens; end

  private

  def adjacent_let_chunks; end
  def let_group_for(let); end
  def let_token(node); end

  # Returns the value of attribute root.
  def root; end

  def single_line_lets; end
  def target_column_for(let); end

  # Returns the value of attribute token.
  def token; end
end

RuboCop::RSpec::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Wrapper for RSpec DSL methods
class RuboCop::RSpec::Concept
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  # @return [Concept] a new instance of Concept
  def initialize(node); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def to_node; end

  protected

  # Returns the value of attribute node.
  def node; end
end

module RuboCop::RSpec::Corrector; end

# Helper methods to move a node
class RuboCop::RSpec::Corrector::MoveNode
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RSpec::CommentsHelp

  # @return [MoveNode] a new instance of MoveNode
  def initialize(node, corrector, processed_source); end

  # Returns the value of attribute corrector.
  def corrector; end

  def move_after(other); end
  def move_before(other); end

  # Returns the value of attribute original.
  def original; end

  # Returns the value of attribute processed_source.
  def processed_source; end

  private

  def node_range(node); end
  def node_range_with_surrounding_space(node); end
  def source(node); end
end

# Wrapper for RSpec examples
class RuboCop::RSpec::Example < ::RuboCop::RSpec::Concept
  def definition; end
  def doc_string; end
  def extract_doc_string(param0 = T.unsafe(nil)); end
  def extract_implementation(param0 = T.unsafe(nil)); end
  def extract_metadata(param0 = T.unsafe(nil)); end
  def implementation; end
  def metadata; end
end

# Wrapper for RSpec example groups
class RuboCop::RSpec::ExampleGroup < ::RuboCop::RSpec::Concept
  def examples; end
  def hooks; end
  def lets; end

  # Detect if the node is an example group or shared example
  #
  # Selectors which indicate that we should stop searching
  def scope_change?(param0 = T.unsafe(nil)); end

  def subjects; end

  private

  def find_all(node, predicate); end

  # Recursively search for predicate within the current scope
  #
  # Searches node and halts when a scope change is detected
  #
  # @param node [RuboCop::AST::Node] node to recursively search
  # @param predicate [Symbol] method to call with node as argument
  # @return [Array<RuboCop::AST::Node>] discovered nodes
  def find_all_in_scope(node, predicate); end
end

# Wrapper for RSpec hook
class RuboCop::RSpec::Hook < ::RuboCop::RSpec::Concept
  # @return [Boolean]
  def example?; end

  def extract_metadata(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def knowable_scope?; end

  def metadata; end
  def name; end
  def scope; end

  private

  def scope_argument; end
  def scope_name; end
  def transform_metadata(meta); end
  def transform_true(node); end

  # @return [Boolean]
  def valid_scope?(node); end
end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::RSpec::Inject
  class << self
    def defaults!; end
  end
end

# Contains node matchers for common RSpec DSL.
#
# RSpec allows for configuring aliases for commonly used DSL elements, e.g.
# example groups and hooks. It is possible to configure RuboCop RSpec to
# be able to properly detect these elements in the `RSpec/Language` section
# of the RuboCop YAML configuration file.
#
# In addition to providing useful matchers, this class is responsible for
# using the configured aliases.
module RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  def example?(param0 = T.unsafe(nil)); end
  def example_group?(param0 = T.unsafe(nil)); end
  def example_group_with_body?(param0 = T.unsafe(nil)); end
  def explicit_rspec?(param0 = T.unsafe(nil)); end
  def hook?(param0 = T.unsafe(nil)); end
  def include?(param0 = T.unsafe(nil)); end
  def let?(param0 = T.unsafe(nil)); end
  def rspec?(param0 = T.unsafe(nil)); end
  def shared_group?(param0 = T.unsafe(nil)); end
  def spec_group?(param0 = T.unsafe(nil)); end
  def subject?(param0 = T.unsafe(nil)); end

  class << self
    # Returns the value of attribute config.
    def config; end

    # Sets the attribute config
    #
    # @param value the value to set the attribute config to.
    def config=(_arg0); end
  end
end

# This is used in Dialect and DescribeClass cops to detect RSpec blocks.
module RuboCop::RSpec::Language::ALL
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::ExampleGroups
  class << self
    def all(element); end
    def focused(element); end
    def regular(element); end
    def skipped(element); end
  end
end

module RuboCop::RSpec::Language::Examples
  class << self
    def all(element); end
    def focused(element); end
    def pending(element); end
    def regular(element); end
    def skipped(element); end
  end
end

module RuboCop::RSpec::Language::Expectations
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::Helpers
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::HookScopes
  class << self
    def all(element); end
  end
end

RuboCop::RSpec::Language::HookScopes::ALL = T.let(T.unsafe(nil), Array)

module RuboCop::RSpec::Language::Hooks
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::Includes
  class << self
    def all(element); end
    def context(element); end
    def examples(element); end
  end
end

# Helper methods to detect RSpec DSL used with send and block
#
# @deprecated Prefer using Node Pattern directly
#   Use `'(block (send nil? #Example.all ...) ...)'` instead of
#   `block_pattern('#Example.all')`
module RuboCop::RSpec::Language::NodePattern
  # @deprecated Prefer using Node Pattern directly
  def block_or_numblock_pattern(string); end

  # @deprecated Prefer using Node Pattern directly
  def block_pattern(string); end

  # @deprecated Prefer using Node Pattern directly
  def numblock_pattern(string); end

  # @deprecated Prefer using Node Pattern directly
  def send_pattern(string); end

  private

  def deprecation_warning(method); end
end

module RuboCop::RSpec::Language::Runners
  class << self
    def all(element = T.unsafe(nil)); end
  end
end

RuboCop::RSpec::Language::Runners::ALL = T.let(T.unsafe(nil), Array)

module RuboCop::RSpec::Language::SharedGroups
  class << self
    def all(element); end
    def context(element); end
    def examples(element); end
  end
end

module RuboCop::RSpec::Language::Subjects
  class << self
    def all(element); end
  end
end

# RuboCop RSpec specific extensions of RuboCop::AST::Node
module RuboCop::RSpec::Node
  # In various cops we want to regard const as literal although it's not
  # strictly literal.
  #
  # @return [Boolean]
  def recursive_literal_or_const?; end
end

RuboCop::RSpec::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# Version information for the RSpec RuboCop plugin.
module RuboCop::RSpec::Version; end

RuboCop::RSpec::Version::STRING = T.let(T.unsafe(nil), String)

# RSpec example wording rewriter
class RuboCop::RSpec::Wording
  # @return [Wording] a new instance of Wording
  def initialize(text, ignore:, replace:); end

  def rewrite; end

  private

  def append_suffix(word, suffix); end

  # @return [Boolean]
  def ignored_word?(word); end

  # Returns the value of attribute ignores.
  def ignores; end

  def remove_should_and_pluralize; end
  def replace_prefix(pattern, replacement); end

  # Returns the value of attribute replacements.
  def replacements; end

  def substitute(word); end

  # Returns the value of attribute text.
  def text; end

  # @return [Boolean]
  def uppercase?(word); end
end

RuboCop::RSpec::Wording::ES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::IES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::SHOULDNT_BE_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::SHOULDNT_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::WILL_NOT_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::WONT_PREFIX = T.let(T.unsafe(nil), Regexp)
