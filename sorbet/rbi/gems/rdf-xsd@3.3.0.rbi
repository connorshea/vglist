# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rdf-xsd` gem.
# Please instead update this file by running `bin/tapioca gem rdf-xsd`.

# REXML C14N
class Array
  include ::Enumerable

  # Canonicalize the NodeSet. Return a new NodeSet marked
  # as being canonical with all child nodes canonicalized.
  #
  # @param options [Hash{Symbol => Object}] Passed to {Nokogiri::XML::Node#c14nxl}
  def c14nxl(options = T.unsafe(nil)); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end
end

module Nokogiri::XML
  class << self
    def Reader(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end
    def RelaxNG(string_or_io, options = T.unsafe(nil)); end
    def Schema(string_or_io, options = T.unsafe(nil)); end
    def fragment(string, options = T.unsafe(nil), &block); end
    def parse(thing, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class Nokogiri::XML::Comment < ::Nokogiri::XML::CharacterData
  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::Document < ::Nokogiri::XML::Node
  def initialize(*args); end

  def <<(node_or_tags); end
  def add_child(node_or_tags); end
  def canonicalize(*_arg0); end
  def clone(*_arg0); end
  def collect_namespaces; end
  def create_cdata(string, &block); end
  def create_comment(string, &block); end
  def create_element(name, *contents_or_attrs, &block); end
  def create_entity(*_arg0); end
  def create_text_node(string, &block); end
  def deconstruct_keys(keys); end
  def decorate(node); end
  def decorators(key); end
  def doctype; end
  def document; end
  def dup(*_arg0); end
  def encoding; end
  def encoding=(_arg0); end
  def errors; end
  def errors=(_arg0); end
  def fragment(tags = T.unsafe(nil)); end
  def name; end
  def namespace_inheritance; end
  def namespace_inheritance=(_arg0); end
  def namespaces; end
  def remove_namespaces!; end
  def root; end
  def root=(_arg0); end
  def slop!; end
  def to_xml(*args, &block); end
  def url; end
  def validate; end
  def version; end
  def xpath_doctype; end

  private

  def inspect_attributes; end

  class << self
    def new(*_arg0); end
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end
    def read_io(_arg0, _arg1, _arg2, _arg3); end
    def read_memory(_arg0, _arg1, _arg2, _arg3); end

    private

    def empty_doc?(string_or_io); end
  end
end

class Nokogiri::XML::Element < ::Nokogiri::XML::Node
  # Canonicalize the Element. Return a new instance of this node
  # which is canonicalized and marked as such.
  #
  # Apply namespaces either passed as an option, or that are in scope.
  #
  # @param options [Hash{Symbol => Object}] From {Nokogiri::XML::Node#c14nxl}
  def c14nxl(options = T.unsafe(nil)); end
end

# XML Exclusive Canonicalization (c14n) for Nokogiri.
#
# Classes mixin this module to implement canonicalization methods.
#
# This implementation acts in two parts, first to canonicalize the Node
# or NoteSet in the context of its containing document, and second to
# serialize to a lexical representation.
#
# @see # @see   https://www.w3.org/TR/xml-exc-c14n/
class Nokogiri::XML::Node
  def initialize(name, document); end

  def <<(node_or_tags); end
  def <=>(other); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def accept(visitor); end
  def add_child(node_or_tags); end
  def add_class(names); end
  def add_namespace(_arg0, _arg1); end
  def add_namespace_definition(_arg0, _arg1); end
  def add_next_sibling(node_or_tags); end
  def add_previous_sibling(node_or_tags); end
  def after(node_or_tags); end
  def ancestors(selector = T.unsafe(nil)); end
  def append_class(names); end
  def attr(name); end
  def attribute(_arg0); end
  def attribute_nodes; end
  def attribute_with_ns(_arg0, _arg1); end
  def attributes; end
  def before(node_or_tags); end
  def blank?; end

  # Canonicalize the Node. Return a new instance of this node
  # which is canonicalized and marked as such
  #
  # @option options
  # @option options
  # @param options [Hash{Symbol => Object}]
  def c14nxl(options = T.unsafe(nil)); end

  def canonicalize(mode = T.unsafe(nil), inclusive_namespaces = T.unsafe(nil), with_comments = T.unsafe(nil)); end
  def cdata?; end
  def child; end
  def children; end
  def children=(node_or_tags); end
  def classes; end
  def clone(*_arg0); end
  def comment?; end
  def content; end
  def content=(string); end
  def create_external_subset(_arg0, _arg1, _arg2); end
  def create_internal_subset(_arg0, _arg1, _arg2); end
  def css_path; end
  def deconstruct_keys(keys); end
  def decorate!; end
  def default_namespace=(url); end
  def delete(name); end
  def description; end
  def do_xinclude(options = T.unsafe(nil)); end
  def document; end
  def document?; end
  def dup(*_arg0); end
  def each; end
  def elem?; end
  def element?; end
  def element_children; end
  def elements; end
  def encode_special_chars(_arg0); end
  def external_subset; end
  def first_element_child; end
  def fragment(tags); end
  def fragment?; end
  def get_attribute(name); end
  def has_attribute?(_arg0); end
  def html?; end
  def inner_html(options = T.unsafe(nil)); end
  def inner_html=(node_or_tags); end
  def inner_text; end
  def internal_subset; end
  def key?(_arg0); end
  def keys; end
  def kwattr_add(attribute_name, keywords); end
  def kwattr_append(attribute_name, keywords); end
  def kwattr_remove(attribute_name, keywords); end
  def kwattr_values(attribute_name); end
  def lang; end
  def lang=(_arg0); end
  def last_element_child; end
  def line; end
  def line=(_arg0); end
  def matches?(selector); end
  def name; end
  def name=(_arg0); end
  def namespace; end
  def namespace=(ns); end
  def namespace_definitions; end
  def namespace_scopes; end
  def namespaced_key?(_arg0, _arg1); end
  def namespaces; end
  def native_content=(_arg0); end
  def next; end
  def next=(node_or_tags); end
  def next_element; end
  def next_sibling; end
  def node_name; end
  def node_name=(_arg0); end
  def node_type; end
  def parent; end
  def parent=(parent_node); end
  def parse(string_or_io, options = T.unsafe(nil)); end
  def path; end
  def pointer_id; end
  def prepend_child(node_or_tags); end
  def previous; end
  def previous=(node_or_tags); end
  def previous_element; end
  def previous_sibling; end
  def processing_instruction?; end
  def read_only?; end
  def remove; end
  def remove_attribute(name); end
  def remove_class(names = T.unsafe(nil)); end
  def replace(node_or_tags); end
  def serialize(*args, &block); end
  def set_attribute(name, value); end
  def swap(node_or_tags); end
  def text; end
  def text?; end
  def to_html(options = T.unsafe(nil)); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end

  def to_s_without_c14nxl; end
  def to_str; end
  def to_xhtml(options = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end
  def traverse(&block); end
  def type; end
  def unlink; end
  def value?(value); end
  def values; end
  def wrap(node_or_tags); end
  def write_html_to(io, options = T.unsafe(nil)); end
  def write_to(io, *options); end
  def write_xhtml_to(io, options = T.unsafe(nil)); end
  def write_xml_to(io, options = T.unsafe(nil)); end
  def xml?; end

  protected

  def coerce(data); end

  private

  def add_child_node(_arg0); end
  def add_child_node_and_reparent_attrs(node); end
  def add_next_sibling_node(_arg0); end
  def add_previous_sibling_node(_arg0); end
  def add_sibling(next_or_previous, node_or_tags); end
  def compare(_arg0); end
  def dump_html; end
  def get(_arg0); end
  def html_standard_serialize(_arg0); end
  def in_context(_arg0, _arg1); end
  def inspect_attributes; end
  def keywordify(keywords); end
  def native_write_to(_arg0, _arg1, _arg2, _arg3); end
  def prepend_newline?; end
  def process_xincludes(_arg0); end
  def replace_node(_arg0); end
  def set(_arg0, _arg1); end
  def set_namespace(_arg0); end
  def to_format(save_option, options); end
  def write_format_to(save_option, io, options); end

  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::NodeSet
  def initialize(document, list = T.unsafe(nil)); end

  def %(*args); end
  def &(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def ==(other); end
  def [](*_arg0); end
  def add_class(name); end
  def after(datum); end
  def append_class(name); end
  def at(*args); end
  def attr(key, value = T.unsafe(nil), &block); end
  def attribute(key, value = T.unsafe(nil), &block); end
  def before(datum); end

  # Canonicalize the NodeSet. Return a new NodeSet marked
  # as being canonical with all child nodes canonicalized.
  #
  # @param options [Hash{Symbol => Object}] Passed to `Nokogiri::XML::Node#c14nxl`
  def c14nxl(options = T.unsafe(nil)); end

  def children; end
  def clone; end
  def css(*args); end
  def deconstruct; end
  def delete(_arg0); end
  def document; end
  def document=(_arg0); end
  def dup; end
  def each; end
  def empty?; end
  def filter(expr); end
  def first(n = T.unsafe(nil)); end
  def include?(_arg0); end
  def index(node = T.unsafe(nil)); end
  def inner_html(*args); end
  def inner_text; end
  def inspect; end
  def last; end
  def length; end
  def pop; end
  def push(_arg0); end
  def remove; end
  def remove_attr(name); end
  def remove_attribute(name); end
  def remove_class(name = T.unsafe(nil)); end
  def reverse; end
  def set(key, value = T.unsafe(nil), &block); end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def text; end
  def to_a; end
  def to_ary; end
  def to_html(*args); end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s; end

  # Serialize a canonicalized Node or NodeSet to XML
  #
  # Override standard #to_s implementation to output in c14n representation
  # if the Node or NodeSet is marked as having been canonicalized
  def to_s_with_c14nxl; end

  def to_s_without_c14nxl; end
  def to_xhtml(*args); end
  def to_xml(*args); end
  def unlink; end
  def wrap(node_or_tags); end
  def xpath(*args); end
  def |(_arg0); end
end

module RDF
  class << self
    def Graph(**options, &block); end
    def List(*args); end
    def Literal(literal, **options); end
    def Node(*args); end
    def Resource(*args); end
    def Statement(*args, **options); end
    def StrictVocabulary(uri); end
    def URI(*args); end
    def Vocabulary(uri); end
    def [](property); end
    def config; end
    def enum_for(method = T.unsafe(nil), *args); end
    def method_missing(property, *args, &block); end
    def respond_to?(method, include_all = T.unsafe(nil)); end
    def to_enum(method = T.unsafe(nil), *args); end
  end
end

class RDF::Literal
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Util::Logger
  include ::SPARQL::Algebra::Expression

  def initialize(value, language: T.unsafe(nil), datatype: T.unsafe(nil), direction: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype2?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(_arg0); end
  def datatype?; end
  def datatyped?; end
  def direction; end
  def direction=(_arg0); end
  def direction?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = T.unsafe(nil)); end
  def inspect; end
  def language; end
  def language=(_arg0); end
  def language?; end
  def literal?; end
  def object; end
  def plain?; end
  def simple?; end
  def squish(*other_string); end
  def squish!; end
  def to_s; end
  def to_sxp(**options); end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end

  protected

  def method_missing(name, *args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def datatype_map; end
    def datatyped_class(uri); end
    def inherited(child); end
    def new(value, language: T.unsafe(nil), datatype: T.unsafe(nil), direction: T.unsafe(nil), lexical: T.unsafe(nil), validate: T.unsafe(nil), canonicalize: T.unsafe(nil), **options); end
  end
end

# anyURI represents a Uniform Resource Identifier Reference (URI).
# An anyURI value can be absolute or relative, and may have an
# optional fragment identifier (i.e., it may be a URI Reference).
# This type should be used to specify the intention that the value fulfills
# the role of a URI as defined by [RFC 2396], as amended by [RFC 2732].
#
# @see https://www.w3.org/TR/xmlschema11-2/#anyURI
# @see https://www.ietf.org/rfc/rfc2396.txt
# @see https://www.ietf.org/rfc/rfc2732.txt
class RDF::Literal::AnyURI < ::RDF::Literal
  # @param value [String, Object] If given a string, it will decode it as an object value.
  #   Otherwise, it will take the value as the object and encode to retrieve a value
  # @param lexical [String] (nil)
  # @return [AnyURI] a new instance of AnyURI
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  def canonicalize!; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::AnyURI::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# base64Binary represents Base64-encoded arbitrary binary data. The ·value space· of base64Binary is the set of
# finite-length sequences of binary octets. For base64Binary data the entire binary stream is encoded using the Base64
# Alphabet in [RFC 2045].
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#hexBinary
class RDF::Literal::Base64Binary < ::RDF::Literal
  # @option options
  # @param value [String, Object] If given a string, it will decode it as an object value.
  #   Otherwise, it will take the value as the object and encode to retrieve a value
  # @param options [Hash] a customizable set of options
  # @return [Base64Binary] a new instance of Base64Binary
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  # @see https://www.w3.org/TR/xmlschema-2/#dateTime
  def canonicalize!; end

  # Returns the value as a string.
  #
  # @return [String]
  def to_s; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Base64Binary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# byte is derived from short by setting the value of maxInclusive to be 127 and minInclusive to be -128.
# The base type of byte is short.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#byte
class RDF::Literal::Byte < ::RDF::Literal::Short
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Byte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# dateTimeStamp
#
# The dateTimeStamp datatype is ·derived· from dateTime by giving the value required to its explicitTimezone facet. The result is that all values of dateTimeStamp are required to have explicit time zone offsets and the datatype is totally ordered.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dateTimeStamp
class RDF::Literal::DateTimeStamp < ::RDF::Literal::DateTime; end

RDF::Literal::DateTimeStamp::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DateTimeStamp::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::DateTimeStamp::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gDay is a gregorian day that recurs, specifically a day of the month such as the 5th of the month. Arbitrary
# recurring days are not supported by this datatype. The value space of gDay is the space of a set of calendar
# dates as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-day long, monthly periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gDay
class RDF::Literal::Day < ::RDF::Literal::Date
  # @return [Day] a new instance of Day
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Day::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Day::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Day::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A DayTimeDuration literal.
#
# `dayTimeDuration` is a datatype ·derived· from `duration` by restricting its ·lexical representations· to instances of `dayTimeDurationLexicalRep`. The ·value space· of `dayTimeDuration` is therefore that of `duration` restricted to those whose ·months· property is 0.  This results in a duration datatype which is totally ordered.
#
# @see https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration
class RDF::Literal::DayTimeDuration < ::RDF::Literal::Duration
  # Returns the result of multiplying the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery function [op:multiply-dayTimeDuration](https://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration).
  #
  # @param other [Literal::Numeric, ::Numeric]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration
  def *(other); end

  # Returns the sum of two xs:dayTimeDuration values.
  #
  # From the XQuery function [op:add-dayTimeDurations](https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations).
  #
  # @param other [DayTimeDuration]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations
  def +(other); end

  # Returns the result of subtracting one xs:dayTimeDuration value from another.
  #
  # From the XQuery function [op:subtract-dayTimeDurationss](https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations).
  #
  # @param other [DayTimeDuration]
  # @return [DayTimeDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations
  def -(other); end

  # Returns the result of dividing the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery functions [op:divide-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration) and [op:divide-yearMonthDuration-by-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration-by-dayTimeDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, DayTimeDuration]
  # @return [DayTimeDuration, Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration-by-dayTimeDuration
  def /(other); end

  # Compares this literal to `other` for sorting purposes.
  #
  # From the XQuery function [op:dayTimeDuration-less-than](https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than).
  #
  # @param other [DayTimeDuration]
  # @return [Boolean] `true` if less than other for defined datatypes
  # @see https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than
  # @see https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-greater-than
  def <=>(other); end

  # Converts the dayTimeDuration into rational seconds.
  #
  # @return [Rational]
  def to_r; end
end

RDF::Literal::DayTimeDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::DayTimeDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A duration literal.
#
# `duration` is a datatype that represents durations of time.  The concept of duration being captured is drawn from those of [ISO 8601](https://www.w3.org/TR/xmlschema11-2/#ISO8601), specifically durations without fixed endpoints.
#
# @see https://www.w3.org/TR/xmlschema11-2/#duration
class RDF::Literal::Duration < ::RDF::Literal
  # Creates a new Duration instance.
  #
  # * Given a `String`, parse as `xsd:duration` into months and seconds
  # * Given a `Hash` containing any of `:yr`, `:mo`, :da`, `:hr`, `:mi` and `:si`, it is transformed into months and seconds
  # * Given a Rational, the result is interpreted as days, hours, minutes, and seconds.
  # * Given an Integer, the result is interpreted as years and months.
  # * Object representation is the `Array(months, seconds)`
  #
  # @option options
  # @option options
  # @param value [Literal::Duration, Hash, Array, Literal::Numeric, #to_s] If provided an Array, it is the same as the object form of this literal, an array of two integers, the first of which may be negative.
  # @param lexical [String] (nil)
  #   Supplied lexical representation of this literal,
  #   otherwise it comes from transforming `value` to a string form..
  # @param datatype [URI] (nil)
  # @param options [Hash{Symbol => Object}] other options passed to `RDF::Literal#initialize`.
  # @return [Duration] a new instance of Duration
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Returns `true` if `self` and `other` are durations of the same length.
  #
  # From the XQuery function [op:duration-equal](https://www.w3.org/TR/xpath-functions/#func-duration-equal).
  #
  # @see https://www.w3.org/TR/xpath-functions/#func-duration-equal
  def ==(other); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [Literal] `self`
  # @see https://www.w3.org/TR/xmlschema11-2/#dateTime
  def canonicalize!; end

  # Days
  #
  # From the XQuery function [fn:days-from-duration](https://www.w3.org/TR/xpath-functions/#func-days-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-days-from-duration
  def days; end

  # Hours
  #
  # From the XQuery function [fn:hours-from-duration](https://www.w3.org/TR/xpath-functions/#func-hours-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-hours-from-duration
  def hours; end

  # Returns a human-readable value for the interval
  def humanize(lang = T.unsafe(nil)); end

  # Minutes
  #
  # From the XQuery function [fn:minutes-from-duration](https://www.w3.org/TR/xpath-functions/#func-minutes-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-minutes-from-duration
  def minutes; end

  # Months
  #
  # From the XQuery function [fn:months-from-duration](https://www.w3.org/TR/xpath-functions/#func-months-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-months-from-duration
  def months; end

  def plural(v, str); end

  # Seconds
  #
  # From the XQuery function [fn:seconds-from-duration](https://www.w3.org/TR/xpath-functions/#func-seconds-from-duration).
  #
  # @return [Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-seconds-from-duration
  def seconds; end

  # Returns a hash representation.
  #
  # @return [Hash]
  def to_h; end

  # Returns the value as a string.
  #
  # @return [String]
  def to_s; end

  # Returns `true` if the value adheres to the defined grammar of the
  # datatype.
  #
  # Special case for date and dateTime, for which '0000' is not a valid year
  #
  # @return [Boolean]
  def valid?; end

  # Years
  #
  # From the XQuery function [fn:years-from-duration](https://www.w3.org/TR/xpath-functions/#func-years-from-duration).
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/xpath-functions/#func-years-from-duration
  def years; end

  private

  # Reverse convert from XSD version of duration
  # XSD allows -P1111Y22M33DT44H55M66.666S with any combination in regular order
  # We assume 1M == 30D, but are out of spec in this regard
  # We only output up to hours
  #
  # @param value [String] XSD formatted duration
  # @return [Duration]
  def parse(value); end

  def sec_str; end
end

RDF::Literal::Duration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Duration::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# Note that in XML Schema, Float is not really derived from Double,
# but implementations are identical in Ruby
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#float
class RDF::Literal::Float < ::RDF::Literal::Double; end

RDF::Literal::Float::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# An HTML literal.
#
# HTML Literals are managed equivalent to XML Literals. Processors
# are responsible for coercing the input to an
# [DOM DocumentFragment](https://www.w3.org/TR/dom/#interface-documentfragment).
#
# @see https://dvcs.w3.org/hg/rdf/raw-file/default/rdf-concepts/index.html#section-html
class RDF::Literal::HTML < ::RDF::Literal::XML; end

# hexBinary represents arbitrary hex-encoded binary data. The value space of hexBinary is the set of finite-length
# sequences of binary octets.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#hexBinary
class RDF::Literal::HexBinary < ::RDF::Literal
  # @option options
  # @param value [String] The encoded form of the literal
  # @param options [Hash] a customizable set of options
  # @return [HexBinary] a new instance of HexBinary
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # Converts this literal into its canonical lexical representation.
  #
  # @return [RDF::Literal] `self`
  def canonicalize!; end

  # Returns the encoded value as a string.
  #
  # @return [String]
  def to_s; end

  private

  def bin_to_hex(value); end
  def hex_to_bin(value); end
end

RDF::Literal::HexBinary::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::HexBinary::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# int is derived from long by setting the value of maxInclusive to be 2147483647 and minInclusive to be
# -2147483648. The base type of int is long.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#int
class RDF::Literal::Int < ::RDF::Literal::Long
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Int::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# long is derived from integer by setting the value of maxInclusive to be 9223372036854775807
# and minInclusive to be -9223372036854775808.
#
# The base type of long is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#long
class RDF::Literal::Long < ::RDF::Literal::Integer
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Long::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# gMonth is a gregorian month that recurs every year. The value space of gMonth is the space of a set of calendar
# months as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-month long, yearly periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gMonth
class RDF::Literal::Month < ::RDF::Literal::Date
  # @return [Month] a new instance of Month
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Month::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Month::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Month::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gMonthDay is a gregorian date that recurs, specifically a day of the year such as the third of May. Arbitrary
# recurring dates are not supported by this datatype. The value space of gMonthDay is the set of calendar dates,
# as defined in § 3 of [ISO 8601]. Specifically, it is a set of one-day long, annually periodic instances.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gMonthDay
class RDF::Literal::MonthDay < ::RDF::Literal::Date
  # @return [MonthDay] a new instance of MonthDay
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::MonthDay::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::MonthDay::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::MonthDay::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# negativeInteger is derived from nonPositiveInteger by setting the value of maxInclusive to be -1. This
# results in the standard mathematical concept of the negative integers. The value space of negativeInteger is
# the infinite set `{...,-2,-1}`. The base type of negativeInteger is nonPositiveInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#negativeInteger
class RDF::Literal::NegativeInteger < ::RDF::Literal::NonPositiveInteger
  # Returns `self` negated.
  #
  # @return [RDF::Literal::Numeric]
  def -@; end

  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# nonNegativeInteger is derived from integer by setting the value of minInclusive to be 0. This results in
# the standard mathematical concept of the non-negative integers. The value space of nonNegativeInteger is the
# infinite set [0,1,2,...]. The base type of nonNegativeInteger is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#nonNegativeInteger
class RDF::Literal::NonNegativeInteger < ::RDF::Literal::Integer
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NonNegativeInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonNegativeInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# nonPositiveInteger is derived from integer by setting the value of maxInclusive to be 0. This results in
# the standard mathematical concept of the non-positive integers. The value space of nonPositiveInteger is the
# infinite set `{...,-2,-1,0}`. The base type of nonPositiveInteger is integer.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#nonPositiveInteger
class RDF::Literal::NonPositiveInteger < ::RDF::Literal::Integer
  # Returns `self` negated.
  #
  # @return [RDF::Literal::Numeric]
  def -@; end

  # @return [Boolean]
  def valid?; end
end

RDF::Literal::NonPositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::NonPositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# positiveInteger is derived from nonNegativeInteger by setting the value of minInclusive to be 1. This
# results in the standard mathematical concept of the positive integer numbers. The value space of
# positiveInteger is the infinite set [1,2,...]. The base type of positiveInteger is nonNegativeInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#positiveInteger
class RDF::Literal::PositiveInteger < ::RDF::Literal::NonNegativeInteger
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::PositiveInteger::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::PositiveInteger::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# short is derived from int by setting the value of maxInclusive to be 32767 and minInclusive to be
# -32768. The base type of short is int.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#short
class RDF::Literal::Short < ::RDF::Literal::Int
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::Short::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# unsignedByte is derived from unsignedShort by setting the value of maxInclusive to be 255. The base
# type of unsignedByte is unsignedShort.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedByte
class RDF::Literal::UnsignedByte < ::RDF::Literal::UnsignedShort
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedByte::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# unsignedInt is derived from unsignedLong by setting the value of maxInclusive to be 4294967295. The base
# type of unsignedInt is unsignedLong.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedInt
class RDF::Literal::UnsignedInt < ::RDF::Literal::UnsignedLong
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedInt::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# unsignedLong is derived from nonNegativeInteger by setting the value of maxInclusive to be
# 18446744073709551615. The base type of unsignedLong is nonNegativeInteger.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedLong
class RDF::Literal::UnsignedLong < ::RDF::Literal::NonNegativeInteger
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedLong::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::UnsignedLong::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# unsignedShort is derived from unsignedInt by setting the value of maxInclusive to be 65535. The base
# type of unsignedShort is unsignedInt.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#unsignedShort
class RDF::Literal::UnsignedShort < ::RDF::Literal::UnsignedInt
  # @return [Boolean]
  def valid?; end
end

RDF::Literal::UnsignedShort::DATATYPE = T.let(T.unsafe(nil), RDF::URI)

# An XML literal.
#
# XML Literals are maintained in a lexical form, unless an object form is provided.
# The both lexical and object forms are presumed to be in Exclusive Canonical XML.
# As generating this form is dependent on the context of the XML Literal from the
# original document, canonicalization cannot be performed directly within this
# class.
#
# This gem includes Exclusive Canonical XML extensions `Nokogiri::XML::Node#c14nxl`,
# `Nokogiri::XML::NodeSet#c14nxl`, `REXML::Element#c14nxl` and `Array#c14nxl` (necessary
# for REXML node children, which is the REXML implementation of a NodeSet)
#
# @see https://www.w3.org/TR/rdf-concepts/#section-XMLLiteral
# @see https://www.w3.org/TR/rdfa-core/#s_xml_literals
# @see https://www.w3.org/TR/xml-exc-c14n/
class RDF::Literal::XML < ::RDF::Literal
  # @option options
  # @param value [Object]
  # @param lexical [String] (nil)
  # @param options [Hash] a customizable set of options
  # @return [XML] a new instance of XML
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end

  # XML Equivalence. XML Literals can be compared with each other or with xsd:strings
  #
  # @param other [Object]
  # @return [Boolean] `true` or `false`
  # @see https://www.w3.org/TR/rdf-concepts/#section-XMLLiteral
  def eql?(other); end

  # Parse value, if necessary
  #
  # @return [Object]
  def object; end

  def to_s; end

  private

  # Use equivalent-xml to determine equivalence
  def equivalent_nokogiri(other); end

  # Simple equivalence test for REXML
  def equivalent_rexml(other); end

  # Parse the value either as a NodeSet, as results are equivalent if it is just a node
  def parse_nokogiri(value); end

  # Parse the value either as a NodeSet, as results are equivalent if it is just a node
  def parse_rexml(value); end
end

RDF::Literal::XML::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::XML::GRAMMAR = T.let(T.unsafe(nil), T.untyped)

# gYear represents a gregorian calendar year. The value space of gYear is the set of Gregorian calendar years as
# defined in § 5.2.1 of [ISO 8601]. Specifically, it is a set of one-year long, non-periodic instances e.g. lexical
# 1999 to represent the whole year 1999, independent of how many months and days this year has.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gYear
class RDF::Literal::Year < ::RDF::Literal::Date
  # @return [Year] a new instance of Year
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::Year::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::Year::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::Year::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# gYearMonth represents a specific gregorian month in a specific gregorian year. The value space of gYearMonth is
# the set of Gregorian calendar months as defined in § 5.2.1 of [ISO 8601]. Specifically, it is a set of one-month
# long, non-periodic instances e.g. 1999-10 to represent the whole month of 1999-10, independent of how many days this
# month has.
#
# @see https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#gYearMonth
class RDF::Literal::YearMonth < ::RDF::Literal::Date
  # @return [YearMonth] a new instance of YearMonth
  def initialize(value, datatype: T.unsafe(nil), lexical: T.unsafe(nil), **options); end
end

RDF::Literal::YearMonth::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonth::FORMAT = T.let(T.unsafe(nil), String)
RDF::Literal::YearMonth::GRAMMAR = T.let(T.unsafe(nil), Regexp)

# A `YearMonthDuration` literal.
#
# `yearMonthDuration` is a datatype ·derived· from `xsd:duration` by restricting its ·lexical representations· to instances of `yearMonthDurationLexicalRep`.  The ·value space· of `yearMonthDuration` is therefore that of `duration` restricted to those whose ·seconds· property is 0.  This results in a `duration` datatype which is totally ordered.
#
# @see https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration
class RDF::Literal::YearMonthDuration < ::RDF::Literal::Duration
  # Returns the result of multiplying the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery function [op:multiply-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, DayTimeDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration
  def *(other); end

  # Returns the sum of two xs:yearMonthDuration values.
  #
  # From the XQuery function [op:add-yearMonthDurations](https://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations).
  #
  # @param other [YearMonthDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations
  def +(other); end

  # Returns the result of subtracting one xs:yearMonthDuration value from another.
  #
  # From the XQuery function [op:subtract-yearMonthDurations](https://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations).
  #
  # @param other [YearMonthDuration]
  # @return [YearMonthDuration]
  # @see https://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations
  def -(other); end

  # Returns the result of dividing the value of self by `other`. The result is rounded to the nearest month.
  #
  # From the XQuery functions [op:divide-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration) and [op:divide-yearMonthDuration-by-yearMonthDuration](https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration-by-yearMonthDuration).
  #
  # @param other [Literal::Numeric, ::Numeric, YearMonthDuration]
  # @return [YearMonthDuration, Decimal]
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration
  # @see https://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration-by-yearMonthDuration
  def /(other); end

  # Compares this literal to `other` for sorting purposes.
  #
  # From the XQuery function [op:yearMonthDuration-greater-than](https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than).
  #
  # @param other [Literal::YearMonthDuration]
  # @return [Boolean] `true` if less than other for defined datatypes
  # @see https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than
  # @see https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-greater-than
  def <=>(other); end

  # Converts the dayTimeDuration into rational seconds.
  #
  # @return [Rational]
  def to_i; end
end

RDF::Literal::YearMonthDuration::DATATYPE = T.let(T.unsafe(nil), RDF::URI)
RDF::Literal::YearMonthDuration::GRAMMAR = T.let(T.unsafe(nil), Regexp)

module RDF::XSD::VERSION
  class << self
    # @return [Array(Integer, Integer, Integer)]
    def to_a; end

    # @return [String]
    def to_s; end

    # @return [String]
    def to_str; end
  end
end

RDF::XSD::VERSION::EXTRA = T.let(T.unsafe(nil), T.untyped)
RDF::XSD::VERSION::MAJOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::MINOR = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::STRING = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::TINY = T.let(T.unsafe(nil), String)
RDF::XSD::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

class REXML::Element < ::REXML::Parent
  include ::REXML::XMLTokens

  # Canonicalize the Element. Return a new instance of this node
  # which is canonicalized and marked as such.
  #
  # Apply namespaces either passed as an option, or that are in scope.
  #
  # @param options [Hash{Symbol => Object}] From `Nokogiri::XML::Node#c14nxl`
  def c14nxl(options = T.unsafe(nil)); end
end
